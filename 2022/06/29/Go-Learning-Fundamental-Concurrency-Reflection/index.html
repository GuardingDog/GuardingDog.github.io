<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"guardingdog.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":{"disqus":{"text":"Load Disqus","order":-1},"gitalk":{"order":-2}},"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="You can find all the code for this chapter here From Twitter  golang challenge: write a function walk(x interface&amp;#123;&amp;#125;, fn func(string)) which takes a struct x and calls fn for all strings fiel">
<meta property="og:type" content="article">
<meta property="og:title" content="Go_Learning_Fundamental_Concurrency_Reflection">
<meta property="og:url" content="https://guardingdog.github.io/2022/06/29/Go-Learning-Fundamental-Concurrency-Reflection/index.html">
<meta property="og:site_name" content="QingZhi&#39;s Blog">
<meta property="og:description" content="You can find all the code for this chapter here From Twitter  golang challenge: write a function walk(x interface&amp;#123;&amp;#125;, fn func(string)) which takes a struct x and calls fn for all strings fiel">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-06-28T16:16:27.000Z">
<meta property="article:modified_time" content="2024-01-30T16:08:15.071Z">
<meta property="article:author" content="GuardingDog">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://guardingdog.github.io/2022/06/29/Go-Learning-Fundamental-Concurrency-Reflection/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Go_Learning_Fundamental_Concurrency_Reflection | QingZhi's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband">
	<a target="_blank" rel="noopener" href="https://github.com/GuardingDog" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
	</div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">QingZhi's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Persistence is not easy</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-guestbook">

    <a href="/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>guestbook</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://guardingdog.github.io/2022/06/29/Go-Learning-Fundamental-Concurrency-Reflection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="GuardingDog">
      <meta itemprop="description" content="Personal website for recording life and technology. If there is any resemblance, Icopied it.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingZhi's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go_Learning_Fundamental_Concurrency_Reflection
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-29 00:16:27" itemprop="dateCreated datePublished" datetime="2022-06-29T00:16:27+08:00">2022-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-31 00:08:15" itemprop="dateModified" datetime="2024-01-31T00:08:15+08:00">2024-01-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          
            <span id="/2022/06/29/Go-Learning-Fundamental-Concurrency-Reflection/" class="post-meta-item leancloud_visitors" data-flag-title="Go_Learning_Fundamental_Concurrency_Reflection" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/06/29/Go-Learning-Fundamental-Concurrency-Reflection/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/06/29/Go-Learning-Fundamental-Concurrency-Reflection/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong><a target="_blank" rel="noopener" href="https://github.com/quii/learn-go-with-tests/tree/main/reflection">You can find all the code for this chapter here</a></strong></p>
<p><a target="_blank" rel="noopener" href="https://twitter.com/peterbourgon/status/1011403901419937792?s=09">From Twitter</a></p>
<blockquote>
<p>golang challenge: write a function <code>walk(x interface&#123;&#125;, fn func(string))</code> which takes a struct <code>x</code> and calls <code>fn</code> for all strings fields found inside. difficulty level: recursively.</p>
</blockquote>
<a id="more"></a>

<p>To do this we will need to use <em>reflection</em>.</p>
<blockquote>
<p>Reflection in computing is the ability of a program to examine its own structure, particularly through types; it’s a form of metaprogramming. It’s also a great source of confusion.</p>
</blockquote>
<p>From <a target="_blank" rel="noopener" href="https://blog.golang.org/laws-of-reflection">The Go Blog: Reflection</a></p>
<h2 id="What-is-interface"><a href="#What-is-interface" class="headerlink" title="What is interface?"></a>What is <code>interface</code>?</h2><p>We have enjoyed the type-safety that Go has offered us in terms of functions that work with known types, such as <code>string</code>, <code>int</code> and our own types like <code>BankAccount</code>.</p>
<p>This means that we get some documentation for free and the compiler will complain if you try and pass the wrong type to a function.</p>
<p>You may come across scenarios though where you want to write a function where you don’t know the type at compile time.</p>
<p>Go lets us get around this with the type <code>interface&#123;&#125;</code> which you can think of as just <em>any</em> type.</p>
<p>So <code>walk(x interface&#123;&#125;, fn func(string))</code> will accept any value for <code>x</code>.</p>
<h3 id="So-why-not-use-interface-for-everything-and-have-really-flexible-functions"><a href="#So-why-not-use-interface-for-everything-and-have-really-flexible-functions" class="headerlink" title="So why not use interface for everything and have really flexible functions?"></a>So why not use <code>interface</code> for everything and have really flexible functions?</h3><ul>
<li>As a user of a function that takes <code>interface</code> you lose type safety. What if you meant to pass <code>Foo.bar</code> of type <code>string</code> into a function but instead did <code>Foo.baz</code> which is an <code>int</code>? The compiler won’t be able to inform you of your mistake. You also have no idea <em>what</em> you’re allowed to pass to a function. Knowing that a function takes a <code>UserService</code> for instance is very useful.</li>
<li>As a writer of such a function, you have to be able to inspect <em>anything</em> that has been passed to you and try and figure out what the type is and what you can do with it. This is done using <em>reflection</em>. This can be quite clumsy and difficult to read and is generally less performant (as you have to do checks at runtime).</li>
</ul>
<p>In short only use reflection if you really need to.</p>
<p>If you want polymorphic functions, consider if you could design it around an interface (not <code>interface</code>, confusingly) so that users can use your function with multiple types if they implement whatever methods you need for your function to work.</p>
<p>Our function will need to be able to work with lots of different things. As always we’ll take an iterative approach, writing tests for each new thing we want to support and refactoring along the way until we’re done.</p>
<h2 id="Write-the-test-first"><a href="#Write-the-test-first" class="headerlink" title="Write the test first"></a>Write the test first</h2><p>We’ll want to call our function with a struct that has a string field in it (<code>x</code>). Then we can spy on the function (<code>fn</code>) passed in to see if it is called.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestWalk</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    expected := <span class="string">&quot;Chris&quot;</span></span><br><span class="line">    <span class="keyword">var</span> got []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    x := <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">    &#125;&#123;expected&#125;</span><br><span class="line"></span><br><span class="line">    walk(x, <span class="function"><span class="keyword">func</span><span class="params">(input <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        got = <span class="built_in">append</span>(got, input)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(got) != <span class="number">1</span> &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;wrong number of function calls, got %d want %d&quot;</span>, <span class="built_in">len</span>(got), <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>We want to store a slice of strings (<code>got</code>) which stores which strings were passed into <code>fn</code> by <code>walk</code>. Often in previous chapters, we have made dedicated types for this to spy on function/method invocations but in this case, we can just pass in an anonymous function for <code>fn</code> that closes over <code>got</code>.</li>
<li>We use an anonymous <code>struct</code> with a <code>Name</code> field of type string to go for the simplest “happy” path.</li>
<li>Finally, call <code>walk</code> with <code>x</code> and the spy and for now just check the length of <code>got</code>, we’ll be more specific with our assertions once we’ve got something very basic working.</li>
</ul>
<h2 id="Try-to-run-the-test"><a href="#Try-to-run-the-test" class="headerlink" title="Try to run the test"></a>Try to run the test</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;reflection_test.go:21:2: undefined: walk</span><br></pre></td></tr></table></figure>
<h2 id="Write-the-minimal-amount-of-code-for-the-test-to-run-and-check-the-failing-test-output"><a href="#Write-the-minimal-amount-of-code-for-the-test-to-run-and-check-the-failing-test-output" class="headerlink" title="Write the minimal amount of code for the test to run and check the failing test output"></a>Write the minimal amount of code for the test to run and check the failing test output</h2><p>We need to define <code>walk</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Try and run the test again</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestWalk</span><br><span class="line">--- FAIL: TestWalk (0.00s)</span><br><span class="line">    reflection_test.go:19: wrong number of function calls, got 0 want 1</span><br><span class="line">FAIL</span><br></pre></td></tr></table></figure>
<h2 id="Write-enough-code-to-make-it-pass"><a href="#Write-enough-code-to-make-it-pass" class="headerlink" title="Write enough code to make it pass"></a>Write enough code to make it pass</h2><p>We can call the spy with any string to make this pass.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    fn(<span class="string">&quot;I still can&#x27;t believe South Korea beat Germany 2-0 to put them last in their group&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The test should now be passing. The next thing we’ll need to do is make a more specific assertion on what our <code>fn</code> is being called with.</p>
<h2 id="Write-the-test-first-1"><a href="#Write-the-test-first-1" class="headerlink" title="Write the test first"></a>Write the test first</h2><p>Add the following to the existing test to check the string passed to <code>fn</code> is correct</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> got[<span class="number">0</span>] != expected &#123;</span><br><span class="line">    t.Errorf(<span class="string">&quot;got %q, want %q&quot;</span>, got[<span class="number">0</span>], expected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Try-to-run-the-test-1"><a href="#Try-to-run-the-test-1" class="headerlink" title="Try to run the test"></a>Try to run the test</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestWalk</span><br><span class="line">--- FAIL: TestWalk (0.00s)</span><br><span class="line">    reflection_test.go:23: got &#39;I still can&#39;t believe South Korea beat Germany 2-0 to put them last in their group&#39;, want &#39;Chris&#39;</span><br><span class="line">FAIL</span><br></pre></td></tr></table></figure>
<h2 id="Write-enough-code-to-make-it-pass-1"><a href="#Write-enough-code-to-make-it-pass-1" class="headerlink" title="Write enough code to make it pass"></a>Write enough code to make it pass</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := reflect.ValueOf(x)</span><br><span class="line">    field := val.Field(<span class="number">0</span>)</span><br><span class="line">    fn(field.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This code is <em>very unsafe and very naive</em>, but remember: our goal when we are in “red” (the tests failing) is to write the smallest amount of code possible. We then write more tests to address our concerns.</p>
<p>We need to use reflection to have a look at <code>x</code> and try and look at its properties.</p>
<p>The <a target="_blank" rel="noopener" href="https://godoc.org/reflect">reflect package</a> has a function <code>ValueOf</code> which returns us a <code>Value</code> of a given variable. This has ways for us to inspect a value, including its fields which we use on the next line.</p>
<p>We then make some very optimistic assumptions about the value passed in</p>
<ul>
<li>We look at the first and only field, there may be no fields at all which would cause a panic</li>
<li>We then call <code>String()</code> which returns the underlying value as a string but we know it would be wrong if the field was something other than a string.</li>
</ul>
<h2 id="Refactor"><a href="#Refactor" class="headerlink" title="Refactor"></a>Refactor</h2><p>Our code is passing for the simple case but we know our code has a lot of shortcomings.</p>
<p>We’re going to be writing a number of tests where we pass in different values and checking the array of strings that <code>fn</code> was called with.</p>
<p>We should refactor our test into a table based test to make this easier to continue testing new scenarios.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestWalk</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    cases := []<span class="keyword">struct</span>&#123;</span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        Input <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">        ExpectedCalls []<span class="keyword">string</span></span><br><span class="line">    &#125; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;Struct with one string field&quot;</span>,</span><br><span class="line">            <span class="keyword">struct</span> &#123;</span><br><span class="line">                Name <span class="keyword">string</span></span><br><span class="line">            &#125;&#123; <span class="string">&quot;Chris&quot;</span>&#125;,</span><br><span class="line">            []<span class="keyword">string</span>&#123;<span class="string">&quot;Chris&quot;</span>&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, test := <span class="keyword">range</span> cases &#123;</span><br><span class="line">        t.Run(test.Name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            <span class="keyword">var</span> got []<span class="keyword">string</span></span><br><span class="line">            walk(test.Input, <span class="function"><span class="keyword">func</span><span class="params">(input <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">                got = <span class="built_in">append</span>(got, input)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> !reflect.DeepEqual(got, test.ExpectedCalls) &#123;</span><br><span class="line">                t.Errorf(<span class="string">&quot;got %v, want %v&quot;</span>, got, test.ExpectedCalls)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now we can easily add a scenario to see what happens if we have more than one string field.</p>
<h2 id="Write-the-test-first-2"><a href="#Write-the-test-first-2" class="headerlink" title="Write the test first"></a>Write the test first</h2><p>Add the following scenario to the <code>cases</code>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Struct with two string fields&quot;</span>,</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        City <span class="keyword">string</span></span><br><span class="line">    &#125;&#123;<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;London&quot;</span>&#125;,</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;London&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Try-to-run-the-test-2"><a href="#Try-to-run-the-test-2" class="headerlink" title="Try to run the test"></a>Try to run the test</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestWalk&#x2F;Struct_with_two_string_fields</span><br><span class="line">    --- FAIL: TestWalk&#x2F;Struct_with_two_string_fields (0.00s)</span><br><span class="line">        reflection_test.go:40: got [Chris], want [Chris London]</span><br></pre></td></tr></table></figure>
<h2 id="Write-enough-code-to-make-it-pass-2"><a href="#Write-enough-code-to-make-it-pass-2" class="headerlink" title="Write enough code to make it pass"></a>Write enough code to make it pass</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;val.NumField(); i++ &#123;</span><br><span class="line">        field := val.Field(i)</span><br><span class="line">        fn(field.String())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>val</code> has a method <code>NumField</code> which returns the number of fields in the value. This lets us iterate over the fields and call <code>fn</code> which passes our test.</p>
<h2 id="Refactor-1"><a href="#Refactor-1" class="headerlink" title="Refactor"></a>Refactor</h2><p>It doesn’t look like there’s any obvious refactors here that would improve the code so let’s press on.</p>
<p>The next shortcoming in <code>walk</code> is that it assumes every field is a <code>string</code>. Let’s write a test for this scenario.</p>
<h2 id="Write-the-test-first-3"><a href="#Write-the-test-first-3" class="headerlink" title="Write the test first"></a>Write the test first</h2><p>Add the following case</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Struct with non string field&quot;</span>,</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        Age  <span class="keyword">int</span></span><br><span class="line">    &#125;&#123;<span class="string">&quot;Chris&quot;</span>, <span class="number">33</span>&#125;,</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;Chris&quot;</span>&#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="Try-to-run-the-test-3"><a href="#Try-to-run-the-test-3" class="headerlink" title="Try to run the test"></a>Try to run the test</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestWalk&#x2F;Struct_with_non_string_field</span><br><span class="line">    --- FAIL: TestWalk&#x2F;Struct_with_non_string_field (0.00s)</span><br><span class="line">        reflection_test.go:46: got [Chris &lt;int Value&gt;], want [Chris]</span><br></pre></td></tr></table></figure>
<h2 id="Write-enough-code-to-make-it-pass-3"><a href="#Write-enough-code-to-make-it-pass-3" class="headerlink" title="Write enough code to make it pass"></a>Write enough code to make it pass</h2><p>We need to check that the type of the field is a <code>string</code>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.NumField(); i++ &#123;</span><br><span class="line">        field := val.Field(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> field.Kind() == reflect.String &#123;</span><br><span class="line">            fn(field.String())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We can do that by checking its <a target="_blank" rel="noopener" href="https://godoc.org/reflect#Kind"><code>Kind</code></a>.</p>
<h2 id="Refactor-2"><a href="#Refactor-2" class="headerlink" title="Refactor"></a>Refactor</h2><p>Again it looks like the code is reasonable enough for now.</p>
<p>The next scenario is what if it isn’t a “flat” <code>struct</code>? In other words, what happens if we have a <code>struct</code> with some nested fields?</p>
<h2 id="Write-the-test-first-4"><a href="#Write-the-test-first-4" class="headerlink" title="Write the test first"></a>Write the test first</h2><p>We have been using the anonymous struct syntax to declare types ad-hocly for our tests so we could continue to do that like so</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Nested fields&quot;</span>,</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">            Age  <span class="keyword">int</span></span><br><span class="line">            City <span class="keyword">string</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#123;<span class="string">&quot;Chris&quot;</span>, <span class="keyword">struct</span> &#123;</span><br><span class="line">        Age  <span class="keyword">int</span></span><br><span class="line">        City <span class="keyword">string</span></span><br><span class="line">    &#125;&#123;<span class="number">33</span>, <span class="string">&quot;London&quot;</span>&#125;&#125;,</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;London&quot;</span>&#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>But we can see that when you get inner anonymous structs the syntax gets a little messy. <a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/12854">There is a proposal to make it so the syntax would be nicer</a>.</p>
<p>Let’s just refactor this by making a known type for this scenario and reference it in the test. There is a little indirection in that some of the code for our test is outside the test but readers should be able to infer the structure of the <code>struct</code> by looking at the initialisation.</p>
<p>Add the following type declarations somewhere in your test file</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    Profile Profile</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">    City <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now we can add this to our cases which reads a lot clearer than before</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Nested fields&quot;</span>,</span><br><span class="line">    Person&#123;</span><br><span class="line">        <span class="string">&quot;Chris&quot;</span>,</span><br><span class="line">        Profile&#123;<span class="number">33</span>, <span class="string">&quot;London&quot;</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;London&quot;</span>&#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="Try-to-run-the-test-4"><a href="#Try-to-run-the-test-4" class="headerlink" title="Try to run the test"></a>Try to run the test</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestWalk&#x2F;Nested_fields</span><br><span class="line">    --- FAIL: TestWalk&#x2F;Nested_fields (0.00s)</span><br><span class="line">        reflection_test.go:54: got [Chris], want [Chris London]</span><br></pre></td></tr></table></figure>
<p>The problem is we’re only iterating on the fields on the first level of the type’s hierarchy.</p>
<h2 id="Write-enough-code-to-make-it-pass-4"><a href="#Write-enough-code-to-make-it-pass-4" class="headerlink" title="Write enough code to make it pass"></a>Write enough code to make it pass</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.NumField(); i++ &#123;</span><br><span class="line">        field := val.Field(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> field.Kind() == reflect.String &#123;</span><br><span class="line">            fn(field.String())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> field.Kind() == reflect.Struct &#123;</span><br><span class="line">            walk(field.Interface(), fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The solution is quite simple, we again inspect its <code>Kind</code> and if it happens to be a <code>struct</code> we just call <code>walk</code> again on that inner <code>struct</code>.</p>
<h2 id="Refactor-3"><a href="#Refactor-3" class="headerlink" title="Refactor"></a>Refactor</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.NumField(); i++ &#123;</span><br><span class="line">        field := val.Field(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> field.Kind() &#123;</span><br><span class="line">        <span class="keyword">case</span> reflect.String:</span><br><span class="line">            fn(field.String())</span><br><span class="line">        <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">            walk(field.Interface(), fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When you’re doing a comparison on the same value more than once <em>generally</em> refactoring into a <code>switch</code> will improve readability and make your code easier to extend.</p>
<p>What if the value of the struct passed in is a pointer?</p>
<h2 id="Write-the-test-first-5"><a href="#Write-the-test-first-5" class="headerlink" title="Write the test first"></a>Write the test first</h2><p>Add this case</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Pointers to things&quot;</span>,</span><br><span class="line">    &amp;Person&#123;</span><br><span class="line">        <span class="string">&quot;Chris&quot;</span>,</span><br><span class="line">        Profile&#123;<span class="number">33</span>, <span class="string">&quot;London&quot;</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;London&quot;</span>&#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="Try-to-run-the-test-5"><a href="#Try-to-run-the-test-5" class="headerlink" title="Try to run the test"></a>Try to run the test</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestWalk&#x2F;Pointers_to_things</span><br><span class="line">panic: reflect: call of reflect.Value.NumField on ptr Value [recovered]</span><br><span class="line">    panic: reflect: call of reflect.Value.NumField on ptr Value</span><br></pre></td></tr></table></figure>
<h2 id="Write-enough-code-to-make-it-pass-5"><a href="#Write-enough-code-to-make-it-pass-5" class="headerlink" title="Write enough code to make it pass"></a>Write enough code to make it pass</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> val.Kind() == reflect.Ptr &#123;</span><br><span class="line">        val = val.Elem()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.NumField(); i++ &#123;</span><br><span class="line">        field := val.Field(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> field.Kind() &#123;</span><br><span class="line">        <span class="keyword">case</span> reflect.String:</span><br><span class="line">            fn(field.String())</span><br><span class="line">        <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">            walk(field.Interface(), fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You can’t use <code>NumField</code> on a pointer <code>Value</code>, we need to extract the underlying value before we can do that by using <code>Elem()</code>.</p>
<h2 id="Refactor-4"><a href="#Refactor-4" class="headerlink" title="Refactor"></a>Refactor</h2><p>Let’s encapsulate the responsibility of extracting the <code>reflect.Value</code> from a given <code>interface&#123;&#125;</code> into a function.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := getValue(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.NumField(); i++ &#123;</span><br><span class="line">        field := val.Field(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> field.Kind() &#123;</span><br><span class="line">        <span class="keyword">case</span> reflect.String:</span><br><span class="line">            fn(field.String())</span><br><span class="line">        <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">            walk(field.Interface(), fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getValue</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">reflect</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line">    val := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> val.Kind() == reflect.Ptr &#123;</span><br><span class="line">        val = val.Elem()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This actually adds <em>more</em> code but I feel the abstraction level is right.</p>
<ul>
<li>Get the <code>reflect.Value</code> of <code>x</code> so I can inspect it, I don’t care how.</li>
<li>Iterate over the fields, doing whatever needs to be done depending on its type.</li>
</ul>
<p>Next, we need to cover slices.</p>
<h2 id="Write-the-test-first-6"><a href="#Write-the-test-first-6" class="headerlink" title="Write the test first"></a>Write the test first</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Slices&quot;</span>,</span><br><span class="line">    []Profile &#123;</span><br><span class="line">        &#123;<span class="number">33</span>, <span class="string">&quot;London&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">34</span>, <span class="string">&quot;Reykjavík&quot;</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;London&quot;</span>, <span class="string">&quot;Reykjavík&quot;</span>&#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="Try-to-run-the-test-6"><a href="#Try-to-run-the-test-6" class="headerlink" title="Try to run the test"></a>Try to run the test</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestWalk&#x2F;Slices</span><br><span class="line">panic: reflect: call of reflect.Value.NumField on slice Value [recovered]</span><br><span class="line">    panic: reflect: call of reflect.Value.NumField on slice Value</span><br></pre></td></tr></table></figure>
<h2 id="Write-the-minimal-amount-of-code-for-the-test-to-run-and-check-the-failing-test-output-1"><a href="#Write-the-minimal-amount-of-code-for-the-test-to-run-and-check-the-failing-test-output-1" class="headerlink" title="Write the minimal amount of code for the test to run and check the failing test output"></a>Write the minimal amount of code for the test to run and check the failing test output</h2><p>This is similar to the pointer scenario before, we are trying to call <code>NumField</code> on our <code>reflect.Value</code> but it doesn’t have one as it’s not a struct.</p>
<h2 id="Write-enough-code-to-make-it-pass-6"><a href="#Write-enough-code-to-make-it-pass-6" class="headerlink" title="Write enough code to make it pass"></a>Write enough code to make it pass</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := getValue(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> val.Kind() == reflect.Slice &#123;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; val.Len(); i++ &#123;</span><br><span class="line">            walk(val.Index(i).Interface(), fn)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.NumField(); i++ &#123;</span><br><span class="line">        field := val.Field(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> field.Kind() &#123;</span><br><span class="line">        <span class="keyword">case</span> reflect.String:</span><br><span class="line">            fn(field.String())</span><br><span class="line">        <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">            walk(field.Interface(), fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Refactor-5"><a href="#Refactor-5" class="headerlink" title="Refactor"></a>Refactor</h2><p>This works but it’s yucky. No worries, we have working code backed by tests so we are free to tinker all we like.</p>
<p>If you think a little abstractly, we want to call <code>walk</code> on either</p>
<ul>
<li>Each field in a struct</li>
<li>Each <em>thing</em> in a slice</li>
</ul>
<p>Our code at the moment does this but doesn’t reflect it very well. We just have a check at the start to see if it’s a slice (with a <code>return</code> to stop the rest of the code executing) and if it’s not we just assume it’s a struct.</p>
<p>Let’s rework the code so instead we check the type <em>first</em> and then do our work.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := getValue(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> val.Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;val.NumField(); i++ &#123;</span><br><span class="line">            walk(val.Field(i).Interface(), fn)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> reflect.Slice:</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;val.Len(); i++ &#123;</span><br><span class="line">            walk(val.Index(i).Interface(), fn)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> reflect.String:</span><br><span class="line">        fn(val.String())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Looking much better! If it’s a struct or a slice we iterate over its values calling <code>walk</code> on each one. Otherwise, if it’s a <code>reflect.String</code> we can call <code>fn</code>.</p>
<p>Still, to me it feels like it could be better. There’s repetition of the operation of iterating over fields/values and then calling <code>walk</code> but conceptually they’re the same.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := getValue(x)</span><br><span class="line"></span><br><span class="line">    numberOfValues := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> getField <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">reflect</span>.<span class="title">Value</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> val.Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.String:</span><br><span class="line">        fn(val.String())</span><br><span class="line">    <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">        numberOfValues = val.NumField()</span><br><span class="line">        getField = val.Field</span><br><span class="line">    <span class="keyword">case</span> reflect.Slice:</span><br><span class="line">        numberOfValues = val.Len()</span><br><span class="line">        getField = val.Index</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; numberOfValues; i++ &#123;</span><br><span class="line">        walk(getField(i).Interface(), fn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If the <code>value</code> is a <code>reflect.String</code> then we just call <code>fn</code> like normal.</p>
<p>Otherwise, our <code>switch</code> will extract out two things depending on the type</p>
<ul>
<li>How many fields there are</li>
<li>How to extract the <code>Value</code> (<code>Field</code> or <code>Index</code>)</li>
</ul>
<p>Once we’ve determined those things we can iterate through <code>numberOfValues</code> calling <code>walk</code> with the result of the <code>getField</code> function.</p>
<p>Now we’ve done this, handling arrays should be trivial.</p>
<h2 id="Write-the-test-first-7"><a href="#Write-the-test-first-7" class="headerlink" title="Write the test first"></a>Write the test first</h2><p>Add to the cases</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Arrays&quot;</span>,</span><br><span class="line">    [<span class="number">2</span>]Profile &#123;</span><br><span class="line">        &#123;<span class="number">33</span>, <span class="string">&quot;London&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">34</span>, <span class="string">&quot;Reykjavík&quot;</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;London&quot;</span>, <span class="string">&quot;Reykjavík&quot;</span>&#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="Try-to-run-the-test-7"><a href="#Try-to-run-the-test-7" class="headerlink" title="Try to run the test"></a>Try to run the test</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestWalk&#x2F;Arrays</span><br><span class="line">    --- FAIL: TestWalk&#x2F;Arrays (0.00s)</span><br><span class="line">        reflection_test.go:78: got [], want [London Reykjavík]</span><br></pre></td></tr></table></figure>
<h2 id="Write-enough-code-to-make-it-pass-7"><a href="#Write-enough-code-to-make-it-pass-7" class="headerlink" title="Write enough code to make it pass"></a>Write enough code to make it pass</h2><p>Arrays can be handled the same way as slices, so just add it to the case with a comma</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := getValue(x)</span><br><span class="line"></span><br><span class="line">    numberOfValues := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> getField <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">reflect</span>.<span class="title">Value</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> val.Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.String:</span><br><span class="line">        fn(val.String())</span><br><span class="line">    <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">        numberOfValues = val.NumField()</span><br><span class="line">        getField = val.Field</span><br><span class="line">    <span class="keyword">case</span> reflect.Slice, reflect.Array:</span><br><span class="line">        numberOfValues = val.Len()</span><br><span class="line">        getField = val.Index</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; numberOfValues; i++ &#123;</span><br><span class="line">        walk(getField(i).Interface(), fn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The next type we want to handle is <code>map</code>.</p>
<h2 id="Write-the-test-first-8"><a href="#Write-the-test-first-8" class="headerlink" title="Write the test first"></a>Write the test first</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Maps&quot;</span>,</span><br><span class="line">    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;Foo&quot;</span>: <span class="string">&quot;Bar&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Baz&quot;</span>: <span class="string">&quot;Boz&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;Bar&quot;</span>, <span class="string">&quot;Boz&quot;</span>&#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="Try-to-run-the-test-8"><a href="#Try-to-run-the-test-8" class="headerlink" title="Try to run the test"></a>Try to run the test</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestWalk&#x2F;Maps</span><br><span class="line">    --- FAIL: TestWalk&#x2F;Maps (0.00s)</span><br><span class="line">        reflection_test.go:86: got [], want [Bar Boz]</span><br></pre></td></tr></table></figure>
<h2 id="Write-enough-code-to-make-it-pass-8"><a href="#Write-enough-code-to-make-it-pass-8" class="headerlink" title="Write enough code to make it pass"></a>Write enough code to make it pass</h2><p>Again if you think a little abstractly you can see that <code>map</code> is very similar to <code>struct</code>, it’s just the keys are unknown at compile time.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := getValue(x)</span><br><span class="line"></span><br><span class="line">    numberOfValues := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> getField <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">reflect</span>.<span class="title">Value</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> val.Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.String:</span><br><span class="line">        fn(val.String())</span><br><span class="line">    <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">        numberOfValues = val.NumField()</span><br><span class="line">        getField = val.Field</span><br><span class="line">    <span class="keyword">case</span> reflect.Slice, reflect.Array:</span><br><span class="line">        numberOfValues = val.Len()</span><br><span class="line">        getField = val.Index</span><br><span class="line">    <span class="keyword">case</span> reflect.Map:</span><br><span class="line">        <span class="keyword">for</span> _, key := <span class="keyword">range</span> val.MapKeys() &#123;</span><br><span class="line">            walk(val.MapIndex(key).Interface(), fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; numberOfValues; i++ &#123;</span><br><span class="line">        walk(getField(i).Interface(), fn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>However, by design you cannot get values out of a map by index. It’s only done by <em>key</em>, so that breaks our abstraction, darn.</p>
<h2 id="Refactor-6"><a href="#Refactor-6" class="headerlink" title="Refactor"></a>Refactor</h2><p>How do you feel right now? It felt like maybe a nice abstraction at the time but now the code feels a little wonky.</p>
<p><em>This is OK!</em> Refactoring is a journey and sometimes we will make mistakes. A major point of TDD is it gives us the freedom to try these things out.</p>
<p>By taking small steps backed by tests this is in no way an irreversible situation. Let’s just put it back to how it was before the refactor.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := getValue(x)</span><br><span class="line"></span><br><span class="line">    walkValue := <span class="function"><span class="keyword">func</span><span class="params">(value reflect.Value)</span></span> &#123;</span><br><span class="line">        walk(value.Interface(), fn)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> val.Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.String:</span><br><span class="line">        fn(val.String())</span><br><span class="line">    <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i&lt; val.NumField(); i++ &#123;</span><br><span class="line">            walkValue(val.Field(i))</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> reflect.Slice, reflect.Array:</span><br><span class="line">        <span class="keyword">for</span> i:= <span class="number">0</span>; i&lt;val.Len(); i++ &#123;</span><br><span class="line">            walkValue(val.Index(i))</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> reflect.Map:</span><br><span class="line">        <span class="keyword">for</span> _, key := <span class="keyword">range</span> val.MapKeys() &#123;</span><br><span class="line">            walkValue(val.MapIndex(key))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We’ve introduced <code>walkValue</code> which DRYs up the calls to <code>walk</code> inside our <code>switch</code> so that they only have to extract out the <code>reflect.Value</code>s from <code>val</code>.</p>
<h3 id="One-final-problem"><a href="#One-final-problem" class="headerlink" title="One final problem"></a>One final problem</h3><p>Remember that maps in Go do not guarantee order. So your tests will sometimes fail because we assert that the calls to <code>fn</code> are done in a particular order.</p>
<p>To fix this, we’ll need to move our assertion with the maps to a new test where we do not care about the order.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">t.Run(<span class="string">&quot;with maps&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    aMap := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;Foo&quot;</span>: <span class="string">&quot;Bar&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Baz&quot;</span>: <span class="string">&quot;Boz&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> got []<span class="keyword">string</span></span><br><span class="line">    walk(aMap, <span class="function"><span class="keyword">func</span><span class="params">(input <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        got = <span class="built_in">append</span>(got, input)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    assertContains(t, got, <span class="string">&quot;Bar&quot;</span>)</span><br><span class="line">    assertContains(t, got, <span class="string">&quot;Boz&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Here is how <code>assertContains</code> is defined</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertContains</span><span class="params">(t testing.TB, haystack []<span class="keyword">string</span>, needle <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">    t.Helper()</span><br><span class="line">    contains := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> haystack &#123;</span><br><span class="line">        <span class="keyword">if</span> x == needle &#123;</span><br><span class="line">            contains = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !contains &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;expected %+v to contain %q but it didn&#x27;t&quot;</span>, haystack, needle)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The next type we want to handle is <code>chan</code>.</p>
<h2 id="Write-the-test-first-9"><a href="#Write-the-test-first-9" class="headerlink" title="Write the test first"></a>Write the test first</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">t.Run(<span class="string">&quot;with channels&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">		aChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> Profile)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			aChannel &lt;- Profile&#123;<span class="number">33</span>, <span class="string">&quot;Berlin&quot;</span>&#125;</span><br><span class="line">			aChannel &lt;- Profile&#123;<span class="number">34</span>, <span class="string">&quot;Katowice&quot;</span>&#125;</span><br><span class="line">			<span class="built_in">close</span>(aChannel)</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> got []<span class="keyword">string</span></span><br><span class="line">		want := []<span class="keyword">string</span>&#123;<span class="string">&quot;Berlin&quot;</span>, <span class="string">&quot;Katowice&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		walk(aChannel, <span class="function"><span class="keyword">func</span><span class="params">(input <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">			got = <span class="built_in">append</span>(got, input)</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !reflect.DeepEqual(got, want) &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;got %v, want %v&quot;</span>, got, want)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Try-to-run-the-test-9"><a href="#Try-to-run-the-test-9" class="headerlink" title="Try to run the test"></a>Try to run the test</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--- FAIL: TestWalk (0.00s)</span><br><span class="line">    --- FAIL: TestWalk&#x2F;with_channels (0.00s)</span><br><span class="line">        reflection_test.go:115: got [], want [Berlin Katowice]</span><br></pre></td></tr></table></figure>
<h2 id="Write-enough-code-to-make-it-pass-9"><a href="#Write-enough-code-to-make-it-pass-9" class="headerlink" title="Write enough code to make it pass"></a>Write enough code to make it pass</h2><p>We can iterate through all values sent through channel until it was closed with Recv()</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">	val := getValue(x)</span><br><span class="line"></span><br><span class="line">	walkValue := <span class="function"><span class="keyword">func</span><span class="params">(value reflect.Value)</span></span> &#123;</span><br><span class="line">		walk(value.Interface(), fn)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> val.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.String:</span><br><span class="line">		fn(val.String())</span><br><span class="line">	<span class="keyword">case</span> reflect.Struct:</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.NumField(); i++ &#123;</span><br><span class="line">			walkValue(val.Field(i))</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Slice, reflect.Array:</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.Len(); i++ &#123;</span><br><span class="line">			walkValue(val.Index(i))</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Map:</span><br><span class="line">		<span class="keyword">for</span> _, key := <span class="keyword">range</span> val.MapKeys() &#123;</span><br><span class="line">			walkValue(val.MapIndex(key))</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Chan:</span><br><span class="line">		<span class="keyword">for</span> v, ok := val.Recv(); ok; v, ok = val.Recv() &#123;</span><br><span class="line">			walk(v.Interface(), fn)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The next type we want to handle is <code>func</code>.</p>
<h2 id="Write-the-test-first-10"><a href="#Write-the-test-first-10" class="headerlink" title="Write the test first"></a>Write the test first</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">t.Run(<span class="string">&quot;with function&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">		aFunction := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(Profile, Profile)</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> Profile&#123;<span class="number">33</span>, <span class="string">&quot;Berlin&quot;</span>&#125;, Profile&#123;<span class="number">34</span>, <span class="string">&quot;Katowice&quot;</span>&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> got []<span class="keyword">string</span></span><br><span class="line">		want := []<span class="keyword">string</span>&#123;<span class="string">&quot;Berlin&quot;</span>, <span class="string">&quot;Katowice&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		walk(aFunction, <span class="function"><span class="keyword">func</span><span class="params">(input <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">			got = <span class="built_in">append</span>(got, input)</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !reflect.DeepEqual(got, want) &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;got %v, want %v&quot;</span>, got, want)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Try-to-run-the-test-10"><a href="#Try-to-run-the-test-10" class="headerlink" title="Try to run the test"></a>Try to run the test</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--- FAIL: TestWalk (0.00s)</span><br><span class="line">    --- FAIL: TestWalk&#x2F;with_function (0.00s)</span><br><span class="line">        reflection_test.go:132: got [], want [Berlin Katowice]</span><br></pre></td></tr></table></figure>
<h2 id="Write-enough-code-to-make-it-pass-10"><a href="#Write-enough-code-to-make-it-pass-10" class="headerlink" title="Write enough code to make it pass"></a>Write enough code to make it pass</h2><p>Non zero-argument functions do not seem to make a lot of sense in this scenario. But we should allow for arbitrary return values.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">	val := getValue(x)</span><br><span class="line"></span><br><span class="line">	walkValue := <span class="function"><span class="keyword">func</span><span class="params">(value reflect.Value)</span></span> &#123;</span><br><span class="line">		walk(value.Interface(), fn)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> val.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.String:</span><br><span class="line">		fn(val.String())</span><br><span class="line">	<span class="keyword">case</span> reflect.Struct:</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.NumField(); i++ &#123;</span><br><span class="line">			walkValue(val.Field(i))</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Slice, reflect.Array:</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.Len(); i++ &#123;</span><br><span class="line">			walkValue(val.Index(i))</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Map:</span><br><span class="line">		<span class="keyword">for</span> _, key := <span class="keyword">range</span> val.MapKeys() &#123;</span><br><span class="line">			walkValue(val.MapIndex(key))</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Chan:</span><br><span class="line">		<span class="keyword">for</span> v, ok := val.Recv(); ok; v, ok = val.Recv() &#123;</span><br><span class="line">			walk(v.Interface(), fn)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Func:</span><br><span class="line">		valFnResult := val.Call(<span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">for</span> _, res := <span class="keyword">range</span> valFnResult &#123;</span><br><span class="line">			walk(res.Interface(), fn)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Wrapping-up"><a href="#Wrapping-up" class="headerlink" title="Wrapping up"></a>Wrapping up</h2><ul>
<li>Introduced some of the concepts from the <code>reflect</code> package.</li>
<li>Used recursion to traverse arbitrary data structures.</li>
<li>Did an in retrospect bad refactor but didn’t get too upset about it. By working iteratively with tests it’s not such a big deal.</li>
<li>This only covered a small aspect of reflection. <a target="_blank" rel="noopener" href="https://blog.golang.org/laws-of-reflection">The Go blog has an excellent post covering more details</a>.</li>
<li>Now that you know about reflection, do your best to avoid using it.</li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatPay.jpg" alt="GuardingDog WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/aliPay.jpg" alt="GuardingDog Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Go/" rel="tag"><i class="fa fa-tag"></i> Go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/06/29/Go-Learning-Fundamental-Concurrency-Channel/" rel="prev" title="Go_Learning_Fundamental_Concurrency_Channel">
      <i class="fa fa-chevron-left"></i> Go_Learning_Fundamental_Concurrency_Channel
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/06/29/GO-Learning-Fundamental-Array-Slice-Map/" rel="next" title="GO_Learning_Fundamental_Array_Slice_Map">
      GO_Learning_Fundamental_Array_Slice_Map <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#What-is-interface"><span class="nav-number">1.</span> <span class="nav-text">What is interface?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#So-why-not-use-interface-for-everything-and-have-really-flexible-functions"><span class="nav-number">1.1.</span> <span class="nav-text">So why not use interface for everything and have really flexible functions?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-the-test-first"><span class="nav-number">2.</span> <span class="nav-text">Write the test first</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Try-to-run-the-test"><span class="nav-number">3.</span> <span class="nav-text">Try to run the test</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-the-minimal-amount-of-code-for-the-test-to-run-and-check-the-failing-test-output"><span class="nav-number">4.</span> <span class="nav-text">Write the minimal amount of code for the test to run and check the failing test output</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-enough-code-to-make-it-pass"><span class="nav-number">5.</span> <span class="nav-text">Write enough code to make it pass</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-the-test-first-1"><span class="nav-number">6.</span> <span class="nav-text">Write the test first</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Try-to-run-the-test-1"><span class="nav-number">7.</span> <span class="nav-text">Try to run the test</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-enough-code-to-make-it-pass-1"><span class="nav-number">8.</span> <span class="nav-text">Write enough code to make it pass</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Refactor"><span class="nav-number">9.</span> <span class="nav-text">Refactor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-the-test-first-2"><span class="nav-number">10.</span> <span class="nav-text">Write the test first</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Try-to-run-the-test-2"><span class="nav-number">11.</span> <span class="nav-text">Try to run the test</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-enough-code-to-make-it-pass-2"><span class="nav-number">12.</span> <span class="nav-text">Write enough code to make it pass</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Refactor-1"><span class="nav-number">13.</span> <span class="nav-text">Refactor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-the-test-first-3"><span class="nav-number">14.</span> <span class="nav-text">Write the test first</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Try-to-run-the-test-3"><span class="nav-number">15.</span> <span class="nav-text">Try to run the test</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-enough-code-to-make-it-pass-3"><span class="nav-number">16.</span> <span class="nav-text">Write enough code to make it pass</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Refactor-2"><span class="nav-number">17.</span> <span class="nav-text">Refactor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-the-test-first-4"><span class="nav-number">18.</span> <span class="nav-text">Write the test first</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Try-to-run-the-test-4"><span class="nav-number">19.</span> <span class="nav-text">Try to run the test</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-enough-code-to-make-it-pass-4"><span class="nav-number">20.</span> <span class="nav-text">Write enough code to make it pass</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Refactor-3"><span class="nav-number">21.</span> <span class="nav-text">Refactor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-the-test-first-5"><span class="nav-number">22.</span> <span class="nav-text">Write the test first</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Try-to-run-the-test-5"><span class="nav-number">23.</span> <span class="nav-text">Try to run the test</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-enough-code-to-make-it-pass-5"><span class="nav-number">24.</span> <span class="nav-text">Write enough code to make it pass</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Refactor-4"><span class="nav-number">25.</span> <span class="nav-text">Refactor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-the-test-first-6"><span class="nav-number">26.</span> <span class="nav-text">Write the test first</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Try-to-run-the-test-6"><span class="nav-number">27.</span> <span class="nav-text">Try to run the test</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-the-minimal-amount-of-code-for-the-test-to-run-and-check-the-failing-test-output-1"><span class="nav-number">28.</span> <span class="nav-text">Write the minimal amount of code for the test to run and check the failing test output</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-enough-code-to-make-it-pass-6"><span class="nav-number">29.</span> <span class="nav-text">Write enough code to make it pass</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Refactor-5"><span class="nav-number">30.</span> <span class="nav-text">Refactor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-the-test-first-7"><span class="nav-number">31.</span> <span class="nav-text">Write the test first</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Try-to-run-the-test-7"><span class="nav-number">32.</span> <span class="nav-text">Try to run the test</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-enough-code-to-make-it-pass-7"><span class="nav-number">33.</span> <span class="nav-text">Write enough code to make it pass</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-the-test-first-8"><span class="nav-number">34.</span> <span class="nav-text">Write the test first</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Try-to-run-the-test-8"><span class="nav-number">35.</span> <span class="nav-text">Try to run the test</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-enough-code-to-make-it-pass-8"><span class="nav-number">36.</span> <span class="nav-text">Write enough code to make it pass</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Refactor-6"><span class="nav-number">37.</span> <span class="nav-text">Refactor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#One-final-problem"><span class="nav-number">37.1.</span> <span class="nav-text">One final problem</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-the-test-first-9"><span class="nav-number">38.</span> <span class="nav-text">Write the test first</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Try-to-run-the-test-9"><span class="nav-number">39.</span> <span class="nav-text">Try to run the test</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-enough-code-to-make-it-pass-9"><span class="nav-number">40.</span> <span class="nav-text">Write enough code to make it pass</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-the-test-first-10"><span class="nav-number">41.</span> <span class="nav-text">Write the test first</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Try-to-run-the-test-10"><span class="nav-number">42.</span> <span class="nav-text">Try to run the test</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-enough-code-to-make-it-pass-10"><span class="nav-number">43.</span> <span class="nav-text">Write enough code to make it pass</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Wrapping-up"><span class="nav-number">44.</span> <span class="nav-text">Wrapping up</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="GuardingDog"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">GuardingDog</p>
  <div class="site-description" itemprop="description">Personal website for recording life and technology. If there is any resemblance, Icopied it.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">110</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/GuardingDog" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;GuardingDog" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/sun2387353@163.com" title="E-Mail → sun2387353@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/yourname" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://plus.google.com/yourname" title="Google → https:&#x2F;&#x2F;plus.google.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Google</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GuardingDog</span>
</div>
<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  




  
  <style>
  
  button.darkmode-toggle {
  z-index: 9999;
  }
  
  img, .darkmode-ignore {
    isolation: isolate;
    display: block;
  }
  </style>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
  <script src="/lib/darkmode-js/lib/darkmode-js.min.js"></script>


<script>
var options = {
  bottom: '64px', // default: '32px'
  right: 'unset', // default: '32px'
  left: '32px', // default: 'unset'
  time: '0.5s', // default: '0.3s'
  mixColor: '#fff', // default: '#fff'
  backgroundColor: '#fff',  // default: '#fff'
  buttonColorDark: '#100f2c',  // default: '#100f2c'
  buttonColorLight: '#fff', // default: '#fff'
  saveInCookies: false, // default: true,
  label: '🌓', // default: ''
  autoMatchOsTheme: true // default: true
}
const darkmode = new Darkmode(options);
darkmode.showWidget();
// window.onload = function(){
//   setTimeout(
//     function() {
//       document.getElementsByClassName('darkmode-toggle')[0].click();
//     },
//     550,
//   );
//   document.getElementsByClassName('darkmode-toggle')[0].click();
// }
</script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '7alk9zMW4cerOHY4GBQkS9pX-gzGzoHsz',
      appKey     : '0DEHlLcP8dJ2GLpKJ8gqy9U9',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

    </div>
</body>
</html>
