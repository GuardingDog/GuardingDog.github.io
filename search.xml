<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Pyhton_字符编码</title>
    <url>/2020/04/02/Pyhton-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a></p>
</blockquote>
<h2 id="1-ASCII编码"><a href="#1-ASCII编码" class="headerlink" title="1.ASCII编码"></a>1.ASCII编码</h2><blockquote>
<p>我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有<code>0</code>和<code>1</code>两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从<code>00000000</code>到<code>11111111</code>。</p>
<p>上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。</p>
<p>ASCII 码一共规定了128个字符的编码，比如空格<code>SPACE</code>是32（二进制<code>00100000</code>），大写的字母<code>A</code>是65（二进制<code>01000001</code>）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为<code>0</code>。</p>
</blockquote>
<a id="more"></a>
<h2 id="2-非ASCII编码"><a href="#2-非ASCII编码" class="headerlink" title="2.非ASCII编码"></a>2.非ASCII编码</h2><blockquote>
<p>英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的<code>é</code>的编码为130（二进制<code>10000010</code>）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。</p>
<p>但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了<code>é</code>，在希伯来语编码中却代表了字母<code>Gimel</code> (<code>ג</code>)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0–127表示的符号是一样的，不一样的只是128–255的这一段。</p>
<p>至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。</p>
<p>中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。</p>
</blockquote>
<h2 id="3-Unicode"><a href="#3-Unicode" class="headerlink" title="3.Unicode"></a>3.Unicode</h2><blockquote>
<p>正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。</p>
<p>可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。</p>
<p>Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，<code>U+0639</code>表示阿拉伯字母<code>Ain</code>，<code>U+0041</code>表示英语的大写字母<code>A</code>，<code>U+4E25</code>表示汉字<code>严</code>。具体的符号对应表，可以查询<a href="http://www.unicode.org/">unicode.org</a>，或者专门的<a href="http://www.chi2ko.com/tool/CJK.htm">汉字对应表</a>。</p>
</blockquote>
<h2 id="4-Unicode-的问题"><a href="#4-Unicode-的问题" class="headerlink" title="4.Unicode 的问题"></a>4.<strong>Unicode 的问题</strong></h2><blockquote>
<p>需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</p>
<p>比如，汉字<code>严</code>的 Unicode 是十六进制数<code>4E25</code>，转换成二进制数足足有15位（<code>100111000100101</code>），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。</p>
<p>这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是<code>0</code>，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p>
<p>它们造成的结果是：1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。2）Unicode 在很长一段时间内无法推广，直到互联网的出现。</p>
</blockquote>
<h2 id="5-UTF-8"><a href="#5-UTF-8" class="headerlink" title="5.UTF-8"></a>5.<strong>UTF-8</strong></h2><blockquote>
<p>互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。<strong>重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。</strong></p>
<p>UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>
<p>UTF-8 的编码规则很简单，只有二条：</p>
<p>1）对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p>
<p>2）对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p>
<p>下表总结了编码规则，字母<code>x</code>表示可用编码的位。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><figcaption><span>|        UTF-8编码方式</span></figcaption><table><tr><td class="code"><pre><span class="line">Unicode符号范围     |        UTF-8编码方式</span><br><span class="line">(十六进制)        |              （二进制）</span><br><span class="line">----------------------+---------------------------------------------</span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。</p>
<p>下面，还是以汉字<code>严</code>为例，演示如何实现 UTF-8 编码。</p>
<p><code>严</code>的 Unicode 是<code>4E25</code>（<code>100111000100101</code>），根据上表，可以发现<code>4E25</code>处在第三行的范围内（<code>0000 0800 - 0000 FFFF</code>），因此<code>严</code>的 UTF-8 编码需要三个字节，即格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从<code>严</code>的最后一个二进制位开始，依次从后向前填入格式中的<code>x</code>，多出的位补<code>0</code>。这样就得到了，<code>严</code>的 UTF-8 编码是<code>11100100 10111000 10100101</code>，转换成十六进制就是<code>E4B8A5</code>。</p>
</blockquote>
<h2 id="6-Little-endian-和-Big-endian"><a href="#6-Little-endian-和-Big-endian" class="headerlink" title="6.Little endian 和 Big endian"></a>6.<strong>Little endian 和 Big endian</strong></h2><blockquote>
<p>上一节已经提到，UCS-2 格式可以存储 Unicode 码（码点不超过<code>0xFFFF</code>）。以汉字<code>严</code>为例，Unicode 码是<code>4E25</code>，需要用两个字节存储，一个字节是<code>4E</code>，另一个字节是<code>25</code>。存储的时候，<code>4E</code>在前，<code>25</code>在后，这就是 Big endian 方式；<code>25</code>在前，<code>4E</code>在后，这是 Little endian 方式。</p>
<p>这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-endian)敲开还是从小头(Little-endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。</p>
<p>第一个字节在前，就是”大头方式”（Big endian），第二个字节在前就是”小头方式”（Little endian）。</p>
<p>那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？</p>
<p>Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用<code>FEFF</code>表示。这正好是两个字节，而且<code>FF</code>比<code>FE</code>大<code>1</code>。</p>
<p>如果一个文本文件的头两个字节是<code>FE FF</code>，就表示该文件采用大头方式；如果头两个字节是<code>FF FE</code>，就表示该文件采用小头方式。</p>
</blockquote>
<h2 id="7-延伸阅读"><a href="#7-延伸阅读" class="headerlink" title="7.延伸阅读"></a>7.延伸阅读</h2><blockquote>
<p><a href="http://www.joelonsoftware.com/articles/Unicode.html">http://www.joelonsoftware.com/articles/Unicode.html</a></p>
<p><a href="https://www.pconline.com.cn/pcedu/empolder/gj/other/0505/616631.html">https://www.pconline.com.cn/pcedu/empolder/gj/other/0505/616631.html</a></p>
<p><a href="https://www.ietf.org/rfc/rfc3629.txt">https://www.ietf.org/rfc/rfc3629.txt</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python2—_编码问题</title>
    <url>/2020/04/02/Python2-%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="python2编码问题"><a href="#python2编码问题" class="headerlink" title="python2编码问题"></a>python2编码问题</h2><blockquote>
<p>[Github相关解释][<a href="https://github.com/solomonxie/solomonxie.github.io/issues/24]">https://github.com/solomonxie/solomonxie.github.io/issues/24]</a></p>
<p>[知乎相关解释][<a href="https://zhuanlan.zhihu.com/p/39210353]">https://zhuanlan.zhihu.com/p/39210353]</a></p>
<p>[简书相关解释][<a href="https://www.jianshu.com/p/19c74e76ee0a]">https://www.jianshu.com/p/19c74e76ee0a]</a></p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>最近在调试python2过程中经常出现编码的问题，尤其是将python3程序重构为python2程序过程中出现的问题。</p>
<p>问题一：编码本身有什么不同</p>
<ul>
<li>这在字符编码.md文件中已经有了清晰的解释</li>
</ul>
<p>问题二：python2处理中文时为什么总是会出现乱码</p>
<ul>
<li>encode与decode两者需要明确区分</li>
<li>对应的字符与字节也需要区分</li>
</ul>
<p>带着以上两个问题看到了相关的解释，特记录如下：</p>
</blockquote>
<!-- more -->

<h2 id="1-字符与字节问题"><a href="#1-字符与字节问题" class="headerlink" title="1.字符与字节问题"></a>1.字符与字节问题</h2><blockquote>
<p>字符与字节之间并不是同等地位。</p>
<p><strong>字符串：</strong>由字符组成的序列</p>
<p><strong>字符：</strong>字符是<strong>人</strong>使用的符号，是一种人所认知的单位。例如：“中” ， “1” ，“￥”等等</p>
<blockquote>
<ul>
<li><p>在python3中，str对象中获取的元素是<strong>Unicode字符</strong> </p>
</li>
<li><p>在python2中，str对象中获取的原始<strong>字节序列</strong></p>
</li>
</ul>
<p>可以看到同样是str对象，python2中其实是字节，python3中是字符</p>
</blockquote>
<p><strong>字节：</strong>字节是<strong>计算机</strong>所使用的符号，是8位的二进制数字。例如 0x01,01010101,0b45</p>
</blockquote>
<p><strong>不同编码体制中，字符与字节拥有着不同的对应关系：</strong></p>
<ol>
<li><p><strong>ASCII码：</strong>  一个英文字母（不分大小写）占一个字节的空间，<strong>一个中文汉字占两个字节</strong>的空间。一个<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLPANWnW01uH6suhf3nWmk0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPjRYPjnvPH63nHmLnWRvPHcd">二进制数字</a>序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值0，最大值255。</p>
</li>
<li><p><strong>UTF-8：</strong>一个英文字符=一个字节，一个中文（含繁体）=三个字节。</p>
<blockquote>
<p>已知UTF-8编码是UNICODE编码的实现形式的一种，Unicode规定了世界上所有的符号与二进制的对应关系，但是其实现形式多种多样，比如UTF-8,UTF-16等等。</p>
<p><strong>Unicode才是真正的（人）字符串，而用ASCII、UTF-8、GBK等字符编码表示的是字节串。</strong></p>
<blockquote>
<p>从这个角度理解unicode就是CAMEO，utf-8就是VerbDic.</p>
</blockquote>
</blockquote>
</li>
</ol>
<h2 id="2-encode与decode"><a href="#2-encode与decode" class="headerlink" title="2.encode与decode"></a>2.encode与decode</h2><blockquote>
<p>encode与decode分别对应</p>
<p><strong>encode:</strong> 将人类可识别的字符转换为机器可识别的字节码，<strong>字符到字节的过程</strong>。</p>
<p><strong>decode:**就是将机器可识别的字节码转换成人类可识别的字符，</strong>字节到字符的过程**。</p>
</blockquote>
<h2 id="3-python中的默认编码"><a href="#3-python中的默认编码" class="headerlink" title="3.python中的默认编码"></a>3.python中的默认编码</h2><h3 id="3-1-Python源代码的执行过程"><a href="#3-1-Python源代码的执行过程" class="headerlink" title="3.1 Python源代码的执行过程"></a>3.1 Python源代码的执行过程</h3><blockquote>
<p>我们都知道，磁盘上的文件都是以二进制格式存放的，其中文本文件都是以某种特定编码的字节形式存放的。对于程序源代码文件的字符编码是由编辑器指定的，比如我们使用Pycharm来编写Python程序时会指定工程编码和文件编码为UTF-8，那么Python代码被<strong>保存到磁盘</strong>时就会被转换为UTF-8编码对应的字节（<strong>encode过程</strong>）后写入磁盘。</p>
<p>当执行Python代码文件中的代码时，Python解释器在读取Python代码文件中的字节串之后，需要将其转换为Unicode字符串（decode过程）之后才执行后续操作。</p>

</blockquote>
<h3 id="3-2默认编码"><a href="#3-2默认编码" class="headerlink" title="3.2默认编码"></a>3.2默认编码</h3><blockquote>
<p>如果我们没有在代码文件指定字符编码，Python解释器会使用哪种字符编码把从代码文件中读取到的字节转换为Unicode字符串呢？就像我们配置某些软件时，有很多默认选项一样，需要在Python解释器内部设置默认的字符编码来解决这个问题，这就是“默认编码”。</p>
<p>Python2和Python3的解释器使用的默认编码是不一样的，我们可以通过sys.getdefaultencoding()来获取默认编码：</p>
<ul>
<li><strong>Python2:ascii</strong></li>
<li><strong>Python3:utf-8</strong></li>
</ul>
</blockquote>
<h3 id="3-3-python2与python3处理文件"><a href="#3-3-python2与python3处理文件" class="headerlink" title="3.3 python2与python3处理文件"></a>3.3 python2与python3处理文件</h3><blockquote>
<p>对于Python2来讲，Python解释器在读取到中文字符的字节码时，会先查看当前代码文件头部是否指明字符编码是什么。如果没有指定，则使用默认字符编码”ASCII”进行解码，导致中文字符解码失败，出现如下错误</p>
<blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">SyntaxError:Non-ASCII character <span class="string">&#x27;\xc4&#x27;</span> <span class="keyword">in</span> file xxx.py <span class="keyword">on</span> line <span class="number">11</span>, but no encoding declared;</span><br><span class="line">see http:<span class="comment">//python.org/dev/peps/pep-0263/ for details</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>对于Python3来讲，执行过程是一样的，只是Python3的解释器以”UTF-8”作为默认编码，但是这并不表示可以完全兼容中文问题。比如我们在Windows上进行开发时，Python工程及代码文件都使用的是默认的GBK编码，也就是说Python代码文件是被转换成GBK格式的字节码保存到磁盘中的。Python3的解释器执行该代码文件时，试图用UTF-8进行解码操作时，同样会解码失败，出现如下错误：</p>
<blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">SyntaxError:Non-UTF<span class="number">-8</span> code starting <span class="keyword">with</span> <span class="string">&#x27;\xc4&#x27;</span> <span class="keyword">in</span> file xx.py <span class="keyword">on</span> line <span class="number">11</span>, but no encodingdeclared; </span><br><span class="line">see http:<span class="comment">//python.org/dev/peps/pep-0263/ for details</span></span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h2 id="4-Python2-Python3对字符串的支持"><a href="#4-Python2-Python3对字符串的支持" class="headerlink" title="4. Python2 Python3对字符串的支持"></a>4. Python2 Python3对字符串的支持</h2><h3 id="4-1-Python2"><a href="#4-1-Python2" class="headerlink" title="4.1 Python2"></a>4.1 Python2</h3><blockquote>
<p>Python2中对字符串的支持由以下三个类别提供：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">basestring</span></span>(<span class="keyword">object</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">str</span></span>(basestring)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unicode</span></span>(basestring)</span><br></pre></td></tr></table></figure>

<p>其中basestring类是str类与unicode类的父类。</p>
<ul>
<li><p><strong>str其实是字节串</strong>，它是unicode经过编码后的字节组成的序列。</p>
<blockquote>
<p>对UTF-8编码的str’汉’使用len()函数时，结果是3，因为UTF-8编码的’汉’==’\xE6\xB1\x89’。</p>
</blockquote>
</li>
<li><p><strong>unicode才是真正意义上的字符串</strong>，对字节串str使用正确的字符编码进行解码后获得，并且len(u’汉’)==1。</p>
</li>
</ul>
</blockquote>
<h3 id="4-2-Python3"><a href="#4-2-Python3" class="headerlink" title="4.2 Python3"></a>4.2 Python3</h3><blockquote>
<p>Python3中对字符串的支持进行了实现类层次的上简化，去掉了unicode类，添加了一个bytes类。从表面上来看，可认为Python3中的str和unicode合二为一了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bytes</span></span>(<span class="keyword">object</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">str</span></span>(<span class="keyword">object</span>)</span><br></pre></td></tr></table></figure>

<p>实际上，<strong>Python3中已经意识到之前的错误，开始明确区分字符串与字节</strong>。</p>
<p><strong>因此Python3中的str已经是真正的字符串，而字节是用单独的bytes类来表示。</strong></p>
<p>也就是说，Python3默认定义的就是字符串，实现了对Unicode的内置支持，减轻了程序员对字符串处理的负担。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*- </span></span><br><span class="line">a = <span class="string">&#x27;你好&#x27;</span></span><br><span class="line">b = <span class="string">u&#x27;你好&#x27;</span></span><br><span class="line">c = <span class="string">&#x27;你好&#x27;</span>.encode(<span class="string">&#x27;gbk&#x27;</span>) </span><br><span class="line">print(<span class="built_in">type</span>(a),<span class="built_in">len</span>(a))         <span class="comment"># output:&lt;class&#x27;str&#x27;&gt; 2</span></span><br><span class="line">print(<span class="built_in">type</span>(b),<span class="built_in">len</span>(b))         <span class="comment"># output:&lt;class&#x27;str&#x27;&gt; 2</span></span><br><span class="line">print(<span class="built_in">type</span>(c),<span class="built_in">len</span>(c))         <span class="comment"># output:&lt;class&#x27;bytes&#x27;&gt; 4</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="4-3-字符与字节转换"><a href="#4-3-字符与字节转换" class="headerlink" title="4.3 字符与字节转换"></a>4.3 字符与字节转换</h3><blockquote>
<p>4.3的名称我自己起的，合不合适的我们再看</p>
</blockquote>
<ul>
<li><p><strong>单个字符的encode：</strong></p>
<blockquote>
<p>Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="number">65</span></span><br><span class="line">&gt;&gt;&gt; ord(<span class="string">&#x27;中&#x27;</span>)</span><br><span class="line"><span class="number">20013</span></span><br><span class="line">&gt;&gt;&gt; chr(<span class="number">97</span>)</span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line">&gt;&gt;&gt; chr(<span class="number">20013</span>)</span><br><span class="line"><span class="string">&#x27;中&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果知道字符的整数编码，还可以用十六进制这么写字符：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="string">&#x27;\u4e2d\u6587&#x27;</span></span><br><span class="line"><span class="string">&#x27;中文&#x27;</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p><strong>字符.encode() = 字节</strong></p>
<blockquote>
<p>Python3的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。</p>
<p>Python对bytes类型的数据用带b前缀的单引号或双引号表示：x = b’ABC’。</p>
<p>要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。</p>
<p>以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="string">&#x27;ABC&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">b<span class="string">&#x27;ABC&#x27;</span></span><br><span class="line">&gt;&gt;&gt; <span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">b<span class="string">&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span></span><br><span class="line">&gt;&gt;&gt; <span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="symbol">UnicodeEncodeError:</span> <span class="string">&#x27;ascii&#x27;</span> codec can<span class="string">&#x27;t encode characters in position 0-1: ordinal not in range(128)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>常见的中文报错问题愿意：</p>
<p>纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。<strong>中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。</strong></p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>字节.decode() = 字符：</strong></p>
<blockquote>
<p>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b<span class="string">&#x27;ABC&#x27;</span>.decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;ABC&#x27;</span></span><br><span class="line">&gt;&gt;&gt; b<span class="string">&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;中文&#x27;</span></span><br></pre></td></tr></table></figure>

<p>要计算str包含多少个字符，可以用len()函数：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; len(<span class="string">&#x27;ABC&#x27;</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt; len(<span class="string">&#x27;中文&#x27;</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>en()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; len(b<span class="string">&#x27;ABC&#x27;</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt; len(b<span class="string">&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line">&gt;&gt;&gt; len(<span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="5-Python2-Python3字符编码的转换"><a href="#5-Python2-Python3字符编码的转换" class="headerlink" title="5.Python2 Python3字符编码的转换"></a>5.Python2 Python3字符编码的转换</h2><p>Unicode字符串可以与任意字符编码的字节串进行相互转换：</p>


</li>
</ul>
<blockquote>
<p>从上图可以看出不同字节编码之间是可以通过Unicode来实现相互转换的。</p>
<ul>
<li><p>Python2中的字符串进行字符编码转换过程是：</p>
<p><strong>字节串(Python2的str默认是字节串)–&gt;decode(‘原来的字符编码’)–&gt;Unicode字符串–&gt;encode(‘新的字符编码’)–&gt;字节串</strong></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python2</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*- </span></span><br><span class="line">utf_8_a = <span class="string">&#x27;我爱中国&#x27;</span></span><br><span class="line">gbk_a = utf_8_a.decode(<span class="string">&#x27;utf-8&#x27;</span>).encode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(gbk_a.decode(<span class="string">&#x27;gbk&#x27;</span>))</span><br><span class="line"><span class="comment"># 输出结果：我爱中国</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Python3中定义的字符串默认就是unicode，因此不需要先解码，可以直接编码成新的字符编码：</p>
<p><strong>字符串(str就是Unicode字符串)–&gt;encode(‘新的字符编码’)–&gt;字节串</strong></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*- </span></span><br><span class="line">utf_8_b = <span class="string">&#x27;我爱中国&#x27;</span></span><br><span class="line">gbk_b = utf_8_b.encode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(gbk_b.decode(<span class="string">&#x27;gbk&#x27;</span>))</span><br><span class="line"><span class="comment"># 输出结果：我爱中国</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="6-Python2-中乱码问题的解决方案"><a href="#6-Python2-中乱码问题的解决方案" class="headerlink" title="6.Python2 中乱码问题的解决方案"></a>6.Python2 中乱码问题的解决方案</h2><h3 id="6-1-不要相信Print-结果"><a href="#6-1-不要相信Print-结果" class="headerlink" title="6.1 不要相信Print()结果"></a>6.1 不要相信Print()结果</h3><blockquote>
<p>print()函数本身是加工后给<strong>人</strong>看的,不管给它什么样子的编码格式文件，都可以打印出来。</p>
<p><strong>这也就意味着print()，并没有展示变量的本质。</strong></p>
<p>可以选择 jupyter中</p>
<blockquote>
<p>这里是<strong>Python2</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>chinese = <span class="string">&#x27;中文&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chinese </span><br><span class="line"><span class="string">&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="6-2-Python2中“字符串”两大阵容"><a href="#6-2-Python2中“字符串”两大阵容" class="headerlink" title="6.2 Python2中“字符串”两大阵容"></a>6.2 Python2中“字符串”两大阵容</h3><blockquote>
<p>unicode和str</p>
<p>如果<code>type(字符串)</code>显示结果是<code>str</code>，其实指的是<code>bytes</code>字节码。</p>
<blockquote>
<p>由上面的内容我们已经理解当前python2中str对象与unicode对象分别代表：字节与字符</p>
</blockquote>
</blockquote>
<ul>
<li><p>encoding与decoding</p>
<p>从<code>unicode</code>转换到<code>str</code>，这个叫<code>encoding</code>，编码。<br>从<code>str</code>转换到<code>unicode</code>，这个叫<code>decoding</code>，解码。</p>



</li>
</ul>
<ul>
<li><p>案例</p>
<blockquote>
<p>Python2</p>
</blockquote>
  




</li>
</ul>
<h3 id="6-3-具体统一方案"><a href="#6-3-具体统一方案" class="headerlink" title="6.3 具体统一方案"></a>6.3 具体统一方案</h3><blockquote>
<p>见[剩余内容][<a href="https://segmentfault.com/a/1190000013202801]">https://segmentfault.com/a/1190000013202801]</a></p>
<p>这里的统一方案无非就是按照字符处理文件还是按照字节处理文件，何时进行decode何时encode的问题。</p>
<p>做个给出了一个方案，但我目前并没有采用，这里不详细写</p>
</blockquote>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python包管理之setup()函数详解</title>
    <url>/2020/04/02/Python%E5%8C%85%E7%AE%A1%E7%90%86-setup%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Python包管理-setup-详解"><a href="#Python包管理-setup-详解" class="headerlink" title="Python包管理.setup()详解"></a>Python包管理.setup()详解</h1><blockquote>
<p>[PythonPackageGuide][<a href="https://packaging.python.org/guides/distributing-packages-using-setuptools/]">https://packaging.python.org/guides/distributing-packages-using-setuptools/]</a></p>
<p>[Python包样例][<a href="https://github.com/pypa/sampleproject]">https://github.com/pypa/sampleproject]</a></p>
<p>[子包、数据文件与依赖包参数情况][[<a href="http://www.wbh-doc.com.s3.amazonaws.com/Python-OpenSource-Project-Developer-Guide/appendix%20-%20setup%20script.html]">http://www.wbh-doc.com.s3.amazonaws.com/Python-OpenSource-Project-Developer-Guide/appendix%20-%20setup%20script.html]</a></p>
</blockquote>
<a id="more"></a>

<h2 id="1-Setup-Args"><a href="#1-Setup-Args" class="headerlink" title="1. Setup() Args"></a>1. Setup() Args</h2><blockquote>
<p>参数详解</p>
</blockquote>
<h3 id="1-1-name"><a href="#1-1-name" class="headerlink" title="1.1 name"></a>1.1 name</h3><ul>
<li><p>项目名称</p>
<ul>
<li><p>命名规范：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Consist only of ASCII letters, digits, underscores (_), hyphens (-), and/or periods (.), and</span><br><span class="line"></span><br><span class="line">Start &amp; end with an ASCII letter or digit.</span><br></pre></td></tr></table></figure></li>
<li><p>PS：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Comparison of project names is case insensitive and treats arbitrarily-long runs of underscores, hyphens, and/or periods as equal.</span><br></pre></td></tr></table></figure>
<ol>
<li><p>大小写 不敏感</p>
</li>
<li><p>上述特殊符号（下划线、连字符、_、-、.）任意数量一致对待</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#以下名称等价</span><br><span class="line">Cool-Stuff</span><br><span class="line">cool.stuff</span><br><span class="line">COOL_STUFF</span><br><span class="line">CoOl__-.-__sTuFF</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-version"><a href="#1-2-version" class="headerlink" title="1.2 version"></a>1.2 version</h3></li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>版本号，version = “1.1.0”</p>
<p>[版本框架选择][<a href="https://packaging.python.org/guides/distributing-packages-using-setuptools/#choosing-a-versioning-scheme]">https://packaging.python.org/guides/distributing-packages-using-setuptools/#choosing-a-versioning-scheme]</a></p>
</blockquote>
<h3 id="1-3-description"><a href="#1-3-description" class="headerlink" title="1.3 description"></a>1.3 description</h3><blockquote>
<p>具体包含三个参数</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">description=&#x27;A sample Python project&#x27;,</span><br><span class="line">long_description=long_description,</span><br><span class="line">long_description_content_type=&#x27;text/x-rst&#x27;,</span><br></pre></td></tr></table></figure>
<ul>
<li>描述信息会在PyPI相关位置显示</li>
<li>long_description_content_type参数可选：<ol>
<li>text/plain    没有格式</li>
<li>text/x-rst    reST格式 </li>
<li>text/markdown     markdown格式</li>
</ol>
</li>
</ul>
<h3 id="1-4-url"><a href="#1-4-url" class="headerlink" title="1.4 url"></a>1.4 url</h3><blockquote>
<p>主页地址</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url&#x3D;&#39;https:&#x2F;&#x2F;github.com&#x2F;pypa&#x2F;sampleproject&#39;,</span><br></pre></td></tr></table></figure>
<h3 id="1-5-author"><a href="#1-5-author" class="headerlink" title="1.5 author"></a>1.5 author</h3><blockquote>
<p>提供作者信息</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">author=&#x27;The Python Packaging Authority&#x27;,</span><br><span class="line">author_email=&#x27;pypa-dev@googlegroups.com&#x27;,</span><br></pre></td></tr></table></figure>
<h3 id="1-6-license"><a href="#1-6-license" class="headerlink" title="1.6 license"></a>1.6 license</h3><blockquote>
<p>表明发布遵循的协议</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">license=&#x27;MIT&#x27;,</span><br></pre></td></tr></table></figure>
<ol>
<li>此字段不需要表明发布的协议</li>
<li>若采用标准协议则采用：classifiers字段</li>
<li>license字段通常用于指定与常用协议差异的部分，故此字段不常用</li>
</ol>
<h3 id="1-7-classifier"><a href="#1-7-classifier" class="headerlink" title="1.7 classifier"></a>1.7 classifier</h3><blockquote>
<p>按照内部成分对项目进行分类</p>
<p>[分类详细文档][<a href="https://pypi.org/classifiers/]">https://pypi.org/classifiers/]</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">classifiers=[</span><br><span class="line">    <span class="comment"># How mature is this project? Common values are</span></span><br><span class="line">    <span class="comment">#   3 - Alpha</span></span><br><span class="line">    <span class="comment">#   4 - Beta</span></span><br><span class="line">    <span class="comment">#   5 - Production/Stable</span></span><br><span class="line">    <span class="string">&#x27;Development Status :: 3 - Alpha&#x27;</span>,</span><br><span class="line">    <span class="comment"># Indicate who your project is intended for</span></span><br><span class="line">    <span class="string">&#x27;Intended Audience :: Developers&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Topic :: Software Development :: Build Tools&#x27;</span>,</span><br><span class="line">    <span class="comment"># Pick your license as you wish (should match &quot;license&quot; above)</span></span><br><span class="line">     <span class="string">&#x27;License :: OSI Approved :: MIT License&#x27;</span>,</span><br><span class="line">    <span class="comment"># Specify the Python versions you support here. In particular, ensure</span></span><br><span class="line">    <span class="comment"># that you indicate whether you support Python 2, Python 3 or both.</span></span><br><span class="line">    <span class="string">&#x27;Programming Language :: Python :: 2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Programming Language :: Python :: 2.6&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Programming Language :: Python :: 2.7&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Programming Language :: Python :: 3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Programming Language :: Python :: 3.2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Programming Language :: Python :: 3.3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Programming Language :: Python :: 3.4&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ol>
<li>上面内容可以看到，这里可以指定Python版本，但其并不能用于限制Python版本。只能用于在PyPI上面浏览时显示，版本限制需要用 python_requires 参数指定。</li>
</ol>
<h3 id="1-8-keywords"><a href="#1-8-keywords" class="headerlink" title="1.8 keywords"></a>1.8 keywords</h3><blockquote>
<p>列出项目关键字</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keywords=<span class="string">&#x27;sample setuptools development&#x27;</span>,</span><br></pre></td></tr></table></figure>
<h3 id="1-9-project-urls"><a href="#1-9-project-urls" class="headerlink" title="1.9 project_urls"></a>1.9 project_urls</h3><blockquote>
<p>列出相关url地址</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">project_urls=&#123;</span><br><span class="line">    <span class="string">&#x27;Documentation&#x27;</span>: <span class="string">&#x27;https://packaging.python.org/tutorials/distributing-packages/&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Funding&#x27;</span>: <span class="string">&#x27;https://donate.pypi.org&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Say Thanks!&#x27;</span>: <span class="string">&#x27;http://saythanks.io/to/example&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Source&#x27;</span>: <span class="string">&#x27;https://github.com/pypa/sampleproject/&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Tracker&#x27;</span>: <span class="string">&#x27;https://github.com/pypa/sampleproject/issues&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1-10-packages"><a href="#1-10-packages" class="headerlink" title="1.10 packages"></a>1.10 packages</h3><blockquote>
<p>设置项目中采用的所有包，包含其子包</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">packages=find_packages(include=[<span class="string">&#x27;sample&#x27;</span>, <span class="string">&#x27;sample.*&#x27;</span>]),</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>可手动指定</li>
<li>可利用setuptools.find_packages()自动寻找<ul>
<li>其方法可使用include字段找到指定的位置</li>
<li>其方法可使用exclude字段排除指定的位置</li>
</ul>
</li>
</ul>
<h3 id="1-11-py-modules"><a href="#1-11-py-modules" class="headerlink" title="1.11 py_modules"></a>1.11 py_modules</h3><blockquote>
<p>用于指定非包内的模块</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">py_modules=[<span class="string">&quot;six&quot;</span>],</span><br></pre></td></tr></table></figure>
<h3 id="1-12-install-requires"><a href="#1-12-install-requires" class="headerlink" title="1.12 install_requires"></a>1.12 install_requires</h3><blockquote>
<p>指定项目启动所需要的依赖</p>
<p>[install_requiresVSrequirements files][<a href="https://packaging.python.org/discussions/install-requires-vs-requirements/#install-requires-vs-requirements-files]">https://packaging.python.org/discussions/install-requires-vs-requirements/#install-requires-vs-requirements-files]</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">install_requires=[<span class="string">&#x27;peppercorn&#x27;</span>],</span><br></pre></td></tr></table></figure>
<h3 id="1-13-python-requires"><a href="#1-13-python-requires" class="headerlink" title="1.13 python_requires"></a>1.13 python_requires</h3><blockquote>
<p>指定可运行Python的版本</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#if your package is for Python 3+ only, write:</span></span><br><span class="line">python_requires=<span class="string">&#x27;&gt;=3&#x27;</span>,</span><br><span class="line"><span class="comment">#If your package is for Python 3.3 and up but you’re not willing to commit to Python 4 support yet, write:</span></span><br><span class="line">python_requires=<span class="string">&#x27;~=3.3&#x27;</span>,</span><br><span class="line"><span class="comment">#If your package is for Python 2.6, 2.7, and all versions of Python 3 starting with 3.3, write:</span></span><br><span class="line">python_requires=<span class="string">&#x27;&gt;=2.6, !=3.0.*, !=3.1.*, !=3.2.*, &lt;4&#x27;</span>,</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1-14-package-data"><a href="#1-14-package-data" class="headerlink" title="1.14 package_data"></a>1.14 package_data</h3><blockquote>
<p>指定包数据文件，包数据文件指不在包内的与项目相关的数据文件。比如字典。</p>
<p>[包文件详解][<a href="https://setuptools.readthedocs.io/en/latest/setuptools.html#including-data-files]">https://setuptools.readthedocs.io/en/latest/setuptools.html#including-data-files]</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">package_data=&#123;</span><br><span class="line">    <span class="string">&#x27;sample&#x27;</span>: [<span class="string">&#x27;package_data.dat&#x27;</span>],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="1-15-data-files"><a href="#1-15-data-files" class="headerlink" title="1.15 data_files"></a>1.15 data_files</h3><blockquote>
<p>data_files也用于指定文件，但是同package_data不同的是其用于指定<strong>不在包内</strong>的数据文件。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_files=[(<span class="string">&#x27;my_data&#x27;</span>, [<span class="string">&#x27;data/data_file&#x27;</span>])],</span><br></pre></td></tr></table></figure>
<ul>
<li>采用<code>(directory, files)</code>的形式指定文件。<ul>
<li>directory 采用相对地址[详解][<a href="https://docs.python.org/3/distutils/setupscript.html#installing-additional-files]">https://docs.python.org/3/distutils/setupscript.html#installing-additional-files]</a></li>
</ul>
</li>
</ul>
<h3 id="1-16-scripts"><a href="#1-16-scripts" class="headerlink" title="1.16 scripts"></a>1.16 scripts</h3><blockquote>
<p>用于指定安装的脚本，但目前并不推荐使用</p>
</blockquote>
<h3 id="1-17-entry-points"><a href="#1-17-entry-points" class="headerlink" title="1.17 entry_points"></a>1.17 entry_points</h3><blockquote>
<p>Use this keyword to specify any plugins that your project provides for any named entry points that may be defined by your project or others that you depend on..</p>
<p>没看懂</p>
<p>[文档详解][<a href="https://setuptools.readthedocs.io/en/latest/setuptools.html#dynamic-discovery-of-services-and-plugins]">https://setuptools.readthedocs.io/en/latest/setuptools.html#dynamic-discovery-of-services-and-plugins]</a></p>
<blockquote>
<p>官方文档没看懂，可以看[博客][<a href="http://blog.luoyuanhang.com/2016/03/25/Python-%E5%88%86%E5%8F%91%E5%B7%A5%E5%85%B7%E5%88%9D%E6%8E%A2%E4%B9%8B-setuptools-%E8%BF%9B%E9%98%B6/">http://blog.luoyuanhang.com/2016/03/25/Python-%E5%88%86%E5%8F%91%E5%B7%A5%E5%85%B7%E5%88%9D%E6%8E%A2%E4%B9%8B-setuptools-%E8%BF%9B%E9%98%B6/</a></p>
<p>entry_points 是一个字典，从entry point组名映射道一个表示entry point的字符串或字符串列表。Entry points是用来支持动态发现服务和插件的，也用来支持自动生成脚本。</p>
</blockquote>
</blockquote>
<h3 id="1-18-console-scripts"><a href="#1-18-console-scripts" class="headerlink" title="1.18 console_scripts"></a>1.18 console_scripts</h3><blockquote>
<p>entry_points内部参数，用于生成脚本文件<br>用于在系统路径下生成可执行脚本。</p>
<p>[官方文档详解][<a href="https://setuptools.readthedocs.io/en/latest/setuptools.html#automatic-script-creation]">https://setuptools.readthedocs.io/en/latest/setuptools.html#automatic-script-creation]</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">entry_points=&#123;</span><br><span class="line">    <span class="string">&#x27;console_scripts&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;sample=sample:main&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python2包管理工具对比</title>
    <url>/2020/04/02/Python%E5%8C%85%E7%AE%A1%E7%90%86-%E5%B7%A5%E5%85%B7%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<blockquote>
<p>参考地址：<a href="https://blog.zengrong.net/post/python_packaging/">Python 包管理工具解惑</a></p>
<blockquote>
<p>参考地址中作者详尽的调研并解释了相关问题，相对于其他博客内容，此篇内容系统性更强，这需要学习。</p>
</blockquote>
</blockquote>
<a id="more"></a>

<h2 id="1-疑惑问题"><a href="#1-疑惑问题" class="headerlink" title="1.  疑惑问题"></a>1.  疑惑问题</h2><blockquote>
<p>python 包管理我本身一直未曾仔细研究，处于混沌的状态。目前只知道pip,conda等包管理工具。</p>
</blockquote>
<p>目前存在的问题有：</p>
<ol>
<li><p>如何私有发布自己的模块</p>
</li>
<li><p>如何共有发布模块(发布到PyPI)</p>
</li>
<li><p>各种包管理工具的差异与用法</p>
<ul>
<li><p>distutils</p>
</li>
<li><p>setuptppls</p>
</li>
<li><p>distribute</p>
</li>
<li><p>disutils2</p>
</li>
<li><p>dislib</p>
</li>
<li><p>pip</p>
</li>
</ul>
</li>
<li><p>wheel与Egg的关系</p>
<!-- more -->

</li>
</ol>
<h2 id="2-Python包管理工具学习"><a href="#2-Python包管理工具学习" class="headerlink" title="2. Python包管理工具学习"></a>2. Python包管理工具学习</h2><blockquote>
<p>在上述参考文章中对各包管理工具已经有了基本的侧重，故此学习也存在侧重。</p>
</blockquote>
<h3 id="2-1-distutils"><a href="#2-1-distutils" class="headerlink" title="2.1 distutils"></a>2.1 distutils</h3><blockquote>
<p>setuptools是 distutils 的加强版，目前已经自动采用setuptools</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/distutils.html">distutils</a>是python标准库的一部分，能够进行python模块的<a href="https://docs.python.org/3/install/index.html">安装</a>与<a href="https://docs.python.org/3/distutils/index.html">发布</a>。</p>
<ul>
<li><p>setup.py是利用distutils 的功能写成的，<a href="https://docs.python.org/3/distutils/introduction.html?highlight=distutils#a-simple-example">示例</a></p>
<ul>
<li>setup.py格式的详细描述：<a href="https://docs.python.org/3/distutils/setupscript.html">Writing the Setup Script</a></li>
</ul>
</li>
<li><p>常用功能</p>
<ol>
<li><p>安装模块：到当前Python环境中,可以使用此模块提供的setup.py 文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></li>
<li><p>发布模块：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#打包为tar.gz或者zip压缩包</span><br><span class="line">python setup.py sdist</span><br><span class="line">#打包为rpm</span><br><span class="line">python setip.py bdist_rpm</span><br><span class="line">#打包为exe</span><br><span class="line">python setup.py bdist_wininst</span><br></pre></td></tr></table></figure>
<h3 id="2-2-setuptools-和-distribute"><a href="#2-2-setuptools-和-distribute" class="headerlink" title="2.2  setuptools 和 distribute"></a>2.2  setuptools 和 distribute</h3></li>
</ol>
</li>
</ul>
<h4 id="2-2-1-setuptools"><a href="#2-2-1-setuptools" class="headerlink" title="2.2.1 setuptools"></a>2.2.1 setuptools</h4><blockquote>
<p><a href="https://docs.python.org/3/distutils/setupscript.html">setuptools</a>包含了easy_install 这个工具。</p>
</blockquote>
<p>ez_setup.py 是 setuptools的安装工具。ez是easy的简写。</p>
<blockquote>
<p>简单的说，setuptools 是一个项目的名称，是基础组件。而 <code>easy_install</code> 是这个项目中提供的工具，它依赖基础组件工作。</p>
</blockquote>
<p>使用setuptools可以自动下载、构建、安装和管理python模块。</p>
<h3 id="2-2-2-distribute"><a href="#2-2-2-distribute" class="headerlink" title="2.2.2 distribute"></a>2.2.2 distribute</h3><blockquote>
<p>distribute 是setuptools的一个分支版本。</p>
</blockquote>
<h3 id="2-3-distutil2和dislib"><a href="#2-3-distutil2和dislib" class="headerlink" title="2.3 distutil2和dislib"></a>2.3 distutil2和dislib</h3><blockquote>
<p>这两种工具目前并未进入python3的标准库中，不必了解</p>
</blockquote>
<h2 id="3-打包文件格式"><a href="#3-打包文件格式" class="headerlink" title="3.打包文件格式"></a>3.打包文件格式</h2><h3 id="3-1-Eggs"><a href="#3-1-Eggs" class="headerlink" title="3.1 Eggs"></a>3.1 Eggs</h3><blockquote>
<p><a href="http://peak.telecommunity.com/DevCenter/PythonEggs">The Quick Guide to Python Eggs</a></p>
<pre><code>    Eggs are to Pythons as Jars are to Java..</code></pre>
</blockquote>
<p>Eggs格式是setuptools引入的一种文件格式，使用.egg扩展名，用于python模块的安装。</p>
<p>setuptools可以识别、解析并安装它。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">easy_install /my_downloads/OtherPackage-3.2.1-py2.3.egg</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>缺点：</p>
<p><strong>但是</strong>pip目前是python 包管理标准，而且pip 目前已经替代了 easy_install ，即是其很多功能建立在setuptools 组件之上。pip 本身并不希望使用Egg 格式，更希望采用“源码发行版（python setup.py sdist ）”,这样可充分利用 <a href="https://pip.pypa.io/en/latest/reference/pip_install/#requirements-file-format">Requirements File Format</a>提供的功能。</p>
</li>
</ul>
<h3 id="3-2-Wheel"><a href="#3-2-Wheel" class="headerlink" title="3.2 Wheel"></a>3.2 Wheel</h3><p><a href="https://wheel.readthedocs.io/en/stable/">Wheel</a> 本质上是一个zip 包格式，其使用 .whl 扩展名，用于python 模块的安装，它的出现是为了替代 Egg.</p>
<ul>
<li><p>发布包</p>
<p>wheel 还提供一个 bdist_wheel 作为setuptools 的扩展命令， 这个命令可以用来生成 wheel 包。</p>
</li>
<li><p>安装包</p>
<p>pip 提供了一个wheel 子命令来安装wheel 包。</p>
</li>
<li><p>setup.cfg</p>
<p><a href="https://wheel.readthedocs.io/en/latest/#defining-the-python-version">setup.cfg</a>可以用来定义wheel 打包的相关信息</p>
</li>
<li><p>与Egg 的区别</p>
<p><a href="">wheel vs Egg</a></p>
</li>
</ul>
<h2 id="4-发布模块"><a href="#4-发布模块" class="headerlink" title="4.发布模块"></a>4.发布模块</h2><blockquote>
<p>这里纯抄</p>
</blockquote>
<p>对于 python3 程序员来说，当然应该先看这一篇：<a href="https://docs.python.org/3/distributing/index.html">Distributing Python Modules</a>。</p>
<p>另外，<a href="https://packaging.python.org/en/latest/distributing.html">Tutorial on Packaging and Distributing Projects</a> 也足够详细和官方。</p>
<p>而 Python2 程序员则应该看这篇 <a href="https://docs.python.org/2.7/distutils/index.html">Distributing Python Modules</a> 。</p>
<p>当然，setuptools 的官方文档也是不错的教程：<a href="http://pythonhosted.org/setuptools/setuptools.html">Building and Distributing Packages with Setuptools</a> 。</p>
<p>这篇教程可以用来入门：<a href="https://hynek.me/articles/sharing-your-labor-of-love-pypi-quick-and-dirty/">Sharing Your Labor of Love: PyPI Quick and Dirty</a></p>
<p>至于如何发布自己的模块到 PyPI 或者搭建自己的私有包管理服务器，上面的文章已经讲得非常清楚了。</p>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5.结论"></a>5.结论</h2><ul>
<li>发布包采用的工具：setuptools</li>
<li>发布包格式：wheel</li>
</ul>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python包管理_实例操作</title>
    <url>/2020/04/02/Python%E5%8C%85%E7%AE%A1%E7%90%86-%E5%AE%9E%E4%BE%8B%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="Python包管理——简单案例"><a href="#Python包管理——简单案例" class="headerlink" title="Python包管理——简单案例"></a>Python包管理——简单案例</h1><blockquote>
<p>[Python packaging User Guide][<a href="https://packaging.python.org/tutorials/packaging-projects/]">https://packaging.python.org/tutorials/packaging-projects/]</a></p>
</blockquote>
<h2 id="1-创建简单项目"><a href="#1-创建简单项目" class="headerlink" title="1. 创建简单项目"></a>1. 创建简单项目</h2><ul>
<li><p>项目结构</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 可在D盘文件目录下查看</span><br><span class="line">packaging_tutorial/</span><br><span class="line">  example_pkg/</span><br><span class="line">    __init__.py</span><br></pre></td></tr></table></figure>
<ol>
<li>根目录：packaging_tutorial</li>
<li>包：example_pkg</li>
<li>包文件标识：__init__.py</li>
</ol>
</li>
</ul>
 <a id="more"></a> 

<h2 id="2-创建打包文件"><a href="#2-创建打包文件" class="headerlink" title="2. 创建打包文件"></a>2. 创建打包文件</h2><ul>
<li><p>结果项目结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">packaging_tutorial&#x2F;</span><br><span class="line">  example_pkg&#x2F;</span><br><span class="line">    __init__.py</span><br><span class="line">  setup.py</span><br><span class="line">  LICENSE</span><br><span class="line">  README.md</span><br></pre></td></tr></table></figure>
<ul>
<li><p>新增文件</p>
<blockquote>
<p>均位于主目录下</p>
</blockquote>
<ol>
<li><p>setup.py</p>
</li>
<li><p>LICENCE</p>
</li>
<li><p>README.MD</p>
<blockquote>
<p>非必须</p>
</blockquote>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="2-1-setup-py-文件简单编写"><a href="#2-1-setup-py-文件简单编写" class="headerlink" title="2.1 setup.py 文件简单编写"></a>2.1 setup.py 文件简单编写</h3><blockquote>
<p>此文件是打包的核心文件，用于告知setuptools包信息</p>
</blockquote>
<ul>
<li><p>此文档的编写示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> setuptools</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;README.md&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> fh:</span><br><span class="line">    long_description = fh.read()</span><br><span class="line"></span><br><span class="line">setuptools.setup(</span><br><span class="line">    name=<span class="string">&quot;example-pkg-HowardSun&quot;</span>, <span class="comment"># Replace with your own username</span></span><br><span class="line">    version=<span class="string">&quot;0.0.1&quot;</span>,</span><br><span class="line">    author=<span class="string">&quot;HowardSun&quot;</span>,</span><br><span class="line">    author_email=<span class="string">&quot;sun2387353@163.com&quot;</span>,</span><br><span class="line">    description=<span class="string">&quot;A small example package&quot;</span>,</span><br><span class="line">    long_description=long_description,</span><br><span class="line">    long_description_content_type=<span class="string">&quot;text/markdown&quot;</span>,</span><br><span class="line">    url=<span class="string">&quot;https://github.com/pypa/sampleproject&quot;</span>,</span><br><span class="line">    packages=setuptools.find_packages(),</span><br><span class="line">    classifiers=[</span><br><span class="line">        <span class="string">&quot;Programming Language :: Python :: 3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;License :: OSI Approved :: MIT License&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Operating System :: OS Independent&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    python_requires=<span class="string">&#x27;&gt;=3.6&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>name:发布的包名称，需要保证与他人发布包名无冲突。命名规则：字母、数字，-，_</p>
</li>
<li><p>version:版本号</p>
</li>
<li><p>author:作者</p>
</li>
<li><p>author_email：作者邮箱地址</p>
</li>
<li><p>long_description:发布包详细描述，可使用readme.md文件。</p>
</li>
<li><p>url:一般是github\gitlab地址</p>
</li>
<li><p>packages:项目所需要的包，可手动指定或使用find_packages()方式自动补充。</p>
<blockquote>
<p>此packages字段比较复杂，可以专门详解</p>
</blockquote>
</li>
<li><p>classifiers:添加包相关元信息</p>
<blockquote>
<p>[官方详解][<a href="https://pypi.org/classifiers/]%EF%BC%8C%E8%99%BD%E7%84%B6%E5%B9%B6%E6%9C%AA%E7%A0%94%E7%A9%B6%EF%BC%8C%E4%BD%86%E7%9C%8B%E6%9D%A5%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81">https://pypi.org/classifiers/]，虽然并未研究，但看来比较重要</a></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-README-md文件编写"><a href="#2-2-README-md文件编写" class="headerlink" title="2.2 README.md文件编写"></a>2.2 README.md文件编写</h3><blockquote>
<p>不解释</p>
</blockquote>
<h3 id="2-3-创建LICENSE文件"><a href="#2-3-创建LICENSE文件" class="headerlink" title="2.3 创建LICENSE文件"></a>2.3 创建LICENSE文件</h3><blockquote>
<p>用于告知用户相关的授权标准</p>
<p>[License官网][<a href="https://choosealicense.com/]">https://choosealicense.com/]</a></p>
</blockquote>
<h2 id="3-创建发布压缩文件"><a href="#3-创建发布压缩文件" class="headerlink" title="3. 创建发布压缩文件"></a>3. 创建发布压缩文件</h2><h3 id="3-1-安装工具包"><a href="#3-1-安装工具包" class="headerlink" title="3.1 安装工具包"></a>3.1 安装工具包</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python -m pip install --user --upgrade setuptools wheel</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-2-运行相关命令"><a href="#3-2-运行相关命令" class="headerlink" title="3.2 运行相关命令"></a>3.2 运行相关命令</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">python setup.py sdist bdist_wheel</span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果</p>
<ol>
<li><p>创建了build文件夹</p>
</li>
<li><p>创建了dist文件夹</p>
<ol>
<li><p>example_pkg_HowardSun-0.0.1-py3-none-any.whl</p>
<blockquote>
<p>发布文件</p>
</blockquote>
</li>
<li><p>example-pkg-HowardSun-0.0.1.tar.gz</p>
<blockquote>
<p>发布包的压缩文件</p>
</blockquote>
</li>
</ol>
</li>
<li><p>创建了example_pkg_HowardSun.egg-info文件夹</p>
</li>
</ol>
<h2 id="4-上传发布文件"><a href="#4-上传发布文件" class="headerlink" title="4.上传发布文件"></a>4.上传发布文件</h2></li>
</ul>
<h3 id="4-1-注册PyPI账号"><a href="#4-1-注册PyPI账号" class="headerlink" title="4.1 注册PyPI账号"></a>4.1 注册PyPI账号</h3><blockquote>
<p>测试中使用的[Test PyPI][ <a href="https://test.pypi.org/account/register/],%E4%B8%8E%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E4%B8%8D%E4%B8%80%E8%87%B4">https://test.pypi.org/account/register/],与正式发布不一致</a></p>
</blockquote>
<h3 id="4-2-安装发布工具包"><a href="#4-2-安装发布工具包" class="headerlink" title="4.2 安装发布工具包"></a>4.2 安装发布工具包</h3><blockquote>
<p>使用twine发布</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">python -m pip install --user --upgrade twine</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-3-运行相关命令"><a href="#4-3-运行相关命令" class="headerlink" title="4.3 运行相关命令"></a>4.3 运行相关命令</h3><blockquote>
<p>需要使用创建账户时创建的APITOKEN信息验证</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">python3 -m twine upload --repository-url https://test.pypi.org/legacy/ dist/*</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-安装新发布的包"><a href="#5-安装新发布的包" class="headerlink" title="5. 安装新发布的包"></a>5. 安装新发布的包</h2><blockquote>
<p>pip安装即可</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">python -m pip install --index-url https://test.pypi.org/simple/ --no-deps example-pkg-HowardSun</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>正常发布到PyPI上并不需要指定url</p>
</blockquote>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络基础</title>
    <url>/2020/04/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="神经网络和深度学习"><a href="#神经网络和深度学习" class="headerlink" title="神经网络和深度学习"></a>神经网络和深度学习</h1><blockquote>
<p><a href="https://kyonhuang.top/Andrew-Ng-Deep-Learning-notes/#/Neural_Networks_and_Deep_Learning/">笔记来源</a></p>
</blockquote>
<a id="more"></a>
<h2 id="神经网络基础"><a href="#神经网络基础" class="headerlink" title="神经网络基础"></a>神经网络基础</h2><h3 id="训练集、验证集与测试集"><a href="#训练集、验证集与测试集" class="headerlink" title="训练集、验证集与测试集"></a>训练集、验证集与测试集</h3><blockquote>
<p><a href="https://www.cnblogs.com/HuZihu/p/10538295.html">解释博客</a></p>
</blockquote>
<p>三种集合的关系一直是容易混淆的概念：</p>
<p><strong>训练集（Training Set）</strong>：用于训练模型。</p>
<p><strong>验证集（Validation Set）</strong>：用于调整和选择模型。</p>
<p><strong>测试集（Test Set）</strong>：用于评估最终的模型。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>Logistic回归中损失函数建议采用</li>
</ol>
<p>$$<br>L(\hat{y},y) = -(y\log\hat{y})-(1-y)\log(1-\hat{y})<br>$$</p>
<p>不建议采用平方差函数，存在局部解。<strong>可以去了解</strong></p>
<ol start="2">
<li>样本实例在矩阵中多采用<strong>列向量</strong>表示，也就是说m个由n维特征表示的样本矩阵为[n,m]</li>
</ol>
<ul>
<li>实现一个神经网络时，如果需要遍历整个训练集，并不需要直接使用 for 循环。</li>
<li>神经网络的计算过程中，通常有一个正向过程（forward pass）或者叫<strong>正向传播步骤（forward propagation step）</strong>，接着会有一个反向过程（backward pass）或者叫<strong>反向传播步骤（backward propagation step）</strong>。</li>
</ul>
<h3 id="Logistic回归"><a href="#Logistic回归" class="headerlink" title="Logistic回归"></a>Logistic回归</h3><blockquote>
<p>逻辑回归最简总结：</p>
<ul>
<li>线性回归+sigmoid函数</li>
</ul>
<p>$$<br>z= (w^Tx+b)<br>$$</p>
<p>$$<br>\hat y = \frac{1}{1+e^{-z}}<br>$$</p>
</blockquote>
<p>Logistic 回归是一个用于二分分类的算法。</p>
<p>Logistic 回归中使用的参数如下：</p>
<ul>
<li><p>输入的特征向量：$ x \in R^{n_x}$ , 其中${n_x}$是特征数量；</p>
</li>
<li><p>用于训练的标签：$y \in 0,1$;</p>
</li>
<li><p>权重：$w \in R^{n_x}$</p>
</li>
<li><p>偏置：$b \in R$</p>
</li>
<li><p>输出：$\hat{y} = \sigma(w^Tx+b)$</p>
</li>
<li><p>Sigmoid 函数：</p>
</li>
</ul>
<p>$$<br>  s = \sigma(w^Tx+b) = \sigma(z) = \frac{1}{1+e^{-z}}<br>$$</p>
<p>为了将 $w^Tx+b$  约束在 [0, 1] 间，引入 Sigmoid 函数。从下图可看出，Sigmoid 函数的值域为 [0, 1]。</p>



<p>Logistic 回归可以看作是一个非常小的神经网络。下图是一个典型例子：</p>
<blockquote>
<p>也就是一个普通的神经元</p>
</blockquote>



<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p><strong>损失函数（loss function）</strong>用于衡量预测结果与真实值之间的误差。</p>
<p>最简单的损失函数定义方式为平方差损失：<br>$$<br>L(\hat{y},y) = \frac{1}{2}(\hat{y}-y)^2<br>$$<br>但 Logistic 回归中我们<strong>并不倾向</strong>于使用这样的损失函数，因为之后讨论的优化问题会变成非凸的，最后会得到很多个局部最优解，梯度下降法可能找不到全局最优值。</p>
<p>一般使用<br>$$<br>L(\hat{y},y) = -(y\log\hat{y})-(1-y)\log(1-\hat{y})<br>$$<br>损失函数是在单个训练样本中定义的，它衡量了在<strong>单个</strong>训练样本上的表现。而<strong>代价函数（cost function，或者称作成本函数）</strong>衡量的是在<strong>全体</strong>训练样本上的表现，即衡量参数 w 和 b 的效果。<br>$$<br>J(w,b) = \frac{1}{m}\sum_{i=1}^mL(\hat{y}^{(i)},y^{(i)})<br>$$</p>
<h3 id="梯度下降法（Gradient-Descent）"><a href="#梯度下降法（Gradient-Descent）" class="headerlink" title="梯度下降法（Gradient Descent）"></a>梯度下降法（Gradient Descent）</h3><blockquote>
<p>最简总结：<br>$$<br>w := w - \alpha\frac{dJ(w, b)}{dw}<br>$$</p>
</blockquote>
<p>函数的<strong>梯度（gradient）</strong>指出了函数的最陡增长方向。即是说，按梯度的方向走，函数增长得就越快。那么按梯度的负方向走，函数值自然就降低得最快了。</p>
<p>模型的训练目标即是寻找合适的 w 与 b 以最小化代价函数值。简单起见我们先假设 w 与 b 都是一维实数，那么可以得到如下的 J 关于 w 与 b 的图：</p>



<p>可以看到，成本函数 J 是一个<strong>凸函数</strong>，与非凸函数的区别在于其不含有多个局部最低点；选择这样的代价函数就保证了无论我们初始化模型参数如何，都能够寻找到合适的最优解。</p>
<p>参数 w 的更新公式为：<br>$$<br>w := w - \alpha\frac{dJ(w, b)}{dw}<br>$$<br>其中 α 表示学习速率，即每次更新的 w 的步伐长度。</p>
<p>当 w 大于最优解 w′ 时，导数大于 0，那么 w 就会向更小的方向更新。反之当 w 小于最优解 w′ 时，导数小于 0，那么 w 就会向更大的方向更新。迭代直到收敛。</p>
<p>在成本函数 J(w, b) 中还存在参数 b，因此也有：<br>$$<br>b := b - \alpha\frac{dJ(w, b)}{db}<br>$$</p>
<h3 id="计算图（Computation-Graph）"><a href="#计算图（Computation-Graph）" class="headerlink" title="计算图（Computation Graph）"></a>计算图（Computation Graph）</h3><p>神经网络中的计算即是由多个计算网络输出的前向传播与计算梯度的后向传播构成。所谓的<strong>反向传播（Back Propagation）</strong>即是当我们需要计算最终值相对于某个特征变量的导数时，我们需要利用计算图中上一步的结点定义。</p>
<h3 id="Logistic回归中的梯度下降法"><a href="#Logistic回归中的梯度下降法" class="headerlink" title="Logistic回归中的梯度下降法"></a>Logistic回归中的梯度下降法</h3><p>假设输入的特征向量维度为 2，即输入参数共有 x1, w1, x2, w2, b 这五个。可以推导出如下的计算图：</p>



<p>首先反向求出 L 对于 a 的导数：<br>$$<br>da=\frac{dL(a,y)}{da}=\frac{1-y}{1-a}-\frac{y}{a}<br>$$<br>然后继续反向求出 L 对于 z 的导数：<br>$$<br>dz=\frac{dL}{dz}=\frac{dL(a,y)}{dz}=\frac{dL}{da}\frac{da}{dz}=a-y<br>$$<br>依此类推求出最终的损失函数相较于原始参数的导数之后，根据如下公式进行参数更新：<br>$$<br>w _1:=w _1-\alpha dw _1<br>$$</p>
<p>$$<br>w _2:=w _2-\alpha dw _2<br>$$</p>
<p>$$<br>b:=b-\alpha db<br>$$</p>
<p>接下来我们需要将对于单个用例的损失函数扩展到整个训练集的代价函数：<br>$$<br>J(w,b)=\frac{1}{m}\sum^m_{i=1}L(a^{(i)},y^{(i)})<br>$$<br>其中:<br>$$<br>  a^{(i)}=\hat{y}^{(i)}=\sigma(z^{(i)})=\sigma(w^Tx^{(i)}+b)<br>$$<br>我们可以对于某个权重参数 $w_1$，其导数计算为：<br>$$<br>\frac{\partial J(w,b)}{\partial{w_1}}=\frac{1}{m}\sum^m_{i=1}\frac{\partial L(a^{(i)},y^{(i)})}{\partial{w_1}}<br>$$<br>完整的 Logistic 回归中某次训练的流程如下，这里仅假设特征向量的维度为 2：</p>



<p>然后对 w1、w2、b 进行迭代。</p>
<p>上述过程在计算时有一个缺点：你需要编写两个 for 循环。第一个 for 循环遍历 m 个样本，而第二个 for 循环遍历所有特征。如果有大量特征，在代码中显式使用 for 循环会使算法很低效。<strong>向量化</strong>可以用于解决显式使用 for 循环的问题。</p>
<h3 id="向量化（Vectorization）"><a href="#向量化（Vectorization）" class="headerlink" title="向量化（Vectorization）"></a>向量化（Vectorization）</h3><p>在 Logistic 回归中，需要计算<br>$$<br>z=w^Tx+b<br>$$<br>如果是非向量化的循环方式操作，代码可能如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_x):</span><br><span class="line">    z += w[i] * x[i]</span><br><span class="line">z += b</span><br></pre></td></tr></table></figure>
<p>而如果是向量化的操作，代码则会简洁很多，并带来近百倍的性能提升（并行指令）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = np.dot(w, x) + b</span><br></pre></td></tr></table></figure>
<p>不用显式 for 循环，实现 Logistic 回归的梯度下降一次迭代（对应之前蓝色代码的 for 循环部分。这里公式和 NumPy 的代码混杂，注意分辨）<br>$$<br>Z=w^TX+b=np.dot(w.T, x) + b<br>$$</p>
<p>$$<br> A=\sigma(Z)<br>$$</p>
<p>$$<br> dZ=A-Y<br>$$</p>
<p>$$<br>dw=\frac{1}{m}XdZ^T<br>$$</p>
<p>$$<br> db=\frac{1}{m}np.sum(dZ)<br>$$</p>
<p>$$<br> w:=w-\sigma dw<br>$$</p>
<p>$$<br> b:=b-\sigma db<br>$$</p>
<p>正向和反向传播尽管如此，多次迭代的梯度下降依然需要 for 循环。</p>
<h3 id="广播（broadcasting）"><a href="#广播（broadcasting）" class="headerlink" title="广播（broadcasting）"></a>广播（broadcasting）</h3><p>Numpy 的 Universal functions 中要求输入的数组 shape 是一致的。当数组的 shape 不相等的时候，则会使用广播机制，调整数组使得 shape 一样，满足规则，则可以运算，否则就出错。</p>
<p>四条规则：</p>
<ol>
<li>让所有输入数组都向其中 shape 最长的数组看齐，shape 中不足的部分都通过在前面加 1 补齐；</li>
<li>输出数组的 shape 是输入数组 shape 的各个轴上的最大值；</li>
<li>如果输入数组的某个轴和输出数组的对应轴的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错；</li>
<li>当输入数组的某个轴的长度为 1 时，沿着此轴运算时都用此轴上的第一组值。</li>
</ol>
<h3 id="Numpy-使用技巧"><a href="#Numpy-使用技巧" class="headerlink" title="Numpy 使用技巧"></a>Numpy 使用技巧</h3><p>转置对秩为 1 的数组无效。因此，应该避免使用秩为 1 的数组，用 n * 1 的矩阵代替。例如，用<code>np.random.randn(5,1)</code>代替<code>np.random.randn(5)</code>。</p>
<p>如果得到了一个秩为 1 的数组，可以使用<code>reshape</code>进行转换。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Neural Network</category>
      </categories>
  </entry>
  <entry>
    <title>语言是窗</title>
    <url>/2020/04/03/%E8%AF%AD%E8%A8%80%E6%98%AF%E7%AA%97/</url>
    <content><![CDATA[<p>难得看了一会儿书，这首诗写得很有代入感，故摘抄部分。</p>
<!-- more -- >


## 语言是窗

听了你的话，我仿佛受到审判，

无比委屈，又无从分辨，

那离开前，我想问，

那真的是你的意思吗？



在自我辩护前，

在带着痛苦或恐惧质问前，

在我用言语筑起心灵之墙前，

告诉我，我听明白了吗？

...

如果你以为我想羞辱你，

如果你认定我不在乎你，

请透过我的言语，

倾听我们共有的情感。

]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title>python-爬虫</title>
    <url>/2020/04/05/python-%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h1 id="Python-爬虫"><a href="#Python-爬虫" class="headerlink" title="Python_爬虫"></a>Python_爬虫</h1><p>爬虫对我来说一直是听说过没做过，今天一时兴起将爬虫的课程过了一遍，整理笔记如下。Python中是提供了爬虫库的，但学习中多采用requests库用于理解爬虫的过程。这里仅对老师讲解的部分进行了记录，还有很多未曾接触了，例如动态代理、header模拟浏览器等等针对反爬虫的策略。权当一份框架型笔记即可。</p>
<a id="more"></a>

<blockquote>
<p>[慕课课程][<a href="https://www.icourse163.org/course/BIT-1001870001]">https://www.icourse163.org/course/BIT-1001870001]</a></p>
</blockquote>
<h2 id="爬虫的主要流程"><a href="#爬虫的主要流程" class="headerlink" title="爬虫的主要流程"></a>爬虫的主要流程</h2><ol>
<li>请求获得对应网络信息</li>
<li>解析网络信息</li>
<li>存储需要的网络信息</li>
</ol>
<h2 id="Requests库介绍"><a href="#Requests库介绍" class="headerlink" title="Requests库介绍"></a>Requests库介绍</h2><p>用于爬虫第一步，发送HTTP请求获取对应网络信息。这里仅对Requests库做整体的介绍，具体方法的操作与技巧，可看[官方文档][<a href="https://requests.readthedocs.io/en/master/]%E6%88%96%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99%E3%80%82">https://requests.readthedocs.io/en/master/]或其他相关资料。</a></p>
<h4 id="requests主要方法"><a href="#requests主要方法" class="headerlink" title="requests主要方法"></a>requests主要方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>与HTTP对应</th>
<th>HTTP说明</th>
</tr>
</thead>
<tbody><tr>
<td>requests.request()</td>
<td>基础方法，构造一个请求</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>get()</td>
<td>获取HTML网页内容</td>
<td>GET</td>
<td>获得网页<strong>全内容</strong></td>
</tr>
<tr>
<td>head()</td>
<td>获取HTML网页头信息</td>
<td>HEAD</td>
<td>仅获得网页<strong>头信息</strong></td>
</tr>
<tr>
<td>post()</td>
<td>向HTML网页提交POST请求</td>
<td>POST</td>
<td>在已有资源后<strong>添加</strong>POST资源</td>
</tr>
<tr>
<td>put()</td>
<td>向HTML网页提交PUT请求</td>
<td>PUT</td>
<td>利用PUT资源<strong>替换</strong>原有资源</td>
</tr>
<tr>
<td>patch()</td>
<td>向HTML网页提交PATCH请求</td>
<td>PATCH</td>
<td><strong>局部更新</strong>PATCH指定资源</td>
</tr>
<tr>
<td>delete()</td>
<td>向HTML网页提交DELETE请求</td>
<td>DELETE</td>
<td><strong>删除</strong>资源</td>
</tr>
</tbody></table>
<p>我们可以看到其拥有七个主要方法，并且除基础方法外均一一对应与HTTP定义。除request() 方法外，六个方法均包装了request() 方法，所以上面七个方法本质上均为request() 方法，仅为方便用户使用。</p>
<p>在爬虫应用中，常使用get()或head()方法，其他对于资源修改的方法，反而不常用。</p>
<p>这里需要简单了解HTTP协议，以便更好的理解上述内容。</p>
<h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>HTTP：Hypertext Transfer Protocol , 超文本传输协议，是一种基于”<strong>请求与响应</strong>“,无状态的应用层协议。</p>
<p>理解此协议可以从定义出发：1.<strong>请求与响应</strong>：说明HTTP协议的工作方式为客户端向服务器发送请求，服务器向客户端响应。2.<strong>无状态</strong>：说明HTTP协议前后无关，没有记忆信息。3.<strong>应用层</strong>:高层协议，已经是面向用户的协议了。</p>
<p>HTTP协议通过URL定位资源，通过对应请求（GET\HEAD\PUT…）进行相关操作。对于URL的格式这里不解释。对于请求，HTTP规定了6种请求方式，如图：</p>

<p>各种方法解释，图上都有，这里不详细解释。我们发现与request的请求方法<strong>是一一对应</strong>的。前两种方法用于获取数据，后四种方法用于修改数据。</p>
<h4 id="Request对象与Response对象"><a href="#Request对象与Response对象" class="headerlink" title="Request对象与Response对象"></a>Request对象与Response对象</h4><p>requests库主要包含两个对象，分别是Request与Response,分别对应<strong>发送对象</strong>，<strong>返回对象</strong>。</p>


<h5 id="Response对象属性"><a href="#Response对象属性" class="headerlink" title="Response对象属性"></a>Response对象属性</h5><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r.status_code</td>
<td>HTTP请求的返回状态，<strong>200</strong>表示<strong>连接成功</strong>，<strong>404</strong>表示<strong>失败</strong></td>
</tr>
<tr>
<td>r.text</td>
<td>HTTP相应内容的字符串信息，即URL对应的网页内容</td>
</tr>
<tr>
<td>r.encoding</td>
<td>从HTTPheader中<strong>猜测</strong>的相应内容编码方式</td>
</tr>
<tr>
<td>r.apparent_encoding</td>
<td>从<strong>内容</strong>中<strong>分析</strong>出的响应内容编码方式</td>
</tr>
<tr>
<td>r.content</td>
<td>HTTP响应内容的<strong>二进制</strong>形式</td>
</tr>
</tbody></table>
<p>注意点：</p>
<ol>
<li><p>encoding属性与apparent_encoding的区别</p>
<p>encoding属性是根据HTTP头信息中是否存在charset字典来确定值，但并不是每一个网站设计都会包含此字段，默认为”ISO…”编码格式，其不一定准确。</p>
<p>apparent_encoding属性，是根据文本内容分析得到的，通常具有较高的准确性。</p>
</li>
</ol>
<h5 id="Request异常与通用代码框架"><a href="#Request异常与通用代码框架" class="headerlink" title="Request异常与通用代码框架"></a>Request异常与通用代码框架</h5><table>
<thead>
<tr>
<th>异常</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>requests.ConnectionError</td>
<td>连接错误异常，如DNS查询失败、拒绝连接</td>
</tr>
<tr>
<td>requests.HTTPError</td>
<td>HTTP错误异常</td>
</tr>
<tr>
<td>request.URLRequired</td>
<td>URL缺失异常</td>
</tr>
<tr>
<td>request.ConnectTimeout</td>
<td>连接远程服务器超时异常</td>
</tr>
<tr>
<td>request.Timeout</td>
<td>请求URL超时异常</td>
</tr>
</tbody></table>
<p>请求异常可以分为以上几种，但并不需要记录，知道即可。</p>
<table>
<thead>
<tr>
<th>检测异常方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r.raise_for_status()</td>
<td>若果不是200，产生异常request.HTTPError</td>
</tr>
</tbody></table>
<p>上述方法用于检测是否出现异常，常用。</p>
<p>一下通用代码框架可用于常见爬虫框架。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url ,timeout = <span class="number">30</span>)</span><br><span class="line">        r.raise_for_status() <span class="comment"># 状态不是200则引发一场</span></span><br><span class="line">        r.enconding = r.apparent_encoding <span class="comment"># 替换编码格式</span></span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;产生异常&quot;</span></span><br><span class="line">    </span><br><span class="line">url = <span class="string">&quot;http://www.baidu.com&quot;</span></span><br><span class="line">print(getHTMLText(url))</span><br></pre></td></tr></table></figure>
<h2 id="Robots协议"><a href="#Robots协议" class="headerlink" title="Robots协议"></a>Robots协议</h2><p>此协议是针对爬虫所指定的规范，哪些可以爬，哪些不能爬。通常直接放置在根目录下。例如百度”<a href="https://www.baidu.com/robots.txt&quot;.%E5%B9%B6%E6%88%AA%E5%8F%96%E5%A6%82%E4%B8%8B%E5%B1%95%E7%A4%BA%EF%BC%9A">https://www.baidu.com/robots.txt&quot;.并截取如下展示：</a></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">User-agent: Baiduspider</span><br><span class="line">Disallow: /baidu</span><br><span class="line">Disallow: /s?</span><br><span class="line">Disallow: /ulink?</span><br><span class="line">Disallow: /link?</span><br><span class="line">Disallow: /home/news/data/</span><br><span class="line">Disallow: /bh</span><br><span class="line"></span><br><span class="line">User-agent: Googlebot</span><br><span class="line">Disallow: /baidu</span><br><span class="line">Disallow: /s?</span><br><span class="line">Disallow: /shifen/</span><br><span class="line">Disallow: /homepage/</span><br><span class="line">Disallow: /cpro</span><br><span class="line">Disallow: /ulink?</span><br><span class="line">Disallow: /link?</span><br><span class="line">Disallow: /home/ne</span><br></pre></td></tr></table></figure>
<ul>
<li>user-agent:爬取框架/爬取人</li>
<li>Disallow:不允许爬取的内容通配符</li>
</ul>
<h2 id="BeautifulSoup库"><a href="#BeautifulSoup库" class="headerlink" title="BeautifulSoup库"></a>BeautifulSoup库</h2><p>BeautifulSoup可用于爬虫过程第二步，对HTML进行树结构解析，并提供了相对完备的遍历方法。</p>
<h3 id="BeautifulSoup的基本使用"><a href="#BeautifulSoup的基本使用" class="headerlink" title="BeautifulSoup的基本使用"></a>BeautifulSoup的基本使用</h3><p>使用很简单，指定HTML地址与解析方式即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将纯文本文件转换为树形结构，并进行解析便是BeautifulSoup的作用</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="keyword">as</span> bs</span><br><span class="line"><span class="comment">#第一个参数为通过requests获得的html文本</span></span><br><span class="line"><span class="comment">#第二个参数为指定用HTML格式解析此文本</span></span><br><span class="line"><span class="comment">#返回soup对象</span></span><br><span class="line">soup = bs(r.text,<span class="string">&quot;html.parser&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="soup对象的基本元素"><a href="#soup对象的基本元素" class="headerlink" title="soup对象的基本元素"></a>soup对象的基本元素</h3><table>
<thead>
<tr>
<th>基本元素</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Tag</td>
<td>标签，基本的信息组织单元，分别用&lt;&gt;和&lt;/&gt;表明开头与结尾</td>
</tr>
<tr>
<td>Name</td>
<td>标签名，p标签，a标签等，使用格式：Tag.name</td>
</tr>
<tr>
<td>Attributes</td>
<td>标签属性，字典形式组织，使用格式: Tag.attrs</td>
</tr>
<tr>
<td>NavigableString</td>
<td>标签内非属性字符串，使用格式：Tag.string</td>
</tr>
<tr>
<td>Comment</td>
<td>标签内字符串的注释部分，<!--....<--></td>
</tr>
</tbody></table>
<p>由上表可知，soup内对象基本元素的调用，以Tag元素为基础进行。</p>
<ul>
<li><p>Tag标签的调用</p>
<p>直接通过标签名称调用即可</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = bs(<span class="string">&quot;htmladress&quot;</span>,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"><span class="comment">#调用a标签，并获得标签对象</span></span><br><span class="line">soup.a</span><br><span class="line"><span class="comment">#调用body标签并获得标签对象</span></span><br><span class="line">soup.body</span><br></pre></td></tr></table></figure>
<ul>
<li>name,标签名的获得</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = bs(<span class="string">&quot;htmladress&quot;</span>,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"><span class="comment">#调用a标签，并获得标签对象</span></span><br><span class="line">tagA = soup.a</span><br><span class="line"><span class="comment">#获得a标签的标签名</span></span><br><span class="line">tagA.name</span><br></pre></td></tr></table></figure>
<ul>
<li>attrs,标签属性的获得</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = bs(<span class="string">&quot;htmladress&quot;</span>,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"><span class="comment">#调用a标签，并获得标签对象</span></span><br><span class="line">tagA = soup.a</span><br><span class="line"><span class="comment">#获得a标签的属性字典</span></span><br><span class="line">tagA.attrs</span><br></pre></td></tr></table></figure>
<ul>
<li>NavigableString,标签内非属性字符串的获得</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = bs(<span class="string">&quot;htmladress&quot;</span>,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"><span class="comment">#调用a标签，并获得标签对象</span></span><br><span class="line">tagA = soup.a</span><br><span class="line"><span class="comment">#获得普通字符串，可以跨层次</span></span><br><span class="line">tagA.string</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Comment,标签内部Comment获得，比较特殊</p>
<p>并没有一个为comment的属性直接进行提取Comment，但是可通过上述的.string方式获得Comment内容，不同处在于其列别可通过type()函数进行鉴别。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">newsoup = BeautifulSoup(<span class="string">&quot;&lt;b&gt;&lt;!-- this is comment --&gt;&lt;p&gt;This is not comment&lt;/p&gt;&lt;/b&gt;&quot;</span>)</span><br><span class="line">newsoup.b.string</span><br><span class="line"><span class="comment">#获得字符，但不知是否是comment还是NavigableString</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">type</span>(newsoup.b.string) <span class="keyword">is</span> bs4.elemnt.Comment :</span><br><span class="line">    print(<span class="string">&quot;发现Comment&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>下图为熟知的HTML格式，其与BeautifulSoup基本是一一对应的。</p>


<h3 id="BS的遍历"><a href="#BS的遍历" class="headerlink" title="BS的遍历"></a>BS的遍历</h3><p>BeautifulSoup对于树的遍历方式，并没有特殊的内容，这里仅做简单的介绍，知道即可。重点还是在应用中的情形。</p>
<p>三种遍历方式：上行、下行、平行</p>


<ul>
<li>下行遍历方法展示</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.content</td>
<td>子节点的列表，将所有子节点信息存入列表</td>
</tr>
<tr>
<td>.children</td>
<td>子节点的<strong>迭代</strong>类型，用于循环<strong>遍历</strong>子节点情形</td>
</tr>
<tr>
<td>.descendants</td>
<td>子孙节点的迭代类型，包含<strong>所有的子孙节点</strong>，用于<strong>遍历</strong></td>
</tr>
</tbody></table>
<ul>
<li>上行遍历方法展示</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.parent</td>
<td>节点的父节点标签</td>
</tr>
<tr>
<td>.parents</td>
<td>节点的祖先节点标签，用于<strong>循环遍历</strong></td>
</tr>
</tbody></table>
<ul>
<li>平行遍历方法展示</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.next_sibling</td>
<td>返回HTML文本顺序中下一个平行节点标签</td>
</tr>
<tr>
<td>.previous_sibling</td>
<td>返回HTML文本顺序中上一个平行节点标签</td>
</tr>
<tr>
<td>.next_siblings</td>
<td>迭代类型，返回HTML文本顺序中后序所有平行节点标签</td>
</tr>
<tr>
<td>.previous_siblings</td>
<td>迭代类型，返回HTML文本顺序中前序所有平行节点标签</td>
</tr>
</tbody></table>
<p>注意：平行遍历指的是在同一个父节点的前提下，而不是树中所有同一层次的情况。如图：</p>

<p>Bs4的遍历情况总结如图：</p>


<h2 id="信息标注方式与信息提取方法"><a href="#信息标注方式与信息提取方法" class="headerlink" title="信息标注方式与信息提取方法"></a>信息标注方式与信息提取方法</h2><h3 id="信息标注方式简介"><a href="#信息标注方式简介" class="headerlink" title="信息标注方式简介"></a>信息标注方式简介</h3><p>常见的信息标注方式有三种，分别是XML、JSON、YAML。HTML是XML的变种，也属于XML格式。下面简单的介绍比较三种信息标注方式。</p>
<ul>
<li>XML：eXtensible Markup Language , 其构成单位是Tag标签，且标签内包含有名称属性等信息如图：</li>
</ul>



<pre><code>其中空元素可通过一个&lt;&gt;表示 , 注释通过&lt;!-- --&gt; 表示</code></pre>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#XML空元素表示</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;china.jpg&quot;</span> <span class="attr">size</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">#XML注释格式</span><br><span class="line"><span class="comment">&lt;!-- This is a comment --&gt;</span></span><br></pre></td></tr></table></figure>
<p>总结：XML格式共包含三种样式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- --&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>JSON：JavaScript Object Notation , <strong>有类型</strong>的键值对表示方式</li>
</ul>



<p>总结：JSON格式包含三种样式</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#普通键值对表示</span><br><span class="line">&quot;key&quot; : &quot;Value&quot;</span><br><span class="line">#多值键值对表示</span><br><span class="line">&quot;key&quot; : [&quot;Value1&quot;,&quot;Value2&quot;]</span><br><span class="line">#键值对嵌套表示</span><br><span class="line">&quot;key&quot; : &#123;&quot;subkey&quot; : &quot;subvalue&quot;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>YAML：Ain’t Markup Language ， 无类型键值对</li>
</ul>


<p>  其表示各种关系情况：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#缩进表示所属关系，同Python</span></span><br><span class="line"><span class="attr">name:</span></span><br><span class="line">	<span class="attr">newName :</span> <span class="string">北京理工</span></span><br><span class="line">	<span class="attr">OldName :</span> <span class="string">延安自然科学院</span></span><br><span class="line"><span class="comment"># “-” 表达并列关系</span></span><br><span class="line"><span class="attr">name:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">北京理工大学</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">延安自然科学院</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># “|”表达整块数据</span></span><br><span class="line"><span class="attr">text:</span> <span class="string">|</span></span><br><span class="line"><span class="string">北京理工大学创立与......</span></span><br></pre></td></tr></table></figure>
<p>总结:三种表示形式如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">key :</span> <span class="string">value</span></span><br><span class="line"></span><br><span class="line"><span class="attr">key :</span> <span class="comment">#comment</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">value1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">value2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">key:</span></span><br><span class="line">	<span class="attr">subkey :</span> <span class="string">value</span> </span><br><span class="line">		</span><br></pre></td></tr></table></figure>
<h3 id="信息标注方式实例比较"><a href="#信息标注方式实例比较" class="headerlink" title="信息标注方式实例比较"></a>信息标注方式实例比较</h3><p>XML：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">firstName</span>&gt;</span>Tian<span class="tag">&lt;/<span class="name">firstName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lastName</span>&gt;</span>Song<span class="tag">&lt;/<span class="name">lastName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">streetAddr</span>&gt;</span>中关村南大街5号<span class="tag">&lt;/<span class="name">streetAddr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">city</span>&gt;</span>北京市<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">zipcode</span>&gt;</span>100081<span class="tag">&lt;/<span class="name">zipcode</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prof</span>&gt;</span>ComputerSystem<span class="tag">&lt;/<span class="name">prof</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prof</span>&gt;</span>Security<span class="tag">&lt;/<span class="name">prof</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--最早的通用标记语言，可扩展性好，但很繁琐 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用于INTERNET 信息交互与传递 --&gt;</span></span><br></pre></td></tr></table></figure>
<p>JSON:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    “firstName”: “Tian”,</span><br><span class="line">    “lastName”: “Song”,</span><br><span class="line">    “address”:&#123;“streetAddr”: “中关村南大街5号” ,</span><br><span class="line">               “city”: “北京市” ,</span><br><span class="line">               “zipcode”: “100081”&#125;,</span><br><span class="line">    “prof”:[“ComputerSystem”, “Security”]</span><br><span class="line">&#125;</span><br><span class="line">#信息有类型，适合程序处理，比XML简洁</span><br><span class="line">#用于移动英语云端与节点信息通信，无注释</span><br></pre></td></tr></table></figure>
<p>YAML:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">firstName:</span> <span class="string">Tian</span></span><br><span class="line"><span class="attr">lastName:</span> <span class="string">Song</span></span><br><span class="line"><span class="attr">address:</span></span><br><span class="line">	<span class="string">streetAddr:中关村南大街5号</span></span><br><span class="line">	<span class="string">city:北京市</span></span><br><span class="line">	<span class="attr">zipcode:</span> <span class="number">100081</span></span><br><span class="line"><span class="attr">prof:</span></span><br><span class="line"><span class="string">‐Computer</span> <span class="string">System</span></span><br><span class="line"><span class="string">‐Security</span></span><br><span class="line"><span class="comment"># 信息无类型，文本信息比例最高，可读性好</span></span><br><span class="line"><span class="comment"># 常用于各类系统配置文件，有注释易读</span></span><br></pre></td></tr></table></figure>


<h3 id="信息提取的三种方法"><a href="#信息提取的三种方法" class="headerlink" title="信息提取的三种方法"></a>信息提取的三种方法</h3><p>这里的信息提取指的是提取标注信息（xml、json、yaml）内容。</p>
<ol>
<li><p>完整解析信息标记，再提取关键信息，需要标记解析器，如BS4。虽然准确但是繁琐，速度慢。</p>
</li>
<li><p>无视标记形式，直接搜索关键信息。对信息文本直接查找。提取速度快，但准确性不确定。</p>
</li>
<li><p>融合方法，一般先通过第二种方式确定范围，再使用第一种方式精确处理。如图</p>


</li>
</ol>
<h3 id="基于Bs4库的HTML内容查找方法"><a href="#基于Bs4库的HTML内容查找方法" class="headerlink" title="基于Bs4库的HTML内容查找方法"></a>基于Bs4库的HTML内容查找方法</h3><p>由于本部分内容过于简单，更多的需要在实践中应用，故未详细说明。正则表达式也可以用于检索。</p>
<ol>
<li>首先利用find_all()方法，无视标记形式，直接搜索关键信息。</li>
</ol>


<ol start="2">
<li>其次解析其标签格式</li>
</ol>
<h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定向页面爬取</span></span><br><span class="line"><span class="comment">#获得中国“最好”大学排名情况</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"><span class="comment"># 1.通过requests等库获得网页内容</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 2.通过beautifulSoup等库解析网页内容，并获取关键信息 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillUnivList</span>(<span class="params">ulist, html</span>):</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">&#x27;tbody&#x27;</span>).children:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(tr, bs4.element.Tag):</span><br><span class="line">            tds = tr(<span class="string">&#x27;td&#x27;</span>)</span><br><span class="line">            ulist.append([tds[<span class="number">0</span>].string, tds[<span class="number">1</span>].string, tds[<span class="number">3</span>].string])</span><br><span class="line"><span class="comment"># 3.可视化输出</span></span><br><span class="line"><span class="comment">#chr(12288)用于中文符号填充，未研究</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList</span>(<span class="params">ulist, num</span>):</span></span><br><span class="line">    tplt = <span class="string">&quot;&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;&quot;</span></span><br><span class="line">    print(tplt.<span class="built_in">format</span>(<span class="string">&quot;排名&quot;</span>,<span class="string">&quot;学校名称&quot;</span>,<span class="string">&quot;总分&quot;</span>,<span class="built_in">chr</span>(<span class="number">12288</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        u=ulist[i]</span><br><span class="line">        print(tplt.<span class="built_in">format</span>(u[<span class="number">0</span>],u[<span class="number">1</span>],u[<span class="number">2</span>],<span class="built_in">chr</span>(<span class="number">12288</span>)))</span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">&#x27;http://www.zuihaodaxue.com/zuihaodaxuepaiming2018.html&#x27;</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    fillUnivList(uinfo, html)</span><br><span class="line">    printUnivList(uinfo, <span class="number">20</span>) <span class="comment"># 20 univs</span></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>wordNet Introduction</title>
    <url>/2020/04/26/wordNet-Introduction/</url>
    <content><![CDATA[<h1 id="WordNet简介与原理"><a href="#WordNet简介与原理" class="headerlink" title="WordNet简介与原理"></a>WordNet简介与原理</h1><h2 id="什么是WordNet"><a href="#什么是WordNet" class="headerlink" title="什么是WordNet"></a>什么是WordNet</h2><blockquote>
<p><a href="http://wordnetweb.princeton.edu/perl/webwn">wordNet在线使用地址</a>  <a href="http://www.nltk.org/howto/wordnet.html">wordNet_API</a>  <a href="http://wordvis.com/">wordNet_可视化</a></p>
</blockquote>
<p>一句话概括WorNet即为：面向<strong>英文</strong>的<strong>词汇</strong>数据库，其按照单词的含义构造了单词的网络。WordNet的最大的特点为<strong>按照词义构建词集</strong>，</p>
<a id="more"></a>

<p>在WordNet中词性是分类的重要标准，按照词性划分为四类同义词集，分别是动词同义词集、名词同义词集、形容词同义词集与副词同义词集。上述的四种同义词集各自构成了同义词网络。每一个同义词的集合表示一个基本<strong>语义</strong>概念，并且集合之间存在各种关系。</p>
<p>集合之间的关系包括九类：上下位关系（动词、名词）、蕴含关系（动词）、相似关系（名词）、成员部分关系（名词）、物质部分关系（名词）、部件部分关系（名词）、致使关系（动词）、相关动词关系（动词）、属性关系（形容词）。</p>
<p>例如名词”Love”的上下位关系为：</p>
<blockquote>
<p>entity——&gt;abstract entity——&gt;abstraction——&gt;attribute——&gt;state——&gt;feeling——&gt; emotion——&gt;love;</p>
</blockquote>
<h2 id="WordNet的特点"><a href="#WordNet的特点" class="headerlink" title="WordNet的特点"></a>WordNet的特点</h2><h3 id="1-与一般词典的组织结构不同"><a href="#1-与一般词典的组织结构不同" class="headerlink" title="1.与一般词典的组织结构不同"></a>1.与一般词典的组织结构不同</h3><p>它利用<strong>同义词集合</strong>作为基本组织单位，用户可以在同义词集中找到合适的词表示某个已知的基本概念，同时也给出了定义与例句。</p>
<p>如果将WordNet视为数据库，则Synset就是一条数据的主键，代表了一个词义。Python中Synset展示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-2bb918806d6a3a21932dbed3514368a9_720w.jpg"></p>
<p>上图中是Synset基础用法，其通过单词”dog”，寻找包含”dog”的所有同义词集。</p>
<h3 id="2-同义词集间通过关系构成网络"><a href="#2-同义词集间通过关系构成网络" class="headerlink" title="2.同义词集间通过关系构成网络"></a>2.同义词集间通过关系构成网络</h3><p>WordNet中同义词集并非是独立的，其通过特定的关系类型构建同义词集网络架构。</p>


<p>上图是”China”词，在WordNet中涉及的同义词集关系展示。</p>
<h3 id="3-WordNet中同义词集的单义性"><a href="#3-WordNet中同义词集的单义性" class="headerlink" title="3.WordNet中同义词集的单义性"></a>3.WordNet中同义词集的单义性</h3><p>在WordNet中，大多数的同义词集都有说明性的注释，但一个Synset不等于词典中的一个词条，因为一个Synset只包含一个注释，而在传统词典中的词条是多义词，会有多个解释。</p>
<p>所以说，“一个Synset等于的是一个词义”这一点必须反复强调。以一条词义为一条数据，是<strong>跨语言</strong>想要成立所必须的条件。</p>
<h3 id="WordNet-非重要概念"><a href="#WordNet-非重要概念" class="headerlink" title="WordNet 非重要概念"></a>WordNet 非重要概念</h3><p>这一部分内容介绍了WordNet中不太重要的概念，不影响基本使用，但有利于理解。</p>
<ol>
<li><p>独立起始概念（Unique Beginner）</p>
<p>某些同义词集不存在上位词集，那么我们称之为独立起始概念。这个可以认为是语义领域内所有概念的<strong>原始语义元素</strong>。在WordNet中名词体系中存在25个独立起始概念，例如：时间、物质、目的、关系、属性等等。其下位词继承上位词的所有特点，这与编程思想中父子类的关系类似。</p>
</li>
<li><p>词典ID（Lexicographer ID）</p>
<p>每一个同义词集都包含一个唯一的编号。</p>
</li>
<li><p>概念链（Concept Chain）</p>
<p>这里的概念链指的是同义词集间<strong>上下位关系</strong>，构成的概念链条。与上面提到的关系可视化概念类似，但其仅包含<strong>上下位关系</strong>。</p>
<p><img src="https://images0.cnblogs.com/blog/577482/201411/271433099491914.png"></p>
<p>上图内容与可视化展示相似，这里不解释。</p>
</li>
</ol>
<h3 id="WordNet文件结构简介"><a href="#WordNet文件结构简介" class="headerlink" title="WordNet文件结构简介"></a>WordNet文件结构简介</h3><p>WordNet语料库中最常用的有两个：omw与wordnet</p>
<h3 id="omw文件夹"><a href="#omw文件夹" class="headerlink" title="omw文件夹"></a>omw文件夹</h3><p>此文件夹内包含有各国家地区的研究人员基于英文WordNet构建的本国语言的WordNet，目前包含有27个国家与地区，其中cmn(简体中文)和qcn（繁体中文）与中文相关。</p>
<p>文件夹中有三个文件，分别是<em>citation.bib</em>、<em>LICENSE</em>和<em>wn-data-语言名.tab</em>。</p>
<h4 id="wn-data-cmn-tab文件"><a href="#wn-data-cmn-tab文件" class="headerlink" title="wn-data-cmn.tab文件"></a>wn-data-cmn.tab文件</h4><p>词条保存在<em>wn-data-语言名.tab</em>文件中。打开后发现，简体中文下的词条一共有79808条，繁体为8069条</p>
<blockquote>
<p>数据为两年前，目前中文词条应高于上述数据。</p>
</blockquote>
<p>如图：<img src="https://pic3.zhimg.com/80/v2-41006ed2100aa2b4db229b225f1a232e_720w.jpg"></p>
<p>文件的内容分为三列，第一列为词义的八位十进制序号（offset）（对应于上述的词典ID）和词性（n：名词、v：动词、a：形容词、r：动词）；第二列内容为“语言名：lemma”；第三列是对应语言的词义。</p>
<p>“00001740-a”的词义共包含有3个具体的词汇，分别是可以+的，有能力+的、能。</p>
<p>中文简体通过去重之后的词义数量为42312条数据。</p>
<p>WordNet中原本的此役统计数据为：名词：82115条，动词：13767条，形容词：18156条，副词：3621条，共计：117659条。大约占三分之一。</p>
<h4 id="wordnet文件"><a href="#wordnet文件" class="headerlink" title="wordnet文件"></a>wordnet文件</h4><p>此文件内包含有wordnet的本体。</p>
<blockquote>
<p>wordnet文件夹中一共有18个文件，比较重要的文件有15个。其中四个是data文件，存放四种词性的词的根本内容；四个是index文件，即索引文件；四个是exc文件，对词汇的变形进行对应；还有一个是lexnames文件，存放所有词的45个意向集（即这117659条词义，可以被归为这45个类）。</p>
</blockquote>
<p><img src="https://pic4.zhimg.com/v2-c5dbed774c162f765bc463d8e304eaa7_r.jpg"></p>
<p><strong>data.pos文件</strong></p>
<p>此文件是一个数据文件，以data.adj中able词条为例子：</p>
<p><img src="https://pic4.zhimg.com/80/v2-1827c3322b2e806c0d7c39ac1aea170f_720w.jpg"></p>
<p>上图中表示了”1740”同义词集下的able词条，其内容依次包含：词典ID、词意向集序号、词性、同义词集内词个数、指针个数、指针列表、句型、注释与例句。</p>
<p><img src="https://pic3.zhimg.com/80/v2-ab25ae65a88e5b69cc1021d465ee0fa2_720w.jpg"></p>
<p>上图是指针符号列表，用于表示此同义词集与其他同义词集的关系。</p>
<p><strong>lexnames文件</strong></p>
<p>WordNet讲英文单词归类为45个意向集，其中名词26个，动词15个，形容词3个，副词1个。</p>
<p><img src="https://pic2.zhimg.com/80/v2-9344743c81376dce4224704602f02ef9_720w.jpg"></p>
<h2 id="WordNet-API"><a href="#WordNet-API" class="headerlink" title="WordNet_API"></a>WordNet_API</h2><p>官方提供了WordNet接口用于研究与应用。其提供了基于上述数据库文件的基本使用方式：包括同义词集的获取、同义词集对应关系的获取、意向词集的获取、语义相似度的判断。</p>
<p>wordNet提供了多种维度的语义相似度接口，一共包含有6种；</p>
<ol>
<li><p>基于上下位词的最短路径,输出空间0-1.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dog.path_similarity(cat)  <span class="comment"># doctest: +ELLIPSIS</span></span><br><span class="line"><span class="number">0.2</span>...</span><br></pre></td></tr></table></figure></li>
<li><p>基于上下位词的最短路径与最大深度，其计算公式$-\log(p/2d)$.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dog.lch_similarity(cat)  <span class="comment"># doctest: +ELLIPSIS</span></span><br><span class="line"><span class="number">2.028</span>...</span><br></pre></td></tr></table></figure></li>
<li><p>基于两同义词深度与最近公共父节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dog.wup_similarity(cat)  <span class="comment"># doctest: +ELLIPSIS</span></span><br><span class="line"><span class="number">0.857</span>...</span><br></pre></td></tr></table></figure></li>
<li><p>基于两同义词深度与最近公共父节点的含义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dog.res_similarity(cat, brown_ic)  <span class="comment"># doctest: +ELLIPSIS</span></span><br><span class="line"><span class="number">7.911</span>...</span><br></pre></td></tr></table></figure>
<p>第五种与第六种与上述类似，仅仅是公式不同，这里不再赘述。</p>
</li>
</ol>
<p>可以看到WordNet利用了同义词集、同义词集网络深度等信息实现语义相似度的计算。</p>
<p>参考地址：</p>
<blockquote>
<p><a href="https://wordnet.princeton.edu/">wordnet官网</a> <br><a href="https://blog.csdn.net/weixin_30600503/article/details/97794989">wordnet的一些入门性介绍</a><br><a href="https://blog.csdn.net/skiffloveblue/article/details/9359427">wordnet词网研究</a><br><a href="https://zhuanlan.zhihu.com/p/26527203">wordnet思路</a><br><a href="http://wordnetweb.princeton.edu/perl/webwn">wordNet在线使用地址</a>  <br><a href="http://www.nltk.org/howto/wordnet.html">wordNet_API</a><br> [wordNet_可视化](</p>
</blockquote>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Wordnet</category>
      </categories>
      <tags>
        <tag>wordnet</tag>
      </tags>
  </entry>
  <entry>
    <title>python-正则表达式</title>
    <url>/2020/04/06/python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Python-正则表达式"><a href="#Python-正则表达式" class="headerlink" title="Python_正则表达式"></a>Python_正则表达式</h1><p>正则表达式是常用于字符串匹配。之前也曾系统的看过相关的内容，但是一段时间不用发现又很陌生，特将相关内容记录如下。</p>
<a id="more"></a>

<p>正则表达式本身适用于匹配含有<strong>某种特征</strong>的字符串，从而对字符串进行相关处理（分割、替换、匹配等）。Python语言通过re库支持正则表达式。</p>
<h2 id="正则表达式简介"><a href="#正则表达式简介" class="headerlink" title="正则表达式简介"></a>正则表达式简介</h2><blockquote>
<p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p>
</blockquote>
<p>一个正则表达式由运算符与操作符构成，而运算符与操作符又可以分为若干种类。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>表示待匹配字符本身的符号，[a-z] 表示由a到z的单个字符。</p>
<h4 id="普通运算符"><a href="#普通运算符" class="headerlink" title="普通运算符"></a>普通运算符</h4><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。这里的<a href="https://www.runoob.com/regexp/regexp-metachar.html">元字符</a>可以单纯的理解为具有特殊含义的字符，不需要记忆。</p>
<h4 id="特殊运算符"><a href="#特殊运算符" class="headerlink" title="特殊运算符"></a>特殊运算符</h4><p>特殊运算符指的是利用<strong>转义字符</strong>表示特定字符的表示。可理解为对常见的运算符进行了约定表达，以达到简化的目的。</p>
<p>这里仅列举了常见的特殊运算符。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\w</td>
<td>匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。</td>
</tr>
<tr>
<td>\W</td>
<td>匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字字符。等价于 [0-9]。</td>
</tr>
<tr>
<td>\D</td>
<td>匹配一个非数字字符。等价于 [^0-9]。</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody></table>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>用于表示对运算符的某种操作，通常是限定符号。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>$</td>
<td>匹配结尾位置</td>
</tr>
<tr>
<td>( )</td>
<td>标记一个子表达式的开始和结束位置</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。</td>
</tr>
<tr>
<td>[</td>
<td>标记一个中括号表达式的开始。要匹配 [，请使用 [。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的开始位置</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。匹配确定的 n 次。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是一个非负整数。至少匹配n 次。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>最少匹配 n 次且最多匹配 m 次</td>
</tr>
</tbody></table>
<p>  通过上述运算符+操作符可以表示任意符号，根据应用场景千变万化。</p>
<h2 id="Python-中正则表达式的应用"><a href="#Python-中正则表达式的应用" class="headerlink" title="Python 中正则表达式的应用"></a>Python 中正则表达式的应用</h2><p>Python中采用re库对正则表达式进行处理。其正则表达式的调用方式分为两种：1.库直接调用 2.利用正则表达式对象调用。这里的关系我认为与类同对象的关系一致。</p>
<h3 id="库调用"><a href="#库调用" class="headerlink" title="库调用"></a>库调用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#实例</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#匹配一个或多个字母</span></span><br><span class="line">match = re.search(<span class="string">r&quot;[a-zA-Z]+&quot;</span> ,<span class="string">&quot;We are the chamion&quot;</span> )</span><br><span class="line">print(match.group(<span class="number">0</span>))</span><br><span class="line"><span class="comment">#Result : We</span></span><br></pre></td></tr></table></figure>
<p>直接使用库函数调用方法即可。主要方法如下：</p>
<table>
<thead>
<tr>
<th>函数调用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>re.search()</td>
<td>搜索匹配的第一个，并返回<strong>match</strong>对象</td>
</tr>
<tr>
<td>re.match()</td>
<td>从<strong>开始位置</strong>匹配符合正则的字符串，并返回<strong>match</strong>对象</td>
</tr>
<tr>
<td>re.findall()</td>
<td>搜索字符串，以<strong>列表</strong>形式返回全部匹配的字符串</td>
</tr>
<tr>
<td>re.split()</td>
<td>按照正则表达式分割原始字符串，并返回<strong>列表</strong>类型</td>
</tr>
<tr>
<td>re.finditer()</td>
<td>搜索字符串，返回符合匹配结果的<strong>迭代</strong>类型，每个迭代元素均为<strong>match</strong>对象</td>
</tr>
<tr>
<td>re.sub()</td>
<td>替换符合正则表达的子串为特定字符串，返回替换后的<strong>字符串</strong></td>
</tr>
</tbody></table>
<p>简单实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#实例</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#匹配一个或多个字母</span></span><br><span class="line">match = re.search(<span class="string">r&quot;[a-zA-Z]+&quot;</span> ,<span class="string">&quot;We are the 45 chamion 123&quot;</span> )</span><br><span class="line">print(match.group(<span class="number">0</span>))</span><br><span class="line"><span class="comment"># We</span></span><br><span class="line"></span><br><span class="line">match = re.match(<span class="string">r&quot;[a-zA-Z]+&quot;</span> ,<span class="string">&quot;We are the 45 chamion 123&quot;</span> )</span><br><span class="line">print(match.group(<span class="number">0</span>))</span><br><span class="line"><span class="comment"># We</span></span><br><span class="line"></span><br><span class="line">matchList = re.findall(<span class="string">r&quot;[a-zA-Z]+&quot;</span> ,<span class="string">&quot;We are the 45 chamion 123&quot;</span> )</span><br><span class="line">print(matchList)</span><br><span class="line"><span class="comment"># [&#x27;We&#x27;, &#x27;are&#x27;, &#x27;the&#x27;, &#x27;chamion&#x27;]</span></span><br><span class="line"></span><br><span class="line">splitList = re.split(<span class="string">r&quot;[a-zA-Z]+&quot;</span> ,<span class="string">&quot;We are the 45 chamion 123&quot;</span>  )</span><br><span class="line">print(splitList)</span><br><span class="line"><span class="comment"># [&#x27;&#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; 45 &#x27;, &#x27; 123&#x27;]</span></span><br><span class="line"></span><br><span class="line">iterMatch = re.finditer(<span class="string">r&quot;[a-zA-Z]+&quot;</span> ,<span class="string">&quot;We are the 45 chamion 123&quot;</span>  )</span><br><span class="line"><span class="keyword">for</span> match <span class="keyword">in</span> iterMatch:</span><br><span class="line">    print(match.group(<span class="number">0</span>))</span><br><span class="line"><span class="comment"># We</span></span><br><span class="line"><span class="comment"># are</span></span><br><span class="line"><span class="comment"># the</span></span><br><span class="line"><span class="comment"># chamion</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">subResult = re.sub(<span class="string">r&quot;[a-zA-Z]+&quot;</span> ,<span class="string">&quot;zzz&quot;</span> ,<span class="string">&quot;We are the 45 chamion 123&quot;</span>   )</span><br><span class="line">print(subResult)</span><br><span class="line"><span class="comment"># zzz zzz zzz 45 zzz 123</span></span><br></pre></td></tr></table></figure>
<p>上面仅仅是简单的实例，具体每个方法可以设置的参数都为细讲，可在应用时再看。</p>
<p>通过观察方法表中对每种方法的描述，我们可以发现<strong>match对象</strong>多次提及，其相应的属性与方法可简单了解。</p>
<h3 id="regex对象调用"><a href="#regex对象调用" class="headerlink" title="regex对象调用"></a>regex对象调用</h3><p>选择用regex对象调用上述方法的好处为，对于同一个正则表达式多次使用时可以减少系统默认的多次编译正则表达式次数。调用形式与库调用一致，理解为类与对象的关系即可。</p>
<p>调用实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re </span><br><span class="line"><span class="comment">#先编译，返回一个regex对象</span></span><br><span class="line">regex = re.<span class="built_in">compile</span>(<span class="string">r&quot;[a-z]+&quot;</span>)</span><br><span class="line"><span class="comment">#在调用相关方法即可</span></span><br><span class="line">regex.search(<span class="string">&quot;String&quot;</span>)</span><br></pre></td></tr></table></figure>


<h3 id="Match对象"><a href="#Match对象" class="headerlink" title="Match对象"></a>Match对象</h3><p>在上述方法中，多个方法返回的为<strong>match对象</strong>，其有自己的属性与方法，需要简单的了解下。</p>
<p>Match对象的属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.string</td>
<td>待匹配的文本</td>
</tr>
<tr>
<td>.re</td>
<td>匹配时使用的pattern对象，即正则</td>
</tr>
<tr>
<td>.pos</td>
<td>正则搜索文本的开始位置</td>
</tr>
<tr>
<td>.endpos</td>
<td>正则搜索的结束位置</td>
</tr>
</tbody></table>
<p>Match对象的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.group(0)</td>
<td>获得匹配的字符串</td>
</tr>
<tr>
<td>.start()</td>
<td>匹配字符串在原始字符串中的起始位置</td>
</tr>
<tr>
<td>.end()</td>
<td>匹配字符串在原始字符串中的结束位置</td>
</tr>
<tr>
<td>.span()</td>
<td>返回（.start() , .end()）</td>
</tr>
</tbody></table>
<p>本文中包含由正则表达的含义，与基本的用法 + Pyhon库re对于正则表达式的用法。多是用于理解与了解必要的使用方法与框架，并没有涉及具体的代码演示。个人认为正则的使用，跟需要在应用过程中进行。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_OrderDict</title>
    <url>/2021/01/17/Python-OrderDict/</url>
    <content><![CDATA[<blockquote>
<p>reference Adress:<a href="https://docs.python.org/zh-cn/3/library/collections.html#ordereddict-objects">official Doc</a> <a href="https://pymotw.com/2/collections/ordereddict.html">Learning Bolg</a></p>
</blockquote>
<a id="more"></a>

<h2 id="What"><a href="#What" class="headerlink" title="What?"></a>What?</h2><p>An OrderedDict is a dictionary subclass that remembers the order in which its contents are added.<br>Compare with regular dict class, the OrderedDict remember the add sequentence and offer some functions to revise inner order;Intuitively,it more like a dict with list;</p>
<h2 id="Feature"><a href="#Feature" class="headerlink" title="Feature?"></a>Feature?</h2><h3 id="1-Remember-the-order-in-which-its-contents-are-added"><a href="#1-Remember-the-order-in-which-its-contents-are-added" class="headerlink" title="1.Remember the order in which its contents are added"></a>1.Remember the order in which its contents are added</h3><p>However Python3.7 dict has the same feature;So this feature is not matter any more;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;Regular dictionary:&#x27;</span>)</span><br><span class="line">d = &#123;&#125;</span><br><span class="line">d[<span class="string">&#x27;a&#x27;</span>] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">d[<span class="string">&#x27;b&#x27;</span>] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">d[<span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;C&#x27;</span></span><br><span class="line">d[<span class="string">&#x27;d&#x27;</span>] = <span class="string">&#x27;D&#x27;</span></span><br><span class="line">d[<span class="string">&#x27;e&#x27;</span>] = <span class="string">&#x27;E&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span> (k, v)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;\nOrderedDict:&#x27;</span>)</span><br><span class="line">d = collections.OrderedDict()</span><br><span class="line">d[<span class="string">&#x27;a&#x27;</span>] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">d[<span class="string">&#x27;b&#x27;</span>] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">d[<span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;C&#x27;</span></span><br><span class="line">d[<span class="string">&#x27;d&#x27;</span>] = <span class="string">&#x27;D&#x27;</span></span><br><span class="line">d[<span class="string">&#x27;e&#x27;</span>] = <span class="string">&#x27;E&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span> (k, v)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Regular dictionary:</span><br><span class="line">a A</span><br><span class="line">b B</span><br><span class="line">c C</span><br><span class="line">d D</span><br><span class="line">e E</span><br><span class="line"></span><br><span class="line">OrderedDict:</span><br><span class="line">a A</span><br><span class="line">b B</span><br><span class="line">c C</span><br><span class="line">d D</span><br><span class="line">e E</span><br></pre></td></tr></table></figure>
<h3 id="2-Offer-functions-to-revise-inner-order"><a href="#2-Offer-functions-to-revise-inner-order" class="headerlink" title="2.Offer functions to revise inner order"></a>2.Offer functions to revise inner order</h3><h4 id="1-popitem-last-True"><a href="#1-popitem-last-True" class="headerlink" title="1.popitem(last=True)"></a>1.popitem(last=True)</h4><p>The popitem() method for ordered dictionaries returns and removes a (key, value) pair. The pairs are returned in LIFO order if last is true or FIFO order if false.</p>
<h4 id="2-move-to-end-key-last-True"><a href="#2-move-to-end-key-last-True" class="headerlink" title="2.move_to_end(key, last=True)"></a>2.move_to_end(key, last=True)</h4><p>Move an existing key to either end of an ordered dictionary. The item is moved to the right end if last is true (the default) or to the beginning if last is false. Raises KeyError if the key does not exist:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = collections.OrderedDict.fromkeys(<span class="string">&#x27;abcde&#x27;</span>)</span><br><span class="line">d.move_to_end(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;</span>.join(d.keys())</span><br><span class="line"><span class="comment"># &#x27;acdeb&#x27;</span></span><br><span class="line"></span><br><span class="line">d.move_to_end(<span class="string">&quot;b&quot;</span> , last = <span class="literal">False</span>)</span><br><span class="line"><span class="string">&quot;&quot;</span>.join(d.keys())</span><br><span class="line"><span class="comment"># &#x27;bacde&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-order-sensitive"><a href="#3-order-sensitive" class="headerlink" title="3.order-sensitive"></a>3.order-sensitive</h3><p>A regular dict looks at its contents when testing for equality. An OrderedDict also considers the order the items were added.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;dict       :&#x27;</span>),</span><br><span class="line">d1 = &#123;&#125;</span><br><span class="line">d1[<span class="string">&#x27;a&#x27;</span>] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">d1[<span class="string">&#x27;b&#x27;</span>] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">d1[<span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;C&#x27;</span></span><br><span class="line">d1[<span class="string">&#x27;d&#x27;</span>] = <span class="string">&#x27;D&#x27;</span></span><br><span class="line">d1[<span class="string">&#x27;e&#x27;</span>] = <span class="string">&#x27;E&#x27;</span></span><br><span class="line"></span><br><span class="line">d2 = &#123;&#125;</span><br><span class="line">d2[<span class="string">&#x27;e&#x27;</span>] = <span class="string">&#x27;E&#x27;</span></span><br><span class="line">d2[<span class="string">&#x27;d&#x27;</span>] = <span class="string">&#x27;D&#x27;</span></span><br><span class="line">d2[<span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;C&#x27;</span></span><br><span class="line">d2[<span class="string">&#x27;b&#x27;</span>] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">d2[<span class="string">&#x27;a&#x27;</span>] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (d1 == d2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;OrderedDict:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d1 = collections.OrderedDict()</span><br><span class="line">d1[<span class="string">&#x27;a&#x27;</span>] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">d1[<span class="string">&#x27;b&#x27;</span>] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">d1[<span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;C&#x27;</span></span><br><span class="line">d1[<span class="string">&#x27;d&#x27;</span>] = <span class="string">&#x27;D&#x27;</span></span><br><span class="line">d1[<span class="string">&#x27;e&#x27;</span>] = <span class="string">&#x27;E&#x27;</span></span><br><span class="line"></span><br><span class="line">d2 = collections.OrderedDict()</span><br><span class="line">d2[<span class="string">&#x27;e&#x27;</span>] = <span class="string">&#x27;E&#x27;</span></span><br><span class="line">d2[<span class="string">&#x27;d&#x27;</span>] = <span class="string">&#x27;D&#x27;</span></span><br><span class="line">d2[<span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;C&#x27;</span></span><br><span class="line">d2[<span class="string">&#x27;b&#x27;</span>] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">d2[<span class="string">&#x27;a&#x27;</span>] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (d1 == d2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dict       :</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># OrderedDict:</span></span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples?"></a>Examples?</h2><p>LRU function can be easility finished by OrderedDict.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>(<span class="params">OrderedDict</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity</span>):</span></span><br><span class="line">        </span><br><span class="line">        self.capacity = capacity</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">return</span> - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        self.move_to_end(key)</span><br><span class="line">        <span class="keyword">return</span> self[key]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self:</span><br><span class="line">            self.move_to_end(key)</span><br><span class="line">        self[key] = value</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self) &gt; self.capacity:</span><br><span class="line">            self.popitem(last = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_Counter</title>
    <url>/2021/01/17/Python-Counter/</url>
    <content><![CDATA[<p>Counter类是一个用来<strong>统计元素频率</strong>的容器类别:</p>
<a id="more"></a>

<blockquote>
<p><a href="https://www.itread01.com/articles/1475818990.html">教学地址</a></p>
</blockquote>
<h2 id="Counter是什么"><a href="#Counter是什么" class="headerlink" title="Counter是什么?"></a>Counter是什么?</h2><p>Counter类是一个用来<strong>统计元素频率</strong>的容器类别,其是一个<strong>无序的容器</strong>类型,利用的<strong>键值对</strong>的形式存储,元素作为键,频率作为值.需要注意的是这里的频率可以为<strong>负数</strong>.</p>
<h2 id="Counter的构建"><a href="#Counter的构建" class="headerlink" title="Counter的构建"></a>Counter的构建</h2><p>Counter 提供了多种构建方式,属于符合Python风格的类别.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter() <span class="comment"># 創建一個空的Counter類</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(<span class="string">&#x27;gallahad&#x27;</span>) <span class="comment"># 從一個可iterable對象（list、tuple、dict、字符串等）創建</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;) <span class="comment"># 從一個字典對象創建</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(a=<span class="number">4</span>, b=<span class="number">2</span>) <span class="comment"># 從一組鍵值對創建</span></span><br></pre></td></tr></table></figure>
<h2 id="Counter访问空缺值"><a href="#Counter访问空缺值" class="headerlink" title="Counter访问空缺值"></a>Counter访问空缺值</h2><p>Counter实现了__missing__方法,对于没有的键值,会返回0.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(<span class="string">&quot;abcdefgab&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">&quot;a&quot;</span>]</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">&quot;c&quot;</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">&quot;h&quot;</span>]</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="Counter的更新"><a href="#Counter的更新" class="headerlink" title="Counter的更新"></a>Counter的更新</h2><h3 id="增加-update"><a href="#增加-update" class="headerlink" title="增加,update()"></a>增加,update()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(<span class="string">&#x27;which&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.update(<span class="string">&#x27;witch&#x27;</span>) <span class="comment"># 使用另一個iterable對象更新</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">&#x27;h&#x27;</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Counter(<span class="string">&#x27;watch&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.update(d) <span class="comment"># 使用另一個Counter對象更新</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">&#x27;h&#x27;</span>]</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="减少-subtract"><a href="#减少-subtract" class="headerlink" title="减少,subtract()"></a>减少,subtract()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(<span class="string">&#x27;which&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.subtract(<span class="string">&#x27;witch&#x27;</span>) <span class="comment"># 使用另一個iterable對象更新</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">&#x27;h&#x27;</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Counter(<span class="string">&#x27;watch&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.subtract(d) <span class="comment"># 使用另一個Counter對象更新</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="Counter键的删除-del"><a href="#Counter键的删除-del" class="headerlink" title="Counter键的删除:del"></a>Counter键的删除:del</h2><p>Counter类键的删除需要 使用del方法,不是使用赋值0操作.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(<span class="string">&quot;abcdcba&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">&quot;b&quot;</span>] = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">0</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> c[<span class="string">&quot;a&quot;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">Counter(&#123;<span class="string">&#x27;c&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Counter返回迭代器-elements"><a href="#Counter返回迭代器-elements" class="headerlink" title="Counter返回迭代器:elements()"></a>Counter返回迭代器:elements()</h2><p>此方法返回一个迭代器,元素重复多少次,则迭代器中包含有多少个相同元素,并且按照字母序排序.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">elements()方法Python</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(a=<span class="number">4</span>, b=<span class="number">2</span>, c=<span class="number">0</span>, d=-<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(c.elements())</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h2 id="Counter返回-TopN-列表-most-common-n"><a href="#Counter返回-TopN-列表-most-common-n" class="headerlink" title="Counter返回 TopN 列表:most_common([n])"></a>Counter返回 TopN 列表:most_common([n])</h2><p>返回一个TopN列表,如果n并没有指定,则全部返回.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.most_common()</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;r&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.most_common(<span class="number">3</span>)</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;r&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>
<h2 id="Counter中的算术操作与集合操作-amp"><a href="#Counter中的算术操作与集合操作-amp" class="headerlink" title="Counter中的算术操作与集合操作: + - &amp; |"></a>Counter中的算术操作与集合操作: + - &amp; |</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">+、-、&amp;、|操作也可以用於Counter。其中&amp;和|操作分別返回兩個Counter對象各元素的最小值和最大值。需要註意的是，得到的Counter對象將刪除小於<span class="number">1</span>的元素。</span><br><span class="line"></span><br><span class="line">Counter對象的算術和集合操作Python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(a=<span class="number">3</span>, b=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Counter(a=<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c + d <span class="comment"># c[x] + d[x]</span></span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">3</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c - d <span class="comment"># subtract（只保留正數計數的元素）</span></span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c &amp; d <span class="comment"># 交集: min(c[x], d[x])</span></span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c | d <span class="comment"># 並集: max(c[x], d[x])</span></span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span>(c.values()) <span class="comment"># 所有計數的總數</span></span><br><span class="line">c.clear() <span class="comment"># 重置Counter對象，註意不是刪除</span></span><br><span class="line"><span class="built_in">list</span>(c) <span class="comment"># 將c中的鍵轉為列表</span></span><br><span class="line"><span class="built_in">set</span>(c) <span class="comment"># 將c中的鍵轉為set</span></span><br><span class="line"><span class="built_in">dict</span>(c) <span class="comment"># 將c中的鍵值對轉為字典</span></span><br><span class="line">c.items() <span class="comment"># 轉為(elem, cnt)格式的列表</span></span><br><span class="line">Counter(<span class="built_in">dict</span>(list_of_pairs)) <span class="comment"># 從(elem, cnt)格式的列表轉換為Counter類對象</span></span><br><span class="line">c.most_common()[:-n:-<span class="number">1</span>] <span class="comment"># 取出計數最少的n個元素</span></span><br><span class="line">c += Counter() <span class="comment"># 移除0和負值</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python内存管理</title>
    <url>/2021/01/11/python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>Python内存管理是理解Python运行机制的重要一环,也是面试的高频问题,特整理相关信息如下:</p>
<a id="more"></a>

<blockquote>
<p>参考地址：<a href="https://www.cnblogs.com/geaozhang/p/7111961.html">博客一</a> ， <a href="https://andrewpqc.github.io/2018/10/08/python-memory-management/">博客二</a> ，<a href="https://cloud.tencent.com/developer/article/1670455">博客三</a></p>
</blockquote>
<p>Python内存管理是理解Python运行机制的重要一环，故整理下相关内容如下：</p>
<h2 id="前置知识：Python变量与对象"><a href="#前置知识：Python变量与对象" class="headerlink" title="前置知识：Python变量与对象"></a>前置知识：Python变量与对象</h2><p>我们在编程过程中，不可避免的使用变量指代对象，其关系为变量通过指针指向了对象；对象有自己的类型，而变量的类型则跟随者对象的类型而变化。关系如图：</p>
<p><img src="https://i.loli.net/2021/01/11/pSmqUE57vVdYGcx.png"></p>
<p><strong>变量：</strong>通过变量指针引用对象。而变量指针指向具体对象的<strong>内存空间</strong>；变量类型是<strong>动态</strong>的，与对象类型一致</p>
<p><strong>对象：</strong>类型是<strong>已知</strong>的，每个对象都包含有头部信息，其中为<strong>类型标识</strong>符与<strong>引用计数</strong>器</p>
<h3 id="多变量指向同一对象情况"><a href="#多变量指向同一对象情况" class="headerlink" title="多变量指向同一对象情况"></a>多变量指向同一对象情况</h3><p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var_1 = <span class="number">123</span></span><br><span class="line">var_2 = var_1</span><br><span class="line">print(<span class="built_in">id</span>(var_1)) <span class="comment"># 140711337393728</span></span><br><span class="line">print(<span class="built_in">id</span>(var_2)) <span class="comment"># 140711337393728</span></span><br><span class="line">print(<span class="built_in">id</span>(<span class="number">123</span>)) <span class="comment"># 140711337393728</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">type</span>(var_1)) <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>(var_2)) <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>(<span class="number">123</span>)) <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过对象被引用的方式(var_2 = var_1)，两个变量指向了同一地址，并且变量的类别与被引用对象的类别一致。简单示意图：</p>
<p><img src="https://i.loli.net/2021/01/11/qsDZ8Kr2tPHFUkV.png"></p>
<h3 id="多变量引用所指的判断"><a href="#多变量引用所指的判断" class="headerlink" title="多变量引用所指的判断"></a>多变量引用所指的判断</h3><p>在Python中判断多个变量的引用地址是否一致采用了内置函数is。先看一段代码再去讲。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 小于等于256的整数</span></span><br><span class="line">intA = <span class="number">256</span></span><br><span class="line">intB = <span class="number">256</span></span><br><span class="line">print(<span class="built_in">id</span>(intA)) <span class="comment"># 140711337397984</span></span><br><span class="line">print(<span class="built_in">id</span>(intB)) <span class="comment"># 140711337397984</span></span><br><span class="line">intA <span class="keyword">is</span> intB <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 大于256的整数</span></span><br><span class="line">intA = <span class="number">257</span> <span class="comment"># 3037955041360</span></span><br><span class="line">intB = <span class="number">257</span> <span class="comment"># 3037955041424</span></span><br><span class="line">print(<span class="built_in">id</span>(intA))</span><br><span class="line">print(<span class="built_in">id</span>(intB))</span><br><span class="line">intA <span class="keyword">is</span> intB <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 短字符串</span></span><br><span class="line">charA = <span class="string">&quot;aaaaaaaaaaa&quot;</span></span><br><span class="line">charB = <span class="string">&quot;aaaaaaaaaaa&quot;</span></span><br><span class="line">charA <span class="keyword">is</span> charB <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 长字符串</span></span><br><span class="line">charA = <span class="string">&quot;very Good&quot;</span></span><br><span class="line">charB = <span class="string">&quot;very Good&quot;</span></span><br><span class="line">charA <span class="keyword">is</span> charB <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器——列表</span></span><br><span class="line">listA = []</span><br><span class="line">listB = []</span><br><span class="line">listA <span class="keyword">is</span> listB <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<p>我们发现不同的数据类型或者同一数据类型不同“长度”时，多次创建时，其内存地址情况并不一致。这是由于Python会选择缓存常用的对象，使得多次赋值对象时，不需要创建新的对象，例如1~256的数字，短字符串等。基本上都是不可修改的数据类型。</p>
<ol>
<li>Python缓存了整数（1~256，短字符串），每个变量进行为赋值操作时，不需要创建新的对象，大家引用对象一致。</li>
<li>Python对于未缓存的对象，在进行赋值操作时，会直接生成新的对象，占用新的内存地址。</li>
</ol>
<h2 id="Python的垃圾回收机制"><a href="#Python的垃圾回收机制" class="headerlink" title="Python的垃圾回收机制"></a>Python的垃圾回收机制</h2><p>一句话描述就是：<strong>引用计数为主，标记清除与分代回收为辅</strong>；</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>Python中主要使用引用计数(Reference Counting)进行垃圾回收。每一个对象的核心就是一个结构体PyObject,其内部存在一个引用计数器(ob_refcnt)。当某对象的引用计数值为0时，其内存就可以被释放掉；</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"> typedef struct_object &#123;</span><br><span class="line">    <span class="built_in">int</span> ob_refcnt;</span><br><span class="line">    struct_typeobject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>
<h4 id="引起引用计数变化的情况"><a href="#引起引用计数变化的情况" class="headerlink" title="引起引用计数变化的情况"></a>引起引用计数变化的情况</h4><p><strong>引用计数增加的情况：</strong></p>
<ul>
<li>对象被创建,a = 2</li>
<li>对象被引用,b=a</li>
<li>对象作为参数传递到函数中,fun(a)</li>
<li>对象作为元素存储在容器中,numList.append(a)</li>
</ul>
<p><strong>引用计数减少的情况：</strong></p>
<ul>
<li>对象别名被显示销毁,del a</li>
<li>对象别名赋予了新的对象,b = 3</li>
<li>包含对象的函数运行结束,</li>
<li>对象所在的容器被摧毁或者从容其中删除了对象,numList.remove(a)</li>
</ul>
<h4 id="获取引用数量的方式"><a href="#获取引用数量的方式" class="headerlink" title="获取引用数量的方式"></a>获取引用数量的方式</h4><p>通过sys包中的getrefcount()获取一个名称所引用的对象当前的引用计数，这个函数本身也会造成其引用+1.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys.getrefcount(a)</span><br></pre></td></tr></table></figure>
<h4 id="引用计数的优缺点"><a href="#引用计数的优缺点" class="headerlink" title="引用计数的优缺点"></a>引用计数的优缺点</h4><p><strong>优点：</strong></p>
<ul>
<li>逻辑简单而高效，具备实时性；</li>
<li>垃圾回收随机分配到运行阶段，处理回收时间分散有利于系统稳定；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>空间浪费：每个对象都存在用来统计的引用的空间，加大了空间负担；</li>
<li>大对象释放缓慢：当需要释放大的对象时，比如字典，需要对引用的所有对象循环嵌套调用；</li>
<li>循环引用问题：引用计数的致命问题。</li>
</ul>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>标记清除(Mark and Sweep)算法，是为了解决对象可能产生的循环引用问题。(注意，只有<strong>容器</strong>对象才会产生循环引用的情况，比如列表、字典、用户自定义类的对象、元组等。而像数字，字符串这类简单类型不会出现循环引用。作为一种优化策略，对于只包含简单类型的元组也不在标记清除算法的考虑之列)。</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ol>
<li>标记阶段，遍历所有对象，如果对象可达（表明存在对象引用它），则标记对象可达；</li>
<li>清除阶段，再次遍历所有对象，对于不可达的对象，进行回收；</li>
</ol>
<p>如下图所示，在标记清除算法中，为了追踪容器对象，需要每个容器对象维护两个额外的指针，用来将容器对象组成一个双端链表，指针分别指向前后两个容器对象，方便插入和删除操作。python解释器(Cpython)维护了两个这样的双端链表，一个链表存放着需要被扫描的容器对象，另一个链表存放着临时不可达对象。在图中，这两个链表分别被命名为”Object to Scan”和”Unreachable”。图中例子是这么一个情况：link1,link2,link3组成了一个引用环，同时link1还被一个变量A(其实这里称为名称A更好)引用。link4自引用，也构成了一个引用环。从图中我们还可以看到，每一个节点除了有一个记录当前引用计数的变量<code>ref_count</code>还有一个<code>gc_ref</code>变量，这个<code>gc_ref</code>是<code>ref_count</code>的一个副本，所以初始值为<code>ref_count</code>的大小。<br><a href="https://andrewpqc.github.io/images/marksweep1.png"><img src="https://andrewpqc.github.io/images/marksweep1.png" alt="img"></a></p>
<p>gc启动的时候，会逐个遍历”Object to Scan”链表中的容器对象，并且将当前对象所引用的所有对象的<code>gc_ref</code>减一。(扫描到link1的时候，由于link1引用了link2,所以会将link2的<code>gc_ref</code>减一，接着扫描link2,由于link2引用了link3,所以会将link3的<code>gc_ref</code>减一…..)像这样将”Objects to Scan”链表中的所有对象考察一遍之后，两个链表中的对象的<code>ref_count</code>和<code>gc_ref</code>的情况如下图所示。这一步操作就相当于解除了循环引用对引用计数的影响。<br><a href="https://andrewpqc.github.io/images/marksweep2.png"><img src="https://andrewpqc.github.io/images/marksweep2.png" alt="img"></a></p>
<p>接着，gc会再次扫描所有的容器对象，如果对象的<code>gc_ref</code>值为0，那么这个对象就被标记为<code>GC_TENTATIVELY_UNREACHABLE</code>，并且被移至”Unreachable”链表中。下图中的link3和link4就是这样一种情况。<br><a href="https://andrewpqc.github.io/images/marksweep3.png"><img src="https://andrewpqc.github.io/images/marksweep3.png" alt="img"></a></p>
<p>如果对象的<code>gc_ref</code>不为0，那么这个对象就会被标记为<code>GC_REACHABLE</code>。同时当gc发现有一个节点是可达的，那么他会递归式的将从该节点出发可以到达的所有节点标记为<code>GC_REACHABLE</code>,这就是下图中link2和link3所碰到的情形。<br><a href="https://andrewpqc.github.io/images/marksweep4.png"><img src="https://andrewpqc.github.io/images/marksweep4.png" alt="img"></a></p>
<p>除了将所有可达节点标记为<code>GC_REACHABLE</code>之外，如果该节点当前在”Unreachable”链表中的话，还需要将其移回到”Object to Scan”链表中，下图就是link3移回之后的情形。<br><a href="https://andrewpqc.github.io/images/marksweep5.png"><img src="https://andrewpqc.github.io/images/marksweep5.png" alt="img"></a><br>第二次遍历的所有对象都遍历完成之后，存在于”Unreachable”链表中的对象就是真正需要被释放的对象。如上图所示，此时link4存在于Unreachable链表中，gc随即释放之。</p>
<p><strong>上面描述的垃圾回收的阶段，会暂停整个应用程序，等待标记清除结束后才会恢复应用程序的运行。</strong></p>
<h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><p>Python通过“分代回收”（Generational Collection）以<strong>空间换时间</strong>的方法提高<strong>垃圾回收效率</strong>。</p>
<h4 id="分代回收的依据"><a href="#分代回收的依据" class="headerlink" title="分代回收的依据"></a>分代回收的依据</h4><p><strong>对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。</strong></p>
<p>python gc给对象定义了三种世代(0,1,2),每一个新生对象在generation zero中，如果它在一轮gc扫描中活了下来，那么它将被移至generation one,在那里他将较少的被扫描，如果它又活过了一轮gc,它又将被移至generation two，在那里它被扫描的次数将会更少。</p>
<p>gc的扫描在什么时候会被触发呢?答案是<strong>当某一世代中被分配的对象与被释放的对象之差达到某一阈值的时候，就会触发gc对某一世代的扫描。</strong>值得注意的是<strong>当某一世代的扫描被触发的时候，比该世代年轻的世代也会被扫描。</strong>也就是说如果世代2的gc扫描被触发了，那么世代0,世代1也将被扫描，如果世代1的gc扫描被触发，世代0也会被扫描。</p>
<p>该阈值可以通过下面两个函数查看和调整:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gc.get_threshold() <span class="comment"># (threshold0, threshold1, threshold2).</span></span><br><span class="line">gc.set_threshold(threshold0[, threshold1[, threshold2]])</span><br></pre></td></tr></table></figure>
<p>下面对set_threshold()中的三个参数threshold0, threshold1, threshold2进行介绍。gc会记录自从上次收集以来新分配的对象数量与释放的对象数量，当两者之差超过threshold0的值时，gc的扫描就会启动，初始的时候只有世代0被检查。如果自从世代1最近一次被检查以来，世代0被检查超过threshold1次，那么对世代1的检查将被触发。相同的，如果自从世代2最近一次被检查以来，世代1被检查超过threshold2次，那么对世代2的检查将被触发。get_threshold()是获取三者的值，默认值为(700,10,10).</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>总体来说，在Python中，主要通过引用计数进行垃圾回收；通过 “标记-清除” 解决容器对象可能产生的循环引用问题；通过 “分代回收” 以空间换时间的方法提高垃圾回收效率。</strong></p>
<h2 id="内存池机制"><a href="#内存池机制" class="headerlink" title="内存池机制"></a>内存池机制</h2><p>Python中对于大内存（&gt; 256 字节）与小内存（1 ~ 256字节）的分配机制是不同的。</p>
<h4 id="为什么引入内存池"><a href="#为什么引入内存池" class="headerlink" title="为什么引入内存池"></a>为什么引入内存池</h4><p>解决多次调用malloc导致大量内存碎片的问题。</p>
<p>内存池就是预先申请一定数量的，大小相同的内存块，当出现新的内存需求，可以选择从内存池分配内存；</p>
<h4 id="大内存的分配机制：malloc"><a href="#大内存的分配机制：malloc" class="headerlink" title="大内存的分配机制：malloc"></a>大内存的分配机制：malloc</h4><p>大内存—–若请求分配的内存大于256K，malloc函数分配内存，free函数释放内存。</p>
<h4 id="小内存的分配机制：内存池"><a href="#小内存的分配机制：内存池" class="headerlink" title="小内存的分配机制：内存池"></a>小内存的分配机制：内存池</h4><p>内存池，有Python的接口函数PyMem_Malloc实现—–若请求分配的内存在1~256字节之间就使用内存池管理系统进行分配，调用malloc函数分配内存，但是每次只会分配一块大小为256K的大块内存，不会调用free函数释放内存，将该内存块留在内存池中以便下次使用。</p>
<h4 id="Python解释器的解释"><a href="#Python解释器的解释" class="headerlink" title="Python解释器的解释"></a>Python解释器的解释</h4><p><img src="https://i.loli.net/2021/01/11/weVvjoAi7s2FENz.png"></p>
<ul>
<li>python的对象管理主要位于Level+1~Level+3层</li>
<li>Level+3层：对于python内置的对象（比如int,dict等）都有独立的私有内存池，对象之间的内存池不共享，即int释放的内存，不会被分配给float使用</li>
<li>Level+2层：当申请的内存大小小于256KB时，内存分配主要由 Python 对象分配器（Python’s object allocator）实施</li>
<li>Level+1层：当申请的内存大小大于256KB时，由Python原生的内存分配器进行分配，本质上是调用C标准库中的malloc/realloc等函数.</li>
</ul>
<blockquote>
<p>关于释放内存方面，当一个对象的引用计数变为0时，Python就会调用它的析构函数。调用析构函数并不意味着最终一定会调用free来释放内存空间，如果真是这样的话，那频繁地申请、释放内存空间会使Python的执行效率大打折扣。因此在析构时也采用了内存池机制，从内存池申请到的内存会被归还到内存池中，以避免频繁地申请和释放动作.</p>
</blockquote>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_Logging</title>
    <url>/2021/01/17/Python-Logging/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://docs.python.org/3.7/howto/logging.html#logging-basic-tutorial">官方文档</a> <a href="https://zhuanlan.zhihu.com/p/38781838">知乎专栏</a></p>
<p>python 3.7</p>
</blockquote>
<h2 id="Logging是什么"><a href="#Logging是什么" class="headerlink" title="Logging是什么"></a>Logging是什么</h2><p>Logging包是Python的<strong>标准包</strong>之一,可用于<strong>代码事件追踪</strong>.事件也是分<strong>等级</strong>的,一般而言不同类型的<strong>事件</strong>所采用的<strong>策略</strong>是不同的.</p>
<h3 id="Logging提供的常用接口"><a href="#Logging提供的常用接口" class="headerlink" title="Logging提供的常用接口"></a>Logging提供的常用接口</h3><p>Logging针对不同等级的事件,提供了以下默认接口:debug() , info() , warning() , error() , critical().以下的表格展示了代码中<strong>事件的级别</strong>以及相应的<strong>追踪</strong>方法:</p>
<table>
<thead>
<tr>
<th>追踪任务</th>
<th>推荐使用的工具</th>
</tr>
</thead>
<tbody><tr>
<td>日常使用中<strong>展示</strong>控制台的<strong>输出</strong></td>
<td>print()</td>
</tr>
<tr>
<td>日程程序操作中<strong>报告</strong>某事件的发生</td>
<td>logging.info()/logging.debug()</td>
</tr>
<tr>
<td>程序运行时提出<strong>警告</strong>信息</td>
<td>logging.warning()/warning.warn()</td>
</tr>
<tr>
<td>程序运行时<strong>出错</strong></td>
<td>Raise exception</td>
</tr>
<tr>
<td>程序运行时<strong>出错</strong>但<strong>不抛出异常</strong></td>
<td>logging.error()/logging.exception()/logging.critical()</td>
</tr>
</tbody></table>
<p>我们发现对于不同等级的事件,对应这不同的解决方式,其有不同的名称:比如:DEBUG,INFO等.这些名称的含义如下表展示:</p>
<table>
<thead>
<tr>
<th>Level</th>
<th>When it’s used</th>
</tr>
</thead>
<tbody><tr>
<td>DEBUG</td>
<td>Detailed information, typically of interest only when diagnosing problems.</td>
</tr>
<tr>
<td>INFO</td>
<td>Confirmation that things are working as expected.</td>
</tr>
<tr>
<td>WARNING</td>
<td>An indication that something unexpected happened, or indicative of some problem in the near future (e.g. ‘disk space low’). The software is still working as expected.</td>
</tr>
<tr>
<td>ERROR</td>
<td>Due to a more serious problem, the software has not been able to perform some function.</td>
</tr>
<tr>
<td>CRITICAL</td>
<td>A serious error, indicating that the program itself may be unable to continue running.</td>
</tr>
</tbody></table>
<p>看到这里应该对<strong>事件级别</strong>有了大概的认识,logging包中默认的追踪级别时DEBUG;</p>
<p>在日常使用时,我们最常用的事件追踪方式就两种:</p>
<ol>
<li>打印到控制台;</li>
<li>写到硬盘文件中;</li>
</ol>
<h2 id="Logging的基本使用方式"><a href="#Logging的基本使用方式" class="headerlink" title="Logging的基本使用方式"></a>Logging的基本使用方式</h2><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><p>直接调用logging.debug()等接口即可,在<strong>控制台</strong>输出对应格式;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.warning(<span class="string">&#x27;Watch out!&#x27;</span>)  <span class="comment"># will print a message to the console</span></span><br><span class="line">logging.info(<span class="string">&#x27;I told you so&#x27;</span>)  <span class="comment"># will not print anything</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># WARNING:root:Watch out!</span></span><br></pre></td></tr></table></figure>
<p>上面代码只输出了warning()方法的信息,这是由于logging默认只追踪DEBUG(包括)之上的日志信息.</p>
<p>默认输出格式:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LEVEL:INFORMATION</span><br></pre></td></tr></table></figure>
<p>我们发现相较于默认的输出格式,还有一个root被输出出来,这里的root指的时logger的层次.</p>
<h4 id="输出到文件示例"><a href="#输出到文件示例" class="headerlink" title="输出到文件示例"></a>输出到文件示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(filename=<span class="string">&#x27;example.log&#x27;</span>,level=logging.DEBUG)</span><br><span class="line">logging.debug(<span class="string">&#x27;This message should go to the log file&#x27;</span>)</span><br><span class="line">logging.info(<span class="string">&#x27;So should this&#x27;</span>)</span><br><span class="line">logging.warning(<span class="string">&#x27;And this, too&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出文件内容:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">DEBUG:root:This message should go to the log file</span><br><span class="line">INFO:root:So should this</span><br><span class="line">WARNING:root:And this, too</span><br></pre></td></tr></table></figure>
<p>通过设置basicConfig()进行相关设置,细节这里不写;</p>
<h4 id="更改文件的输出格式-format关键字"><a href="#更改文件的输出格式-format关键字" class="headerlink" title="更改文件的输出格式:format关键字"></a>更改文件的输出格式:format关键字</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(<span class="built_in">format</span>=<span class="string">&#x27;%(levelname)s:%(message)s&#x27;</span>, level=logging.DEBUG)</span><br><span class="line">logging.debug(<span class="string">&#x27;This message should appear on the console&#x27;</span>)</span><br><span class="line">logging.info(<span class="string">&#x27;So should this&#x27;</span>)</span><br><span class="line">logging.warning(<span class="string">&#x27;And this, too&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出内容:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">DEBUG:This message should appear on the console</span><br><span class="line">INFO:So should this</span><br><span class="line">WARNING:And this, too</span><br></pre></td></tr></table></figure>
<h4 id="添加时间到输出格式中-asctime-s"><a href="#添加时间到输出格式中-asctime-s" class="headerlink" title="添加时间到输出格式中:%(asctime)s"></a>添加时间到输出格式中:%(asctime)s</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(<span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s %(message)s&#x27;</span>)</span><br><span class="line">logging.warning(<span class="string">&#x27;is when this event was logged.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出内容;</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">2010-12-12 11:41:42,612 is when this event was logged.</span><br></pre></td></tr></table></figure>
<h4 id="定制时间格式-datafmt关键字"><a href="#定制时间格式-datafmt关键字" class="headerlink" title="定制时间格式:datafmt关键字"></a>定制时间格式:datafmt关键字</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(<span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s %(message)s&#x27;</span>, datefmt=<span class="string">&#x27;%m/%d/%Y %I:%M:%S %p&#x27;</span>)</span><br><span class="line">logging.warning(<span class="string">&#x27;is when this event was logged.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出内容:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">12/12/2010 11:46:36 AM is when this event was logged.</span><br></pre></td></tr></table></figure>
<h3 id="format参数"><a href="#format参数" class="headerlink" title="format参数"></a>format参数</h3><p>在logging.basicConfig()方法内,format起着调整输出格式的作用.岂可选参数如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">`%(asctime)s`    表示当前时间，格式为`<span class="number">2018</span>-07-01 <span class="number">19</span>:08:<span class="number">41</span>,050`，逗号后面是毫秒</span><br><span class="line">`%(levelname)s`  表示日志级别名称</span><br><span class="line">`%(message)s`    表示日志内容</span><br><span class="line">`%(name)s`       表示日志名称（未指定则为roots）</span><br><span class="line">`%(lineno)d`     表示输出日志的代码所在行数</span><br><span class="line">`%(levelno)s`    表示数字形式的日志级别</span><br><span class="line">`%(pathname)s`   表示程序执行路径，相当于`sys.argv[<span class="number">0</span>]`</span><br><span class="line">`%(filename)s`   表示所在文件名称</span><br><span class="line">`%(funcName)s`   表示所在函数名称</span><br><span class="line">`%(thread)d`     表示当前线程ID</span><br><span class="line">`%(threadName)s` 表示当前线程名称</span><br><span class="line">`%(process)d`    表示当前进程ID</span><br><span class="line">`%(processName)s`表示当前进程名称</span><br><span class="line">`%(module)s`     表示当前模块名称</span><br><span class="line">`%(created)f`    表示UNIX标准时间浮点数表示</span><br></pre></td></tr></table></figure>
<h4 id="datefmt对时间格式进行修改"><a href="#datefmt对时间格式进行修改" class="headerlink" title="datefmt对时间格式进行修改"></a><code>datefmt</code>对时间格式进行修改</h4><p>使用例子如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(level&#x3D;logging.INFO,</span><br><span class="line">                   format&#x3D;&#39;%(asctime)s  %(message)s&#39;,</span><br><span class="line">                   datefmt&#x3D;&#39;%a, %d %b %Y %H:%M:%S +0000&#39;)</span><br><span class="line">logging.info(&#39;this is a info&#39;)</span><br></pre></td></tr></table></figure>
<p>输出结果如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Sun, 01 Jul 2018 19:19:00 +0000  this is a info</span><br></pre></td></tr></table></figure>
<p><code>datefmt</code>的格式可以参考<a href="https://link.zhihu.com/?target=https://docs.python.org/3.6/library/time.html%23time.strftime">官网表格</a></p>
<h4 id="style"><a href="#style" class="headerlink" title="style"></a>style</h4><p>默认为<code>%</code>，可选<code>&#123;</code>和<code>$</code>，他们的使用方法分别如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># %</span><br><span class="line">import logging</span><br><span class="line">logging.basicConfig(level&#x3D;logging.INFO,</span><br><span class="line">                   format&#x3D;&#39;%(asctime)s  %(message)s&#39;,</span><br><span class="line">                   datefmt&#x3D;&#39;%a, %d %b %Y %H:%M:%S +0000&#39;,</span><br><span class="line">                   style&#x3D;&#39;%&#39;)</span><br><span class="line">logging.info(&#39;this is a info&#39;)</span><br><span class="line"></span><br><span class="line"># &#123;</span><br><span class="line">import logging</span><br><span class="line">logging.basicConfig(level&#x3D;logging.INFO,</span><br><span class="line">                   format&#x3D;&#39;&#123;asctime&#125;  &#123;message&#125;&#39;,</span><br><span class="line">                   datefmt&#x3D;&#39;%a, %d %b %Y %H:%M:%S +0000&#39;,</span><br><span class="line">                   style&#x3D;&#39;&#123;&#39;)</span><br><span class="line">logging.info(&#39;this is a info&#39;)</span><br><span class="line"></span><br><span class="line"># $</span><br><span class="line">import logging</span><br><span class="line">logging.basicConfig(level&#x3D;logging.INFO,</span><br><span class="line">                   format&#x3D;&#39;$asctime  $message&#39;,</span><br><span class="line">                   datefmt&#x3D;&#39;%a, %d %b %Y %H:%M:%S +0000&#39;,</span><br><span class="line">                   style&#x3D;&#39;$&#39;)</span><br><span class="line">logging.info(&#39;this is a info&#39;)</span><br></pre></td></tr></table></figure>


<h2 id="Logging的高级使用方式"><a href="#Logging的高级使用方式" class="headerlink" title="Logging的高级使用方式"></a>Logging的高级使用方式</h2><p>高级模块无非是可以定制化log的生成,存储,具体格式等内容.上面的简单示例已经或多或少的有所触及,比如通过format关键字指定输出格式,通过filename关键字指定log存储文件地址,等等.</p>
<p>在logging中,分布有四个模块,每个模块都包含有特定的功能,分别是:logger,handler,filter,formatter;</p>
<h3 id="模块解释"><a href="#模块解释" class="headerlink" title="模块解释"></a>模块解释</h3><ul>
<li>Loggers expose the interface that application code directly uses.</li>
<li>Handlers send the log records (created by loggers) to the appropriate destination.</li>
<li>Filters provide a finer grained facility for determining which log records to output.</li>
<li>Formatters specify the layout of log records in the final output.</li>
</ul>
<p>Log事件信息会在上述四个模块间传递,最终得到你想要的log日志信息;</p>
<h4 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h4><p>Logger对象是logging的核心对象,其任务可以简单的分为产生信息并传递给下一模块,具体有三:</p>
<ol>
<li>提供了多种接口,用于<strong>运行时</strong>记录相关信息.这里说的接口与logging类一致:<strong>debug(),info(),warning(),error(),etc</strong>;</li>
<li>Logger对象可以<strong>决定处理什么等级的信息</strong>,可以通过默认关键字(level)设置或者filter对象;</li>
<li>Logger对象可以将日志信息**传递给相关对象(handler)**进行接下来的处理.</li>
</ol>
<p><strong>特点:</strong></p>
<p>Logger对象<strong>通过名称标识层次</strong>,层次间用英文句号分割.例如有三个logger其名称分别为:foo , foo.bar , foo.bar.baz,其分别扮演祖先,父母,与儿子的角色.类似于继承的概念.</p>
<p>一般情况下以当前的模块名称作为logger名称,这也就对模块的规范进行要求.以下是示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logger = logging.getLogger(__name__)</span><br></pre></td></tr></table></figure>
<p><strong>常见方法:</strong></p>
<hr>
<ul>
<li>Logger.setLevel():指定logger需要处理的最低层次信息;</li>
<li>Logger.addHandler() and Logger.removeHandler():添加与移除Handler对象</li>
<li>Logger.addFilter() and Logger.removeFilter():添加与移除Filter对象</li>
</ul>
<p>上述三个方法均具有继承性;</p>
<hr>
<ul>
<li>Logger.debug(),Logger.info(),Logger.warning(),Logger.error(),Logger.critical():产生log信息的方法.其信息均为format string,可通过替代符号”%s,%d,%d”进行设置.</li>
<li><a href="https://docs.python.org/3.7/library/logging.html#logging.Logger.exception"><code>Logger.exception()</code></a> creates a log message similar to <a href="https://docs.python.org/3.7/library/logging.html#logging.Logger.error"><code>Logger.error()</code></a>. The difference is that <a href="https://docs.python.org/3.7/library/logging.html#logging.Logger.exception"><code>Logger.exception()</code></a> dumps a stack trace along with it. Call this method only from an exception handler.</li>
<li><a href="https://docs.python.org/3.7/library/logging.html#logging.Logger.log"><code>Logger.log()</code></a> takes a log level as an explicit argument. This is a little more verbose for logging messages than using the log level convenience methods listed above, but this is how to log at custom log levels.</li>
</ul>
<hr>
<ul>
<li>getLogger():获得logger对象的方法,默认名称为root,可指定.</li>
</ul>
<h4 id="Handlers"><a href="#Handlers" class="headerlink" title="Handlers"></a>Handlers</h4><p>Handlers用来对log进行特定的分派处理,例如将某类型log发送到邮箱或存储在特定文件内.一般情况一个logger对象可以添加多个Handlers对象.   </p>
<p><strong>常见方法:</strong></p>
<ul>
<li>setLevel():设定进行<strong>dispatch</strong>的最底层事件</li>
<li>setFormatter():为handler对象选定格式对象</li>
<li>addFilter()/removeFilter():配置过滤对象</li>
</ul>
<h4 id="Formatters"><a href="#Formatters" class="headerlink" title="Formatters"></a>Formatters</h4><blockquote>
<p>这里没看懂文档解释</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>配置它们的流程是</p>
<ul>
<li>配置好的format设置到handler中</li>
<li>配置好的handler添加到logger中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># create logger</span></span><br><span class="line">logger = logging.getLogger(<span class="string">&#x27;simple_example&#x27;</span>)</span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create console handler and set level to debug</span></span><br><span class="line">ch = logging.StreamHandler()</span><br><span class="line">ch.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create formatter</span></span><br><span class="line">formatter = logging.Formatter(<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add formatter to ch</span></span><br><span class="line">ch.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add ch to logger</span></span><br><span class="line">logger.addHandler(ch)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;application&#x27; code</span></span><br><span class="line">logger.debug(<span class="string">&#x27;debug message&#x27;</span>)</span><br><span class="line">logger.info(<span class="string">&#x27;info message&#x27;</span>)</span><br><span class="line">logger.warning(<span class="string">&#x27;warn message&#x27;</span>)</span><br><span class="line">logger.error(<span class="string">&#x27;error message&#x27;</span>)</span><br><span class="line">logger.critical(<span class="string">&#x27;critical message&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2005</span>-03-<span class="number">19</span> <span class="number">15</span>:<span class="number">10</span>:<span class="number">26</span>,<span class="number">618</span> - simple_example - DEBUG - debug message</span><br><span class="line"><span class="number">2005</span>-03-<span class="number">19</span> <span class="number">15</span>:<span class="number">10</span>:<span class="number">26</span>,<span class="number">620</span> - simple_example - INFO - info message</span><br><span class="line"><span class="number">2005</span>-03-<span class="number">19</span> <span class="number">15</span>:<span class="number">10</span>:<span class="number">26</span>,<span class="number">695</span> - simple_example - WARNING - warn message</span><br><span class="line"><span class="number">2005</span>-03-<span class="number">19</span> <span class="number">15</span>:<span class="number">10</span>:<span class="number">26</span>,<span class="number">697</span> - simple_example - ERROR - error message</span><br><span class="line"><span class="number">2005</span>-03-<span class="number">19</span> <span class="number">15</span>:<span class="number">10</span>:<span class="number">26</span>,<span class="number">773</span> - simple_example - CRITICAL - critical message</span><br></pre></td></tr></table></figure>
<h4 id="创建log流程的多种方式"><a href="#创建log流程的多种方式" class="headerlink" title="创建log流程的多种方式"></a>创建log流程的多种方式</h4><blockquote>
<p>这里不一一展示</p>
</blockquote>
<ol>
<li>Creating loggers, handlers, and formatters explicitly using Python code that calls the configuration methods listed above.</li>
<li>Creating a logging config file and reading it using the <a href="https://docs.python.org/3.7/library/logging.config.html#logging.config.fileConfig"><code>fileConfig()</code></a> function.</li>
<li>Creating a dictionary of configuration information and passing it to the <a href="https://docs.python.org/3.7/library/logging.config.html#logging.config.dictConfig"><code>dictConfig()</code></a> function.</li>
</ol>
<h2 id="样例探究Logging的特点"><a href="#样例探究Logging的特点" class="headerlink" title="样例探究Logging的特点"></a>样例探究Logging的特点</h2><blockquote>
<p><a href="https://docs.python.org/3.7/howto/logging-cookbook.html">样例地址</a> 上述地址上讲解了各种情况下Logger的使用方式,不需要意义查看,针对自己的场景常看相关样例即可,这里仅介绍第一个样例.</p>
</blockquote>
<h3 id="多模块使用Logging的方式"><a href="#多模块使用Logging的方式" class="headerlink" title="多模块使用Logging的方式"></a>多模块使用Logging的方式</h3><ol>
<li>模块<strong>名称标识</strong>Logger的方式,即使在不同模块我们使用相同的名称,也会获得相同的对象;</li>
<li>不同模块间建议使用<strong>层次化模块名称</strong>,名称层次使用<strong>句号</strong>分割,主模块采用作为父名称,副模块采用子名称.</li>
<li>子模块的调用会自动传给父模块;</li>
</ol>
<p>module.py模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> auxiliary_module</span><br><span class="line"></span><br><span class="line"><span class="comment"># create logger with &#x27;spam_application&#x27;</span></span><br><span class="line">logger = logging.getLogger(<span class="string">&#x27;spam_application&#x27;</span>)</span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"><span class="comment"># create file handler which logs even debug messages</span></span><br><span class="line">fh = logging.FileHandler(<span class="string">&#x27;spam.log&#x27;</span>)</span><br><span class="line">fh.setLevel(logging.DEBUG)</span><br><span class="line"><span class="comment"># create console handler with a higher log level</span></span><br><span class="line">ch = logging.StreamHandler()</span><br><span class="line">ch.setLevel(logging.ERROR)</span><br><span class="line"><span class="comment"># create formatter and add it to the handlers</span></span><br><span class="line">formatter = logging.Formatter(<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line">fh.setFormatter(formatter)</span><br><span class="line">ch.setFormatter(formatter)</span><br><span class="line"><span class="comment"># add the handlers to the logger</span></span><br><span class="line">logger.addHandler(fh)</span><br><span class="line">logger.addHandler(ch)</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">&#x27;creating an instance of auxiliary_module.Auxiliary&#x27;</span>)</span><br><span class="line">a = auxiliary_module.Auxiliary()</span><br><span class="line">logger.info(<span class="string">&#x27;created an instance of auxiliary_module.Auxiliary&#x27;</span>)</span><br><span class="line">logger.info(<span class="string">&#x27;calling auxiliary_module.Auxiliary.do_something&#x27;</span>)</span><br><span class="line">a.do_something()</span><br><span class="line">logger.info(<span class="string">&#x27;finished auxiliary_module.Auxiliary.do_something&#x27;</span>)</span><br><span class="line">logger.info(<span class="string">&#x27;calling auxiliary_module.some_function()&#x27;</span>)</span><br><span class="line">auxiliary_module.some_function()</span><br><span class="line">logger.info(<span class="string">&#x27;done with auxiliary_module.some_function()&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>auxiliary_module.py辅助模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># create logger</span></span><br><span class="line">module_logger = logging.getLogger(<span class="string">&#x27;spam_application.auxiliary&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Auxiliary</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.logger = logging.getLogger(<span class="string">&#x27;spam_application.auxiliary.Auxiliary&#x27;</span>)</span><br><span class="line">        self.logger.info(<span class="string">&#x27;creating an instance of Auxiliary&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_something</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.logger.info(<span class="string">&#x27;doing something&#x27;</span>)</span><br><span class="line">        a = <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">        self.logger.info(<span class="string">&#x27;done doing something&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_function</span>():</span></span><br><span class="line">    module_logger.info(<span class="string">&#x27;received a call to &quot;some_function&quot;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">2020-08-14 16:51:52,747 - spam_application - INFO - creating an instance of auxiliary_module.Auxiliary</span><br><span class="line">2020-08-14 16:51:52,747 - spam_application.auxiliary.Auxiliary - INFO - creating an instance of Auxiliary</span><br><span class="line">2020-08-14 16:51:52,747 - spam_application - INFO - created an instance of auxiliary_module.Auxiliary</span><br><span class="line">2020-08-14 16:51:52,747 - spam_application - INFO - calling auxiliary_module.Auxiliary.do_something</span><br><span class="line">2020-08-14 16:51:52,748 - spam_application.auxiliary.Auxiliary - INFO - doing something</span><br><span class="line">2020-08-14 16:51:52,748 - spam_application.auxiliary.Auxiliary - INFO - done doing something</span><br><span class="line">2020-08-14 16:51:52,748 - spam_application - INFO - finished auxiliary_module.Auxiliary.do_something</span><br><span class="line">2020-08-14 16:51:52,748 - spam_application - INFO - calling auxiliary_module.some_function()</span><br><span class="line">2020-08-14 16:51:52,748 - spam_application.auxiliary - INFO - received a call to &quot;some_function&quot;</span><br><span class="line">2020-08-14 16:51:52,748 - spam_application - INFO - done with auxiliary_module.some_function()</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_else块</title>
    <url>/2021/01/17/Python-else%E5%9D%97/</url>
    <content><![CDATA[<p>else简单也不简单:</p>
<a id="more"></a>

<blockquote>
<p><a href="15%E7%AB%A0%E8%8A%82">流畅的Python</a></p>
</blockquote>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h2><ul>
<li>作为排他性质的关键字: if else情况</li>
<li>作为标识正常运行结束的关键字:for else , while else , try else<ul>
<li>:如果异常或者return\break或continue语句导致控制权跳到了复合语句主块之外,else语句也会被跳过.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_metaclasses</title>
    <url>/2021/01/17/Python-metaclasses/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python">BlogAddress</a></p>
</blockquote>
<p>元类概念在平时的使用中是很少涉及到的，其核心理解概括为一句话就是<strong>类的类</strong>。在Python中我们常见的就是构建一个类，并且实例化这个类，并继续相关的操作。而类本身其实也是一个对象，其是元类的示例。 上面给定的博客地址就是讲的很详细，如果需要的化再去做相关的文档好了。</p>
<a id="more"></a>

<p>记住三点：</p>
<ol>
<li>元类是类的类</li>
<li>type()是一个元类，我们可以利用其构建类实例</li>
<li>平时很少用，装饰器可以满足其大部分应用。</li>
</ol>
<h2 id="1-Background-Knowledge"><a href="#1-Background-Knowledge" class="headerlink" title="1. Background Knowledge"></a>1. Background Knowledge</h2><h2 id="2-What-is-metaclasses"><a href="#2-What-is-metaclasses" class="headerlink" title="2. What is metaclasses ?"></a>2. What is metaclasses ?</h2><h2 id="3-How-to-use-metaclasses"><a href="#3-How-to-use-metaclasses" class="headerlink" title="3. How to use metaclasses"></a>3. How to use metaclasses</h2><h2 id="4-Custom-your-metaclasses"><a href="#4-Custom-your-metaclasses" class="headerlink" title="4.Custom your metaclasses"></a>4.Custom your metaclasses</h2><h2 id="5-advice"><a href="#5-advice" class="headerlink" title="5.advice"></a>5.advice</h2>]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_del与弱引用</title>
    <url>/2021/01/17/Python-del%E4%B8%8E%E5%BC%B1%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>相似概念</p>
<a id="more"></a>

<h2 id="del的用处"><a href="#del的用处" class="headerlink" title="del的用处"></a>del的用处</h2><p><strong>del 删除的是名称变量，而不是对象</strong>。del可能会导致垃圾回收，但是仅当删除的变量保存的是对象最后一个引用时，或者无法得到对象时。重新绑定也有可能导致对象的引用变量数量归零，导致对象被销毁。</p>
<h2 id="弱引用含义"><a href="#弱引用含义" class="headerlink" title="弱引用含义"></a>弱引用含义</h2><p>弱引用就是在引用的同时不增加引用的数量，通常用于<strong>缓存</strong>中，也就是说弱引用不妨碍垃圾回收。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_dict与set</title>
    <url>/2021/01/17/Python-dict%E4%B8%8Eset/</url>
    <content><![CDATA[<p>Python中的字典类与集合类其内部均采用<strong>散列表</strong>实现，查询速度不受规模影响。</p>
<a id="more"></a>

<h2 id="字典类"><a href="#字典类" class="headerlink" title="字典类"></a>字典类</h2><h3 id="丰富的字典构建方法"><a href="#丰富的字典构建方法" class="headerlink" title="丰富的字典构建方法"></a>丰富的字典构建方法</h3><p><strong>普通构建方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">dict</span>(one = <span class="number">1</span> , two = <span class="number">2</span> , three = <span class="number">3</span>)</span><br><span class="line">b = &#123;<span class="string">&quot;one&quot;</span> : <span class="number">1</span> , <span class="string">&quot;two&quot;</span> : <span class="number">2</span> , <span class="string">&quot;three&quot;</span> : <span class="number">3</span>&#125;</span><br><span class="line">c = <span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&quot;one&quot;</span> , <span class="string">&quot;two&quot;</span> , <span class="string">&quot;three&quot;</span>] , [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br><span class="line">d = <span class="built_in">dict</span>([(<span class="string">&quot;two&quot;</span> , <span class="number">2</span>) , (<span class="string">&quot;one&quot;</span> , <span class="number">1</span>) , (<span class="string">&quot;three&quot;</span> , <span class="number">3</span>)])</span><br><span class="line">e = <span class="built_in">dict</span>(&#123;<span class="string">&quot;three&quot;</span> : <span class="number">3</span> , <span class="string">&quot;one&quot;</span>:<span class="number">1</span> , <span class="string">&quot;two&quot;</span>:<span class="number">2</span>&#125;)</span><br><span class="line">print(a == b == c == d ==e)</span><br></pre></td></tr></table></figure>
<p>上面的构建方法虽然是多样的，但是其键的插入顺序存在不同，如果产生哈希冲突，那么键的顺序会产生偏差。后半节会进行展示。</p>
<p><strong>字典推导构建字典</strong></p>
<p>用法与列表推导很像，这里不解释。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DIAL_CODES = [</span><br><span class="line">        (<span class="number">86</span>, <span class="string">&#x27;China&#x27;</span>),</span><br><span class="line">        (<span class="number">91</span>, <span class="string">&#x27;India&#x27;</span>),</span><br><span class="line">        (<span class="number">1</span>, <span class="string">&#x27;United States&#x27;</span>),</span><br><span class="line">        (<span class="number">62</span>, <span class="string">&#x27;Indonesia&#x27;</span>),</span><br><span class="line">        (<span class="number">55</span>, <span class="string">&#x27;Brazil&#x27;</span>),</span><br><span class="line">        (<span class="number">92</span>, <span class="string">&#x27;Pakistan&#x27;</span>),</span><br><span class="line">        (<span class="number">880</span>, <span class="string">&#x27;Bangladesh&#x27;</span>),</span><br><span class="line">        (<span class="number">234</span>, <span class="string">&#x27;Nigeria&#x27;</span>),</span><br><span class="line">        (<span class="number">7</span>, <span class="string">&#x27;Russia&#x27;</span>),</span><br><span class="line">        (<span class="number">81</span>, <span class="string">&#x27;Japan&#x27;</span>),</span><br><span class="line">    ]</span><br><span class="line">country_code = &#123;code:country.upper() <span class="keyword">for</span> code ,country <span class="keyword">in</span> DIAL_CODES&#125;</span><br><span class="line">print(country_code)</span><br><span class="line"><span class="comment"># &#123;86: &#x27;CHINA&#x27;, 91: &#x27;INDIA&#x27;, 1: &#x27;UNITED STATES&#x27;, 62: &#x27;INDONESIA&#x27;, 55: &#x27;BRAZIL&#x27;, 92: &#x27;PAKISTAN&#x27;, 880: &#x27;BANGLADESH&#x27;, 234: &#x27;NIGERIA&#x27;, 7: &#x27;RUSSIA&#x27;, 81: &#x27;JAPAN&#x27;&#125;</span></span><br><span class="line">country_code = &#123;country:code <span class="keyword">for</span> code ,country <span class="keyword">in</span> DIAL_CODES&#125;</span><br><span class="line">print(country_code)</span><br><span class="line"><span class="comment"># &#123;&#x27;China&#x27;: 86, &#x27;India&#x27;: 91, &#x27;United States&#x27;: 1, &#x27;Indonesia&#x27;: 62, &#x27;Brazil&#x27;: 55, &#x27;Pakistan&#x27;: 92, &#x27;Bangladesh&#x27;: 880, &#x27;Nigeria&#x27;: 234, &#x27;Russia&#x27;: 7, &#x27;Japan&#x27;: 81&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="如何处理找不到的键"><a href="#如何处理找不到的键" class="headerlink" title="如何处理找不到的键"></a>如何处理找不到的键</h3><p>首先介绍几个字典类关键方法与解释，方便接下来的理解；</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>d.default_factory</td>
<td>在__missing__函数中被调用的函数，用于给未找到的元素设置值</td>
</tr>
<tr>
<td>d.get(k , [default])</td>
<td>返回键k对应的值，如果字典里没有键k，则返回None或者default</td>
</tr>
<tr>
<td>d.__getitem__(k)</td>
<td>让字典d能用d[k]的形式返回键k对应的值</td>
</tr>
<tr>
<td>d.__missing__(k)</td>
<td>当__getitem__找不到对应键的时候，则调用此方法</td>
</tr>
<tr>
<td>d.__setdefault(k,[default])</td>
<td>若字典中有键k，则直接返回k所对应的值；若无，则使d[k] = default，然后返回default</td>
</tr>
</tbody></table>
<h4 id="利用get-k-default"><a href="#利用get-k-default" class="headerlink" title="利用get(k , default)"></a>利用get(k , default)</h4><p>以下代码实现了利用字典记录词与词频的记录，在键缺失时，采用get()方法进行处理，但是一般来说get的效率很低。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">WORD_RE = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line">index = &#123;&#125;</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(sys.argv[<span class="number">0</span>], encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="keyword">for</span> line_no, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(fp, <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> match <span class="keyword">in</span> WORD_RE.finditer(line):</span><br><span class="line">            word = match.group()</span><br><span class="line">            column_no = match.start()+<span class="number">1</span></span><br><span class="line">            location = (line_no, column_no)</span><br><span class="line">            <span class="comment"># this is ugly; coded like this to make a point</span></span><br><span class="line">            occurrences = index.get(word, [])  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">            occurrences.append(location)       <span class="comment"># &lt;2&gt;</span></span><br><span class="line">            index[word] = occurrences          <span class="comment"># &lt;3&gt;</span></span><br><span class="line"><span class="comment"># print in alphabetical order</span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> <span class="built_in">sorted</span>(index, key=<span class="built_in">str</span>.upper):  <span class="comment"># &lt;4&gt;</span></span><br><span class="line">    print(word, index[word])</span><br><span class="line"><span class="comment"># END INDEX0</span></span><br></pre></td></tr></table></figure>
<ol>
<li>获得键word的值，没有则返回[ ]</li>
<li>添加新的位置信息到变量中</li>
<li>将此变量赋值给地点对应键</li>
<li>依次打印词与词位置信息</li>
</ol>
<h4 id="利用setdefault方法"><a href="#利用setdefault方法" class="headerlink" title="利用setdefault方法"></a>利用setdefault方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">WORD_RE = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line">index = &#123;&#125;</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(sys.argv[<span class="number">0</span>], encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="keyword">for</span> line_no, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(fp, <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> match <span class="keyword">in</span> WORD_RE.finditer(line):</span><br><span class="line">            word = match.group()</span><br><span class="line">            column_no = match.start()+<span class="number">1</span></span><br><span class="line">            location = (line_no, column_no)</span><br><span class="line">            index.setdefault(word, []).append(location)  <span class="comment"># &lt;1&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print in alphabetical order</span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> <span class="built_in">sorted</span>(index, key=<span class="built_in">str</span>.upper):</span><br><span class="line">    print(word, index[word])</span><br></pre></td></tr></table></figure>
<p>上面代码中仅使用了一条语句就实现的相关功能，这是所提倡的方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict.setdefault(key , []).append(new_value)</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> my_dict:</span><br><span class="line">	my_dict[key] = []</span><br><span class="line">my_dict[key].append(new_value)</span><br></pre></td></tr></table></figure>
<h4 id="利用defaultdict类实现"><a href="#利用defaultdict类实现" class="headerlink" title="利用defaultdict类实现"></a>利用defaultdict类实现</h4><p>collection.defaultdict类的特点在于，在用户创建对象的时候就可以给它<strong>配置一个找不到键值时创造默认值的方法</strong>。通俗将就是在初始化对象时，参数为一个可以调用的方法，此方法在找不到键值时调用。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dd = defaultdict(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<p>如果键值不存在时其会进行接下来的流程：</p>
<ol>
<li>调用list() 构建一个新的列表</li>
<li>新列表作为值，new_value作为键，加入字典中</li>
<li>返回新列表的索引</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">WORD_RE = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\w+&#x27;</span>)</span><br><span class="line"><span class="comment"># 构建一个默认形式的字典</span></span><br><span class="line">index = collections.defaultdict(<span class="built_in">list</span>)     <span class="comment"># &lt;1&gt;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(sys.argv[<span class="number">0</span>], encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="keyword">for</span> line_no, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(fp, <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> match <span class="keyword">in</span> WORD_RE.finditer(line):</span><br><span class="line">            word = match.group()</span><br><span class="line">            column_no = match.start()+<span class="number">1</span></span><br><span class="line">            location = (line_no, column_no)</span><br><span class="line">            <span class="comment"># 代码逻辑看不到差别，透明性</span></span><br><span class="line">            index[word].append(location)  <span class="comment"># &lt;2&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print in alphabetical order</span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> <span class="built_in">sorted</span>(index, key=<span class="built_in">str</span>.upper):</span><br><span class="line">    print(word, index[word])</span><br></pre></td></tr></table></figure>
<h4 id="实现字典子类并重写-missing-方法"><a href="#实现字典子类并重写-missing-方法" class="headerlink" title="实现字典子类并重写 __missing__方法"></a>实现字典子类并重写 __missing__方法</h4><p>当__getitem__找不到对应键的时候，则调用此方法，而__getitem__在dict[key]是进行调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrKeyDict0</span>(<span class="params"><span class="built_in">dict</span></span>):</span>  <span class="comment"># &lt;1&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(key, <span class="built_in">str</span>):  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">        <span class="keyword">return</span> self[<span class="built_in">str</span>(key)]  <span class="comment"># &lt;3&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key, default=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]  <span class="comment"># &lt;4&gt;</span></span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">return</span> default  <span class="comment"># &lt;5&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> self.keys() <span class="keyword">or</span> <span class="built_in">str</span>(key) <span class="keyword">in</span> self.keys()  <span class="comment"># &lt;6&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中实现了字典的子类及相关方法，这里不解释，可在具体应用时操作。</p>
<h3 id="字典的变种"><a href="#字典的变种" class="headerlink" title="字典的变种"></a>字典的变种</h3><p>字典的变种很多，或多或少也接触过。collection.OrderDict\collection.ChainMap\collection.Counter等，不一一解释，用时自然知道。</p>
<h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><p><strong>集合是唯一对象的聚集。</strong>在日常使用中较少，其内部实现结构也是散列表。在集合中包含有两个重要的类别：set与frozenset.其存在一个重要的差别就是：frozenset是可散列的，set是不可散列的。而集合的元素要求是需要散列的。也就是说set的元素可以是forzenset，反之不可以。</p>
<p>上面说的散列就是指的hash()方法，可以哈希则表明hash(key)是不可变的，而set会产生变化，自然不能hash().</p>
<h3 id="集合的构造"><a href="#集合的构造" class="headerlink" title="集合的构造"></a>集合的构造</h3><h4 id="普通构建"><a href="#普通构建" class="headerlink" title="普通构建"></a>普通构建</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 经典构建</span></span><br><span class="line">s = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment"># &#123;1, 2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 空集的构建</span></span><br><span class="line">s = <span class="built_in">set</span>()</span><br><span class="line"><span class="comment"># set()</span></span><br></pre></td></tr></table></figure>
<h4 id="利用字面量构建"><a href="#利用字面量构建" class="headerlink" title="利用字面量构建"></a>利用字面量构建</h4><p>这里的字面量就是数学表达式的方式，除了空集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字面量构建</span></span><br><span class="line">s = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<h4 id="集合推导"><a href="#集合推导" class="headerlink" title="集合推导"></a>集合推导</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> name</span><br><span class="line">print(&#123; <span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>,<span class="number">256</span>) <span class="keyword">if</span> <span class="string">&quot;SIGN&quot;</span> <span class="keyword">in</span> name(<span class="built_in">chr</span>(i) , <span class="string">&quot;&quot;</span>)&#125;)</span><br><span class="line"><span class="comment"># &#123;&#x27;&gt;&#x27;, &#x27;±&#x27;, &#x27;÷&#x27;, &#x27;+&#x27;, &#x27;¤&#x27;, &#x27;£&#x27;, &#x27;&lt;&#x27;, &#x27;©&#x27;, &#x27;$&#x27;, &#x27;¶&#x27;, &#x27;#&#x27;, &#x27;¥&#x27;, &#x27;×&#x27;, &#x27;µ&#x27;, &#x27;¬&#x27;, &#x27;=&#x27;, &#x27;°&#x27;, &#x27;%&#x27;, &#x27;¢&#x27;, &#x27;®&#x27;, &#x27;§&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="dict与set背后的机制"><a href="#dict与set背后的机制" class="headerlink" title="dict与set背后的机制"></a>dict与set背后的机制</h2><p>只介绍dict即可。我们知道字典的背后机制是散列表，而散列表是一种稀疏数组。理想的散列函数应当保证整体的均衡性，也就是说<strong>越相似的散列值，其结果偏差越大</strong>。散列的解决冲突算法采用了再散列法。</p>
<h3 id="键必须是可散列的"><a href="#键必须是可散列的" class="headerlink" title="键必须是可散列的"></a>键必须是可散列的</h3><ol>
<li>支持hash()函数，并且散列值不可变；</li>
<li>支持通过__eq__()方法检测相等性；</li>
<li>若a == b ,则 hash(a) == hash(b)</li>
</ol>
<h3 id="字典内存开销大"><a href="#字典内存开销大" class="headerlink" title="字典内存开销大"></a>字典内存开销大</h3><p>首先需要保证字典是一个稀疏的数组，那么其空间效率低下；</p>
<h3 id="键查询快"><a href="#键查询快" class="headerlink" title="键查询快"></a>键查询快</h3><p>不解释</p>
<h3 id="键的次序却决于添加顺序"><a href="#键的次序却决于添加顺序" class="headerlink" title="键的次序却决于添加顺序"></a>键的次序却决于添加顺序</h3><p>这是由于大量元素插入过程中，不可避免的会产生冲突。不同顺序会导致差别。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BEGIN DIALCODES</span></span><br><span class="line"><span class="comment"># dial codes of the top 10 most populous countries</span></span><br><span class="line">DIAL_CODES = [</span><br><span class="line">        (<span class="number">86</span>, <span class="string">&#x27;China&#x27;</span>),</span><br><span class="line">        (<span class="number">91</span>, <span class="string">&#x27;India&#x27;</span>),</span><br><span class="line">        (<span class="number">1</span>, <span class="string">&#x27;United States&#x27;</span>),</span><br><span class="line">        (<span class="number">62</span>, <span class="string">&#x27;Indonesia&#x27;</span>),</span><br><span class="line">        (<span class="number">55</span>, <span class="string">&#x27;Brazil&#x27;</span>),</span><br><span class="line">        (<span class="number">92</span>, <span class="string">&#x27;Pakistan&#x27;</span>),</span><br><span class="line">        (<span class="number">880</span>, <span class="string">&#x27;Bangladesh&#x27;</span>),</span><br><span class="line">        (<span class="number">234</span>, <span class="string">&#x27;Nigeria&#x27;</span>),</span><br><span class="line">        (<span class="number">7</span>, <span class="string">&#x27;Russia&#x27;</span>),</span><br><span class="line">        (<span class="number">81</span>, <span class="string">&#x27;Japan&#x27;</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">d1 = <span class="built_in">dict</span>(DIAL_CODES)  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">print(<span class="string">&#x27;d1:&#x27;</span>, d1.keys())</span><br><span class="line">d2 = <span class="built_in">dict</span>(<span class="built_in">sorted</span>(DIAL_CODES))  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">print(<span class="string">&#x27;d2:&#x27;</span>, d2.keys())</span><br><span class="line">d3 = <span class="built_in">dict</span>(<span class="built_in">sorted</span>(DIAL_CODES, key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>]))  <span class="comment"># &lt;3&gt;</span></span><br><span class="line">print(<span class="string">&#x27;d3:&#x27;</span>, d3.keys())</span><br><span class="line"><span class="keyword">assert</span> d1 == d2 <span class="keyword">and</span> d2 == d3  <span class="comment"># &lt;4&gt;</span></span><br><span class="line"><span class="comment"># END DIALCODES</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># BEGIN DIALCODES_OUTPUT</span></span><br><span class="line"><span class="string">d1: dict_keys([880, 1, 86, 55, 7, 234, 91, 92, 62, 81])</span></span><br><span class="line"><span class="string">d2: dict_keys([880, 1, 91, 86, 81, 55, 234, 7, 92, 62])</span></span><br><span class="line"><span class="string">d3: dict_keys([880, 81, 1, 86, 55, 7, 234, 91, 92, 62])</span></span><br><span class="line"><span class="string"># END DIALCODES_OUTPUT</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="新键的添加可能影响原键的顺序"><a href="#新键的添加可能影响原键的顺序" class="headerlink" title="新键的添加可能影响原键的顺序"></a>新键的添加可能影响原键的顺序</h3><p>这是一个之前的盲点，无论何时往字典里添加新的键，Python解释器都可能做出为字典扩容的决定。扩容则导致新建一个更大的散列表，并将字典里已有的元素添加到新表里。这个过程可能产生新的散列冲突，导致次序变化。</p>
<p>由此可知，<strong>不可以对字典同时进行迭代与修改</strong>。</p>
<p>如果对字典同时进行迭代与修改，如果想要扫描并修改一个字典，最好分成两步：先对字典迭代，得出需要添加的内容，放入新字典；迭代结束后，对原字典更新。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_python Call Graph学习</title>
    <url>/2021/01/17/Python-python-Call-Graph%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>Python Call Graph是用于<strong>可视化</strong>Python内部函数调用的包，其生成的为<strong>动态程序调用图</strong>。</p>
<a id="more"></a>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p><a href="https://pycallgraph.readthedocs.io/en/master/guide/intro.html">参考地址</a></p>
</blockquote>
<p>Python Call Graph是用于<strong>可视化</strong>Python内部函数调用的包，其生成的为<strong>动态程序调用图</strong>。</p>
<ul>
<li><strong>原理</strong>：利用了Python自带的DEBUG函数（sys.set_trace()）来追踪；<ul>
<li><strong>可追踪项目</strong>：函数名，函数的使用时间，函数间的调用关系；</li>
</ul>
</li>
<li><strong>输出多样化：</strong><ul>
<li>输出DOT文件：符合GraphViz的接口</li>
<li>输出JSON或者GDF文件：符合Gephi的接口</li>
</ul>
</li>
<li><strong>输出定制化：</strong>可利用提供的接口，定制化输出文件</li>
<li><strong>调用方式多样：</strong><ul>
<li>可使用命令行模式；</li>
<li>可使用代码模式；</li>
</ul>
</li>
<li><strong>可以进行过滤：</strong><ul>
<li>指定排外的函数</li>
<li>指定包括的函数</li>
<li>指定最大的深度</li>
</ul>
</li>
</ul>
<p>总的来说Python Call Graph是一个简单的包。</p>
<h2 id="基本代码演示"><a href="#基本代码演示" class="headerlink" title="基本代码演示"></a>基本代码演示</h2><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a><strong>代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">This example demonstrates a simple use of pycallgraph.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> pycallgraph <span class="keyword">import</span> PyCallGraph</span><br><span class="line"><span class="keyword">from</span> pycallgraph.output <span class="keyword">import</span> GraphvizOutput</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.no_bananas()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">no_bananas</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.bananas = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_banana</span>(<span class="params">self, banana</span>):</span></span><br><span class="line">        self.bananas.append(banana)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat_bananas</span>(<span class="params">self</span>):</span></span><br><span class="line">        [banana.eat() <span class="keyword">for</span> banana <span class="keyword">in</span> self.bananas]</span><br><span class="line">        self.no_bananas()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    graphviz = GraphvizOutput()</span><br><span class="line">    graphviz.output_file = <span class="string">&#x27;basic.png&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> PyCallGraph(output=graphviz):</span><br><span class="line">        person = Person()</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            person.add_banana(Banana())</span><br><span class="line">        person.eat_bananas()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a><strong>结果：</strong></h3><p><img src="F:\myPythonProject\PythonCallGraph\Examples\Basic.png"></p>
<p>上图中展示了<strong>函数调用的树图</strong> ， <strong>函数调用的次数</strong> ， <strong>函数调用花费的时间</strong></p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_heapq类</title>
    <url>/2021/01/17/Python-heapq%E7%B1%BB/</url>
    <content><![CDATA[<p>Python官方提供的最小堆类:</p>
<a id="more"></a>

<blockquote>
<p><a href="https://docs.python.org/3.8/library/heapq.html">官方文档</a></p>
<p><a href="https://www.cnblogs.com/xiaobingqianrui/p/8487840.html">博客</a></p>
</blockquote>
<h2 id="heapq类是什么"><a href="#heapq类是什么" class="headerlink" title="heapq类是什么"></a>heapq类是什么</h2><ol>
<li><p>heapq本身是heap queue algorithm的缩略简称。</p>
</li>
<li><p>是Python官方提供的最小堆类</p>
<ul>
<li>提供了常见的操作函数</li>
<li>易于实现堆排序，优先队列等应用</li>
</ul>
</li>
</ol>
<h2 id="初始化与相关函数介绍"><a href="#初始化与相关函数介绍" class="headerlink" title="初始化与相关函数介绍"></a>初始化与相关函数介绍</h2><h3 id="堆的初始化"><a href="#堆的初始化" class="headerlink" title="堆的初始化"></a>堆的初始化</h3><p>堆实质就是一种理论上为树，物理上为列表的一种数据结构。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建一个空堆就是一个空列表</span></span><br><span class="line">emptyHeap = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建一个非空堆利用 heap.heapify()</span></span><br><span class="line"></span><br><span class="line">originalList = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span> , <span class="number">0</span> , -<span class="number">8</span>)]</span><br><span class="line">print(<span class="string">&quot;Before heapify: &quot;</span>,originalList)</span><br><span class="line">heapq.heapify(originalList) <span class="comment"># 注意heap.heapify()方法原地修改了list对象，而没有返回一个新的列表</span></span><br><span class="line">print(<span class="string">&quot;After heapify: &quot;</span>,originalList)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Before heapify:  [100, 92, 84, 76, 68, 60, 52, 44, 36, 28, 20, 12, 4]</span></span><br><span class="line"><span class="comment"># After heapify:  [4, 20, 12, 36, 28, 60, 52, 44, 76, 92, 68, 84, 100]</span></span><br></pre></td></tr></table></figure>
<h3 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h3><table>
<thead>
<tr>
<th>函数名称</th>
<th>函数作用</th>
</tr>
</thead>
<tbody><tr>
<td>heapq.heappush(heap,item)</td>
<td>堆插入，并进行堆调整（保持了最小堆）</td>
</tr>
<tr>
<td>heapq.heappop(heap)</td>
<td>pop堆顶元素，并返回，进行堆调整（保持了最小堆）</td>
</tr>
<tr>
<td>heapq.heappushpop(heap,item)</td>
<td>先push然后pop堆顶元素，并返回此元素，进行堆调整</td>
</tr>
<tr>
<td>heapq.heapify(x)</td>
<td>将list列表转换为最小堆</td>
</tr>
<tr>
<td>heapq.heapreplace(heap,item)</td>
<td>先pop，返回了此元素 ， 然后push item元素，进行堆调整</td>
</tr>
<tr>
<td>heapq.merge(*iterables , key= None , reverse = False)</td>
<td>合并多个堆，并返回结果</td>
</tr>
<tr>
<td>heapq.nlargest(n ,iterable , key=None)</td>
<td>返回可迭代对象的前N个大的元素，从大到小排序</td>
</tr>
<tr>
<td>heapq.nsmallest(n , iterable , key=None)</td>
<td>返回可迭代对象的前N个小的元素，从小到大排序</td>
</tr>
</tbody></table>
<p><strong>函数功能简单展示：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">originalList = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span> , <span class="number">0</span> , -<span class="number">8</span>)]</span><br><span class="line">print(<span class="string">&quot;Before heapify: &quot;</span>,originalList)</span><br><span class="line">heapq.heapify(originalList)</span><br><span class="line">print(<span class="string">&quot;After heapify: &quot;</span>,originalList)</span><br><span class="line">heapq.heappush(originalList , <span class="number">1</span>)</span><br><span class="line">print(<span class="string">&quot;After heappush: &quot;</span> , originalList)</span><br><span class="line">smallest = heapq.heappop(originalList)</span><br><span class="line">print(<span class="string">&quot;smallest elements is: &quot;</span> , smallest)</span><br><span class="line">secondSmall = heapq.heappushpop(originalList , <span class="number">1000</span>)</span><br><span class="line">print(<span class="string">&quot;After heappushpop&quot;</span>, originalList)</span><br><span class="line">print(<span class="string">&quot;second small element is: &quot;</span> , secondSmall)</span><br><span class="line">secondSmall = heapq.heapreplace(originalList , <span class="number">45</span>)</span><br><span class="line">print(<span class="string">&quot;After heapreplace&quot;</span>, originalList)</span><br><span class="line">print(<span class="string">&quot;second small element is: &quot;</span> , secondSmall)</span><br><span class="line">print(<span class="string">&quot;top 3 big elements is: &quot;</span> , heapq.nlargest(<span class="number">3</span>,originalList))</span><br><span class="line">print(<span class="string">&quot;top 3 small elements is:&quot;</span>, heapq.nsmallest(<span class="number">3</span>,originalList))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Before heapify:  [<span class="number">100</span>, <span class="number">92</span>, <span class="number">84</span>, <span class="number">76</span>, <span class="number">68</span>, <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>]</span><br><span class="line">After heapify:  [<span class="number">4</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">76</span>, <span class="number">92</span>, <span class="number">68</span>, <span class="number">84</span>, <span class="number">100</span>]</span><br><span class="line">After heappush:  [<span class="number">1</span>, <span class="number">20</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">60</span>, <span class="number">12</span>, <span class="number">44</span>, <span class="number">76</span>, <span class="number">92</span>, <span class="number">68</span>, <span class="number">84</span>, <span class="number">100</span>, <span class="number">52</span>]</span><br><span class="line">smallest elements <span class="keyword">is</span>:  <span class="number">1</span></span><br><span class="line">After heappushpop [<span class="number">12</span>, <span class="number">20</span>, <span class="number">52</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">60</span>, <span class="number">1000</span>, <span class="number">44</span>, <span class="number">76</span>, <span class="number">92</span>, <span class="number">68</span>, <span class="number">84</span>, <span class="number">100</span>]</span><br><span class="line">second small element <span class="keyword">is</span>:  <span class="number">4</span></span><br><span class="line">After heapreplace [<span class="number">20</span>, <span class="number">28</span>, <span class="number">52</span>, <span class="number">36</span>, <span class="number">45</span>, <span class="number">60</span>, <span class="number">1000</span>, <span class="number">44</span>, <span class="number">76</span>, <span class="number">92</span>, <span class="number">68</span>, <span class="number">84</span>, <span class="number">100</span>]</span><br><span class="line">second small element <span class="keyword">is</span>:  <span class="number">12</span></span><br><span class="line">top <span class="number">3</span> big elements <span class="keyword">is</span>:  [<span class="number">1000</span>, <span class="number">100</span>, <span class="number">92</span>]</span><br><span class="line">top <span class="number">3</span> small elements <span class="keyword">is</span>: [<span class="number">20</span>, <span class="number">28</span>, <span class="number">36</span>]</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappop , heappush</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapsort</span>(<span class="params">iterable</span>):</span></span><br><span class="line">     h = []</span><br><span class="line">     <span class="keyword">for</span> value <span class="keyword">in</span> iterable:</span><br><span class="line">         heappush(h, value)</span><br><span class="line">     <span class="keyword">return</span> [heappop(h) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(h))]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">heapsort([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>])</span><br><span class="line"><span class="comment">#[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_python2的编码问题</title>
    <url>/2021/01/17/Python-python2%E7%9A%84%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<!-- more  -->

<blockquote>
<p>最近在调试python2过程中经常出现编码的问题，尤其是将python3程序重构为python2程序过程中出现的问题。</p>
<p>问题一：编码本身有什么不同</p>
<ul>
<li>这在字符编码.md文件中已经有了清晰的解释</li>
</ul>
<p>问题二：python2处理中文时为什么总是会出现乱码</p>
<ul>
<li>encode与decode两者需要明确区分</li>
<li>对应的字符与字节也需要区分</li>
</ul>
<p>带着以上两个问题看到了相关的解释，特记录如下：</p>
</blockquote>
<h2 id="字符与字节问题"><a href="#字符与字节问题" class="headerlink" title="字符与字节问题"></a>字符与字节问题</h2><blockquote>
<p>字符与字节之间并不是同等地位。</p>
<p><strong>字符串：</strong>由字符组成的序列</p>
<p><strong>字符：</strong>字符是<strong>人</strong>使用的符号，是一种人所认知的单位。例如：“中” ， “1” ，“￥”等等</p>
<blockquote>
<ul>
<li><p>在python3中，str对象中获取的元素是<strong>Unicode字符</strong> </p>
</li>
<li><p>在python2中，str对象中获取的原始<strong>字节序列</strong></p>
</li>
</ul>
<p>可以看到同样是str对象，python2中其实是字节，python3中是字符</p>
</blockquote>
<p><strong>字节：</strong>字节是<strong>计算机</strong>所使用的符号，是8位的二进制数字。例如 0x01,01010101,0b45</p>
</blockquote>
<p><strong>不同编码体制中，字符与字节拥有着不同的对应关系：</strong></p>
<ol>
<li><p><strong>ASCII码：</strong>  一个英文字母（不分大小写）占一个字节的空间，<strong>一个中文汉字占两个字节</strong>的空间。一个<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLPANWnW01uH6suhf3nWmk0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPjRYPjnvPH63nHmLnWRvPHcd">二进制数字</a>序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值0，最大值255。</p>
</li>
<li><p><strong>UTF-8：</strong>一个英文字符=一个字节，一个中文（含繁体）=三个字节。</p>
<blockquote>
<p>已知UTF-8编码是UNICODE编码的实现形式的一种，Unicode规定了世界上所有的符号与二进制的对应关系，但是其实现形式多种多样，比如UTF-8,UTF-16等等。</p>
<p><strong>Unicode才是真正的（人）字符串，而用ASCII、UTF-8、GBK等字符编码表示的是字节串。</strong></p>
<blockquote>
<p>从这个角度理解unicode就是CAMEO，utf-8就是VerbDic.</p>
</blockquote>
</blockquote>
</li>
</ol>
<h2 id="encode与decode"><a href="#encode与decode" class="headerlink" title="encode与decode"></a>encode与decode</h2><blockquote>
<p>encode与decode分别对应</p>
<p><strong>encode:</strong> 将人类可识别的字符转换为机器可识别的字节码，<strong>字符到字节的过程</strong>。</p>
<p><strong>decode:**就是将机器可识别的字节码转换成人类可识别的字符，</strong>字节到字符的过程**。</p>
</blockquote>
<h2 id="python中的默认编码"><a href="#python中的默认编码" class="headerlink" title="python中的默认编码"></a>python中的默认编码</h2><h3 id="Python源代码的执行过程"><a href="#Python源代码的执行过程" class="headerlink" title="Python源代码的执行过程"></a>Python源代码的执行过程</h3><blockquote>
<p>我们都知道，磁盘上的文件都是以二进制格式存放的，其中文本文件都是以某种特定编码的字节形式存放的。对于程序源代码文件的字符编码是由编辑器指定的，比如我们使用Pycharm来编写Python程序时会指定工程编码和文件编码为UTF-8，那么Python代码被<strong>保存到磁盘</strong>时就会被转换为UTF-8编码对应的字节（<strong>encode过程</strong>）后写入磁盘。</p>
<p>当执行Python代码文件中的代码时，Python解释器在读取Python代码文件中的字节串之后，需要将其转换为Unicode字符串（decode过程）之后才执行后续操作。</p>
<p><img src="https://i.loli.net/2021/01/11/fBTidJh2WmHNkyD.png"></p>
</blockquote>
<h3 id="默认编码"><a href="#默认编码" class="headerlink" title="默认编码"></a>默认编码</h3><blockquote>
<p>如果我们没有在代码文件指定字符编码，<strong>Python解释器</strong>会使用哪种字符编码把从代码文件中读取到的字节转换为Unicode字符串呢？就像我们配置某些软件时，有很多默认选项一样，需要在Python解释器内部设置默认的字符编码来解决这个问题，这就是“默认编码”。</p>
<p>Python2和Python3的解释器使用的默认编码是不一样的，我们可以通过sys.getdefaultencoding()来获取默认编码：</p>
<ul>
<li><strong>Python2:ascii</strong></li>
<li><strong>Python3:utf-8</strong></li>
</ul>
</blockquote>
<h3 id="python2与python3处理文件"><a href="#python2与python3处理文件" class="headerlink" title="python2与python3处理文件"></a>python2与python3处理文件</h3><blockquote>
<p>对于Python2来讲，Python解释器在读取到中文字符的字节码时，会先查看当前代码文件头部是否指明字符编码是什么。如果没有指定，则使用默认字符编码”ASCII”进行解码，导致中文字符解码失败，出现如下错误</p>
<blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">SyntaxError:Non-ASCII character <span class="string">&#x27;\xc4&#x27;</span> <span class="keyword">in</span> file xxx.py <span class="keyword">on</span> line <span class="number">11</span>, but no encoding declared;</span><br><span class="line">see http:<span class="comment">//python.org/dev/peps/pep-0263/ for details</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>对于Python3来讲，执行过程是一样的，只是Python3的解释器以”UTF-8”作为默认编码，但是这并不表示可以完全兼容中文问题。比如我们在Windows上进行开发时，Python工程及代码文件都使用的是默认的GBK编码，也就是说Python代码文件是被转换成GBK格式的字节码保存到磁盘中的。Python3的解释器执行该代码文件时，试图用UTF-8进行解码操作时，同样会解码失败，出现如下错误：</p>
<blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">SyntaxError:Non-UTF<span class="number">-8</span> code starting <span class="keyword">with</span> <span class="string">&#x27;\xc4&#x27;</span> <span class="keyword">in</span> file xx.py <span class="keyword">on</span> line <span class="number">11</span>, but no encodingdeclared; </span><br><span class="line">see http:<span class="comment">//python.org/dev/peps/pep-0263/ for details</span></span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h2 id="Python2-Python3对字符串的支持"><a href="#Python2-Python3对字符串的支持" class="headerlink" title="Python2 Python3对字符串的支持"></a>Python2 Python3对字符串的支持</h2><h3 id="Python2"><a href="#Python2" class="headerlink" title="Python2"></a>Python2</h3><blockquote>
<p>Python2中对字符串的支持由以下三个类别提供：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">basestring</span></span>(<span class="keyword">object</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">str</span></span>(basestring)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unicode</span></span>(basestring)</span><br></pre></td></tr></table></figure>

<p>其中basestring类是str类与unicode类的父类。</p>
<ul>
<li><p><strong>str其实是字节串</strong>，它是unicode经过编码后的字节组成的序列。</p>
<blockquote>
<p>对UTF-8编码的str’汉’使用len()函数时，结果是3，因为UTF-8编码的’汉’==’\xE6\xB1\x89’。</p>
</blockquote>
</li>
<li><p><strong>unicode才是真正意义上的字符串</strong>，对字节串str使用正确的字符编码进行解码后获得，并且len(u’汉’)==1。</p>
</li>
</ul>
</blockquote>
<h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h3><blockquote>
<p>Python3中对字符串的支持进行了实现类层次的上简化，去掉了unicode类，添加了一个bytes类。从表面上来看，可认为Python3中的str和unicode合二为一了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bytes</span></span>(<span class="keyword">object</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">str</span></span>(<span class="keyword">object</span>)</span><br></pre></td></tr></table></figure>

<p>实际上，<strong>Python3中已经意识到之前的错误，开始明确区分字符串与字节</strong>。</p>
<p><strong>因此Python3中的str已经是真正的字符串，而字节是用单独的bytes类来表示。</strong></p>
<p>也就是说，Python3默认定义的就是字符串，实现了对Unicode的内置支持，减轻了程序员对字符串处理的负担。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*- </span></span><br><span class="line">a = <span class="string">&#x27;你好&#x27;</span></span><br><span class="line">b = <span class="string">u&#x27;你好&#x27;</span></span><br><span class="line">c = <span class="string">&#x27;你好&#x27;</span>.encode(<span class="string">&#x27;gbk&#x27;</span>) </span><br><span class="line">print(<span class="built_in">type</span>(a),<span class="built_in">len</span>(a))         <span class="comment"># output:&lt;class&#x27;str&#x27;&gt; 2</span></span><br><span class="line">print(<span class="built_in">type</span>(b),<span class="built_in">len</span>(b))         <span class="comment"># output:&lt;class&#x27;str&#x27;&gt; 2</span></span><br><span class="line">print(<span class="built_in">type</span>(c),<span class="built_in">len</span>(c))         <span class="comment"># output:&lt;class&#x27;bytes&#x27;&gt; 4</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="字符与字节转换"><a href="#字符与字节转换" class="headerlink" title="字符与字节转换"></a>字符与字节转换</h3><blockquote>
<p>4.3的名称我自己起的，合不合适的我们再看</p>
</blockquote>
<ul>
<li><p><strong>单个字符的encode：</strong></p>
<blockquote>
<p>Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="number">65</span></span><br><span class="line">&gt;&gt;&gt; ord(<span class="string">&#x27;中&#x27;</span>)</span><br><span class="line"><span class="number">20013</span></span><br><span class="line">&gt;&gt;&gt; chr(<span class="number">97</span>)</span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line">&gt;&gt;&gt; chr(<span class="number">20013</span>)</span><br><span class="line"><span class="string">&#x27;中&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果知道字符的整数编码，还可以用十六进制这么写字符：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="string">&#x27;\u4e2d\u6587&#x27;</span></span><br><span class="line"><span class="string">&#x27;中文&#x27;</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p><strong>字符.encode() = 字节</strong></p>
<blockquote>
<p>Python3的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。</p>
<p>Python对bytes类型的数据用带b前缀的单引号或双引号表示：x = b’ABC’。</p>
<p>要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。</p>
<p>以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="string">&#x27;ABC&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">b<span class="string">&#x27;ABC&#x27;</span></span><br><span class="line">&gt;&gt;&gt; <span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">b<span class="string">&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span></span><br><span class="line">&gt;&gt;&gt; <span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="symbol">UnicodeEncodeError:</span> <span class="string">&#x27;ascii&#x27;</span> codec can<span class="string">&#x27;t encode characters in position 0-1: ordinal not in range(128)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>常见的中文报错问题愿意：</p>
<p>纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。<strong>中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。</strong></p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>字节.decode() = 字符：</strong></p>
<blockquote>
<p>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b<span class="string">&#x27;ABC&#x27;</span>.decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;ABC&#x27;</span></span><br><span class="line">&gt;&gt;&gt; b<span class="string">&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;中文&#x27;</span></span><br></pre></td></tr></table></figure>

<p>要计算str包含多少个字符，可以用len()函数：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; len(<span class="string">&#x27;ABC&#x27;</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt; len(<span class="string">&#x27;中文&#x27;</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; len(b<span class="string">&#x27;ABC&#x27;</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt; len(b<span class="string">&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line">&gt;&gt;&gt; len(<span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Python2-Python3字符编码的转换"><a href="#Python2-Python3字符编码的转换" class="headerlink" title="Python2 Python3字符编码的转换"></a>Python2 Python3字符编码的转换</h2><p>Unicode字符串可以与任意字符编码的字节串进行相互转换：</p>
<p><img src="https://i.loli.net/2021/01/11/nODNpsrMTiJozU2.png"></p>
</li>
</ul>
<blockquote>
<p>从上图可以看出不同字节编码之间是可以通过Unicode来实现相互转换的。</p>
<ul>
<li><p>Python2中的字符串进行字符编码转换过程是：</p>
<p><strong>字节串(Python2的str默认是字节串)–&gt;decode(‘原来的字符编码’)–&gt;Unicode字符串–&gt;encode(‘新的字符编码’)–&gt;字节串</strong></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python2</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*- </span></span><br><span class="line">utf_8_a = <span class="string">&#x27;我爱中国&#x27;</span></span><br><span class="line">gbk_a = utf_8_a.decode(<span class="string">&#x27;utf-8&#x27;</span>).encode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(gbk_a.decode(<span class="string">&#x27;gbk&#x27;</span>))</span><br><span class="line"><span class="comment"># 输出结果：我爱中国</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Python3中定义的字符串默认就是unicode，因此不需要先解码，可以直接编码成新的字符编码：</p>
<p><strong>字符串(str就是Unicode字符串)–&gt;encode(‘新的字符编码’)–&gt;字节串</strong></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*- </span></span><br><span class="line">utf_8_b = <span class="string">&#x27;我爱中国&#x27;</span></span><br><span class="line">gbk_b = utf_8_b.encode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(gbk_b.decode(<span class="string">&#x27;gbk&#x27;</span>))</span><br><span class="line"><span class="comment"># 输出结果：我爱中国</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Python2-中乱码问题的解决方案"><a href="#Python2-中乱码问题的解决方案" class="headerlink" title="Python2 中乱码问题的解决方案"></a>Python2 中乱码问题的解决方案</h2><h3 id="不要相信Print-结果"><a href="#不要相信Print-结果" class="headerlink" title="不要相信Print()结果"></a>不要相信Print()结果</h3><blockquote>
<p>print()函数本身是加工后给<strong>人</strong>看的,不管给它什么样子的编码格式文件，都可以打印出来。</p>
<p><strong>这也就意味着print()，并没有展示变量的本质。</strong></p>
<p>可以选择 jupyter中</p>
<blockquote>
<p>这里是<strong>Python2</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>chinese = <span class="string">&#x27;中文&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chinese </span><br><span class="line"><span class="string">&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Python2中“字符串”两大阵容"><a href="#Python2中“字符串”两大阵容" class="headerlink" title="Python2中“字符串”两大阵容"></a>Python2中“字符串”两大阵容</h3><blockquote>
<p>unicode和str</p>
<p>如果<code>type(字符串)</code>显示结果是<code>str</code>，其实指的是<code>bytes</code>字节码。</p>
<blockquote>
<p>由上面的内容我们已经理解当前python2中str对象与unicode对象分别代表：字节与字符</p>
</blockquote>
</blockquote>
<ul>
<li><p>encoding与decoding</p>
<p>从<code>unicode</code>转换到<code>str</code>，这个叫<code>encoding</code>，编码。<br>从<code>str</code>转换到<code>unicode</code>，这个叫<code>decoding</code>，解码。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/01/11/X4YE6dehLPIiWq7.png"></p>
<ul>
<li><p>案例</p>
<blockquote>
<p>Python2</p>
</blockquote>
<p><img src="https://i.loli.net/2021/01/11/swf96A7lgDz14Rv.png"></p>
</li>
</ul>
<h3 id="具体统一方案"><a href="#具体统一方案" class="headerlink" title="具体统一方案"></a>具体统一方案</h3><blockquote>
<p>见剩余内容<a href="https://segmentfault.com/a/1190000013202801">https://segmentfault.com/a/1190000013202801</a></p>
<p>这里的统一方案无非就是按照字符处理文件还是按照字节处理文件，何时进行decode何时encode的问题。</p>
<p>做个给出了一个方案，但我目前并没有采用，这里不详细写</p>
</blockquote>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_new与init</title>
    <url>/2021/01/17/Python-new%E4%B8%8Einit/</url>
    <content><![CDATA[<p>乍看一下上面两个方法功能相似，但其是其存在区别。</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__new__方法：用来构造一个类实例；</span><br><span class="line">__init__方法：用于初始化一个实例；</span><br></pre></td></tr></table></figure>
<p>那么从上面的差别来看，很明显需要首先调用new方法，构造实例后，才能够调用init初始化该实例。</p>
<p><strong>两个方法的参数差异：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__new__：方法用于构造实例，调用方法时传入的是类(CLS)，而非实例(INSTANCE)；</span><br><span class="line">__init__:方法用于初始化实例，调用方法时传入的是实例（INSTANCE）</span><br></pre></td></tr></table></figure>


<h2 id="相关知识：旧类与新类"><a href="#相关知识：旧类与新类" class="headerlink" title="相关知识：旧类与新类"></a>相关知识：旧类与新类</h2><p>在Python2中存在旧类与新类的概念，其中旧类指的是继承自type元类的类，而新类是继承自object类的类。</p>
<p>旧类代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">oldStyleClass</span>:</span> <span class="comment"># inherits from &#x27;type&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>新类代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">newStyleClass</span>(<span class="params"><span class="built_in">object</span></span>):</span> <span class="comment"># explicitly inherits from &#x27;object&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>在Python3中所有类默认继承自object，并不需要object作为基类；</p>
<p>我们现在就了解Python2中存在旧类与新类，他们只是继承的父类不同，那么也就继承了父类的方法与属性；相应的对new与init方法存在差异。</p>
<h2 id="Python旧类中两方法的差异"><a href="#Python旧类中两方法的差异" class="headerlink" title="Python旧类中两方法的差异"></a>Python旧类中两方法的差异</h2><ul>
<li>旧类中没有new方法，其init方法起到了构造的作用；</li>
<li>旧类中init方法的返回值无法进行控制；</li>
</ul>
<p><strong>定义一个旧类</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">oldStyleClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__new__ is called&quot;</span>) <span class="comment"># this line will never get called during construction</span></span><br><span class="line"></span><br><span class="line">oldStyleClass()</span><br><span class="line"><span class="comment"># &lt;__main__.oldStyleClass instance at 0x0000000003C1A5C8&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到即使，我们构造了一个new方法，在旧类的初始化过程中仍然不会调用它；</p>
<p><strong>重载init方法时：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">oldStyleClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__new__ is called&quot;</span>) <span class="comment"># this line will never get called during construction</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self)</span><br><span class="line">        print(<span class="string">&quot;init is called&quot;</span>)</span><br><span class="line"></span><br><span class="line">oldStyleClass()</span><br><span class="line"><span class="comment"># &lt;__main__.oldStyleClass instance at 0x0000000003C2AE48&gt;</span></span><br><span class="line"><span class="comment"># init is called</span></span><br><span class="line"><span class="comment"># &lt;__main__.oldStyleClass instance at 0x0000000003C2AE48&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们发现在函数的一开始就已经构造好了实例，并且返回了实例；</p>
<p><strong>带返回值的init:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class oldStyleClass:</span><br><span class="line">    def __new__(cls):</span><br><span class="line">        print(&quot;__new__ is called&quot;) # this line will never get called during construction</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(self)</span><br><span class="line">        print(&quot;init is called&quot;)</span><br><span class="line">        return 12</span><br><span class="line"></span><br><span class="line">oldStyleClass()</span><br><span class="line"># &lt;__main__.oldStyleClass instance at 0x00000000053BD708&gt;</span><br><span class="line"># init is called</span><br><span class="line"># TypeError: __init__() should return None</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在旧类中无法控制，init的返回值。</p>
<h2 id="Python新类中两方法差异"><a href="#Python新类中两方法差异" class="headerlink" title="Python新类中两方法差异"></a>Python新类中两方法差异</h2><p>Python的新类允许用户重载<code>__new__</code>和<code>__init__</code>方法，且这两个方法具有不同的作用。<code>__new__</code>作为构造器，起创建一个类实例的作用。而<code>__init__</code>作为初始化器，起初始化一个已被创建的实例的作用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">newStyleClass</span>(<span class="params"><span class="built_in">object</span></span>):</span> </span><br><span class="line">    <span class="comment"># In Python2, we need to specify the object as the base.</span></span><br><span class="line">    <span class="comment"># In Python3 it&#x27;s default.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__new__ is called&quot;</span>)</span><br><span class="line">        print(cls)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(newStyleClass, cls).__new__(cls)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__init__ is called&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;self is: &quot;</span>, self)</span><br><span class="line"></span><br><span class="line">newStyleClass()</span><br><span class="line"><span class="comment"># __new__ is called</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;__main__.newStyleClass&#x27;&gt;</span></span><br><span class="line"><span class="comment"># __init__ is called</span></span><br><span class="line"><span class="comment"># (&#x27;self is: &#x27;, &lt;__main__.newStyleClass object at 0x0000000005440DD8&gt;)</span></span><br><span class="line"><span class="comment"># &lt;__main__.newStyleClass at 0x5440dd8&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建类实例并初始化的过程中<code>__new__</code>和<code>__init__</code>被调用的顺序也能从上面代码的输出结果中看出：<code>__new__</code>函数首先被调用，构造了一个<code>newStyleClass</code>的实例，接着<code>__init__</code>函数在<code>__new__</code>函数返回一个实例的时候被调用，并且这个实例作为<code>self</code>参数被传入了<code>__init__</code>函数。</p>
<p>这里需要注意的是，如果<code>__new__</code>函数返回一个已经存在的实例（不论是哪个类的），<code>__init__</code>不会被调用。如下面代码所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = <span class="number">12</span> </span><br><span class="line"><span class="comment"># obj can be an object from any class, even object.__new__(object)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">returnExistedObj</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__new__ is called&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__init__ is called&quot;</span>)</span><br><span class="line"></span><br><span class="line">returnExistedObj()</span><br><span class="line"><span class="comment"># __new__ is called</span></span><br><span class="line"><span class="comment"># 12</span></span><br></pre></td></tr></table></figure>
<p>同时另一个需要注意的点是：</p>
<p>如果我们在<code>__new__</code>函数中不返回任何对象，则<code>__init__</code>函数也不会被调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">notReturnObj</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__new__ is called&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__init__ is called&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(notReturnObj())</span><br><span class="line"><span class="comment"># __new__ is called</span></span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure>
<p>可见如果<code>__new__</code>函数不返回对象的话，不会有任何对象被创建，<code>__init__</code>函数也不会被调用来初始化对象。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><code>__init__</code>不能有返回值</li>
<li><code>__new__</code>函数直接上可以返回别的类的实例。如上面例子中的<code>returnExistedObj</code>类的<code>__new__</code>函数返回了一个<code>int</code>值。</li>
<li>只有在<code>__new__</code>返回一个新创建属于该类的实例时当前类的<code>__init__</code>才会被调用。</li>
</ol>
<blockquote>
<p><a href="https://blog.csdn.net/Yaokai_AssultMaster/article/details/73500184">参考博客</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_内存管理</title>
    <url>/2021/01/17/Python-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>参考地址：<a href="https://www.cnblogs.com/geaozhang/p/7111961.html">博客一</a> ， <a href="https://andrewpqc.github.io/2018/10/08/python-memory-management/">博客二</a> ，<a href="https://cloud.tencent.com/developer/article/1670455">博客三</a></p>
<p>Python内存管理是理解Python运行机制的重要一环，故整理下相关内容如下：</p>
<a id="more"></a>

<h2 id="前置知识：Python变量与对象"><a href="#前置知识：Python变量与对象" class="headerlink" title="前置知识：Python变量与对象"></a>前置知识：Python变量与对象</h2><p>我们在编程过程中，不可避免的使用变量指代对象，其关系为变量通过指针指向了对象；对象有自己的类型，而变量的类型则跟随者对象的类型而变化。关系如图：</p>
<p><img src="https://i.loli.net/2021/01/17/YENw3MevIFUBcOL.png"></p>
<p><strong>变量：</strong>通过变量指针引用对象。而变量指针指向具体对象的<strong>内存空间</strong>；变量类型是<strong>动态</strong>的，与对象类型一致</p>
<p><strong>对象：</strong>类型是<strong>已知</strong>的，每个对象都包含有头部信息，其中为<strong>类型标识</strong>符与<strong>引用计数</strong>器</p>
<h3 id="多变量指向同一对象情况"><a href="#多变量指向同一对象情况" class="headerlink" title="多变量指向同一对象情况"></a>多变量指向同一对象情况</h3><p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var_1 = <span class="number">123</span></span><br><span class="line">var_2 = var_1</span><br><span class="line">print(<span class="built_in">id</span>(var_1)) <span class="comment"># 140711337393728</span></span><br><span class="line">print(<span class="built_in">id</span>(var_2)) <span class="comment"># 140711337393728</span></span><br><span class="line">print(<span class="built_in">id</span>(<span class="number">123</span>)) <span class="comment"># 140711337393728</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">type</span>(var_1)) <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>(var_2)) <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>(<span class="number">123</span>)) <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过对象被引用的方式(var_2 = var_1)，两个变量指向了同一地址，并且变量的类别与被引用对象的类别一致。简单示意图：</p>
<p><img src="https://i.loli.net/2021/01/17/vJfUoY75K3LjEOV.png"></p>
<h3 id="多变量引用所指的判断"><a href="#多变量引用所指的判断" class="headerlink" title="多变量引用所指的判断"></a>多变量引用所指的判断</h3><p>在Python中判断多个变量的引用地址是否一致采用了内置函数is。先看一段代码再去讲。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 小于等于256的整数</span></span><br><span class="line">intA = <span class="number">256</span></span><br><span class="line">intB = <span class="number">256</span></span><br><span class="line">print(<span class="built_in">id</span>(intA)) <span class="comment"># 140711337397984</span></span><br><span class="line">print(<span class="built_in">id</span>(intB)) <span class="comment"># 140711337397984</span></span><br><span class="line">intA <span class="keyword">is</span> intB <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 大于256的整数</span></span><br><span class="line">intA = <span class="number">257</span> <span class="comment"># 3037955041360</span></span><br><span class="line">intB = <span class="number">257</span> <span class="comment"># 3037955041424</span></span><br><span class="line">print(<span class="built_in">id</span>(intA))</span><br><span class="line">print(<span class="built_in">id</span>(intB))</span><br><span class="line">intA <span class="keyword">is</span> intB <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 短字符串</span></span><br><span class="line">charA = <span class="string">&quot;aaaaaaaaaaa&quot;</span></span><br><span class="line">charB = <span class="string">&quot;aaaaaaaaaaa&quot;</span></span><br><span class="line">charA <span class="keyword">is</span> charB <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 长字符串</span></span><br><span class="line">charA = <span class="string">&quot;very Good&quot;</span></span><br><span class="line">charB = <span class="string">&quot;very Good&quot;</span></span><br><span class="line">charA <span class="keyword">is</span> charB <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器——列表</span></span><br><span class="line">listA = []</span><br><span class="line">listB = []</span><br><span class="line">listA <span class="keyword">is</span> listB <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<p>我们发现不同的数据类型或者同一数据类型不同“长度”时，多次创建时，其内存地址情况并不一致。这是由于Python会选择缓存常用的对象，使得多次赋值对象时，不需要创建新的对象，例如1~256的数字，短字符串等。基本上都是不可修改的数据类型。</p>
<ol>
<li>Python缓存了整数（1~256，短字符串），每个变量进行为赋值操作时，不需要创建新的对象，大家引用对象一致。</li>
<li>Python对于未缓存的对象，在进行赋值操作时，会直接生成新的对象，占用新的内存地址。</li>
</ol>
<h2 id="Python的垃圾回收机制"><a href="#Python的垃圾回收机制" class="headerlink" title="Python的垃圾回收机制"></a>Python的垃圾回收机制</h2><p>一句话描述就是：<strong>引用计数为主，标记清除与分代回收为辅</strong>；</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>Python中主要使用引用计数(Reference Counting)进行垃圾回收。每一个对象的核心就是一个结构体PyObject,其内部存在一个引用计数器(ob_refcnt)。当某对象的引用计数值为0时，其内存就可以被释放掉；</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"> typedef struct_object &#123;</span><br><span class="line">    <span class="built_in">int</span> ob_refcnt;</span><br><span class="line">    struct_typeobject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>
<h4 id="引起引用计数变化的情况"><a href="#引起引用计数变化的情况" class="headerlink" title="引起引用计数变化的情况"></a>引起引用计数变化的情况</h4><p><strong>引用计数增加的情况：</strong></p>
<ul>
<li>对象被创建,a = 2</li>
<li>对象被引用,b=a</li>
<li>对象作为参数传递到函数中,fun(a)</li>
<li>对象作为元素存储在容器中,numList.append(a)</li>
</ul>
<p><strong>引用计数减少的情况：</strong></p>
<ul>
<li>对象别名被显示销毁,del a</li>
<li>对象别名赋予了新的对象,b = 3</li>
<li>包含对象的函数运行结束,</li>
<li>对象所在的容器被摧毁或者从容其中删除了对象,numList.remove(a)</li>
</ul>
<h4 id="获取引用数量的方式"><a href="#获取引用数量的方式" class="headerlink" title="获取引用数量的方式"></a>获取引用数量的方式</h4><p>通过sys包中的getrefcount()获取一个名称所引用的对象当前的引用计数，这个函数本身也会造成其引用+1.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys.getrefcount(a)</span><br></pre></td></tr></table></figure>
<h4 id="引用计数的优缺点"><a href="#引用计数的优缺点" class="headerlink" title="引用计数的优缺点"></a>引用计数的优缺点</h4><p><strong>优点：</strong></p>
<ul>
<li>逻辑简单而高效，具备实时性；</li>
<li>垃圾回收随机分配到运行阶段，处理回收时间分散有利于系统稳定；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>空间浪费：每个对象都存在用来统计的引用的空间，加大了空间负担；</li>
<li>大对象释放缓慢：当需要释放大的对象时，比如字典，需要对引用的所有对象循环嵌套调用；</li>
<li>循环引用问题：引用计数的致命问题。</li>
</ul>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>标记清除(Mark and Sweep)算法，是为了解决对象可能产生的循环引用问题。(注意，只有<strong>容器</strong>对象才会产生循环引用的情况，比如列表、字典、用户自定义类的对象、元组等。而像数字，字符串这类简单类型不会出现循环引用。作为一种优化策略，对于只包含简单类型的元组也不在标记清除算法的考虑之列)。</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ol>
<li>标记阶段，遍历所有对象，如果对象可达（表明存在对象引用它），则标记对象可达；</li>
<li>清除阶段，再次遍历所有对象，对于不可达的对象，进行回收；</li>
</ol>
<p>如下图所示，在标记清除算法中，为了追踪容器对象，需要每个容器对象维护两个额外的指针，用来将容器对象组成一个双端链表，指针分别指向前后两个容器对象，方便插入和删除操作。python解释器(Cpython)维护了两个这样的双端链表，一个链表存放着需要被扫描的容器对象，另一个链表存放着临时不可达对象。在图中，这两个链表分别被命名为”Object to Scan”和”Unreachable”。图中例子是这么一个情况：link1,link2,link3组成了一个引用环，同时link1还被一个变量A(其实这里称为名称A更好)引用。link4自引用，也构成了一个引用环。从图中我们还可以看到，每一个节点除了有一个记录当前引用计数的变量<code>ref_count</code>还有一个<code>gc_ref</code>变量，这个<code>gc_ref</code>是<code>ref_count</code>的一个副本，所以初始值为<code>ref_count</code>的大小。<br><a href="https://andrewpqc.github.io/images/marksweep1.png"><img src="https://andrewpqc.github.io/images/marksweep1.png" alt="img"></a></p>
<p>gc启动的时候，会逐个遍历”Object to Scan”链表中的容器对象，并且将当前对象所引用的所有对象的<code>gc_ref</code>减一。(扫描到link1的时候，由于link1引用了link2,所以会将link2的<code>gc_ref</code>减一，接着扫描link2,由于link2引用了link3,所以会将link3的<code>gc_ref</code>减一…..)像这样将”Objects to Scan”链表中的所有对象考察一遍之后，两个链表中的对象的<code>ref_count</code>和<code>gc_ref</code>的情况如下图所示。这一步操作就相当于解除了循环引用对引用计数的影响。<br><a href="https://andrewpqc.github.io/images/marksweep2.png"><img src="https://andrewpqc.github.io/images/marksweep2.png" alt="img"></a></p>
<p>接着，gc会再次扫描所有的容器对象，如果对象的<code>gc_ref</code>值为0，那么这个对象就被标记为<code>GC_TENTATIVELY_UNREACHABLE</code>，并且被移至”Unreachable”链表中。下图中的link3和link4就是这样一种情况。<br><a href="https://andrewpqc.github.io/images/marksweep3.png"><img src="https://andrewpqc.github.io/images/marksweep3.png" alt="img"></a></p>
<p>如果对象的<code>gc_ref</code>不为0，那么这个对象就会被标记为<code>GC_REACHABLE</code>。同时当gc发现有一个节点是可达的，那么他会递归式的将从该节点出发可以到达的所有节点标记为<code>GC_REACHABLE</code>,这就是下图中link2和link3所碰到的情形。<br><a href="https://andrewpqc.github.io/images/marksweep4.png"><img src="https://andrewpqc.github.io/images/marksweep4.png" alt="img"></a></p>
<p>除了将所有可达节点标记为<code>GC_REACHABLE</code>之外，如果该节点当前在”Unreachable”链表中的话，还需要将其移回到”Object to Scan”链表中，下图就是link3移回之后的情形。<br><a href="https://andrewpqc.github.io/images/marksweep5.png"><img src="https://andrewpqc.github.io/images/marksweep5.png" alt="img"></a><br>第二次遍历的所有对象都遍历完成之后，存在于”Unreachable”链表中的对象就是真正需要被释放的对象。如上图所示，此时link4存在于Unreachable链表中，gc随即释放之。</p>
<p><strong>上面描述的垃圾回收的阶段，会暂停整个应用程序，等待标记清除结束后才会恢复应用程序的运行。</strong></p>
<h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><p>Python通过“分代回收”（Generational Collection）以<strong>空间换时间</strong>的方法提高<strong>垃圾回收效率</strong>。</p>
<h4 id="分代回收的依据"><a href="#分代回收的依据" class="headerlink" title="分代回收的依据"></a>分代回收的依据</h4><p><strong>对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。</strong></p>
<p>python gc给对象定义了三种世代(0,1,2),每一个新生对象在generation zero中，如果它在一轮gc扫描中活了下来，那么它将被移至generation one,在那里他将较少的被扫描，如果它又活过了一轮gc,它又将被移至generation two，在那里它被扫描的次数将会更少。</p>
<p>gc的扫描在什么时候会被触发呢?答案是<strong>当某一世代中被分配的对象与被释放的对象之差达到某一阈值的时候，就会触发gc对某一世代的扫描。</strong>值得注意的是<strong>当某一世代的扫描被触发的时候，比该世代年轻的世代也会被扫描。</strong>也就是说如果世代2的gc扫描被触发了，那么世代0,世代1也将被扫描，如果世代1的gc扫描被触发，世代0也会被扫描。</p>
<p>该阈值可以通过下面两个函数查看和调整:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gc.get_threshold() <span class="comment"># (threshold0, threshold1, threshold2).</span></span><br><span class="line">gc.set_threshold(threshold0[, threshold1[, threshold2]])</span><br></pre></td></tr></table></figure>
<p>下面对set_threshold()中的三个参数threshold0, threshold1, threshold2进行介绍。gc会记录自从上次收集以来新分配的对象数量与释放的对象数量，当两者之差超过threshold0的值时，gc的扫描就会启动，初始的时候只有世代0被检查。如果自从世代1最近一次被检查以来，世代0被检查超过threshold1次，那么对世代1的检查将被触发。相同的，如果自从世代2最近一次被检查以来，世代1被检查超过threshold2次，那么对世代2的检查将被触发。get_threshold()是获取三者的值，默认值为(700,10,10).</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>总体来说，在Python中，主要通过引用计数进行垃圾回收；通过 “标记-清除” 解决容器对象可能产生的循环引用问题；通过 “分代回收” 以空间换时间的方法提高垃圾回收效率。</strong></p>
<h2 id="内存池机制"><a href="#内存池机制" class="headerlink" title="内存池机制"></a>内存池机制</h2><p>Python中对于大内存（&gt; 256 字节）与小内存（1 ~ 256字节）的分配机制是不同的。</p>
<h4 id="为什么引入内存池"><a href="#为什么引入内存池" class="headerlink" title="为什么引入内存池"></a>为什么引入内存池</h4><p>解决多次调用malloc导致大量内存碎片的问题。</p>
<p>内存池就是预先申请一定数量的，大小相同的内存块，当出现新的内存需求，可以选择从内存池分配内存；</p>
<h4 id="大内存的分配机制：malloc"><a href="#大内存的分配机制：malloc" class="headerlink" title="大内存的分配机制：malloc"></a>大内存的分配机制：malloc</h4><p>大内存—–若请求分配的内存大于256K，malloc函数分配内存，free函数释放内存。</p>
<h4 id="小内存的分配机制：内存池"><a href="#小内存的分配机制：内存池" class="headerlink" title="小内存的分配机制：内存池"></a>小内存的分配机制：内存池</h4><p>内存池，有Python的接口函数PyMem_Malloc实现—–若请求分配的内存在1~256字节之间就使用内存池管理系统进行分配，调用malloc函数分配内存，但是每次只会分配一块大小为256K的大块内存，不会调用free函数释放内存，将该内存块留在内存池中以便下次使用。</p>
<h4 id="Python解释器的解释"><a href="#Python解释器的解释" class="headerlink" title="Python解释器的解释"></a>Python解释器的解释</h4><p><img src="https://i.loli.net/2021/01/17/qEk3TmCjSU1vAB8.png"></p>
<ul>
<li>python的对象管理主要位于Level+1~Level+3层</li>
<li>Level+3层：对于python内置的对象（比如int,dict等）都有独立的私有内存池，对象之间的内存池不共享，即int释放的内存，不会被分配给float使用</li>
<li>Level+2层：当申请的内存大小小于256KB时，内存分配主要由 Python 对象分配器（Python’s object allocator）实施</li>
<li>Level+1层：当申请的内存大小大于256KB时，由Python原生的内存分配器进行分配，本质上是调用C标准库中的malloc/realloc等函数.</li>
</ul>
<blockquote>
<p>关于释放内存方面，当一个对象的引用计数变为0时，Python就会调用它的析构函数。调用析构函数并不意味着最终一定会调用free来释放内存空间，如果真是这样的话，那频繁地申请、释放内存空间会使Python的执行效率大打折扣。因此在析构时也采用了内存池机制，从内存池申请到的内存会被归还到内存池中，以避免频繁地申请和释放动作.</p>
</blockquote>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_值传递与引用传递</title>
    <url>/2021/01/17/Python-%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<blockquote>
<p>参考地址：<a href="http://c.biancheng.net/view/4471.html">博客教程</a> <a href="http://c.biancheng.net/view/2258.html">博客详细教程</a> <a href="https://github.com/taizilongxu/interview_python#1-python%E7%9A%84%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">gitHub地址</a></p>
</blockquote>
<a id="more"></a>

<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h3><p> 在函数定义中常见的函数都会选择<strong>有参数</strong>的函数形式，函数的作用是传递数据给函数，并对此数据进行具体的操作；</p>
<p>在使用函数时，经常会用到形式参数（形参）与实际参数（实参），二者都称为参数，其差别在于：</p>
<ul>
<li>形式参数：在<strong>定义函数</strong>时，函数名后面的参数就是形参，例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义函数时采用就是形参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span>(<span class="params">formalParameters</span>):</span></span><br><span class="line">    print(formalParameters)</span><br></pre></td></tr></table></figure>
<ul>
<li>实际参数：在<strong>调用函数</strong>时，函数的调用者给函数的参数，例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用函数时就是实际参数</span></span><br><span class="line">actualParameters = <span class="string">&quot;形式参数还是实际参数这是个问题&quot;</span></span><br><span class="line">demo(actualParameters)</span><br><span class="line"><span class="comment"># 形式参数还是实际参数这是个问题</span></span><br></pre></td></tr></table></figure>
<p>那么将<strong>实际参数传递给形式参数</strong>的过程，就可以分为值传递与引用传递啦；</p>
<h3 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h3><ul>
<li>相同点：都是将实参传递给形参的过程</li>
<li>不同点:<ul>
<li>值传递：适用于<strong>不可变</strong>的参数 ，例如 字符串，元组，数字等 ， 传递的是一个<strong>副本</strong>；</li>
<li>引用传递：适用于<strong>可变</strong>的参数，例如 列表，字典等，传递的是指向可变参数对象的<strong>指针</strong>。</li>
</ul>
</li>
<li>结论：如何判定当前是值传递还是引用传递呢？<ul>
<li>就是看当前传递的参数本身是否可变，不可变就是值传递，可变就是引用传递。<ul>
<li>这里的可变就是能够进行修改，immutable. </li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>其实值传递与引用传递是一回事，看接下来的描述即可；</p>
</blockquote>
<h2 id="值传递与引用传递详解"><a href="#值传递与引用传递详解" class="headerlink" title="值传递与引用传递详解"></a>值传递与引用传递详解</h2><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>我们先从一个例子出发看一看值传递与引用传递的对实际编程的影响；示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span>(<span class="params">obj</span>) :</span></span><br><span class="line">    obj += obj</span><br><span class="line">    print(<span class="string">&quot;形参值为：&quot;</span>,obj)</span><br><span class="line">print(<span class="string">&quot;-------值传递-----&quot;</span>)</span><br><span class="line">a = <span class="string">&quot;C语言中文网&quot;</span></span><br><span class="line">print(<span class="string">&quot;a的值为：&quot;</span>,a)</span><br><span class="line">demo(a)</span><br><span class="line">print(<span class="string">&quot;实参值为：&quot;</span>,a)</span><br><span class="line">print(<span class="string">&quot;-----引用传递-----&quot;</span>)</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">print(<span class="string">&quot;a的值为：&quot;</span>,a)</span><br><span class="line">demo(a)</span><br><span class="line">print(<span class="string">&quot;实参值为：&quot;</span>,a)</span><br></pre></td></tr></table></figure>
<p>结果展示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-------值传递-----</span><br><span class="line">a的值为： 吃了嘛？</span><br><span class="line">形参值为： 吃了嘛？吃了嘛？</span><br><span class="line">实参值为： 吃了嘛？</span><br><span class="line">-----引用传递-----</span><br><span class="line">a的值为： [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">形参值为： [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">实参值为： [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>结论：</p>
<ul>
<li><p>在应用值传递时：<strong>函数内部对数据进行操作，并不影响函数外部的变量的值</strong>；</p>
</li>
<li><p>在应用引用传递时：<strong>函数内部对数据操作，影响了函数外部变量的值</strong>。</p>
<blockquote>
<p>分析运行结果不难看出，在执行值传递时，改变形式参数的值，实际参数并不会发生改变；而在进行引用传递时，改变形式参数的值，实际参数也会发生同样的改变。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>至于为什么会产生如此的差异也很简单，值传递传递的是值的<strong>副本</strong>，引用传递传递的是指向对象的<strong>指针</strong>（<strong>的副本</strong>）。</p>
<p>值传递与引用传递的应用，我个人在使用时，其实一直没有很关注相关的差异，平时总是在不经意的使用，比如操作列表经常不需要返回即可，这就是引用传递的好处；在日常DEBUG中，如果对值传递与引用传递有一个清晰的认识，我想也会顺畅很多；</p>
<h3 id="Python值传递机制"><a href="#Python值传递机制" class="headerlink" title="Python值传递机制"></a>Python值传递机制</h3><p>上面我们已经知道值传递传递的是参数的副本，对其进行操作是不会影响原参数的。接下来也是从一个简单的例子出发，简单的探讨下内存机制的情况，有利于更清晰的认识。</p>
<p>一个值传递的例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span>(<span class="params">a , b</span>) :</span></span><br><span class="line">    <span class="comment"># 下面代码实现a、b变量的值交换</span></span><br><span class="line">    a, b = b, a</span><br><span class="line">    print(<span class="string">&quot;swap函数里，变量a的值是&quot;</span>, \</span><br><span class="line">        a, <span class="string">&quot;；变量b的值是&quot;</span>, b)</span><br><span class="line">a = <span class="number">6</span></span><br><span class="line">b = <span class="number">9</span></span><br><span class="line">swap(a , b)</span><br><span class="line">print(<span class="string">&quot;交换结束后，变量a的值是&quot;</span>, \</span><br><span class="line">    a , <span class="string">&quot;；变量b的值是&quot;</span>, b)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">swap函数里，变量a的值是 <span class="number">9</span> ；变量b的值是 <span class="number">6</span></span><br><span class="line">交换结束后，变量a的值是 <span class="number">6</span> ；变量b的值是 <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>从上面的输出我们可以看出，外部的a,b变量，并不是函数内部的a,b变量；正如上面提到的，swap()函数内部的变量仅仅是主程序变量a,b的复制品罢了；下面通过示意图的方式，展示其栈分配情况：</p>
<ul>
<li><p>首先程序中，定义了a,b两个局部变量，两个变量在内存中存储示意图如下所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190213/2-1Z2131J304295.gif"></p>
</li>
<li><p>然后执行swap()函数时，系统进入swap()函数，并将主程序中的a,b变量作为参数值传递给swap()函数，传入的是副本，并非其本身。进入swap()函数后系统已产生了4个变量，这四个变量在内存的存储示意图如下所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190213/2-1Z2131J33SX.gif"></p>
<ul>
<li>可以看到，目前分别为主程序与swap()生成了两个栈区，每个栈区均分别存在a,b变量。</li>
</ul>
</li>
<li><p>执行swap()函数的内部交换操作，<strong>仅仅</strong>是swap()栈区的变量产生了变化；</p>
</li>
</ul>
<p><img src="http://c.biancheng.net/uploads/allimg/190213/2-1Z2131J4355M.gif"></p>
<blockquote>
<p>对比图 3 与图 1，可以看到两个示意图中主程序栈区中 a、b 的值并未有任何改变，程序改变的只是 swap() 函数栈区中 a、b 的值。这就是值传递的实质：当系统开始执行函数时，系统对形参执行初始化，就是把实参变量的值赋给函数的形参变量，在函数中操作的并不是实际的实参变量</p>
</blockquote>
<h3 id="Python中的引用传递"><a href="#Python中的引用传递" class="headerlink" title="Python中的引用传递"></a>Python中的引用传递</h3><p>引用传递传递的是指向对象的<strong>指针</strong>（<strong>的副本</strong>），其实质其实与值传递一致，区别仅仅是是否改变了主程序中数据情况，而这并不是传递的锅；还是一个相似的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span>(<span class="params">dw</span>):</span></span><br><span class="line">    <span class="comment"># 下面代码实现dw的a、b两个元素的值交换</span></span><br><span class="line">    dw[<span class="string">&#x27;a&#x27;</span>], dw[<span class="string">&#x27;b&#x27;</span>] = dw[<span class="string">&#x27;b&#x27;</span>], dw[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">    print(<span class="string">&quot;swap函数里，a元素的值是&quot;</span>,\</span><br><span class="line">        dw[<span class="string">&#x27;a&#x27;</span>], <span class="string">&quot;；b元素的值是&quot;</span>, dw[<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">dw = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">9</span>&#125;</span><br><span class="line">swap(dw)</span><br><span class="line">print(<span class="string">&quot;交换结束后，a元素的值是&quot;</span>,\</span><br><span class="line">    dw[<span class="string">&#x27;a&#x27;</span>], <span class="string">&quot;；b元素的值是&quot;</span>, dw[<span class="string">&#x27;b&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">swap函数里，a元素的值是 <span class="number">9</span> ；b元素的值是 <span class="number">6</span></span><br><span class="line">交换结束后，a元素的值是 <span class="number">9</span> ；b元素的值是 <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>从上面的结果来看，不仅仅swap函数内部字典元素交换成功，主程序中字典元素也进行了交换。这就造成了一个错觉，再调用swap()函数时，传入的就是dw字典本身，而不是其复制品，但这是错误的，可通过下面图示进行说明：</p>
<blockquote>
<p>我就存在这样的错觉；</p>
</blockquote>
<ul>
<li><p>首先主程序创建了一个字典对象，并通过dw变量指向了字典对象，此时内存中包括：对象本身，指向对象的引用变量，如图：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190213/2-1Z2131J551L5.gif"></p>
</li>
<li><p>其次开始调用swap()函数，在调用时，dw变量作为参数传递给swap()函数，这里与值传递是一模一样的：将主程序中的dw变量的值赋给了swap()函数的dw形参，从而完成了swap()函数的dw参数的初始化。</p>
<ul>
<li>主程序中的dw是一个引用变量，保存了指向字典对象的地址值，当把dw值赋给swap()函数的dw参数后，函数swap()的dw参数也保存了地址值，也会应用到同一字典对象。如图：</li>
</ul>
<p><img src="http://c.biancheng.net/uploads/allimg/190213/2-1Z2131J63I52.gif"></p>
<ul>
<li>从这里可以看到这就是不折不扣的值传递，系统仍然复制了一份dw副本传入swap()函数。但是由于dw只是一个引用变量，因此系统复制的是dw变量，并没有复制对象本身。</li>
</ul>
</li>
<li><p>由于dw只是一个引用变量，故实际操作还是字典对象，也就看到了主程序中的dw引用的对象也发生了变化；</p>
</li>
<li><p>为了更好的证明主程序中的dw和swap()函数中的dw是两个变量，在swap()最后一行添加如下代码：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#把dw 直接赋值为None，让它不再指向任何对象</span></span><br><span class="line">dw = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>其内存如下：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190213/2-1Z2131JK5157.gif"></p>
<blockquote>
<p>从图 6 来看，把 swap() 函数中的 dw 赋值为 None 后，在 swap() 函数中失去了对字典对象的引用，不可再访问该字典对象。但主程序中的 dw 变量不受任何影响，依然可以引用该字典对象，所以依然可以输出字典对象的 a、b 元素的值。</p>
</blockquote>
<p><strong>结论：</strong></p>
<p>如果需要让函数修改某些数据，则可以通过把这些数据包装成列表、字典等可变对象，然后把列表、字典等可变对象作为参数传入函数，在函数中通过列表、字典的方法修改它们，这样才能改变这些数据。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_协程</title>
    <url>/2021/01/17/Python-%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<p>协程本身的定义，与进程、线程其实差不多，都是用于<strong>控制过程的工具</strong>:</p>
<a id="more"></a>

<blockquote>
<p>[流畅的Python 16章](流畅的Python 16章)</p>
</blockquote>
<h2 id="协程的概念与简单示例"><a href="#协程的概念与简单示例" class="headerlink" title="协程的概念与简单示例"></a>协程的概念与简单示例</h2><p>协程本身的定义，与进程、线程其实差不多，都是用于<strong>控制过程的工具</strong>。协程的协字，我们可以理解为<strong>协作</strong>，协程通过与调用方协作，产出相应的结果。</p>
<p>协程能自然的表述多种算法，例如仿真、游戏、异步I/O等事件驱动型编程形式或协作多任务。</p>
<p><strong>协程：关键字 yield</strong> </p>
<p>上面的关键字，与生成器里面的yield，是一模一样的。其实协程就是一种生成器，只是在协程的概念里面，还存在自己独有的特性。两者还是存在一点点差异。下面给出两个例子：</p>
<p><strong>“生成器”的例子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_123</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">print(<span class="built_in">type</span>(gen_123))</span><br><span class="line"><span class="comment"># &lt;class &#x27;function&#x27;&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>(gen_123()))</span><br><span class="line"><span class="comment"># &lt;class &#x27;generator&#x27;&gt;</span></span><br><span class="line">g = gen_123()</span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<p><strong>协程的例子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用作协程的生成器样例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_coroutine</span>():</span></span><br><span class="line">    print(<span class="string">&quot;coroutine start&quot;</span>)</span><br><span class="line">    <span class="comment"># 注意注意：这里将yield 进行了赋值操作，就是将一个普通的生成器转换为了协程生成器</span></span><br><span class="line">    x = <span class="keyword">yield</span></span><br><span class="line">    print(<span class="string">&quot;coroutine received: &quot;</span> , x)</span><br><span class="line">    print(<span class="string">&quot;coroutine ended&quot;</span>)</span><br><span class="line"> </span><br><span class="line">my_coroutine = simple_coroutine()</span><br><span class="line">print(my_coroutine)</span><br><span class="line"><span class="comment"># &lt;generator object simple_coroutine at 0x042E3F30&gt;</span></span><br><span class="line"><span class="built_in">next</span>(my_coroutine)</span><br><span class="line"><span class="comment"># coroutine start</span></span><br><span class="line">my_coroutine.send(<span class="number">123</span>)</span><br><span class="line"><span class="comment"># coroutine ended</span></span><br><span class="line"><span class="comment"># python-BaseException</span></span><br><span class="line"> <span class="string">&quot;&quot;&quot;Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;D:\pycharm_install\PyCharm 2020.2.3\plugins\python\helpers\pydev\pydevd.py&quot;, line 1448, in _exec</span></span><br><span class="line"><span class="string">    pydev_imports.execfile(file, globals, locals)  # execute the script</span></span><br><span class="line"><span class="string"> &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>差异点：<ul>
<li>纯生成器：直接写明yield即可，不需要赋值</li>
<li>协程生成器：将yield通过赋值符号，赋值给内部的局部变量。这里实现了外部调用者动态键入值的功能。</li>
</ul>
</li>
</ul>
<h3 id="协程的状态"><a href="#协程的状态" class="headerlink" title="协程的状态"></a>协程的状态</h3><p>就像进程那样存在多种状态，协程也是包含有多种状态的，分别是：</p>
<p><strong>GEN_CREATED</strong>:等待开始执行</p>
<p><strong>GEN_RUNNING</strong>:解释器正在执行</p>
<p><strong>GEN_SUSPENDED</strong>:在yield表达式处暂停</p>
<p><strong>GEN_CLOSED</strong>: 执行结束</p>
<p>上面给出的例子中通过 send 方法将数据传递给协程内部变量，而<strong>send方法参数只能成为暂停的yield表达式的值</strong>，故当且仅当协程处于<strong>GEN_SUSPENDED</strong> 状态时，才能够调用send方法。这就需要对协程进行激活，也就是next方法。这也就是为什么上面的例子。</p>
<h3 id="协程语句的执行顺序"><a href="#协程语句的执行顺序" class="headerlink" title="协程语句的执行顺序"></a>协程语句的执行顺序</h3><ul>
<li>创建协程</li>
<li>激活协程</li>
<li>协程交互</li>
</ul>
<p>核心在于，yield 在协程中更能够发挥其功能，其功能可以分为两种：产出与接收。分别对应函数next , send.</p>
<p>比如一句话 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="keyword">yield</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>上面这句话，包含有两层含义：</p>
<ol>
<li>产出 5 .</li>
<li>接收一个值并赋值给x .</li>
</ol>
<p>其执行顺序为：先产出再接收。下面一个例子能够更好的解释：</p>
<p><strong>示例：产出两个值的协程</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_coro2</span>(<span class="params">a</span>):</span></span><br><span class="line">    print(<span class="string">&quot;Started: a = &quot;</span> , a)</span><br><span class="line">    b = <span class="keyword">yield</span> a</span><br><span class="line">    print(<span class="string">&quot;Received: b = &quot;</span> , b)</span><br><span class="line">    c = <span class="keyword">yield</span> a + b</span><br><span class="line">    print(<span class="string">&quot;Received: c = &quot;</span> , c)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>from test import simple_coro2</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>my_coro2 = simple_coro2(14)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>next(my_coro2)</span></span><br><span class="line"><span class="string">Started: a =  14</span></span><br><span class="line"><span class="string">14</span></span><br><span class="line"><span class="string"> 可以看到上面的一个next语句，将协程一直运行到第一个yield 产出值后的位置</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>my_coro2.send(28)</span></span><br><span class="line"><span class="string">Received: b =  28</span></span><br><span class="line"><span class="string">42</span></span><br><span class="line"><span class="string"> 可以看到一个send语句完成了对b的赋值与下一个yield语句产出值两个功能。</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>my_coro2.send(99)</span></span><br><span class="line"><span class="string">Received: c =  99</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="string">StopIteration</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>图示如下：</p>
<p><img src="https://i.loli.net/2021/01/17/5MQnL9GuHIE1T43.png" alt="image-20201110110022552"></p>
<h4 id="协程-实现平均数功能"><a href="#协程-实现平均数功能" class="headerlink" title="协程 实现平均数功能"></a>协程 实现平均数功能</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BEGIN CORO_AVERAGER</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span>():</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">      <span class="comment"># 下面的这一句话有两个含义：1.产出yield 2.接收一个值并赋给term</span></span><br><span class="line">        term = <span class="keyword">yield</span> average  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line"><span class="comment"># END CORO_AVERAGER</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">A coroutine to compute a running average</span></span><br><span class="line"><span class="string"># BEGIN CORO_AVERAGER_TEST</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; coro_avg = averager()  # &lt;1&gt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; next(coro_avg)  # &lt;2&gt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; coro_avg.send(10)  # &lt;3&gt;</span></span><br><span class="line"><span class="string">    10.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; coro_avg.send(30)</span></span><br><span class="line"><span class="string">    20.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; coro_avg.send(5)</span></span><br><span class="line"><span class="string">    15.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># END CORO_AVERAGER_TEST</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到代码与测试的数据，每次我们向协程发送一个值，其会传递出一个平均值，那么他的具体执行顺序是怎样的呢？</p>
<p><img src="C:\Users\QingZhi\AppData\Roaming\Typora\typora-user-images\image-20201110140817893.png" alt="image-20201110140817893"></p>
<ol>
<li>激活协程,next()，并将运行到产出第一个值的位置（此时处于GEN_SUSPENDED 状态 ）</li>
<li>协程交互,send(),首先将调用方数据进行赋值操作，其次一直运行到下一次yield产出值后(又处于GEN_SUSPENDED 状态)；</li>
</ol>
<h2 id="预激协程的装饰器"><a href="#预激协程的装饰器" class="headerlink" title="预激协程的装饰器"></a>预激协程的装饰器</h2><p>上面的例子均需要通过next()方法激活协程，但这一步是很容易遗忘的。而装饰器是一种能够对函数进行包装的设计模式，却不会影响你的使用过程。</p>
<blockquote>
<p>有关装饰器的使用与设计，在其他笔记中已有详细论述，这里直接贴代码。</p>
</blockquote>
<p><strong>装饰器定义：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Decorator: primes `func` by advancing to first `yield`&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">primer</span>(<span class="params">*args,**kwargs</span>):</span>  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">        gen = func(*args,**kwargs)  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">        <span class="built_in">next</span>(gen)  <span class="comment"># &lt;3&gt;</span></span><br><span class="line">        <span class="keyword">return</span> gen  <span class="comment"># &lt;4&gt;</span></span><br><span class="line">    <span class="keyword">return</span> primer</span><br></pre></td></tr></table></figure>
<p><strong>协程定义：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> coroutil <span class="keyword">import</span> coroutine  <span class="comment"># &lt;4&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine  </span><span class="comment"># &lt;5&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span>():</span>  <span class="comment"># &lt;6&gt;</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span> average</span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br></pre></td></tr></table></figure>
<p><strong>代码运行情况展示</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from coroaverager1 import averager</span><br><span class="line">&gt;&gt;&gt; ave = averager()</span><br><span class="line">&gt;&gt;&gt; ave.send(10)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line">&gt;&gt;&gt; ave.send(20)</span><br><span class="line"><span class="number">15.0</span></span><br><span class="line">&gt;&gt;&gt; ave.send(30)</span><br><span class="line"><span class="number">20.0</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>通过装饰器的作用，已经不需要显示的激活操作。</p>
<h2 id="终止协程与异常处理"><a href="#终止协程与异常处理" class="headerlink" title="终止协程与异常处理"></a>终止协程与异常处理</h2><h3 id="协程的终止"><a href="#协程的终止" class="headerlink" title="协程的终止"></a>协程的终止</h3><p>协程应该如何终止，这是一只没有考虑过的问题。下面的例子提供了协程终止实例：</p>
<h4 id="协程终止的样例"><a href="#协程终止的样例" class="headerlink" title="协程终止的样例"></a>协程终止的样例</h4><p><strong>1. 协程迭代结束：抛出 StopIteration 异常</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_coro2</span>(<span class="params">a</span>):</span></span><br><span class="line">    print(<span class="string">&quot;Started: a = &quot;</span> , a)</span><br><span class="line">    b = <span class="keyword">yield</span> a</span><br><span class="line">    print(<span class="string">&quot;Received: b = &quot;</span> , b)</span><br><span class="line">    c = <span class="keyword">yield</span> a + b</span><br><span class="line">    print(<span class="string">&quot;Received: c = &quot;</span> , c)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>from test import simple_coro2</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>my_coro2 = simple_coro2(14)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>next(my_coro2)</span></span><br><span class="line"><span class="string">Started: a =  14</span></span><br><span class="line"><span class="string">14</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>my_coro2.send(28)</span></span><br><span class="line"><span class="string">Received: b =  28</span></span><br><span class="line"><span class="string">42</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>my_coro2.send(99)</span></span><br><span class="line"><span class="string">Received: c =  99</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="string">StopIteration</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 出现协程无法处理的异常</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_coro2</span>(<span class="params">a</span>):</span></span><br><span class="line">    print(<span class="string">&quot;Started: a = &quot;</span> , a)</span><br><span class="line">    b = <span class="keyword">yield</span> a</span><br><span class="line">    print(<span class="string">&quot;Received: b = &quot;</span> , b)</span><br><span class="line">    c = <span class="keyword">yield</span> a + b</span><br><span class="line">    print(<span class="string">&quot;Received: c = &quot;</span> , c)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>from test import simple_coro2</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>coro = simple_coro2(14)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>next(coro)</span></span><br><span class="line"><span class="string">Started: a =  14</span></span><br><span class="line"><span class="string">14</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>coro.send(&quot;abc&quot;)</span></span><br><span class="line"><span class="string">Received: b =  abc</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="string">  File &quot;F:\git_localRepository\fluentPython\example-code\16-coroutine\test.py&quot;, line 5, in simple_coro2</span></span><br><span class="line"><span class="string">    c = yield a + b</span></span><br><span class="line"><span class="string">TypeError: unsupported operand type(s) for +: &#x27;int&#x27; and &#x27;str&#x27;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面的两个例子说明了协程终止的方式：<strong>异常</strong>。受此启发，Python提供了两种显示终止的协程的方法：throw()与close().</p>
<h4 id="协程终止的专用方法：throw-与-close"><a href="#协程终止的专用方法：throw-与-close" class="headerlink" title="协程终止的专用方法：throw 与 close"></a>协程终止的专用方法：throw 与 close</h4><p><strong>generator.throw( )</strong>: 使生成器在暂停的yield表达式处抛出指定异常。</p>
<ul>
<li>如果此异常被生成器处理了，那么生成器会运行到下一个yield 表达式处，产生的值称为调用generator.throw方法得到的返回值。</li>
<li>未被生成器处理，异常向外抛出，传到调用方。</li>
</ul>
<p><strong>generator.close( )</strong>:致使生成器在暂停的yield处抛出<strong>GeneratorExit异常</strong></p>
<ul>
<li>如果生成器<strong>没有处理此异常</strong>，或者抛出了<strong>StopIteration 异常</strong>，调用方不会报错，正常退出协程。</li>
<li>如果处理了此异常，（在接收到GeneratorExit异常后），仍旧产出值，那么会报RuntimeError异常。</li>
</ul>
<p>下面会展示相关例子用于理解：</p>
<p><strong>定义一个处理指定异常的协程：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoException</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;An exception type for the demonstration.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo_exc_handling</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;-&gt; coroutine started&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            x = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">except</span> DemoException:  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">            print(<span class="string">&#x27;*** DemoException handled. Continuing...&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">            print(<span class="string">&#x27;-&gt; coroutine received: &#123;!r&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;This line should never run.&#x27;</span>)  <span class="comment"># &lt;3&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>close 方法示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Coroutine closing demonstration::</span></span><br><span class="line"><span class="string">调用close方法后，协程就是关闭状态</span></span><br><span class="line"><span class="string"># BEGIN DEMO_CORO_EXC_1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; exc_coro = demo_exc_handling()</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; next(exc_coro)</span></span><br><span class="line"><span class="string">    -&gt; coroutine started</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; exc_coro.send(11)</span></span><br><span class="line"><span class="string">    -&gt; coroutine received: 11</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; exc_coro.send(22)</span></span><br><span class="line"><span class="string">    -&gt; coroutine received: 22</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; exc_coro.close()</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; from inspect import getgeneratorstate</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; getgeneratorstate(exc_coro)</span></span><br><span class="line"><span class="string">    &#x27;GEN_CLOSED&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># END DEMO_CORO_EXC_1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>throw 方法示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Coroutine handling exception::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># BEGIN DEMO_CORO_EXC_2</span></span><br><span class="line"><span class="string"># 抛出的指定异常，能够被处理，那么协程状态还是暂停状态</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; exc_coro = demo_exc_handling()</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; next(exc_coro)</span></span><br><span class="line"><span class="string">    -&gt; coroutine started</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; exc_coro.send(11)</span></span><br><span class="line"><span class="string">    -&gt; coroutine received: 11</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; exc_coro.throw(DemoException)</span></span><br><span class="line"><span class="string">    *** DemoException handled. Continuing...</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; getgeneratorstate(exc_coro)</span></span><br><span class="line"><span class="string">    &#x27;GEN_SUSPENDED&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># END DEMO_CORO_EXC_2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Coroutine not handling exception::</span></span><br><span class="line"><span class="string"># 抛出的指定异常，不能够被处理，那么协程状态就是关闭状态</span></span><br><span class="line"><span class="string"># BEGIN DEMO_CORO_EXC_3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; exc_coro = demo_exc_handling()</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; next(exc_coro)</span></span><br><span class="line"><span class="string">    -&gt; coroutine started</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; exc_coro.send(11)</span></span><br><span class="line"><span class="string">    -&gt; coroutine received: 11</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; exc_coro.throw(ZeroDivisionError)</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">    ZeroDivisionError</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; getgeneratorstate(exc_coro)</span></span><br><span class="line"><span class="string">    &#x27;GEN_CLOSED&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># END DEMO_CORO_EXC_3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="协程返回值的处理方式"><a href="#协程返回值的处理方式" class="headerlink" title="协程返回值的处理方式"></a>协程返回值的处理方式</h2><p>我们上面的协程都是采用的<strong>产出</strong>的方式，这都是协程在运行过程中的产出，我们能否采用return的方式获得一个最终的结果。例如上面提到的平均值。下面会做一些尝试，并提出一个目前可行的解决方案。</p>
<p><strong>有返回值的协程代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Result = namedtuple(<span class="string">&#x27;Result&#x27;</span>, <span class="string">&#x27;count average&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span>():</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span>  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line">    <span class="keyword">return</span> Result(count, average)  <span class="comment"># &lt;2&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>运行代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> coroaverager2 <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ave = averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(ave)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ave.send(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ave.send(<span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ave.send(<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ave.send(<span class="literal">None</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration: Result(count=<span class="number">3</span>, average=<span class="number">20.0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们发现确实返回了，但是其返回值在StopIteration 异常的一个属性里面。</p>
<p><strong>捕获异常中的值的做法：</strong></p>
<p>根据上面的例子进行一定的改变：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ave = averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(ave)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ave.send(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ave.send(<span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ave.send(<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    ave.send(<span class="literal">None</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> StopIteration <span class="keyword">as</span> exc:</span><br><span class="line"><span class="meta">... </span>    result = exc.value</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result</span><br><span class="line">Result(count=<span class="number">3</span>, average=<span class="number">20.0</span>)</span><br></pre></td></tr></table></figure>
<p>上面的例子捕获的此异常，并获得了异常中的值。</p>
<h2 id="Yield-From"><a href="#Yield-From" class="headerlink" title="Yield From"></a>Yield From</h2><p>yield from 是一种全新的句法结构，作用比yield多。</p>
<p><strong>作用：</strong>在生成器gen中使用 yield from subgen()时 ， subgen() 获得控制权，把产出的值传递给调用gen的调用方，即调用方可以直接控制subgen 。</p>
<blockquote>
<p>上面描述的很抽象，在我理解看来 有三方，两层关系：调用方与gen ， gen与 subgen 。gen就是采用了yield from语法的函数。</p>
</blockquote>
<p>书本中有这么一句话：<strong>yield from 的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来。</strong>这两者可以直接发送和产出值，还可以直接传入异常，不需要在位于中间的协程中添加大量处理异常的样板代码。</p>
<h3 id="Yield-From-用于简化for循环中的yield-表达式"><a href="#Yield-From-用于简化for循环中的yield-表达式" class="headerlink" title="Yield From 用于简化for循环中的yield 表达式"></a>Yield From 用于简化for循环中的yield 表达式</h3><p> 产出目标值的几种方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&quot;ABC&quot;</span>:</span><br><span class="line">        <span class="keyword">yield</span> c</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen2</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> <span class="string">&quot;ABC&quot;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">list</span>(gen()))</span><br><span class="line">print(<span class="built_in">list</span>(gen2()))</span><br><span class="line"><span class="comment"># [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3]</span></span><br><span class="line"><span class="comment"># [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>yield from x 表达式，会首先调用 iter(x) ，并对内部的</li>
</ul>
<h3 id="Yield-From-用做通道"><a href="#Yield-From-用做通道" class="headerlink" title="Yield From 用做通道"></a>Yield From 用做通道</h3><p>这里是Yield From 的主要用处，也是上面提到的话，这种方式的好处在于：能够解决在第4部分的异常值获取问题。</p>
<p><strong>名词解释：</strong></p>
<ul>
<li><strong>委派生成器:</strong> 包含有 yield from <iterable> 表达式的生成器函数</li>
<li><strong>子生成器：</strong>从yield from 表达式中<iterable>部分中获取的生成器</li>
<li><strong>调用方：</strong> 调用 <strong>委派生成器</strong> 部分的代码</li>
</ul>
<p><strong>yield from 结构的用法图示：</strong></p>
<p><img src="C:\Users\QingZhi\AppData\Roaming\Typora\typora-user-images\image-20201110190218832.png" alt="image-20201110190218832"></p>
<p><strong>应用示例：使用 yield from 计算平均值并输出统计报告</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BEGIN YIELD_FROM_AVERAGER</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Result = namedtuple(<span class="string">&#x27;Result&#x27;</span>, <span class="string">&#x27;count average&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># the subgenerator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span>():</span>  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span>  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># &lt;3&gt;</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line">    <span class="keyword">return</span> Result(count, average)  <span class="comment"># &lt;4&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># the delegating generator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span>(<span class="params">results, key</span>):</span>  <span class="comment"># &lt;5&gt;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># &lt;6&gt;</span></span><br><span class="line">        results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager()  <span class="comment"># &lt;7&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># the client code, a.k.a. the caller</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">data</span>):</span>  <span class="comment"># &lt;8&gt;</span></span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> data.items():</span><br><span class="line">        group = grouper(results, key)  <span class="comment"># &lt;9&gt;</span></span><br><span class="line">        <span class="built_in">next</span>(group)  <span class="comment"># &lt;10&gt;</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">            group.send(value)  <span class="comment"># &lt;11&gt;</span></span><br><span class="line">        group.send(<span class="literal">None</span>)  <span class="comment"># important! &lt;12&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(results)  # uncomment to debug</span></span><br><span class="line">    report(results)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># output report</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">report</span>(<span class="params">results</span>):</span></span><br><span class="line">    <span class="keyword">for</span> key, result <span class="keyword">in</span> <span class="built_in">sorted</span>(results.items()):</span><br><span class="line">        group, unit = key.split(<span class="string">&#x27;;&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;&#123;:2&#125; &#123;:5&#125; averaging &#123;:.2f&#125;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">              result.count, group, result.average, unit))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;girls;kg&#x27;</span>:</span><br><span class="line">        [<span class="number">40.9</span>, <span class="number">38.5</span>, <span class="number">44.3</span>, <span class="number">42.2</span>, <span class="number">45.2</span>, <span class="number">41.7</span>, <span class="number">44.5</span>, <span class="number">38.0</span>, <span class="number">40.6</span>, <span class="number">44.5</span>],</span><br><span class="line">    <span class="string">&#x27;girls;m&#x27;</span>:</span><br><span class="line">        [<span class="number">1.6</span>, <span class="number">1.51</span>, <span class="number">1.4</span>, <span class="number">1.3</span>, <span class="number">1.41</span>, <span class="number">1.39</span>, <span class="number">1.33</span>, <span class="number">1.46</span>, <span class="number">1.45</span>, <span class="number">1.43</span>],</span><br><span class="line">    <span class="string">&#x27;boys;kg&#x27;</span>:</span><br><span class="line">        [<span class="number">39.0</span>, <span class="number">40.8</span>, <span class="number">43.2</span>, <span class="number">40.8</span>, <span class="number">43.1</span>, <span class="number">38.6</span>, <span class="number">41.4</span>, <span class="number">40.6</span>, <span class="number">36.3</span>],</span><br><span class="line">    <span class="string">&#x27;boys;m&#x27;</span>:</span><br><span class="line">        [<span class="number">1.38</span>, <span class="number">1.5</span>, <span class="number">1.32</span>, <span class="number">1.25</span>, <span class="number">1.37</span>, <span class="number">1.48</span>, <span class="number">1.25</span>, <span class="number">1.49</span>, <span class="number">1.46</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># END YIELD_FROM_AVERAGER</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码中包含有 子生成器，委派生成器，调用方 三部分定义代码 ，运行结果如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> 9 boys  averaging 40.42kg</span><br><span class="line"> 9 boys  averaging 1.39m</span><br><span class="line">10 girls averaging 42.04kg</span><br><span class="line">10 girls averaging 1.43m</span><br></pre></td></tr></table></figure>
<p>理解上面的代码是很重要的，一开始我自己在看代码时不知道调用方在调用 send() 函数时，究竟是直接作用于内部的子生成器还是作用于外部的委派生成器。作用的位置不同，其逻辑理解也会产生较大的误差。原书中对其内部逻辑的解释很清晰，这里我就直接摘抄下来，看看结果。</p>
<ul>
<li>外层for循环每一迭代会新建一个grouper实例，赋值给group变量，此时group就是委派生成器。</li>
<li>调用 next(group) ，对委派生成器进行激活，从而进入 while True循环，调用了子生成器 average后，在 yield from 表达式处暂停。</li>
<li>内层for 循环调用group.send(value),直接把值传给子生成器 averager. 同时，当前的grouper 实例（group）在yield from表达式处暂停。</li>
<li>内层循环结束后，group 实例依旧在yield from 表达式处暂定，因此，grouper 函数定义体中的results[key]赋值语句还没有执行。</li>
<li>如果外层 for 循环尾部没有，group.send(None) , 那么averager 子生成器永远不会终止，委派生成器 group 永远不会被激活，因此永远不会为 results[key] 进行赋值。</li>
<li>外层 for 循环重新迭代式会创建一个新的 grouper 实例，然后绑定到 group 变量上。前一个grouper实例，被垃圾回收。</li>
</ul>
<p>委派生成器作用是一个管道，那么多几个管道也是可以的，此管道链条需要以一个只使用 yield 表达式的简单生成器结束或者以任何可迭代的对象结束。</p>
<h2 id="应用：仿真系统"><a href="#应用：仿真系统" class="headerlink" title="应用：仿真系统"></a>应用：仿真系统</h2><p>没有去了解相关的内容，如果需要再去看。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_切片原理</title>
    <url>/2021/01/17/Python-%E5%88%87%E7%89%87%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>切片是Python重要的特性之一.与切片密切相关的是索引.一般情况下索引的返回值是序列的元素,切片的返回值是序列:</p>
<a id="more"></a>

<p>如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = <span class="built_in">tuple</span>(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">print(t[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">print(t[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"><span class="comment"># (1, 2)</span></span><br></pre></td></tr></table></figure>
<p>而在序列调用[ ] 时,默认调用的是__getitem__方法.</p>
<p>为了能够构建符合Python风格的索引与切片操作,或者为了学习Python的切片原理,我们对其切片进行分析.</p>
<p><strong>定义一个索引返回类进行查看</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mySeq</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line">s = mySeq()</span><br><span class="line">print(s[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">print(s[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"><span class="comment"># slice(1, 4, None)</span></span><br><span class="line">print(s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>])</span><br><span class="line"><span class="comment"># slice(1, 4, 2)</span></span><br><span class="line">print(s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>,<span class="number">9</span>])</span><br><span class="line"><span class="comment"># (slice(1, 4, 2), 9)</span></span><br><span class="line">print(s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span> , -<span class="number">5</span> :])</span><br><span class="line"><span class="comment"># (slice(1, 4, 2), slice(-5, None, None))</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当仅仅进行索引操作时返回的是数字</li>
<li>当仅一个切片操作时返回的是slice对象</li>
<li>当不仅一个切片操作时返回的时slice元组</li>
</ul>
<p><strong>slice类情况分析</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">slice</span>)</span><br><span class="line">print(<span class="built_in">dir</span>(<span class="built_in">slice</span>))</span><br><span class="line"><span class="comment">#&lt;class &#x27;slice&#x27;&gt;</span></span><br><span class="line"><span class="comment">#[&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__le__&#x27;, &#x27;__lt__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;indices&#x27;, &#x27;start&#x27;, &#x27;step&#x27;, &#x27;stop&#x27;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 上面的slice对象包含有诸多属性,其中start,stop,step我们都很清楚了.indices属性很关键.我们可以看下其解释:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">help</span>(<span class="built_in">slice</span>.indices))</span><br><span class="line">indices(...)</span><br><span class="line">    S.indices(len) -&gt; (start, stop, stride)</span><br><span class="line">    </span><br><span class="line">    Assuming a sequence of length <span class="built_in">len</span>, calculate the start <span class="keyword">and</span> stop</span><br><span class="line">    indices, <span class="keyword">and</span> the stride length of the extended <span class="built_in">slice</span> described by</span><br><span class="line">    S. Out of bounds indices are clipped <span class="keyword">in</span> a manner consistent <span class="keyword">with</span> the</span><br><span class="line">    handling of normal slices.</span><br><span class="line"></span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>那么slice的作用就是把你输入的start,stop,step进行计算,获得正确的索引:例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">slice</span>(<span class="literal">None</span> , <span class="number">10</span> ,<span class="number">2</span>).indices(<span class="number">10</span>))</span><br><span class="line">print(<span class="built_in">slice</span>(-<span class="number">3</span>,<span class="literal">None</span> , <span class="literal">None</span>).indices(<span class="number">5</span>))</span><br><span class="line">(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>这里我们已经知道getitem中该如何操作啦:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">import</span> itertools  <span class="comment"># &lt;1&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    typecode = <span class="string">&#x27;d&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, components</span>):</span></span><br><span class="line">        self._components = array(self.typecode, components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        components = reprlib.<span class="built_in">repr</span>(self._components)</span><br><span class="line">        components = components[components.find(<span class="string">&#x27;[&#x27;</span>):-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Vector(&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(components)</span><br><span class="line"></span><br><span class="line"><span class="comment"># BEGIN VECTOR_V2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        cls = <span class="built_in">type</span>(self)  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(index, <span class="built_in">slice</span>):  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">            <span class="keyword">return</span> cls(self._components[index])  <span class="comment"># &lt;3&gt;</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(index, numbers.Integral):  <span class="comment"># &lt;4&gt;</span></span><br><span class="line">            <span class="keyword">return</span> self._components[index]  <span class="comment"># &lt;5&gt;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg = <span class="string">&#x27;&#123;cls.__name__&#125; indices must be integers&#x27;</span></span><br><span class="line">            <span class="keyword">raise</span> TypeError(msg.<span class="built_in">format</span>(cls=cls))  <span class="comment"># &lt;6&gt;</span></span><br><span class="line">vec = Vector(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">print(vec[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"><span class="comment"># Vector([1.0, 2.0])</span></span><br></pre></td></tr></table></figure>
<p><strong>总结:</strong></p>
<p>Python中在切片或者索引的时候都会走__getitem__方法,对于切片来说会自动将输入范围定义为slice对象,通过解析此slice对象,可以获得正确的索引.</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_上下文管理器</title>
    <url>/2021/01/17/Python-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<p><strong>上下文处理器</strong>是用来管理<strong>with语句</strong>.与之对标的概念就是迭代器用来管理for语句.</p>
<a id="more"></a>

<p><strong>Q:</strong> 上面提到了with语句的作用是什么?</p>
<p><strong>A:</strong> with语句的目的是<strong>简化try/finally</strong>模式,这种模式用于保证一段代码执行完毕后执行某操作,即使这段代码由于异常,return或者sys.exit()调用而终止.</p>
<h2 id="上下文管理器的构成"><a href="#上下文管理器的构成" class="headerlink" title="上下文管理器的构成"></a>上下文管理器的构成</h2><p>上下文管理器协议包含有两个方法:__enter__方法,__exit__方法.</p>
<ul>
<li><p>with语句<strong>开始运行</strong>时,会在上下文管理器对象上调用__enter__方法.</p>
</li>
<li><p>with语句<strong>运行结束</strong>后,会在上下文管理器对象上调用__exit__方法,扮演finally子句的作用.</p>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;mirror.py&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    src = fp.read(<span class="number">60</span>)</span><br><span class="line">print(<span class="built_in">len</span>(src))</span><br><span class="line"><span class="comment"># 60</span></span><br><span class="line">print(fp)</span><br><span class="line"><span class="comment"># &lt;_io.TextIOWrapper name=&#x27;mirror.py&#x27; mode=&#x27;r&#x27; encoding=&#x27;cp936&#x27;&gt;</span></span><br><span class="line">print(fp.closed , fp.encoding)</span><br><span class="line"><span class="comment"># True cp936</span></span><br><span class="line">fp.read(<span class="number">60</span>)</span><br><span class="line"><span class="comment"># ValueError: I/O operation on closed file.</span></span><br></pre></td></tr></table></figure>
<p>**注意:**在第一行语句中分为两部分:</p>
<ul>
<li>执行with后面的表达式得到的结果时<strong>上下文管理器对象</strong>.</li>
<li>执行as语句,是此对象执行__enter__方法返回的结果.<ul>
<li>open()方法本身提供的__enter__方法返回的是本身,所以可以看到fp变量指向的依旧是io.TextIPWrapper</li>
</ul>
</li>
</ul>
<p>不管控制流程以何种方式退出,都会在<strong>上下文管理器</strong>对象上调用__exit__方法,而不是__enter__返回的方法.</p>
<h2 id="深入理解上下文管理器的执行过程"><a href="#深入理解上下文管理器的执行过程" class="headerlink" title="深入理解上下文管理器的执行过程"></a>深入理解上下文管理器的执行过程</h2><p>像生成器的学习方式一样,我们既可以使用with语句隐式的调用上下文管理器的相关方法,也可以直接调用上下文管理器的相关方法以达到相同的目的.</p>
<h3 id="定义一个上下文管理器"><a href="#定义一个上下文管理器" class="headerlink" title="定义一个上下文管理器"></a>定义一个上下文管理器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LookingGlass</span>:</span></span><br><span class="line">		<span class="comment"># __enter__的输入参数,只有self本身</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span>  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        self.original_write = sys.stdout.write  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">        sys.stdout.write = self.reverse_write  <span class="comment"># &lt;3&gt;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;JABBERWOCKY&#x27;</span>  <span class="comment"># &lt;4&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span>(<span class="params">self, text</span>):</span>  <span class="comment"># &lt;5&gt;</span></span><br><span class="line">        self.original_write(text[::-<span class="number">1</span>])</span><br><span class="line">		<span class="comment"># __exit__的输入参数,包括其他</span></span><br><span class="line">    <span class="comment"># exc_type 异常类 , exc_value异常实例 , traceback traceback对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>):</span>  <span class="comment"># &lt;6&gt;</span></span><br><span class="line">        <span class="keyword">import</span> sys  <span class="comment"># &lt;7&gt;</span></span><br><span class="line">        sys.stdout.write = self.original_write  <span class="comment"># &lt;8&gt;</span></span><br><span class="line">        <span class="keyword">if</span> exc_type <span class="keyword">is</span> ZeroDivisionError:  <span class="comment"># &lt;9&gt;</span></span><br><span class="line">            print(<span class="string">&#x27;Please DO NOT divide by zero!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># &lt;10&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过定义__enter__与__exit__方法定义了一个上下文管理器,并且再次方法中利用<strong>monkey  patch</strong> 对sys中的输出方法进行的反转输出的操作.</p>
<h3 id="with语句使用上述的上下文管理器"><a href="#with语句使用上述的上下文管理器" class="headerlink" title="with语句使用上述的上下文管理器"></a>with语句使用上述的上下文管理器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mirror <span class="keyword">import</span> LookingGlass</span><br><span class="line"><span class="comment"># __enter__返回结果绑定到了what变量上面</span></span><br><span class="line"><span class="keyword">with</span> LookingGlass() <span class="keyword">as</span> what:</span><br><span class="line">    print(<span class="string">&quot;SUN QING ZHI&quot;</span>)</span><br><span class="line">    print(what)</span><br><span class="line">print(what)</span><br><span class="line">print(<span class="string">&quot;Back to Normal&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># IHZ GNIQ NUS</span></span><br><span class="line"><span class="comment"># YKCOWREBBAJ</span></span><br><span class="line"><span class="comment"># JABBERWOCKY</span></span><br><span class="line"><span class="comment"># Back to Normal</span></span><br></pre></td></tr></table></figure>
<p>可以看到上面的输出,在位于with语句内部时,print函数调用了上下文管理器中给定的逆输出函数,而跳出之后通过__exit__方法还原的原来的输出函数.</p>
<h3 id="直接调用上下文管理器进行相同操作"><a href="#直接调用上下文管理器进行相同操作" class="headerlink" title="直接调用上下文管理器进行相同操作"></a>直接调用上下文管理器进行相同操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mirror <span class="keyword">import</span> LookingGlass</span><br><span class="line">manager = LookingGlass()</span><br><span class="line">what = manager.__enter__()</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;SUN QING ZHI&quot;</span>)</span><br><span class="line">print(what)</span><br><span class="line">manager.__exit__(<span class="literal">None</span> , <span class="literal">None</span> ,<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">print(what)</span><br><span class="line">print(<span class="string">&quot;Back to Normal&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># IHZ GNIQ NUS</span></span><br><span class="line"><span class="comment"># YKCOWREBBAJ</span></span><br><span class="line"><span class="comment"># JABBERWOCKY</span></span><br><span class="line"><span class="comment"># Back to Normal</span></span><br></pre></td></tr></table></figure>
<p>手动调用了__enter__,__exit__ 两个方法,实现了相同的功能,这也就是with语句内部的逻辑.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 其他操作</span></span><br><span class="line"><span class="keyword">from</span> mirror <span class="keyword">import</span> LookingGlass</span><br><span class="line"><span class="keyword">with</span> LookingGlass():</span><br><span class="line">    print(<span class="string">&quot;SUN QING ZHI&quot;</span>)</span><br><span class="line">    <span class="comment"># IHZ GNIQ NUS</span></span><br><span class="line">    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">    <span class="comment"># Please DO NOT divide by zero!</span></span><br><span class="line">print(<span class="string">&quot;SUN QING ZHI&quot;</span>)</span><br><span class="line"><span class="comment"># SUN QING ZHI</span></span><br><span class="line"><span class="comment"># 正常输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> LookingGlass():</span><br><span class="line">    print(<span class="string">&quot;SUN QING ZHI&quot;</span>)</span><br><span class="line">    <span class="comment"># IHZ GNIQ NUS</span></span><br><span class="line">    A = NO_SUCH_NAME</span><br><span class="line">    <span class="comment"># NameError: name &#x27;NO_SUCH_NAME&#x27; is not defined</span></span><br><span class="line">print(<span class="string">&quot;SUN QING ZHI&quot;</span>)</span><br><span class="line"><span class="comment"># 没输出,上面错误上下文管理器并没有正确捕捉</span></span><br></pre></td></tr></table></figure>
<p>上面两个例子就是为了更好地理解上下文管理器的执行过程.</p>
<h2 id="contextlib-模块中的提供的上下文管理器工具"><a href="#contextlib-模块中的提供的上下文管理器工具" class="headerlink" title="contextlib 模块中的提供的上下文管理器工具"></a>contextlib 模块中的提供的上下文管理器工具</h2><p>应用到上下文管理器的场景其实很多,每次都通过手写管理器难免产生遗漏,为此官方提供了一系列的管理器,应用于不同场景.这里不一一的介绍里面的</p>
<p><strong>@contextmanager</strong>: 上下文管理器装饰器,可以应用于生成器函数,将其装饰为一个上下文管理器.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">A &quot;mirroring&quot; ``stdout`` context manager.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">While active, the context manager reverses text output to</span></span><br><span class="line"><span class="string">``stdout``::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># BEGIN MIRROR_GEN_DEMO_1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; from mirror_gen import looking_glass</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; with looking_glass() as what:  # &lt;1&gt;</span></span><br><span class="line"><span class="string">    ...      print(&#x27;Alice, Kitty and Snowdrop&#x27;)</span></span><br><span class="line"><span class="string">    ...      print(what)</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">    pordwonS dna yttiK ,ecilA</span></span><br><span class="line"><span class="string">    YKCOWREBBAJ</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; what</span></span><br><span class="line"><span class="string">    &#x27;JABBERWOCKY&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># END MIRROR_GEN_DEMO_1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This exposes the context manager operation::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># BEGIN MIRROR_GEN_DEMO_2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; from mirror_gen import looking_glass</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; manager = looking_glass()  # &lt;1&gt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; manager  # doctest: +ELLIPSIS</span></span><br><span class="line"><span class="string">    &lt;contextlib._GeneratorContextManager object at 0x...&gt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; monster = manager.__enter__()  # &lt;2&gt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; monster == &#x27;JABBERWOCKY&#x27;  # &lt;3&gt;</span></span><br><span class="line"><span class="string">    eurT</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; monster</span></span><br><span class="line"><span class="string">    &#x27;YKCOWREBBAJ&#x27;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; manager  # doctest: +ELLIPSIS</span></span><br><span class="line"><span class="string">    &gt;...x0 ta tcejbo reganaMtxetnoCrotareneG_.biltxetnoc&lt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; manager.__exit__(None, None, None)  # &lt;4&gt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; monster</span></span><br><span class="line"><span class="string">    &#x27;JABBERWOCKY&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># END MIRROR_GEN_DEMO_2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># BEGIN MIRROR_GEN_EX</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager  </span><span class="comment"># &lt;1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">looking_glass</span>():</span></span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    original_write = sys.stdout.write  <span class="comment"># &lt;2&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span>(<span class="params">text</span>):</span>  <span class="comment"># &lt;3&gt;</span></span><br><span class="line">        original_write(text[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    sys.stdout.write = reverse_write  <span class="comment"># &lt;4&gt;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;JABBERWOCKY&#x27;</span>  <span class="comment"># &lt;5&gt;</span></span><br><span class="line">    sys.stdout.write = original_write  <span class="comment"># &lt;6&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># END MIRROR_GEN_EX</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我这里就不一一总结了,了解就行.</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_变量理解</title>
    <url>/2021/01/17/Python-%E5%8F%98%E9%87%8F%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>精准变量理解</p>
<a id="more"></a>

<h2 id="变量是不是盒子？"><a href="#变量是不是盒子？" class="headerlink" title="变量是不是盒子？"></a>变量是不是盒子？</h2><p>很多人将变量理解为盒子，其内部包裹着对象，然而这是不准确的。请看下面代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = a      </span><br><span class="line">a.append(<span class="number">4</span>)</span><br><span class="line">print(b)   </span><br><span class="line"><span class="comment"># [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>代码中，a,b 是指向同一列表对象的变量，修改a指向的对象，b指向的对象也随之改变。如果按照盒子去理解，那么a,b应该是分割的，正确理解为<strong>变量就是便利贴</strong>。如图：</p>
<p><img src="https://i.loli.net/2021/01/11/TfNDFEU1AcvVYdb.png"></p>
<p><strong>赋值语句的执行顺序</strong><br>Python中的赋值语句，始终是先读右边，对象在右侧创建或者获取，然后才会绑定到左侧的变量上，就像为对象贴上了便利贴；</p>
<h2 id="标识、相等性与别名"><a href="#标识、相等性与别名" class="headerlink" title="标识、相等性与别名"></a>标识、相等性与别名</h2><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>别名就是<strong>引用对同一对象</strong>的变量名称；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span> ,<span class="number">2</span> ,<span class="number">3</span>]</span><br><span class="line">b = a </span><br><span class="line">c = [<span class="number">1</span> ,<span class="number">2</span> ,<span class="number">3</span>]</span><br><span class="line">print(<span class="built_in">id</span>(a))</span><br><span class="line">print(<span class="built_in">id</span>(b))</span><br><span class="line">print(<span class="built_in">id</span>(c))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">15021560</span></span><br><span class="line"><span class="string">15021560</span></span><br><span class="line"><span class="string">15022720</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>可以看到通过赋值操作，b与a指向同一对象，b就是a的别名；而c指向的对象虽然内部元素与a一致，但是指向不同的对象，所以c不是a的别名。</p>
<h3 id="相等性：is-与"><a href="#相等性：is-与" class="headerlink" title="相等性：is 与 =="></a>相等性：is 与 ==</h3><p>这里大家都比较清除，Python中提供了两种相等性判定操作符：其中is用来判断两变量的标识（地址）。而==用来判断两对象的内部结构是否一致。</p>
<p><strong>TIPS:</strong> ==是一个语法糖，其等价于a.__eq__(b);而基类object中equal方法也是比较的双方的标识，结果与is是一样，一般的子类一般会重写此方法。</p>
<h3 id="元组的相对不可变性"><a href="#元组的相对不可变性" class="headerlink" title="元组的相对不可变性"></a>元组的相对不可变性</h3><p>首先我们要明确元组与列表等是一样的，其存储的是对象的引用。如果元组中的元素是可变的，那么即使元组不变（仍然指向那个内存地址），其内部元素仍然可变。也就是说元组的不可变性指的是<strong>数据结构的物理内容不可变（保存的引用不可变），与引用的对象无关。</strong>感觉就像是把指针冻住了，而没有冻住指向的对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">10</span> ,<span class="number">20</span>])</span><br><span class="line">t2 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">10</span> ,<span class="number">20</span>])</span><br><span class="line">print(t1 == t2) <span class="comment"># True , 俩元组对象内部内容一致</span></span><br><span class="line">print(t1 <span class="keyword">is</span> t2) <span class="comment"># False,不是同一个对象</span></span><br><span class="line">print(<span class="built_in">id</span>(t1)) <span class="comment"># 查看t1对象改变前的内存地址</span></span><br><span class="line">t1[-<span class="number">1</span>].append(<span class="number">30</span>)</span><br><span class="line">print(<span class="built_in">id</span>(t1))  <span class="comment"># 查看t1对象改变后的内存地址，即使内部元素已经变化而地址没有变</span></span><br><span class="line">print(t1)	</span><br><span class="line">print(t1 == t2)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">46182928</span></span><br><span class="line"><span class="string">46182928</span></span><br><span class="line"><span class="string">(1, 2, [10, 20, 30])</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里主要总结了Python中该如何理解变量，结论就是理解为便利贴。指向同一对象的便利贴之间的关系为别名。顺便讨论了在Python中常用到的相等性判断方法，延展出元组的相对不可变性。</p>
<p>总的来说，这一部分内容相对简单，更多的是在实践中检验。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_当函数参数为引用时</title>
    <url>/2021/01/17/Python-%E5%BD%93%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%BA%E5%BC%95%E7%94%A8%E6%97%B6/</url>
    <content><![CDATA[<p>Python在函数传递中唯一支持<strong>共享传参</strong>。共享传参指函数的各个形参获得实参中各个引用的副本，也可以说形参就是实参的别名。</p>
<a id="more"></a>

<p>而上面的参数传递机制就导致了当传入的是可变对象时，可能导致外面对象也出现变化。这一部分已经在值传递与引用传递部分讨论过。本文针对的就是当你传递的就是可变类型时应当如何编写代码是比较好的习惯，</p>
<h2 id="不可以使用可变参数作为默认值"><a href="#不可以使用可变参数作为默认值" class="headerlink" title="不可以使用可变参数作为默认值"></a>不可以使用可变参数作为默认值</h2><p>在Python中允许参数存在默认值，然而应当避免使用<strong>可变参数作为默认值</strong>。例如以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus1 = HauntedBus([&#x27;Alice&#x27;, &#x27;Bill&#x27;])</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus1.passengers</span></span><br><span class="line"><span class="string">[&#x27;Alice&#x27;, &#x27;Bill&#x27;]</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus1.pick(&#x27;Charlie&#x27;)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus1.drop(&#x27;Alice&#x27;)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus1.passengers</span></span><br><span class="line"><span class="string">[&#x27;Bill&#x27;, &#x27;Charlie&#x27;]</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus2 = HauntedBus()</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus2.pick(&#x27;Carrie&#x27;)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers</span></span><br><span class="line"><span class="string">[&#x27;Carrie&#x27;]</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus3 = HauntedBus()</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus3.passengers</span></span><br><span class="line"><span class="string">[&#x27;Carrie&#x27;]</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus3.pick(&#x27;Dave&#x27;)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers</span></span><br><span class="line"><span class="string">[&#x27;Carrie&#x27;, &#x27;Dave&#x27;]</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers is bus3.passengers</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus1.passengers</span></span><br><span class="line"><span class="string">[&#x27;Bill&#x27;, &#x27;Charlie&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>dir(HauntedBus.__init__)  # doctest: +ELLIPSIS</span></span><br><span class="line"><span class="string">[&#x27;__annotations__&#x27;, &#x27;__call__&#x27;, ..., &#x27;__defaults__&#x27;, ...]</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>HauntedBus.__init__.__defaults__</span></span><br><span class="line"><span class="string">([&#x27;Carrie&#x27;, &#x27;Dave&#x27;],)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>HauntedBus.__init__.__defaults__[0] is bus2.passengers</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BEGIN HAUNTED_BUS_CLASS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HauntedBus</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;A bus model haunted by ghost passengers&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, passengers=[]</span>):</span>  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">        self.passengers = passengers  <span class="comment"># &lt;2&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.passengers.append(name)  <span class="comment"># &lt;3&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drop</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.passengers.remove(name)</span><br></pre></td></tr></table></figure>
<p>上面定义了一个Bus类，其初始化方法中采用了[ ](**可变参数**)作为乘客为空时的默认值，乍一看没有问题。而上面的代码展示中发现，bus2,bus3中初始化均为空，而bus3在初始化后，其内部的乘客与bus2一模一样。而且代码显示，两辆车的乘客地址一致。这就不符合想要的逻辑效果。</p>
<p>其<strong>根源在于</strong>默认值是在定义函数时（加载模块时）构建的，随后成为其函数对象的属性。因此，如果默认值为可变对象，并且修改了其值那么后续的函数会受到影响。</p>
<p><strong>解决思路：</strong>通常采用None作为接收可变值的参数的默认值。如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>basketball_team = [&#x27;Sue&#x27;, &#x27;Tina&#x27;, &#x27;Maya&#x27;, &#x27;Diana&#x27;, &#x27;Pat&#x27;]</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus = TwilightBus(basketball_team)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus.drop(&#x27;Tina&#x27;)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus.drop(&#x27;Pat&#x27;)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>basketball_team</span></span><br><span class="line"><span class="string">[&#x27;Sue&#x27;, &#x27;Maya&#x27;, &#x27;Diana&#x27;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BEGIN TWILIGHT_BUS_CLASS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwilightBus</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;A bus model that makes passengers vanish&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, passengers=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.passengers = []  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.passengers = passengers  <span class="comment">#&lt;2&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.passengers.append(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drop</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.passengers.remove(name)  <span class="comment"># &lt;3&gt;</span></span><br><span class="line"><span class="comment"># END TWILIGHT_BUS_CLASS</span></span><br></pre></td></tr></table></figure>
<h2 id="防御可变参数"><a href="#防御可变参数" class="headerlink" title="防御可变参数"></a>防御可变参数</h2><p>上面的代码解决了初始化不适用可变参数的问题，但是却发现，函数内部的使用干扰了外部的使用。原因很明确，也是相同引用的问题。可以改编成这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, passengers=<span class="literal">None</span></span>):</span></span><br><span class="line">       <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">           self.passengers = []  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           self.passengers = <span class="built_in">list</span>(passengers)  <span class="comment">#&lt;2&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_可迭代对象,迭代器,生成器</title>
    <url>/2021/01/17/Python-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<p>在流畅的Python一书中,讲述的有些混乱,这里我自己也只是整理下.</p>
<a id="more"></a>

<blockquote>
<p>来自于<a href="%E6%B5%81%E7%95%85%E7%9A%84Python">流畅的Python</a>.</p>
</blockquote>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>可迭代对象:实现了<strong>iter或者getitem</strong>方法的类实例,使用iter()内置方法可以获取可迭代对象.</li>
<li>迭代器:一种<strong>惰性</strong>获取数据的方式,也就是一次按需要获得一个数据的方式;</li>
<li>生成器: <strong>生成器就是迭代器</strong>,所有的生成器都实现了迭代器的”接口”.而生成器能够”凭空”<strong>生成</strong>元素.</li>
</ul>
<h2 id="背景知识-序列可以迭代的原因-iter函数"><a href="#背景知识-序列可以迭代的原因-iter函数" class="headerlink" title="背景知识:序列可以迭代的原因:iter函数"></a>背景知识:序列可以迭代的原因:iter函数</h2><p>解释器需要迭代对象x时,会自动调用iter(x)函数.</p>
<h3 id="内置的iter函数作用"><a href="#内置的iter函数作用" class="headerlink" title="内置的iter函数作用:"></a><strong>内置的iter函数作用:</strong></h3><ol>
<li><p>检查是否实现了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__iter__方法,如果实现了就调用它,获取一个迭代器.</span><br></pre></td></tr></table></figure></li>
<li><p>如果没有实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__iter__方法,但是实现了__getitem__方法,Python会创建一个迭代器,尝试按顺序(从索引0开始)获取元素.</span><br></pre></td></tr></table></figure></li>
<li><p>如果尝试失败则抛出TyprError异常,”object is not iterable”.</p>
</li>
</ol>
<h3 id="最简单的例子-实现-iter-函数"><a href="#最简单的例子-实现-iter-函数" class="headerlink" title="最简单的例子:实现 iter 函数"></a><strong>最简单的例子</strong>:实现 iter 函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最简单的可迭代类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line">print(<span class="built_in">issubclass</span>(Foo , abc.Iterable))</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">f = Foo()</span><br><span class="line">print(<span class="built_in">isinstance</span>(f , abc.Iterable))</span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>上面的例子我们发现当你实现了 iter ,系统已经默认你是Iter对象或者类.</p>
<p><strong>当你仅实现了 getitem ,则系统并不人为你是可迭代对象或者类</strong>,但是我们已经知道即使只实现 getitem 也会返回一个迭代器.可以看下面的例子.</p>
<h3 id="实现-getitem-函数的实例"><a href="#实现-getitem-函数的实例" class="headerlink" title="实现 getitem 函数的实例"></a>实现 getitem 函数的实例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, text</span>):</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RE_WORD.findall(text)  <span class="comment"># &lt;1&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.words[index]  <span class="comment"># &lt;2&gt;</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">issubclass</span>(Sentence , abc.Iterable))</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">f = Sentence(<span class="string">&quot;as das d&quot;</span>)</span><br><span class="line">print(<span class="built_in">isinstance</span>(f , abc.Iterable))</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> f:</span><br><span class="line">    print(c)</span><br><span class="line"><span class="comment"># as das d</span></span><br></pre></td></tr></table></figure>
<p>可以看到上面的例子只实现了 getitem ,系统并没有认为其为可迭代对象,<strong>然而却能够进行迭代操作.</strong></p>
<p><strong>该如何检查对象可迭代?</strong></p>
<p>从上面的原理与例子看,不能够通过isinstance或者issubclass等内置方法判定是否为可迭代对象,直接通过iter(x)即可.</p>
<h2 id="可迭代对象与迭代器对比"><a href="#可迭代对象与迭代器对比" class="headerlink" title="可迭代对象与迭代器对比"></a>可迭代对象与迭代器对比</h2><h3 id="定义细节"><a href="#定义细节" class="headerlink" title="定义细节"></a>定义细节</h3><p><strong>两者关系</strong>:Python可以通过可迭代对象获得迭代器</p>
<p><strong>迭代器:</strong> 迭代器是这样一个对象,其实现了两个方法,</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__next__():返回序列中下一个元素,如果没有则为StopIteration异常</span><br><span class="line">__iter__():迭代器本身也可以迭代</span><br></pre></td></tr></table></figure>
<p>可迭代对象并不是迭代器.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可迭代对象有一个__iter__方法,其作用是每次均实例化一个新的迭代器.</span><br><span class="line">而迭代器需要实现上面说的两个方法.</span><br><span class="line">故迭代器可以迭代,但是可迭代对象并不是迭代器.</span><br></pre></td></tr></table></figure>
<h3 id="迭代器的使用方式"><a href="#迭代器的使用方式" class="headerlink" title="迭代器的使用方式"></a>迭代器的使用方式</h3><p><strong>最常见的for 调用迭代器:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">	print(c)</span><br><span class="line"><span class="comment"># a b c</span></span><br></pre></td></tr></table></figure>
<p>上面的for循环其实就是使用了迭代器实现的上面的操作.其等价于:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&quot;abc&quot;</span></span><br><span class="line">it = <span class="built_in">iter</span>(S)</span><br><span class="line">print(<span class="built_in">next</span>(it))</span><br><span class="line">print(<span class="built_in">next</span>(it))</span><br><span class="line">print(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="comment"># a b c</span></span><br><span class="line"><span class="comment"># 上面的迭代器是无法还原的</span></span><br></pre></td></tr></table></figure>
<h3 id="两种可迭代对象的定义方式比较"><a href="#两种可迭代对象的定义方式比较" class="headerlink" title="两种可迭代对象的定义方式比较"></a>两种可迭代对象的定义方式比较</h3><p>我们上面知道了迭代器就是实现了next与iter两个方法的类,那么我们是单独构建迭代器对象还是在可迭代对象内部同时实现相关的方法呢?可以看下面的例子:</p>
<p><strong>可迭代对象同时实现迭代器在内部:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, text</span>):</span></span><br><span class="line">        self.text = text</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Sentence(%s)&#x27;</span> % reprlib.<span class="built_in">repr</span>(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        match = <span class="built_in">next</span>(self.word_iter)  <span class="comment"># &lt;4&gt;</span></span><br><span class="line">        <span class="keyword">return</span> match.group()  <span class="comment"># &lt;5&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure>


<p><strong>单独定义迭代器类</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, text</span>):</span></span><br><span class="line">        self.text = text</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Sentence(%s)&#x27;</span> % reprlib.<span class="built_in">repr</span>(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        word_iter = RE_WORD.finditer(self.text)  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">        <span class="keyword">return</span> SentenceIter(word_iter)  <span class="comment"># &lt;2&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SentenceIter</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, word_iter</span>):</span></span><br><span class="line">        self.word_iter = word_iter  <span class="comment"># &lt;3&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        match = <span class="built_in">next</span>(self.word_iter)  <span class="comment"># &lt;4&gt;</span></span><br><span class="line">        <span class="keyword">return</span> match.group()  <span class="comment"># &lt;5&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>很明显单独构建一个迭代器类更加合理,理由之一:为了支持”多种遍历”,必须能从一个可迭代的实例中获取多个独立的迭代器,而且各个迭代器能维护自身的内部状态.</p>
<h2 id="生成器函数充当迭代器"><a href="#生成器函数充当迭代器" class="headerlink" title="生成器函数充当迭代器"></a>生成器函数充当迭代器</h2><p>上面提供的例子中单独定义了迭代器类,但是我们知道生成器也是迭代器,所以利用生成器也可以定义出可迭代对象.</p>
<h3 id="生成器函数-关键字-yield"><a href="#生成器函数-关键字-yield" class="headerlink" title="生成器函数:关键字 yield"></a>生成器函数:关键字 yield</h3><p><strong>包含有yield关键字,该函数就是生成器函数.</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_123</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">print(<span class="built_in">type</span>(gen_123))</span><br><span class="line"><span class="comment"># &lt;class &#x27;function&#x27;&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>(gen_123()))</span><br><span class="line"><span class="comment"># &lt;class &#x27;generator&#x27;&gt;</span></span><br><span class="line">g = gen_123()</span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<p>可以看到实例化后,为一个生成器,也就是迭代器.</p>
<h3 id="生成器函数充当迭代器的应用"><a href="#生成器函数充当迭代器的应用" class="headerlink" title="生成器函数充当迭代器的应用:"></a>生成器函数充当迭代器的应用:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, text</span>):</span></span><br><span class="line">        self.text = text  <span class="comment"># &lt;1&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Sentence(%s)&#x27;</span> % reprlib.<span class="built_in">repr</span>(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text):  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">            <span class="keyword">yield</span> match.group()  <span class="comment"># &lt;3&gt;</span></span><br><span class="line">S = Sentence(<span class="string">&quot;A D F G H&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">    print(c)</span><br><span class="line"><span class="comment"># A</span></span><br><span class="line"><span class="comment"># D</span></span><br><span class="line"><span class="comment"># F</span></span><br><span class="line"><span class="comment"># G</span></span><br><span class="line"><span class="comment"># H</span></span><br></pre></td></tr></table></figure>
<p>生成器函数会创建一个生成器对象.并将生成器传给next()函数时,生成器会向前,执行下一个Yield语句,返回产出的值.知道迭代完成.</p>
<h2 id="惰性实现迭代器"><a href="#惰性实现迭代器" class="headerlink" title="惰性实现迭代器"></a>惰性实现迭代器</h2><p>惰性实现就是不急于实现,生成器就是一种惰性实现.先对于一次性获得所有的元素,惰性实现会减少内存的消耗.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, text</span>):</span></span><br><span class="line">        self.text = text</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Sentence(%s)&#x27;</span> % reprlib.<span class="built_in">repr</span>(self.text)</span><br><span class="line"><span class="comment"># re.finditer()返回的是一个迭代器,能够节省大量的内存</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text):</span><br><span class="line">           <span class="keyword">yield</span> match.group()</span><br><span class="line">S = Sentence(<span class="string">&quot;A B C D E&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">    print(c)</span><br><span class="line"><span class="comment"># A B C D E</span></span><br></pre></td></tr></table></figure>
<p>其实这里在书中的意义更像是在过度.</p>
<h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>与列表表达式一样,这里可以使用生成式表达式,构造生成器.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(match.group() <span class="keyword">for</span> match <span class="keyword">in</span> re.finditer(self.text))</span><br></pre></td></tr></table></figure>
<p>这里没有详细的写,也记不住.哟</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在书中作者还编写了其他的部分,例如标准库中的生成器函数,完整的实例应用以及其他的小细节.我这里仅仅对关于生成器的理论部分进行了论述,理解可迭代对象,迭代器,生成器的关系,以及基本的使用即可.</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_字符串格式化</title>
    <url>/2021/01/17/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    <content><![CDATA[<p>题目中提到的%与format都是Python支持的字符串<strong>格式化</strong>方法，两个都好用，format函数是出现的比较晚，其功能相对全面，一般推荐使用format函数进行格式化；</p>
<a id="more"></a>

<blockquote>
<p><a href="https://www.runoob.com/python/att-string-format.html">菜鸟教程format</a>，<a href="https://www.runoob.com/python3/python3-string.html">菜鸟教程%</a></p>
</blockquote>
<h2 id="两方法差异"><a href="#两方法差异" class="headerlink" title="两方法差异"></a>两方法差异</h2><p>这里直接摘抄网友的结论：</p>
<blockquote>
<p>format的优点</p>
<p>1.不需要理会数据类型的问题，在%方法中%s只能替代字符串类型</p>
<p>2.单个参数可以多次输出，参数顺序可以不相同</p>
<p>3.填充方式十分灵活，对齐方式十分强大</p>
<p>4.官方推荐用的方式，%方式将会在后面的版本被淘汰</p>
</blockquote>
<h2 id="的使用方法"><a href="#的使用方法" class="headerlink" title="%的使用方法"></a>%的使用方法</h2><h2 id="format的使用方法"><a href="#format的使用方法" class="headerlink" title="format的使用方法"></a>format的使用方法</h2>]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_序列</title>
    <url>/2021/01/17/Python-%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>Python中存在大量的序列类型，每种序列类型都具备自己的特点与使用场景，了解其机制有利于构造更加高效的代码与自制序列类。</p>
<a id="more"></a>

<blockquote>
<p><a href="%E4%BC%98%E9%9B%85%E7%9A%84Python">优雅的Python第二章</a></p>
</blockquote>
<h2 id="内置序列概况"><a href="#内置序列概况" class="headerlink" title="内置序列概况"></a>内置序列概况</h2><p>按照能否存储同一数据类型数据分为：</p>
<ul>
<li><strong>容器</strong>序列：list,tuple,collections.deque,存储的为任意类型的<strong>引用</strong>，内存空间<strong>不连续</strong>。</li>
<li><strong>扁平</strong>序列：str,bytes,bytearray,memoryview,array.array，存储的是同一类型的<strong>值</strong>，内存空间<strong>连续</strong>。</li>
</ul>
<blockquote>
<p>上段时间我总结了关于Python中值传递与引用传递问题时，有提到相关概念的区别。</p>
</blockquote>
<p>按照序列类型能否修改：</p>
<ul>
<li>可变序列：list,bytearray.array.array,collection.deque,memoryview</li>
<li>不可变序列：tuple,str,bytes</li>
</ul>
<h2 id="list序列"><a href="#list序列" class="headerlink" title="list序列"></a>list序列</h2><p>列表类型是Python中常见的序列类型，其使用已烂熟于心，不妨关于列表的创建方法：</p>
<h3 id="列表推导与列表生成"><a href="#列表推导与列表生成" class="headerlink" title="列表推导与列表生成"></a>列表推导与列表生成</h3><h4 id="列表推导的简单使用"><a href="#列表推导的简单使用" class="headerlink" title="列表推导的简单使用"></a>列表推导的简单使用</h4><p>列表推导就是用于<strong>生成列表</strong>的，其是一种易于<strong>阅读</strong>的列表生成方式。</p>
<ul>
<li><p>传统的列表构造方式：for + append</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将一个字符串转换为Unicode码位列表</span></span><br><span class="line">symbols = <span class="string">&quot;$#@%&amp;*&quot;</span></span><br><span class="line">codes = []</span><br><span class="line"><span class="keyword">for</span> symbol <span class="keyword">in</span> symbols:</span><br><span class="line">    codes.append(<span class="built_in">ord</span>(symbol))</span><br><span class="line">print(codes)</span><br><span class="line"><span class="comment"># [36, 35, 64, 37, 38, 42]</span></span><br></pre></td></tr></table></figure></li>
<li><p>列表生成式：[ func(s) for s in strs]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将一个字符串转换为Unicode码位列表</span></span><br><span class="line">symbols = <span class="string">&quot;$#@%&amp;*&quot;</span></span><br><span class="line">codes = [<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols ]</span><br><span class="line">print(codes)</span><br><span class="line"><span class="comment"># [36, 35, 64, 37, 38, 42]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>使用标准：</strong></p>
<p>上面两种方式实现了相同的功能，使用哪一种取决于逻辑的复杂程度，逻辑复杂需要编写多行才能表示的使用传统for循环的方式更清晰，逻辑简单的使用列表推导方式则更加易读。</p>
<p>**TIPS:**Python会忽略代码中[],(),{}中的换行符号，方便逻辑展示。</p>
<h4 id="列表推导与map，filter的关系"><a href="#列表推导与map，filter的关系" class="headerlink" title="列表推导与map，filter的关系"></a>列表推导与map，filter的关系</h4><p>关系就是：map，filter能做的，利用列表推导同样可以实现。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 得到所有ASCII大于36的结果,列表生成</span></span><br><span class="line">symbols = <span class="string">&quot;$#@%&amp;*&quot;</span></span><br><span class="line">beyond_ascii = [<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols <span class="keyword">if</span> <span class="built_in">ord</span>(symbol) &gt; <span class="number">36</span>]</span><br><span class="line">print(beyond_ascii)</span><br><span class="line"><span class="comment"># [64, 37, 38, 42]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 得到所有ASCII大于36的结果,map,filter,lambda</span></span><br><span class="line">symbols = <span class="string">&quot;$#@%&amp;*&quot;</span></span><br><span class="line">beyond_ascii = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> c:c &gt; <span class="number">36</span> , <span class="built_in">map</span>(<span class="built_in">ord</span> , symbols)))</span><br><span class="line">print(beyond_ascii)</span><br><span class="line"><span class="comment"># [64, 37, 38, 42]</span></span><br></pre></td></tr></table></figure>
<h4 id="列表推导与笛卡儿积"><a href="#列表推导与笛卡儿积" class="headerlink" title="列表推导与笛卡儿积"></a>列表推导与笛卡儿积</h4><p>在列表推导中也可以生成笛卡儿积，直接看代码即可；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sizes = [<span class="string">&quot;small&quot;</span> , <span class="string">&quot;medium&quot;</span> , <span class="string">&quot;large&quot;</span>]</span><br><span class="line">colors = [<span class="string">&quot;white&quot;</span> , <span class="string">&quot;black&quot;</span>]</span><br><span class="line">print([(size  , color) <span class="keyword">for</span> size <span class="keyword">in</span> sizes </span><br><span class="line">       							  <span class="keyword">for</span> color <span class="keyword">in</span> colors ])</span><br><span class="line"><span class="comment"># [(&#x27;small&#x27;, &#x27;white&#x27;), (&#x27;small&#x27;, &#x27;black&#x27;), (&#x27;medium&#x27;, &#x27;white&#x27;), (&#x27;medium&#x27;, &#x27;black&#x27;), (&#x27;large&#x27;, &#x27;white&#x27;), (&#x27;large&#x27;, &#x27;black&#x27;)]</span></span><br></pre></td></tr></table></figure>
<h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><p>列表生成式也是生成列表的方式，其遵循了<strong>迭代器</strong>协议，逐个的产出元素，而<strong>不是建立完整的列表</strong>，显然可以<strong>节省内存</strong>。其形式与列表推导式大同小异，仅仅将<strong>方括号替换为圆括号</strong>。</p>
<ul>
<li>生成式是唯一参数时，不需要添加圆括号。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">symbols = <span class="string">&quot;$#@%&amp;*&quot;</span></span><br><span class="line">codes = <span class="built_in">list</span>(<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols)</span><br><span class="line">print(codes)</span><br><span class="line"><span class="comment"># [36, 35, 64, 37, 38, 42]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>生成式不是唯一参数时，需要添加圆括号。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> array</span><br><span class="line">symbols = <span class="string">&quot;$#@%&amp;*&quot;</span></span><br><span class="line">codes = array.array(<span class="string">&quot;I&quot;</span>,(<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols))</span><br><span class="line">print(codes)</span><br><span class="line"><span class="comment"># array(&#x27;I&#x27;, [36, 35, 64, 37, 38, 42])</span></span><br></pre></td></tr></table></figure>
<ul>
<li>生成式计算笛卡儿积</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sizes = [<span class="string">&quot;small&quot;</span> , <span class="string">&quot;medium&quot;</span> , <span class="string">&quot;large&quot;</span>]</span><br><span class="line">colors = [<span class="string">&quot;white&quot;</span> , <span class="string">&quot;black&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> tshirts <span class="keyword">in</span> (<span class="string">&quot;%s %s&quot;</span>%(size  , color) <span class="keyword">for</span> size <span class="keyword">in</span> sizes <span class="keyword">for</span> color <span class="keyword">in</span> colors ):</span><br><span class="line">print(tshirts)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">small white</span></span><br><span class="line"><span class="string">small black</span></span><br><span class="line"><span class="string">medium white</span></span><br><span class="line"><span class="string">medium black</span></span><br><span class="line"><span class="string">large white</span></span><br><span class="line"><span class="string">large black</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="Tuple序列"><a href="#Tuple序列" class="headerlink" title="Tuple序列"></a>Tuple序列</h2><p>元组不仅仅是不可变的列表，如何使用也取决于如何看代元组，例如将元素视为用于<strong>记录的字段数据</strong>。那么其数量与位置信息则是非常重要的，</p>
<ul>
<li>元组用于记录：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">metro_areas = [</span><br><span class="line">    (<span class="string">&#x27;Tokyo&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>)),   <span class="comment"># &lt;1&gt;</span></span><br><span class="line">    (<span class="string">&#x27;Delhi NCR&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>)),</span><br><span class="line">    (<span class="string">&#x27;Mexico City&#x27;</span>, <span class="string">&#x27;MX&#x27;</span>, <span class="number">20.142</span>, (<span class="number">19.433333</span>, -<span class="number">99.133333</span>)),</span><br><span class="line">    (<span class="string">&#x27;New York-Newark&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="number">20.104</span>, (<span class="number">40.808611</span>, -<span class="number">74.020386</span>)),</span><br><span class="line">    (<span class="string">&#x27;Sao Paulo&#x27;</span>, <span class="string">&#x27;BR&#x27;</span>, <span class="number">19.649</span>, (-<span class="number">23.547778</span>, -<span class="number">46.635833</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;&#123;:15&#125; | &#123;:^9&#125; | &#123;:^9&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;lat.&#x27;</span>, <span class="string">&#x27;long.&#x27;</span>))</span><br><span class="line">fmt = <span class="string">&#x27;&#123;:15&#125; | &#123;:9.4f&#125; | &#123;:9.4f&#125;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> name, cc, pop, (latitude, longitude) <span class="keyword">in</span> metro_areas:  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">    <span class="keyword">if</span> longitude &lt;= <span class="number">0</span>:  <span class="comment"># &lt;3&gt;</span></span><br><span class="line">        print(fmt.<span class="built_in">format</span>(name, latitude, longitude))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                |   lat.    |   long.  </span></span><br><span class="line"><span class="string">Mexico City     |   19.4333 |  -99.1333</span></span><br><span class="line"><span class="string">New York-Newark |   40.8086 |  -74.0204</span></span><br><span class="line"><span class="string">Sao Paulo       |  -23.5478 |  -46.6358</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>元组内部可嵌套，其内部嵌套标准这里不讨论。</li>
<li>元组可以进行<strong>拆包</strong></li>
</ol>
<h3 id="元组拆包"><a href="#元组拆包" class="headerlink" title="元组拆包"></a>元组拆包</h3><p>拆包就是将元组中的各元素一次性提取到多变量中。平行赋值是元组拆包的形式之一，也是最好辨认的形式。</p>
<ul>
<li>平行赋值示例：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lax_coordinates = (<span class="number">33.9425</span> , -<span class="number">118.4080</span>)</span><br><span class="line">latitude , longitude = lax_coordinates</span><br><span class="line">print(latitude)</span><br><span class="line">print(longitude)</span><br><span class="line"><span class="comment">#33.9425</span></span><br><span class="line"><span class="comment">#-118.408</span></span><br></pre></td></tr></table></figure>
<ul>
<li>“*” 来表示剩余的元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a , b , *rest = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line">print(a , b , rest)</span><br><span class="line"><span class="comment"># 0 1 [2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>嵌套元组的拆包</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">metro_areas = [</span><br><span class="line">    (<span class="string">&#x27;Tokyo&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>)),   <span class="comment"># &lt;1&gt;</span></span><br><span class="line">    (<span class="string">&#x27;Delhi NCR&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>)),</span><br><span class="line">    (<span class="string">&#x27;Mexico City&#x27;</span>, <span class="string">&#x27;MX&#x27;</span>, <span class="number">20.142</span>, (<span class="number">19.433333</span>, -<span class="number">99.133333</span>)),</span><br><span class="line">    (<span class="string">&#x27;New York-Newark&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="number">20.104</span>, (<span class="number">40.808611</span>, -<span class="number">74.020386</span>)),</span><br><span class="line">    (<span class="string">&#x27;Sao Paulo&#x27;</span>, <span class="string">&#x27;BR&#x27;</span>, <span class="number">19.649</span>, (-<span class="number">23.547778</span>, -<span class="number">46.635833</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;&#123;:15&#125; | &#123;:^9&#125; | &#123;:^9&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;lat.&#x27;</span>, <span class="string">&#x27;long.&#x27;</span>))</span><br><span class="line">fmt = <span class="string">&#x27;&#123;:15&#125; | &#123;:9.4f&#125; | &#123;:9.4f&#125;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> name, cc, pop, (latitude, longitude) <span class="keyword">in</span> metro_areas:  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">    <span class="keyword">if</span> longitude &lt;= <span class="number">0</span>:  <span class="comment"># &lt;3&gt;</span></span><br><span class="line">        print(fmt.<span class="built_in">format</span>(name, latitude, longitude))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                |   lat.    |   long.  </span></span><br><span class="line"><span class="string">Mexico City     |   19.4333 |  -99.1333</span></span><br><span class="line"><span class="string">New York-Newark |   40.8086 |  -74.0204</span></span><br><span class="line"><span class="string">Sao Paulo       |  -23.5478 |  -46.6358</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="具名元组"><a href="#具名元组" class="headerlink" title="具名元组"></a>具名元组</h3><p>具名元组是collection类的一个工厂函数，可以用来构建<strong>一个带字段名的元组和一个有名字的类</strong>。具体使用方式这里不表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">City = namedtuple(<span class="string">&quot;City&quot;</span> , <span class="string">&quot;name country population coordinates&quot;</span>)</span><br><span class="line">tokyo = City(<span class="string">&quot;Tokyo&quot;</span> , <span class="string">&quot;JP&quot;</span> , <span class="number">36.933</span> , (<span class="number">35.68</span> , <span class="number">139.69</span>))</span><br><span class="line">print(tokyo)</span><br><span class="line">print(tokyo.name)</span><br><span class="line">print(tokyo.coordinates)</span><br><span class="line">print(tokyo[<span class="number">0</span>])</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">City(name=&#x27;Tokyo&#x27;, country=&#x27;JP&#x27;, population=36.933, coordinates=(35.68, 139.69))</span></span><br><span class="line"><span class="string">Tokyo</span></span><br><span class="line"><span class="string">(35.68, 139.69)</span></span><br><span class="line"><span class="string">Tokyo</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="序列中的-与"><a href="#序列中的-与" class="headerlink" title="序列中的 + 与 *"></a>序列中的 + 与 *</h2><p>Python中的序列是支持的+与* 操作的，用于序列的拼接。而用于拼接的序列是不会被更改的，而是创建一个包含有同样类型的序列并返回。</p>
<p>“+”用于拼接序列时，一般要求<strong>左右元素的类型一致</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment"># * 的应用</span></span><br><span class="line">print(l*<span class="number">5</span>)</span><br><span class="line">print(<span class="string">&quot;abcd&quot;</span> * <span class="number">5</span>)</span><br><span class="line"><span class="comment"># [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]</span></span><br><span class="line"><span class="comment"># abcdabcdabcdabcdabcd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># + 的应用</span></span><br><span class="line">print(l + [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6] </span></span><br><span class="line">print(l + <span class="number">4</span>)</span><br><span class="line"><span class="comment"># TypeError: can only concatenate list (not &quot;int&quot;) to list</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>在使用a * n语句时，序列中的<strong>a中的元素是对其他可变对象的引用</strong>时，得到的结果可能会与预期存在不一致。我自己在编写算法过程中也遇到类似的情形。比如：初始化列表中的列表时，得到的三个元素是三个引用，三个引用指向的地址一致，</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正确的使用姿势</span></span><br><span class="line">board = [[<span class="string">&quot;_&quot;</span>] * <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>) ]</span><br><span class="line">board[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">&quot;x&quot;</span></span><br><span class="line">print(board)</span><br><span class="line"><span class="comment"># [[&#x27;_&#x27;, &#x27;x&#x27;, &#x27;_&#x27;], [&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;], [&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误的使用姿势</span></span><br><span class="line">board = [[<span class="string">&quot;_&quot;</span>] * <span class="number">3</span> ] * <span class="number">3</span></span><br><span class="line">board[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">&quot;x&quot;</span></span><br><span class="line">print(board)</span><br><span class="line"><span class="comment"># [[&#x27;_&#x27;, &#x27;x&#x27;, &#x27;_&#x27;], [&#x27;_&#x27;, &#x27;x&#x27;, &#x27;_&#x27;], [&#x27;_&#x27;, &#x27;x&#x27;, &#x27;_&#x27;]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的错误与接下来的写法一致</span></span><br><span class="line">row = [<span class="string">&quot;_&quot;</span>] * <span class="number">3</span></span><br><span class="line">board = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">  board.append(row)</span><br><span class="line">board[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">&quot;x&quot;</span></span><br><span class="line">print(board)</span><br><span class="line"><span class="comment"># [[&#x27;_&#x27;, &#x27;x&#x27;, &#x27;_&#x27;], [&#x27;_&#x27;, &#x27;x&#x27;, &#x27;_&#x27;], [&#x27;_&#x27;, &#x27;x&#x27;, &#x27;_&#x27;]]</span></span><br></pre></td></tr></table></figure>
<h2 id="序列中的-与-运算"><a href="#序列中的-与-运算" class="headerlink" title="序列中的 += 与 *= 运算"></a>序列中的 += 与 *= 运算</h2><p>序列中的增量赋值运算，大同小异，只介绍+= 即可。理解增量赋值运算，主要是其结果到底是<strong>就地加法</strong>还是<strong>构造新的对象</strong>并赋值。</p>
<p><strong>Python遇到+=时</strong></p>
<ul>
<li>首先会调用“__iadd__”(就地加法方法)，__</li>
<li>如果没有实现，则调用“__add__”,此时等价于a = a +b.</li>
</ul>
<p>而上面是否实现了<strong>就地加法</strong>，却决于a是否是可变对象，比如列表就实现了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可变类型遇到增量赋值，一般为原地修改</span></span><br><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">print(<span class="built_in">id</span>(l))</span><br><span class="line"><span class="comment"># 29050360</span></span><br><span class="line">l += [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">print(<span class="built_in">id</span>(l))</span><br><span class="line"><span class="comment"># 29050360</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不可变类型遇到增量复制，会重新构造对象</span></span><br><span class="line">a = <span class="string">&quot;abcd&quot;</span></span><br><span class="line">print(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="comment"># 29036000</span></span><br><span class="line">a += <span class="string">&quot;efgh&quot;</span></span><br><span class="line">print(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="comment"># 59961416</span></span><br></pre></td></tr></table></figure>
<h2 id="list-sort与内置的sorted方法"><a href="#list-sort与内置的sorted方法" class="headerlink" title="list.sort与内置的sorted方法"></a>list.sort与内置的sorted方法</h2><p>上面的两个方法作用一致，其差别就是list.sort方法会选择原地重建列表结构，地址不变。内置的sorted方法则是重构一个列表对象，并返回。</p>
<h3 id="奇妙的key参数"><a href="#奇妙的key参数" class="headerlink" title="奇妙的key参数"></a>奇妙的key参数</h3><p>在list.sort\sorted\min\max函数中均提供了key参数，用于进行比较大小的依据。在一般的语言中，甚至在python2中也采用了<strong>双参数</strong>函数用于返回“-1，0，1”，以表示大小。而Python3中的key参数支持<strong>单参数</strong>函数进行比较。单参数的优势在于其更加高效，<strong>每个key函数只会调用一次</strong>。在排序中，自然会进行两个键值的比较，但是其发生才C语言一层，这样保证了其高效性。</p>
<p><strong>示例：实现字符与数字的序列排序</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">24</span>,<span class="number">14</span>,<span class="string">&quot;28&quot;</span> , <span class="number">5</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span> , <span class="number">6</span>,<span class="string">&quot;23&quot;</span> , <span class="number">19</span>]</span><br><span class="line">print(<span class="built_in">sorted</span>(l , key= <span class="built_in">int</span>))</span><br><span class="line"><span class="comment"># [&#x27;0&#x27;, &#x27;1&#x27;, 5, 6, &#x27;9&#x27;, 14, 19, &#x27;23&#x27;, 24, &#x27;28&#x27;]</span></span><br><span class="line"></span><br><span class="line">l = [<span class="number">24</span>,<span class="number">14</span>,<span class="string">&quot;28&quot;</span> , <span class="number">5</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span> , <span class="number">6</span>,<span class="string">&quot;23&quot;</span> , <span class="number">19</span>]</span><br><span class="line">print(<span class="built_in">sorted</span>(l , key= <span class="built_in">str</span>))</span><br><span class="line"><span class="comment"># [&#x27;0&#x27;, &#x27;1&#x27;, 14, 19, &#x27;23&#x27;, 24, &#x27;28&#x27;, 5, 6, &#x27;9&#x27;]</span></span><br></pre></td></tr></table></figure>
<h2 id="bisect来管理已排序序列"><a href="#bisect来管理已排序序列" class="headerlink" title="bisect来管理已排序序列"></a>bisect来管理已排序序列</h2><p>看理解就是利用二分查找，用来快速定位元素。支持左右二分查找，支持插入元素等。这里不一一贴代码。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_文本与字节序列</title>
    <url>/2021/01/17/Python-%E6%96%87%E6%9C%AC%E4%B8%8E%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>关于Python2与3的编码差异、unicode的概念、encode与Decode的问题都在<a href="python2%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98.md">Python2编码问题</a>已经讨论过。这里讨论的是</p>
<ol>
<li><p>如何解决与理解编码出现的问题？</p>
</li>
<li><p>BOM是什么</p>
</li>
<li><p>处理文本文件时的建议</p>
</li>
<li><p>规范化Unicode字符串</p>
<a id="more"></a>

</li>
</ol>
<h2 id="编码相关的问题"><a href="#编码相关的问题" class="headerlink" title="编码相关的问题"></a>编码相关的问题</h2><h3 id="问题是怎么产生的？"><a href="#问题是怎么产生的？" class="headerlink" title="问题是怎么产生的？"></a>问题是怎么产生的？</h3><p>日常应用中在解码与编码过程中经常会报错，而报错的原因多半是由于以当前给定的编码方式无法正确解码。这说明不同的编码机制只能对一部分字符进行编码，当你采用其他编码算法进行解码时，那么则无法适配。如图所示：</p>
<p><img src="https://i.loli.net/2021/01/11/dDGFmAPWMS9RXEz.png"></p>
<p>在上图中不同的字符，存在部分编码机制没法编码。而在使用中往往出现有三种编码机制：ascII,gbk,utf-8这三种。</p>
<h3 id="了解解码问题"><a href="#了解解码问题" class="headerlink" title="了解解码问题"></a>了解解码问题</h3><h4 id="UnicodeEncodeError"><a href="#UnicodeEncodeError" class="headerlink" title="UnicodeEncodeError"></a>UnicodeEncodeError</h4><p>多数非UTF编码器只能处理Unicode字符的小部分子集。将文本转换为字节序列时，如果目标编码中没有定义某个字符，就会抛出UnicdeEncodeError异常，除非把errors参数传递给编码方法或函数，对错误进行特殊处理。</p>
<p><img src="https://i.loli.net/2021/01/11/gYvAfI86uF4QB95.png"></p>
<p>上面的代码中展示了3中cp437编码算法无法处理此字符。可通过errors关键字对错误进行相关处理，而不抛出异常。</p>
<ul>
<li>ignore:跳过无法编码的字符，并不推荐使用</li>
<li>replace：将无法编码的字符替换为？；数据出现损坏，用户知道</li>
<li>xmlcharrefreplace：无法编码的字符替换为xml实体</li>
</ul>
<h4 id="UnicodeDecodeError"><a href="#UnicodeDecodeError" class="headerlink" title="UnicodeDecodeError"></a>UnicodeDecodeError</h4><p>将字节转换为字符过程中出错，会抛出此异常。</p>
<p><img src="https://i.loli.net/2021/01/11/xZXvn67BcqkmVlP.png"></p>
<h4 id="SyntaxError"><a href="#SyntaxError" class="headerlink" title="SyntaxError"></a>SyntaxError</h4><h4 id="如何确定当前的编码"><a href="#如何确定当前的编码" class="headerlink" title="如何确定当前的编码"></a>如何确定当前的编码</h4><p>不能，除非有人告诉你。但是每种编码有自己的特点，统一字符编码侦测包 Chardet（<a href="https://pypi.python.org/pypi/chardet%EF%BC%89%E5%B0%B1%E6%98%AF%E8%BF%99%E6%A0%B7%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%8C%E5%AE%83%E8%83%BD%E8%AF%86%E5%88%AB%E6%89%80%E6%94%AF%E6%8C%81%E7%9A%84">https://pypi.python.org/pypi/chardet）就是这样工作的，它能识别所支持的</a> 30 种编码。Chardet 是一个 Python 库，可以在程序中使用，不过它也提供了<br>命令行工具 chardetect。下面是它对本章书稿文件的检测报告：</p>
<p><img src="https://i.loli.net/2021/01/11/uZYglQELvPWwXr4.png"></p>
<h2 id="处理文本文件的建议"><a href="#处理文本文件的建议" class="headerlink" title="处理文本文件的建议"></a>处理文本文件的建议</h2><p>存在一个三明治逻辑，将中间的肉比喻为业务的核心逻辑，将上面包比喻为字节转换为字符的过程，将下面包比喻为将字符转换为字节的过程。建议就是将上面包尽可能的早，而下面包尽可能的晚。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_方法的种类</title>
    <url>/2021/01/17/Python-%E6%96%B9%E6%B3%95%E7%9A%84%E7%A7%8D%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="Python中方法"><a href="#Python中方法" class="headerlink" title="Python中方法"></a>Python中方法</h2><p>一共存在三种方法，分别是<strong>实例方法，类方法（classmethod），静态方法(staticmethod)</strong>;</p>
<a id="more"></a>

<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单独的函数定义，不需要绑定实例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x</span>):</span></span><br><span class="line">    print(<span class="string">&quot;executing foo(%s)&quot;</span>%(x))</span><br><span class="line">foo(<span class="string">&quot;function&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="comment">#实例方法，需要绑定实例self</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self , x</span>):</span></span><br><span class="line">        print(<span class="string">&quot;executing foo(%s,%s)&quot;</span>%(self,x))</span><br><span class="line">    <span class="comment">#类方法需要绑定类，cls</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span>(<span class="params">cls,x</span>):</span></span><br><span class="line">        print(<span class="string">&quot;executing foo(%s,%s)&quot;</span>%(cls,x))</span><br><span class="line">    <span class="comment">#静态方法不需要任何绑定</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_foo</span>(<span class="params">x</span>):</span></span><br><span class="line">        print(<span class="string">&quot;executing foo(%s)&quot;</span>%(x))</span><br></pre></td></tr></table></figure>
<p>代码运行与结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = A()</span><br><span class="line">a.foo(<span class="string">&quot;实例调用实例方法&quot;</span>)</span><br><span class="line">a.class_foo(<span class="string">&quot;实例调用类方法&quot;</span>)</span><br><span class="line">a.static_foo(<span class="string">&quot;实例调用静态方法&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#executing foo(&lt;__main__.A object at 0x0000028BA3754780&gt;,实例调用实例方法):实例方法传入的是实例</span></span><br><span class="line"><span class="comment">#executing foo(&lt;class &#x27;__main__.A&#x27;&gt;,实例调用类方法) ：类方法即使是实例调用传入的仍然是类</span></span><br><span class="line"><span class="comment">#executing foo(实例调用静态方法)</span></span><br><span class="line"></span><br><span class="line">A.class_foo(<span class="string">&quot;类调用类方法&quot;</span>)</span><br><span class="line">A.static_foo(<span class="string">&quot;类调用静态方法&quot;</span>)</span><br><span class="line"><span class="comment"># executing foo(&lt;class &#x27;__main__.A&#x27;&gt;,类调用类方法)</span></span><br><span class="line"><span class="comment"># executing foo(类调用静态方法)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里先理解下函数参数里面的self和cls.这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用<code>foo(x)</code>,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是<code>foo(self, x)</code>,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的<code>a.foo(x)</code>(其实是<code>foo(a, x)</code>).类方法一样,只不过它传递的是类而不是实例,<code>A.class_foo(x)</code>.注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好.</p>
<p>对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用<code>a.static_foo(x)</code>或者<code>A.static_foo(x)</code>来调用.</p>
</blockquote>
<h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>Python中存在方法与函数：方法就是定义在class类定义的函数，其往往需要与实例或者类进行绑定，函数就是独立于实例与类存在的方法，不需要绑定任何事物；我们可以简单的将Python中的方法定义为位于类内部定义的函数即可；</p>
<p>Python中的方法往往需要进行绑定，这种绑定能够起到定义不同的作用域的作用，知道存在三种方法及其写法及其调用方式即可；</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_构造Python风格类</title>
    <url>/2021/01/17/Python-%E6%9E%84%E9%80%A0Python%E9%A3%8E%E6%A0%BC%E7%B1%BB/</url>
    <content><![CDATA[<p>所谓Python风格的对象,就是能够适用于Python原生方法的对象.</p>
<a id="more"></a>

<p>其实现多以通过魔法方法的实现完成的.这就是造轮子的过程.下面给出一个向量类的示例代码:当作参考.具体实现细节没有必要深究,也记不住.用时再查看.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">A 2-dimensional vector class</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector2d(3, 4)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(v1.x, v1.y)</span></span><br><span class="line"><span class="string">    3.0 4.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y = v1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1</span></span><br><span class="line"><span class="string">    Vector2d(3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = eval(repr(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(v1)</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; octets = bytes(v1)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; octets</span></span><br><span class="line"><span class="string">    b&#x27;d\\x00\\x00\\x00\\x00\\x00\\x00\\x08@\\x00\\x00\\x00\\x00\\x00\\x00\\x10@&#x27;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(v1)</span></span><br><span class="line"><span class="string">    5.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; bool(v1), bool(Vector2d(0, 0))</span></span><br><span class="line"><span class="string">    (True, False)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Test of ``.frombytes()`` class method:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = Vector2d.frombytes(bytes(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone</span></span><br><span class="line"><span class="string">    Vector2d(3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of ``format()`` with Cartesian coordinates:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1)</span></span><br><span class="line"><span class="string">    &#x27;(3.0, 4.0)&#x27;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1, &#x27;.2f&#x27;)</span></span><br><span class="line"><span class="string">    &#x27;(3.00, 4.00)&#x27;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1, &#x27;.3e&#x27;)</span></span><br><span class="line"><span class="string">    &#x27;(3.000e+00, 4.000e+00)&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of the ``angle`` method::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Vector2d(0, 0).angle()</span></span><br><span class="line"><span class="string">    0.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Vector2d(1, 0).angle()</span></span><br><span class="line"><span class="string">    0.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; epsilon = 10**-8</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(Vector2d(0, 1).angle() - math.pi/2) &lt; epsilon</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(Vector2d(1, 1).angle() - math.pi/4) &lt; epsilon</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of ``format()`` with polar coordinates:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector2d(1, 1), &#x27;p&#x27;)  # doctest:+ELLIPSIS</span></span><br><span class="line"><span class="string">    &#x27;&lt;1.414213..., 0.785398...&gt;&#x27;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector2d(1, 1), &#x27;.3ep&#x27;)</span></span><br><span class="line"><span class="string">    &#x27;&lt;1.414e+00, 7.854e-01&gt;&#x27;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector2d(1, 1), &#x27;0.5fp&#x27;)</span></span><br><span class="line"><span class="string">    &#x27;&lt;1.41421, 0.78540&gt;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of `x` and `y` read-only properties:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1.x, v1.y</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1.x = 123</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">    AttributeError: can&#x27;t set attribute</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of hashing:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector2d(3, 4)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v2 = Vector2d(3.1, 4.2)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; hash(v1), hash(v2)</span></span><br><span class="line"><span class="string">    (7, 384307168202284039)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; len(set([v1, v2]))</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># END VECTOR2D_V3_DEMO</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment"># BEGIN VECTOR2D_V3_SLOTS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">&#x27;__x&#x27;</span>, <span class="string">&#x27;__y&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    typecode = <span class="string">&#x27;d&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># methods follow (omitted in book listing)</span></span><br><span class="line"><span class="comment"># END VECTOR2D_V3_SLOTS</span></span><br><span class="line">		<span class="comment"># 双下划线开头的属性为私有属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.__x = <span class="built_in">float</span>(x)</span><br><span class="line">        self.__y = <span class="built_in">float</span>(y)</span><br><span class="line">		<span class="comment"># 通过property装饰器将属性设为只读,注意方法名称就是属性名,</span></span><br><span class="line">    <span class="comment"># 你看这里的措施与Java对于属性的getx其实是一样的</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__x</span><br><span class="line">	</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">y</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__y</span><br><span class="line">		<span class="comment"># 迭代返回公开属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br><span class="line">		<span class="comment"># 定义对象的字符表现形式:repr()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        class_name = <span class="built_in">type</span>(self).__name__</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)&#x27;</span>.<span class="built_in">format</span>(class_name, *self)</span><br><span class="line">		<span class="comment">#  定义对象的字符表现形式:str()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">tuple</span>(self))</span><br><span class="line">	<span class="comment"># 定义将对象转换为字节的方法:bytes()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">bytes</span>([<span class="built_in">ord</span>(self.typecode)]) +</span><br><span class="line">                <span class="built_in">bytes</span>(array(self.typecode, self)))</span><br><span class="line"><span class="comment"># 定义 == : ==</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">tuple</span>(self) == <span class="built_in">tuple</span>(other)</span><br><span class="line"><span class="comment"># 定义 散列 : hash()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(self.x) ^ <span class="built_in">hash</span>(self.y)</span><br><span class="line"><span class="comment"># 定义 向量的模: abs()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> math.hypot(self.x, self.y)</span><br><span class="line"><span class="comment"># 定义 向量的模</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(<span class="built_in">abs</span>(self))</span><br><span class="line"><span class="comment"># 定义极坐标计算</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">angle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> math.atan2(self.y, self.x)</span><br><span class="line"><span class="comment"># 格式化显示:format() 或者str.format()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span>(<span class="params">self, fmt_spec=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> fmt_spec.endswith(<span class="string">&#x27;p&#x27;</span>):</span><br><span class="line">            fmt_spec = fmt_spec[:-<span class="number">1</span>]</span><br><span class="line">            coords = (<span class="built_in">abs</span>(self), self.angle())</span><br><span class="line">            outer_fmt = <span class="string">&#x27;&lt;&#123;&#125;, &#123;&#125;&gt;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            coords = self</span><br><span class="line">            outer_fmt = <span class="string">&#x27;(&#123;&#125;, &#123;&#125;)&#x27;</span></span><br><span class="line">        components = (<span class="built_in">format</span>(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> coords)</span><br><span class="line">        <span class="keyword">return</span> outer_fmt.<span class="built_in">format</span>(*components)</span><br><span class="line"><span class="comment"># 定义字节转换为对象的方法</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frombytes</span>(<span class="params">cls, octets</span>):</span></span><br><span class="line">        typecode = <span class="built_in">chr</span>(octets[<span class="number">0</span>])</span><br><span class="line">        memv = <span class="built_in">memoryview</span>(octets[<span class="number">1</span>:]).cast(typecode)</span><br><span class="line">        <span class="keyword">return</span> cls(*memv)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_浅复制与深复制</title>
    <url>/2021/01/17/Python-%E6%B5%85%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B7%B1%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p><a href="%E6%B5%81%E7%95%85%E7%9A%84python.pdf">流畅的python</a>,<a href="https://www.pythontutor.com/">Python可视化网站</a></p>
</blockquote>
<p>深复制与浅复制早就有所耳闻，今天发现没有进行相关笔记。这里简单写下，不做深入探讨。</p>
<a id="more"></a>

<h2 id="默认为浅复制"><a href="#默认为浅复制" class="headerlink" title="默认为浅复制"></a>默认为浅复制</h2><p>浅复制就是仅复制了最外层的引用，而对内部引用不做复制操作；对于不可变元素，这是很好的，减少了内存消耗。然而当内部元素是可变的，就会产生非预期的事情。Python中默认使用浅复制，例如列表中可以采用[:] 与 list() 构造进行复制操作。以下是一段代码，及其内存情况展示，可方便理解，面对不同元素对象操作时的异同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">3</span>, [<span class="number">66</span>,<span class="number">55</span>,<span class="number">44</span>] </span><br><span class="line"><span class="comment"># 通过构造函数进行了浅复制操作</span></span><br><span class="line">l2 = <span class="built_in">list</span>(l1)   <span class="comment"># （1）      </span></span><br><span class="line">l1.append(<span class="number">100</span>)  <span class="comment">#	      </span></span><br><span class="line">l1[<span class="number">1</span>].remove(<span class="number">55</span>)   <span class="comment">#  （2）   </span></span><br><span class="line">print(<span class="string">&quot;l1 ,&quot;</span>, l1 )    </span><br><span class="line">print(<span class="string">&quot;l2 ,&quot;</span> ,l2)</span><br><span class="line"><span class="comment"># l1 , [3, [66, 44], (7, 8, 9), 100]</span></span><br><span class="line"><span class="comment"># l2 , [3, [66, 44], (7, 8, 9)]</span></span><br><span class="line">l2[<span class="number">1</span>] += [<span class="number">33</span>,<span class="number">22</span>]     <span class="comment">#（3） </span></span><br><span class="line">l2[<span class="number">2</span>] += (<span class="number">10</span> ,<span class="number">11</span>)     <span class="comment">#（4）</span></span><br><span class="line">print(<span class="string">&quot;l1 ,&quot;</span>, l1 )    </span><br><span class="line">print(<span class="string">&quot;l2 ,&quot;</span> ,l2)     </span><br><span class="line"><span class="comment"># l1 , [3, [66, 44, 33, 22], (7, 8, 9), 100]</span></span><br><span class="line"><span class="comment"># l2 , [3, [66, 44, 33, 22], (7, 8, 9, 10, 11)]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/11/dDTsIWoG1tNOSek.png"></p>
<p>(1)可以看到上图中通过浅复制，l1,l2指向了不同的对象，而对象内部元素的引用并没有变化。</p>
<p><img src="https://i.loli.net/2021/01/11/2iwVdC8yu4kXEYr.png"></p>
<p>(2)可以看到在对l1中的列表元素进行操作直接影响了l2中列表元素的情况，这当然是由于<strong>其内部列表元素指向对象一致，并且列表是可变元素。</strong> 可变元素就说明其支持原地修改。</p>
<p><img src="https://i.loli.net/2021/01/11/kwFWReO3fi6pyNt.png"></p>
<p>(3)同理，l2中对列表元素的修改，也会影响到l1的内部情况。</p>
<p><img src="https://i.loli.net/2021/01/11/xk6MzWqyXQsbJu8.png"></p>
<p>(4)需要注意，对l2的tuple元素进行修改操作时，l1,l2不再指向同一tuple，这是由于元组本身不支持就地修改操作，其构建了一个新的元组对象并返回给了l2[2]的位置。</p>
<h2 id="如何进行深浅拷贝"><a href="#如何进行深浅拷贝" class="headerlink" title="如何进行深浅拷贝"></a>如何进行深浅拷贝</h2><p>Python提供了copy库方便提供了copy()与deepcopy()方法，很方便。使用方式展示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>import copy</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus1 = Bus([&#x27;Alice&#x27;, &#x27;Bill&#x27;, &#x27;Claire&#x27;, &#x27;David&#x27;])</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus2 = copy.copy(bus1)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus3 = copy.deepcopy(bus1)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus1.drop(&#x27;Bill&#x27;)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers</span></span><br><span class="line"><span class="string">[&#x27;Alice&#x27;, &#x27;Claire&#x27;, &#x27;David&#x27;]</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus3.passengers</span></span><br><span class="line"><span class="string">[&#x27;Alice&#x27;, &#x27;Bill&#x27;, &#x27;Claire&#x27;, &#x27;David&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BEGIN BUS_CLASS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, passengers=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.passengers = []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.passengers = <span class="built_in">list</span>(passengers)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.passengers.append(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drop</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.passengers.remove(name)</span><br><span class="line"><span class="comment"># END BUS_CLASS</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h3><p>深拷贝并没有那么简单，例如遇到循环引用时，岂不是会无限copy。不过这不用担心，Python自带的copy库可以记住已经copy过的对象。大胆用。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_特殊方法</title>
    <url>/2021/01/17/Python-%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Python中存在大量的特殊方法，官方一般称之为魔法方法(magic method)，也叫双下方法(dunder method).其方法形式为以双下划线为起始，并且以双下划线为结束，</p>
<a id="more"></a>

<p>__funcName__ . 魔法方法是指Python内部已经包含的，被双下划线所包围的方法，这些方法在进行特定的操作时会自动被调用，它们是Python面向对象下智慧的结晶。</p>
<blockquote>
<p><a href="P1~P14">流畅的Python</a> , <a href="https://zhuanlan.zhihu.com/p/24567545">知乎专栏</a> , <a href="https://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html">方法指南</a> ，<a href="https://wiki.jikexueyuan.com/project/explore-python/Class/magic_method.html">某教程</a></p>
</blockquote>
<h2 id="日常使用例子"><a href="#日常使用例子" class="headerlink" title="日常使用例子"></a>日常使用例子</h2><ol>
<li>在日常使用中我们其实经常<strong>调用</strong>，最常见的便是 __init__  方法，在创建实例的过程中会自动调用，进行初始化。</li>
<li>len(),方法会自动调用我们的__len__ 方法等等。</li>
</ol>
<p>调用形式多样，没必要意义列举。魔法方法的出现使得Python展现了强大的自由度，简化了繁琐的重写轮子的步骤；</p>
<h2 id="调用方法列举"><a href="#调用方法列举" class="headerlink" title="调用方法列举"></a>调用方法列举</h2><p>Python中每个魔法函数都对应了一个Python内置函数或操作，比如__str__对应str函数，__lt__对应小于号&lt;等。Python中的魔法函数可以大概分为以下几类：</p>
<h3 id="类的构造与删除"><a href="#类的构造与删除" class="headerlink" title="类的构造与删除"></a><strong>类的构造与删除</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span>.__new__(self, ...)</span><br><span class="line"><span class="built_in">object</span>.__init__(self, ...)</span><br><span class="line"><span class="built_in">object</span>.__del__(self)</span><br></pre></td></tr></table></figure>
<h3 id="二元操作"><a href="#二元操作" class="headerlink" title="二元操作"></a><strong>二元操作</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">+	<span class="built_in">object</span>.__add__(self, other)</span><br><span class="line">-	<span class="built_in">object</span>.__sub__(self, other)</span><br><span class="line">*	<span class="built_in">object</span>.__mul__(self, other)</span><br><span class="line">//	<span class="built_in">object</span>.__floordiv__(self, other)</span><br><span class="line">/	<span class="built_in">object</span>.__div__(self, other)</span><br><span class="line">%	<span class="built_in">object</span>.__mod__(self, other)</span><br><span class="line">**	<span class="built_in">object</span>.__pow__(self, other[, modulo])</span><br><span class="line">&lt;&lt;	<span class="built_in">object</span>.__lshift__(self, other)</span><br><span class="line">&gt;&gt;	<span class="built_in">object</span>.__rshift__(self, other)</span><br><span class="line">&amp;	<span class="built_in">object</span>.__and__(self, other)</span><br><span class="line">^	<span class="built_in">object</span>.__xor__(self, other)</span><br><span class="line">|	<span class="built_in">object</span>.__or__(self, other)</span><br></pre></td></tr></table></figure>
<h3 id="扩展二元操作"><a href="#扩展二元操作" class="headerlink" title="扩展二元操作**"></a>扩展二元操作**</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">+=	<span class="built_in">object</span>.__iadd__(self, other)</span><br><span class="line">-=	<span class="built_in">object</span>.__isub__(self, other)</span><br><span class="line">*=	<span class="built_in">object</span>.__imul__(self, other)</span><br><span class="line">/=	<span class="built_in">object</span>.__idiv__(self, other)</span><br><span class="line">//=	<span class="built_in">object</span>.__ifloordiv__(self, other)</span><br><span class="line">%=	<span class="built_in">object</span>.__imod__(self, other)</span><br><span class="line">**=	<span class="built_in">object</span>.__ipow__(self, other[, modulo])</span><br><span class="line">&lt;&lt;=	<span class="built_in">object</span>.__ilshift__(self, other)</span><br><span class="line">&gt;&gt;=	<span class="built_in">object</span>.__irshift__(self, other)</span><br><span class="line">&amp;=	<span class="built_in">object</span>.__iand__(self, other)</span><br><span class="line">^=	<span class="built_in">object</span>.__ixor__(self, other)</span><br><span class="line">|=	<span class="built_in">object</span>.__ior__(self, other)</span><br></pre></td></tr></table></figure>
<h3 id="一元操作"><a href="#一元操作" class="headerlink" title="一元操作"></a><strong>一元操作</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-	<span class="built_in">object</span>.__neg__(self)</span><br><span class="line">+	<span class="built_in">object</span>.__pos__(self)</span><br><span class="line"><span class="built_in">abs</span>()	<span class="built_in">object</span>.__abs__(self)</span><br><span class="line">~	<span class="built_in">object</span>.__invert__(self)</span><br><span class="line"><span class="built_in">complex</span>()	<span class="built_in">object</span>.__complex__(self)</span><br><span class="line"><span class="built_in">int</span>()	<span class="built_in">object</span>.__int__(self)</span><br><span class="line">long()	<span class="built_in">object</span>.__long__(self)</span><br><span class="line"><span class="built_in">float</span>()	<span class="built_in">object</span>.__float__(self)</span><br><span class="line"><span class="built_in">oct</span>()	<span class="built_in">object</span>.__oct__(self)</span><br><span class="line"><span class="built_in">hex</span>()	<span class="built_in">object</span>.__hex__(self)</span><br><span class="line"><span class="built_in">round</span>()	<span class="built_in">object</span>.__round__(self, n)</span><br><span class="line">floor()	object__floor__(self)</span><br><span class="line">ceil()	<span class="built_in">object</span>.__ceil__(self)</span><br><span class="line">trunc()	<span class="built_in">object</span>.__trunc__(self)</span><br></pre></td></tr></table></figure>
<h3 id="比较函数"><a href="#比较函数" class="headerlink" title="比较函数"></a><strong>比较函数</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;	<span class="built_in">object</span>.__lt__(self, other)</span><br><span class="line">&lt;=	<span class="built_in">object</span>.__le__(self, other)</span><br><span class="line">==	<span class="built_in">object</span>.__eq__(self, other)</span><br><span class="line">!=	<span class="built_in">object</span>.__ne__(self, other)</span><br><span class="line">&gt;=	<span class="built_in">object</span>.__ge__(self, other)</span><br><span class="line">&gt;	<span class="built_in">object</span>.__gt__(self, other)</span><br></pre></td></tr></table></figure>
<h3 id="类的表示与输出"><a href="#类的表示与输出" class="headerlink" title="类的表示与输出"></a><strong>类的表示与输出</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>()	<span class="built_in">object</span>.__str__(self) </span><br><span class="line"><span class="built_in">repr</span>()	<span class="built_in">object</span>.__repr__(self)</span><br><span class="line"><span class="built_in">len</span>()	<span class="built_in">object</span>.__len__(self)</span><br><span class="line"><span class="built_in">hash</span>()	<span class="built_in">object</span>.__hash__(self) </span><br><span class="line"><span class="built_in">bool</span>()	<span class="built_in">object</span>.__nonzero__(self) </span><br><span class="line"><span class="built_in">dir</span>()	<span class="built_in">object</span>.__dir__(self)</span><br><span class="line">sys.getsizeof()	<span class="built_in">object</span>.__sizeof__(self)</span><br></pre></td></tr></table></figure>
<h3 id="类容器"><a href="#类容器" class="headerlink" title="类容器**"></a>类容器**</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>()	<span class="built_in">object</span>.__len__(self)</span><br><span class="line">self[key]	<span class="built_in">object</span>.__getitem__(self, key)</span><br><span class="line">self[key] = value	<span class="built_in">object</span>.__setitem__(self, key, value)</span><br><span class="line"><span class="keyword">del</span>[key] <span class="built_in">object</span>.__delitem__(self, key)</span><br><span class="line"><span class="built_in">iter</span>()	<span class="built_in">object</span>.__iter__(self)</span><br><span class="line"><span class="built_in">reversed</span>()	<span class="built_in">object</span>.__reversed__(self)</span><br><span class="line"><span class="keyword">in</span>操作	<span class="built_in">object</span>.__contains__(self, item)</span><br><span class="line">字典key不存在时	<span class="built_in">object</span>.__missing__(self, key)</span><br></pre></td></tr></table></figure>
<h2 id="相关应用"><a href="#相关应用" class="headerlink" title="相关应用"></a>相关应用</h2><p>通过上面的描述我们已经知道我们常见的一些操作，其实是调用了魔法方法的缘故，但是知道又有什么意义呢？</p>
<p>意义：<strong>通过重写上述魔法方法，可以构造符合Python风格的类</strong>。这里的Python风格就是自己构造的类也可以使用Python常见的特性，比如你构建了集合类，可以使用切片、索引、迭代等等特性，你构建了向量类，可以利用操作符” +,-,*,/ ” , 实现向量的加减乘除。</p>
<h3 id="向量类构造实例"><a href="#向量类构造实例" class="headerlink" title="向量类构造实例"></a>向量类构造实例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x=<span class="number">0</span>, y=<span class="number">0</span></span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Vector(%r, %r)&#x27;</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(<span class="built_in">abs</span>(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        x = self.x + other.x</span><br><span class="line">        y = self.y + other.y</span><br><span class="line">        <span class="keyword">return</span> Vector(x, y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span>(<span class="params">self, scalar</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.x * scalar, self.y * scalar)</span><br><span class="line">v1 = Vector(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">v2 = Vector(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">print(v1 + v2) <span class="comment"># Vector(5, 5)</span></span><br><span class="line">print(<span class="built_in">abs</span>(v2)) <span class="comment"># 5.0</span></span><br><span class="line">print(v1 * <span class="number">3</span>)  <span class="comment"># Vector(6, 3)</span></span><br></pre></td></tr></table></figure>
<p>通过实现类内部的魔法方法，使得自定义的类也能够使用Python运算符进行相关计算，符合Python风格。当然你也可以像其他方法那样，实现相关功能，只是没有了Python风格。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_私有属性与受保护的属性</title>
    <url>/2021/01/17/Python-%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>Python中除去常见的普通属性外还存在私有属性与受保护的属性.</p>
<a id="more"></a>

<p>这两种属性往往是设计者不希望他人看到的属性,在类设计过程中会采用下划线来标识.</p>
<h2 id="私有属性双下划线开头"><a href="#私有属性双下划线开头" class="headerlink" title="私有属性双下划线开头"></a>私有属性双下划线开头</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Python中对以__开头的私有属性会进行改名操作,并存入实例__dict__属性中,其改名的策略为在其前面加一个下划线外加类名.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span>:</span></span><br><span class="line">  <span class="comment"># 实例构建方法中定义了三个属性,其中两个为私有属性一个为普通属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self , x, y ,z</span>):</span></span><br><span class="line">        self.__x = x</span><br><span class="line">        self.__y = y</span><br><span class="line">        self.z = z</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        class_name = <span class="built_in">type</span>(self).__name__</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;&#125;(&#123;!r&#125;, &#123;!r&#125; , &#123;!r&#125;)&#x27;</span>.<span class="built_in">format</span>(class_name, *self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">tuple</span>(self))</span><br><span class="line">      <span class="comment"># 发现在类定义里面,既可以使用改名前的私有属性,也可以使用改名后的私有属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.__x, self._vector__y , self.z))</span><br><span class="line">vec = vector(<span class="number">3</span>,<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">print(vec)</span><br><span class="line"><span class="comment"># (3, 4, 5)</span></span><br><span class="line">print(vec.__dict__)</span><br><span class="line"><span class="comment"># &#123;&#x27;_vector__x&#x27;: 3, &#x27;_vector__y&#x27;: 4, &#x27;z&#x27;: 5&#125;</span></span><br><span class="line">print(vec._vector__x)</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 只能通过改名后的属性进行访问</span></span><br><span class="line">print(vec.__x)</span><br><span class="line"><span class="comment"># AttributeError: &#x27;vector&#x27; object has no attribute &#x27;__x&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>优点:Python会进行识别并进行改名操作,防止他人误操作</p>
</li>
<li><p>缺点:不对称的名称规范,无法避免恶意操作,比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 私有属性就是不想让他人进行访问,或者变更,结果你强行更改</span></span><br><span class="line">vec._vector__x = <span class="number">8</span></span><br><span class="line">print(vec._vector__x)</span><br><span class="line"><span class="comment"># 8</span></span><br></pre></td></tr></table></figure>
<h2 id="受保护的属性单下划线开头"><a href="#受保护的属性单下划线开头" class="headerlink" title="受保护的属性单下划线开头"></a>受保护的属性单下划线开头</h2></li>
</ul>
<p>大多数Python程序员反对使用双下划线进行命名操作,于是提出使用单下划线前缀编写受保护的属性,<strong>约定</strong>不对单下划线进行访问.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self , x, y ,z</span>):</span></span><br><span class="line">        self._x = x</span><br><span class="line">        self.__y = y</span><br><span class="line">        self.z = z</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        class_name = <span class="built_in">type</span>(self).__name__</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;&#125;(&#123;!r&#125;, &#123;!r&#125; , &#123;!r&#125;)&#x27;</span>.<span class="built_in">format</span>(class_name, *self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">tuple</span>(self))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self._x, self._vector__y , self.z))</span><br><span class="line">vec = vector(<span class="number">3</span>,<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">print(vec)</span><br><span class="line">print(vec.__dict__)</span><br><span class="line">print(vec._x)</span><br><span class="line"><span class="comment"># (3, 4, 5)</span></span><br><span class="line"><span class="comment"># &#123;&#x27;_x&#x27;: 3, &#x27;_vector__y&#x27;: 4, &#x27;z&#x27;: 5&#125;</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<p>上面的代码实例可以看到单下划线的属性,Python解释器并没有对其进行改名操作,就当作普通属性,这就是一种约定而已.</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_类变量与实例变量</title>
    <url>/2021/01/17/Python-%E7%B1%BB%E5%8F%98%E9%87%8F%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p><strong>类变量：</strong>可以在类的所有实例间共享的变量</p>
<p><strong>实例变量：</strong>实例化后每个实例单独拥有的变量</p>
<a id="more"></a>

<h3 id="示例：利用类变量查看以构建的实例个数"><a href="#示例：利用类变量查看以构建的实例个数" class="headerlink" title="示例：利用类变量查看以构建的实例个数"></a>示例：利用类变量查看以构建的实例个数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params"><span class="built_in">object</span></span>):</span>  </span><br><span class="line">    num_of_instance = <span class="number">0</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">        Test.num_of_instance += <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    print(Test.num_of_instance)   <span class="comment"># 0</span></span><br><span class="line">    t1 = Test(<span class="string">&#x27;jack&#x27;</span>)  </span><br><span class="line">    print(Test.num_of_instance)   <span class="comment"># 1</span></span><br><span class="line">    t2 = Test(<span class="string">&#x27;lucy&#x27;</span>)  </span><br><span class="line">    print(t1.name , t1.num_of_instance)  <span class="comment"># jack 2</span></span><br><span class="line">    print(t2.name , t2.num_of_instance)  <span class="comment"># lucy 2</span></span><br></pre></td></tr></table></figure>
<p>这里还涉及很多变量指向的问题例如以下代码：</p>
<p><strong>不可修改变量时：</strong>值传递时</p>
<p>类修改了变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=<span class="string">&quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">Person.name=<span class="string">&quot;bbb&quot;</span></span><br><span class="line">print(p1.name)  <span class="comment"># bbb</span></span><br><span class="line">print(p2.name)  <span class="comment"># bbb</span></span><br><span class="line">print(Person.name) <span class="comment">#bbb</span></span><br></pre></td></tr></table></figure>
<p>实例修改了变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=<span class="string">&quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name=<span class="string">&quot;bbb&quot;</span></span><br><span class="line">print(p1.name)  <span class="comment"># bbb</span></span><br><span class="line">print(p2.name)  <span class="comment"># aaa</span></span><br><span class="line">print(Person.name)  <span class="comment"># aaa</span></span><br></pre></td></tr></table></figure>
<p>值传递的情况下，类变量的变化同步到了实例变量，而实例变量的改变不会影响类</p>
<p><strong>变量可修改时：</strong> 引用传递时</p>
<p>类修改了变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=[]</span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">Person.name.append(<span class="number">1</span>)</span><br><span class="line">print(p1.name)  <span class="comment"># [1]</span></span><br><span class="line">print(p2.name)  <span class="comment"># [1]</span></span><br><span class="line">print(Person.name)  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure>
<p>实例修改了变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=[]</span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name.append(<span class="number">1</span>)</span><br><span class="line">print(p1.name)  <span class="comment"># [1]</span></span><br><span class="line">print(p2.name)  <span class="comment"># [1]</span></span><br><span class="line">print(Person.name)  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure>
<p>引用传递的情况下，类变量的变化同步到了实例变量，而实例变量的改变同步到了类</p>
<p>具体的分析需要查看内存分布情况，但是我没找到详细的解释，这里略过；</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_装饰器</title>
    <url>/2021/01/17/Python-%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<p><a href="https://www.runoob.com/w3cnote/python-func-decorators.html">W3C文档</a> ， 此文档与文档底下的第一个评论均很好的解释了装饰器的作用这里没有全部列出.</p>
<a id="more"></a>

<h2 id="前置知识：高阶函数与返回函数"><a href="#前置知识：高阶函数与返回函数" class="headerlink" title="前置知识：高阶函数与返回函数"></a>前置知识：高阶函数与返回函数</h2><p>Python中存在一个重要的特性，<strong>函数的参数也可以是函数</strong>，这种函数称为高阶函数。同样的Python中函数的<strong>返回值也可以是函数</strong>。</p>
<h3 id="Python内置的高阶函数："><a href="#Python内置的高阶函数：" class="headerlink" title="Python内置的高阶函数："></a>Python内置的高阶函数：</h3><p><strong>map函数：</strong>其接收一个函数与列表，并将此函数应用到列表中每一个元素上；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>(<span class="built_in">map</span>(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])))</span><br><span class="line"><span class="comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure>
<p><strong>reduce函数：</strong>接收一个函数与列表，此函数要求存在两个参数，reduce会反复调用此函数，并返回最终结果；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x , y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">reduce(add,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>])</span><br><span class="line"><span class="comment"># 25</span></span><br></pre></td></tr></table></figure>
<p><strong>filter函数：</strong>接收一个函数与列表，会根据函数，过滤掉不符合条件的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filter()过滤掉偶数：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">filter</span>(is_odd, [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">17</span>]))</span><br></pre></td></tr></table></figure>
<h3 id="Python的特性"><a href="#Python的特性" class="headerlink" title="Python的特性"></a>Python的特性</h3><h4 id="一切皆对象"><a href="#一切皆对象" class="headerlink" title="一切皆对象"></a>一切皆对象</h4><p>Python中创建函数时，既创建了一个<strong>函数对象</strong>，也创建了一个**指向函数的变量(函数名)**。</p>
<p>在Python中，函数名就是指向函数对象的变量，既然是变量那么也可以通过赋值的方式，将此函数赋值给其他变量；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hi</span>(<span class="params">name=<span class="string">&quot;yasoob&quot;</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hi &quot;</span> + name</span><br><span class="line"> </span><br><span class="line">print(hi())</span><br><span class="line"><span class="comment"># output: &#x27;hi yasoob&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 我们甚至可以将一个函数赋值给一个变量，比如</span></span><br><span class="line">greet = hi</span><br><span class="line"><span class="comment"># 我们这里没有在使用小括号，因为我们并不是在调用hi函数</span></span><br><span class="line"><span class="comment"># 而是在将它放在greet变量里头。我们尝试运行下这个</span></span><br><span class="line"> </span><br><span class="line">print(greet())</span><br><span class="line"><span class="comment"># output: &#x27;hi yasoob&#x27;</span></span><br><span class="line">print(<span class="built_in">id</span>(hi)) <span class="comment"># 2316264257600</span></span><br><span class="line">print(<span class="built_in">id</span>(greet)) <span class="comment"># 2316264257600</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> hi</span><br><span class="line">print(hi())</span><br><span class="line"></span><br><span class="line">print(greet())</span><br><span class="line"><span class="comment">#outputs: &#x27;hi yasoob&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="函数中可以构建函数"><a href="#函数中可以构建函数" class="headerlink" title="函数中可以构建函数"></a>函数中可以构建函数</h4><p>python中支持函数中构建函数，其他语言貌似也可以</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hi</span>(<span class="params">name=<span class="string">&quot;yasoob&quot;</span></span>):</span></span><br><span class="line">    print(<span class="string">&quot;now you are inside the hi() function&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span>():</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;now you are in the greet() function&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">welcome</span>():</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;now you are in the welcome() function&quot;</span></span><br><span class="line"> </span><br><span class="line">    print(greet())</span><br><span class="line">    print(welcome())</span><br><span class="line">    print(<span class="string">&quot;now you are back in the hi() function&quot;</span>)</span><br><span class="line">hi()</span><br><span class="line"><span class="comment">#output:now you are inside the hi() function</span></span><br><span class="line"><span class="comment">#       now you are in the greet() function</span></span><br><span class="line"><span class="comment">#       now you are in the welcome() function</span></span><br><span class="line"><span class="comment">#       now you are back in the hi() function</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 上面展示了无论何时你调用hi(), greet()和welcome()将会同时被调用。</span></span><br><span class="line"><span class="comment"># 然后greet()和welcome()函数在hi()函数之外是不能访问的，比如：</span></span><br><span class="line">greet()</span><br><span class="line"><span class="comment">#outputs: NameError: name &#x27;greet&#x27; is not defined</span></span><br></pre></td></tr></table></figure>
<h4 id="函数中返回函数"><a href="#函数中返回函数" class="headerlink" title="函数中返回函数"></a>函数中返回函数</h4><p>Python的特性之一，既然所有的一切均是对象，能返回数字类型就能返回函数；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hi</span>(<span class="params">name=<span class="string">&quot;yasoob&quot;</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span>():</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;now you are in the greet() function&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">welcome</span>():</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;now you are in the welcome() function&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&quot;yasoob&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> greet</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> welcome</span><br><span class="line"> </span><br><span class="line">a = hi()</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment">#outputs: &lt;function greet at 0x7f2143c01500&gt;</span></span><br><span class="line"><span class="comment">#上面清晰地展示了`a`现在指向到hi()函数中的greet()函数</span></span><br><span class="line"><span class="comment">#现在试试这个</span></span><br><span class="line"> </span><br><span class="line">print(a())</span><br><span class="line"><span class="comment">#outputs: now you are in the greet() function</span></span><br></pre></td></tr></table></figure>
<p><strong>Tips：</strong>返回函数名就是返回的函数对象的引用，加上小括号()，就是运行此函数。</p>
<h4 id="函数可以作为参数传递给另外一个函数"><a href="#函数可以作为参数传递给另外一个函数" class="headerlink" title="函数可以作为参数传递给另外一个函数"></a>函数可以作为参数传递给另外一个函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hi</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Say niHao&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doSomeingBeforeHi</span>(<span class="params">func</span>):</span></span><br><span class="line">    print(<span class="string">&quot;do Something i donot like......&quot;</span>)</span><br><span class="line">    func()</span><br><span class="line">doSomeingBeforeHi(hi)</span><br><span class="line"><span class="comment"># do Something i donot like......</span></span><br><span class="line"><span class="comment"># Say niHao</span></span><br></pre></td></tr></table></figure>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>在1.2.4中的例子就是一个简单的装饰器；</p>
<h3 id="装饰器是什么？"><a href="#装饰器是什么？" class="headerlink" title="装饰器是什么？"></a>装饰器是什么？</h3><p>装饰器本质上是一个 <strong>Python 函数或类</strong>，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的<strong>返回值也是一个函数/类对象</strong>。它经常用于有<strong>切面需求的场景</strong>，比如：<strong>插入日志、性能测试、事务处理、缓存、权限校验等场景</strong>，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</p>
<h3 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h3><h4 id="定义函数与新需求"><a href="#定义函数与新需求" class="headerlink" title="定义函数与新需求"></a>定义函数与新需求</h4><p>定义一个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;i am foo&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>现在有一个新的需求，希望可以记录下函数的执行日志，于是在代码中添加日志代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;i am foo&#x27;</span>)</span><br><span class="line">    logging.info(<span class="string">&quot;foo is running&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>如果函数 bar()、bar2() 也有类似的需求，怎么做？再写一个 logging 在 bar 函数里？这样就造成大量雷同的代码，为了减少重复写代码，我们可以这样做，重新定义一个新的函数：专门处理日志 ，日志处理完之后再执行真正的业务代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span>(<span class="params">func</span>):</span></span><br><span class="line">    logging.warn(<span class="string">&quot;%s is running&quot;</span> % func.__name__)</span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;i am foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">use_logging(foo)</span><br></pre></td></tr></table></figure>
<p>这样做逻辑上是没问题的，功能是实现了，但是我们调用的时候不再是调用真正的业务逻辑 foo 函数，而是换成了 use_logging 函数，这就破坏了原有的代码结构， 现在我们不得不每次都要把原来的那个 foo 函数作为参数传递给 use_logging 函数，那么有没有更好的方式的呢？当然有，答案就是装饰器。</p>
<h4 id="不使用-时"><a href="#不使用-时" class="headerlink" title="不使用@时"></a>不使用@时</h4><p><strong>简单装饰器</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span>(<span class="params">func</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">        logging.warn(<span class="string">&quot;%s is running&quot;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func()   <span class="comment"># 把 foo 当做参数传递进来时，执行func()就相当于执行foo()</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;i am foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">foo = use_logging(foo)  <span class="comment"># 因为装饰器 use_logging(foo) 返回的时函数对象 wrapper，这条语句相当于  foo = wrapper</span></span><br><span class="line">foo()                   <span class="comment"># 执行foo()就相当于执行 wrapper()</span></span><br></pre></td></tr></table></figure>
<p>use_logging 就是一个装饰器，它一个普通的函数，它把执行真正业务逻辑的函数 func 包裹在其中，看起来像 foo 被 use_logging 装饰了一样，use_logging 返回的也是一个函数，这个函数的名字叫 wrapper。在这个例子中，函数进入和退出时 ，被称为一个横切面，这种编程方式被称为<strong>面向切面的编程</strong></p>
<h4 id="使用-时"><a href="#使用-时" class="headerlink" title="使用@时"></a>使用@时</h4><p>@ 语法**</p>
<p>如果你接触 Python 有一段时间了的话，想必你对 @ 符号一定不陌生了，没错 @ 符号就是装饰器的语法糖，它放在函数开始定义的地方，这样就可以省略最后一步再次赋值的操作.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span>(<span class="params">func</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">        logging.warn(<span class="string">&quot;%s is running&quot;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&quot;i am foo&quot;</span>)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>如上所示，有了 @ ，我们就可以省去foo = use_logging(foo)这一句了，直接调用 foo() 即可得到想要的结果。你们看到了没有，foo() 函数不需要做任何修改，只需在定义的地方加上装饰器，调用的时候还是和以前一样，如果我们有其他的类似函数，我们可以继续调用装饰器来修饰函数，而不用重复修改函数或者增加新的封装。这样，我们就提高了程序的可重复利用性，并增加了程序的可读性。</p>
<p>装饰器在 Python 使用如此方便都要归因于 Python 的函数能像普通的对象一样能作为参数传递给其他函数，可以被赋值给其他变量，可以作为返回值，可以被定义在另外一个函数内。</p>
<h4 id="多参数时"><a href="#多参数时" class="headerlink" title="多参数时"></a>多参数时</h4><p><strong><em>args、*</em>kwargs</strong></p>
<p>可能有人问，如果我的业务逻辑函数 foo 需要参数怎么办？比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(<span class="string">&quot;i am %s&quot;</span> % name)</span><br></pre></td></tr></table></figure>
<p>我们可以在定义 wrapper 函数的时候指定参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">name</span>):</span></span><br><span class="line">        logging.warn(<span class="string">&quot;%s is running&quot;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(name)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p>这样 foo 函数定义的参数就可以定义在 wrapper 函数中。这时，又有人要问了，如果 foo 函数接收两个参数呢？三个参数呢？更有甚者，我可能传很多个。当装饰器不知道 foo 到底有多少个参数时，我们可以用 *args 来代替：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args</span>):</span></span><br><span class="line">        logging.warn(<span class="string">&quot;%s is running&quot;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p>如此一来，甭管 foo 定义了多少个参数，我都可以完整地传递到 func 中去。这样就不影响 foo 的业务逻辑了。这时还有读者会问，如果 foo 函数还定义了一些关键字参数呢？比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">name, age=<span class="literal">None</span>, height=<span class="literal">None</span></span>):</span></span><br><span class="line">    print(<span class="string">&quot;I am %s, age %s, height %s&quot;</span> % (name, age, height))</span><br></pre></td></tr></table></figure>
<p>这时，你就可以把 wrapper 函数指定关键字函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># args是一个数组，kwargs一个字典</span></span><br><span class="line">        logging.warn(<span class="string">&quot;%s is running&quot;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"><span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<h4 id="装饰器本身带参数的情况"><a href="#装饰器本身带参数的情况" class="headerlink" title="装饰器本身带参数的情况"></a>装饰器本身带参数的情况</h4><p><strong>带参数的装饰器</strong></p>
<p>装饰器还有更大的灵活性，例如带参数的装饰器，在上面的装饰器调用中，该装饰器接收唯一的参数就是执行业务的函数 foo 。装饰器的语法允许我们在调用时，提供其它参数，比如@decorator(a)。这样，就为装饰器的编写和使用提供了更大的灵活性。比如，我们可以在装饰器中指定日志的等级，因为不同业务函数可能需要的日志级别是不一样的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span>(<span class="params">level</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="keyword">if</span> level == <span class="string">&quot;warn&quot;</span>:</span><br><span class="line">                logging.warn(<span class="string">&quot;%s is running&quot;</span> % func.__name__)</span><br><span class="line">            <span class="keyword">elif</span> level == <span class="string">&quot;info&quot;</span>:</span><br><span class="line">                logging.info(<span class="string">&quot;%s is running&quot;</span> % func.__name__)</span><br><span class="line">            <span class="keyword">return</span> func(*args)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging(<span class="params">level=<span class="string">&quot;warn&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">name=<span class="string">&#x27;foo&#x27;</span></span>):</span></span><br><span class="line">    print(<span class="string">&quot;i am %s&quot;</span> % name)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>上面的 use_logging 是允许带参数的装饰器。它实际上是对原有装饰器的一个函数封装，并返回一个装饰器。我们可以将它理解为一个含有参数的闭包。当我 们使用@use_logging(level=”warn”)调用的时候，Python 能够发现这一层的封装，并把参数传递到装饰器的环境中。</p>
<p><strong>@use_logging(level=”warn”)</strong> 等价于 <strong>@decorator</strong></p>
<h4 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h4><p><strong>类装饰器</strong></p>
<p>没错，装饰器不仅可以是函数，还可以是类，相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。使用类装饰器主要依靠类的__call__方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func</span>):</span></span><br><span class="line">        self._func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;class decorator runing&#x27;</span>)</span><br><span class="line">        self._func()</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;class decorator ending&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Foo</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bar()</span><br><span class="line">functools.wraps</span><br></pre></td></tr></table></figure>
<p>使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了，比如函数的docstring、__name__、参数列表，先看例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logged</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_logging</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span> func.__name__      <span class="comment"># 输出 &#x27;with_logging&#x27;</span></span><br><span class="line">        <span class="built_in">print</span> func.__doc__       <span class="comment"># 输出 None</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> with_logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数</span></span><br><span class="line"><span class="meta">@logged</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">   <span class="string">&quot;&quot;&quot;does some math&quot;&quot;&quot;</span></span><br><span class="line">   <span class="keyword">return</span> x + x * x</span><br><span class="line"></span><br><span class="line">logged(f)</span><br></pre></td></tr></table></figure>
<p>不难发现，函数 f 被with_logging取代了，当然它的docstring，__name__就是变成了with_logging函数的信息了。好在我们有functools.wraps，wraps本身也是一个装饰器，它能把原函数的元信息拷贝到装饰器里面的 func 函数中，这使得装饰器里面的 func 函数也有和原函数 foo 一样的元信息了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logged</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_logging</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span> func.__name__      <span class="comment"># 输出 &#x27;f&#x27;</span></span><br><span class="line">        <span class="built_in">print</span> func.__doc__       <span class="comment"># 输出 &#x27;does some math&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> with_logging</span><br><span class="line"></span><br><span class="line"><span class="meta">@logged</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">   <span class="string">&quot;&quot;&quot;does some math&quot;&quot;&quot;</span></span><br><span class="line">   <span class="keyword">return</span> x + x * x</span><br></pre></td></tr></table></figure>
<h4 id="多装饰器的执行循序"><a href="#多装饰器的执行循序" class="headerlink" title="多装饰器的执行循序"></a>多装饰器的执行循序</h4><p><strong>装饰器顺序</strong></p>
<p>一个函数还可以同时定义多个装饰器，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@a</span></span><br><span class="line"><span class="meta">@b</span></span><br><span class="line"><span class="meta">@c</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span> ():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>它的执行顺序是从里到外，最先调用最里层的装饰器，最后调用最外层的装饰器，它等效于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = a(b(c(f)))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>B树</title>
    <url>/2021/01/24/B%E6%A0%91/</url>
    <content><![CDATA[<p>B树是一种多路查找树，相关的定义与解释解释如下。</p>
<a id="more"></a>

<blockquote>
<p><a href="https://www.nowcoder.com/test/question/done?tid=33839050&qid=14850#summary">原文地址</a></p>
</blockquote>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">是一种多路搜索树（并不是二叉的）：</span><br><span class="line"></span><br><span class="line">       1. 定义任意非叶子结点最多只有 M 个儿子；且 M&gt;2 ；</span><br><span class="line"></span><br><span class="line">       2. 根结点的儿子数为 [2, M] ；</span><br><span class="line"></span><br><span class="line">       3. 除根结点以外的非叶子结点的儿子数为 [M&#x2F;2, M] ；</span><br><span class="line"></span><br><span class="line">       4. 每个结点存放至少 M&#x2F;2-1 （取上整）和至多 M-1 个关键字；（至少 2 个关键字）</span><br><span class="line"></span><br><span class="line">       5. 非叶子结点的关键字个数 &#x3D; 指向儿子的指针个数 -1 ；</span><br><span class="line"></span><br><span class="line">       6. 非叶子结点的关键字： K[1], K[2], …, K[M-1] ；且 K[i] &lt; K[i+1] ；</span><br><span class="line"></span><br><span class="line">       7. 非叶子结点的指针： P[1], P[2], …, P[M] ；其中 P[1] 指向关键字小于 K[1] 的子树， P[M] 指向关键字大于 K[M-1] 的子树，其它 P[i] 指向关键字属于 (K[i-1], K[i]) 的子树；</span><br><span class="line"></span><br><span class="line">       8. 所有叶子结点位于同一层；</span><br><span class="line"></span><br><span class="line">        如：（ M&#x3D;3 ）</span><br></pre></td></tr></table></figure>
<p><img src="http://images.cnblogs.com/cnblogs_com/syxchina/201110/201110012318587145.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> B- 树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；</span><br><span class="line"></span><br><span class="line">B- 树的特性：</span><br><span class="line"></span><br><span class="line">       1. 关键字集合分布在整颗树中；</span><br><span class="line"></span><br><span class="line">       2. 任何一个关键字出现且只出现在一个结点中；</span><br><span class="line"></span><br><span class="line">       3. 搜索有可能在非叶子结点结束；</span><br><span class="line"></span><br><span class="line">       4. 其搜索性能等价于在关键字全集内做一次二分查找；</span><br><span class="line"></span><br><span class="line">       5. 自动层次控制；</span><br><span class="line"></span><br><span class="line">        由于限制了除根结点以外的非叶子结点，至少含有 M&#x2F;2 个儿子，确保了结点的至少利用率，其最底搜索性能为：</span><br></pre></td></tr></table></figure>
<p><img src="http://images.cnblogs.com/cnblogs_com/syxchina/201110/201110012318589936.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其中， M 为设定的非叶子结点最多子树个数， N 为关键字总数；</span><br><span class="line"></span><br><span class="line">      所以 B- 树的性能总是等价于二分查找（与 M 值无关），也就没有 B 树平衡的问题；</span><br><span class="line"></span><br><span class="line">      由于 M&#x2F;2 的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占 M&#x2F;2 的结点；删除结点时，需将两个不足 M&#x2F;2 的兄弟结点合并；</span><br></pre></td></tr></table></figure>
<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B+ 树是 B- 树的变体，也是一种多路搜索树：</span><br><span class="line"></span><br><span class="line">      1. 其定义基本与 B- 树同，除了：</span><br><span class="line"></span><br><span class="line">      2. 非叶子结点的子树指针与关键字个数相同；</span><br><span class="line"></span><br><span class="line">      3. 非叶子结点的子树指针 P[i] ，指向关键字值属于 [K[i], K[i+1]) 的子树（ B- 树是开区间）；</span><br><span class="line"></span><br><span class="line">      5. 为所有叶子结点增加一个链指针；</span><br><span class="line"></span><br><span class="line">      6. 所有关键字都在叶子结点出现；</span><br><span class="line"></span><br><span class="line">       如：（ M&#x3D;3 ）</span><br></pre></td></tr></table></figure>
<p><img src="http://images.cnblogs.com/cnblogs_com/syxchina/201110/20111001231859983.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B+ 的搜索与 B- 树也基本相同，区别是 B+ 树只有达到叶子结点才命中（ B- 树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</span><br><span class="line"></span><br><span class="line">      B+ 的特性：</span><br><span class="line"></span><br><span class="line">      1. 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</span><br><span class="line"></span><br><span class="line">      2. 不可能在非叶子结点命中；</span><br><span class="line"></span><br><span class="line">      3. 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</span><br><span class="line"></span><br><span class="line">      4. 更适合文件索引系统；</span><br></pre></td></tr></table></figure>


<h2 id="B-树-2"><a href="#B-树-2" class="headerlink" title="B*树"></a>B*树</h2><p>是 B+ 树的变体，在 B+ 树的非根和非叶子结点再增加指向兄弟的指针；</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/syxchina/201110/201110012319014688.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B* 树定义了非叶子结点关键字个数至少为 (2&#x2F;3)*M ，即块的最低使用率为 2&#x2F;3 （代替 B+ 树的 1&#x2F;2 ）；</span><br><span class="line"></span><br><span class="line">      B+ 树的分裂：当一个结点满时，分配一个新的结点，并将原结点中 1&#x2F;2 的数据复制到新结点，最后在父结点中增加新结点的指针； B+ 树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</span><br><span class="line"></span><br><span class="line">      B* 树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制 1&#x2F;3 的数据到新结点，最后在父结点增加新结点的指针；</span><br><span class="line"></span><br><span class="line">       所以， B* 树分配新结点的概率比 B+ 树要低，空间使用率更高；</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_鸭子类型</title>
    <url>/2021/01/17/Python-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>最近在学习流畅的Python一书时,经常看到这样的名词”鸭子类型”.而对它的解释是:<strong>一只鸟如果长得像鸭子,走路像鸭子,游泳也像鸭子,那么它可以认为就是一只鸭子</strong>.</p>
<a id="more"></a>

<p>这句话乍看起来有些无厘头.于是看了下大家对鸭子类型的解释,总结如下:</p>
<p>上面标粗的这句话表明一件事:只关注的该对象的行为,而不关注该对象的类型.这是Python的特点,是一门动态语言.</p>
<p><strong>Python默认鸭子类型的示例</strong></p>
<p>像JAVA,C这种静态语言,传入对象后需要检查对象的类型,类型不符合预期会报错.而Python中并不会对类型进行限制.在日常使用中其实已经或多或少的涉及到.例如各种魔法方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">listTemp = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">len</span>(listTemp)</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">tupleTemp = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">len</span>(tupleTemp)</span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<p>不管你传入的列表或者元组甚至是你自己定义的序列类别,都可以正确的输出其长度,只要你实现了__len__方法.</p>
<p><strong>自定义鸭子类型示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;BiuBiuBiu Running One!!!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Infor</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;BiuBiuBiu Running Two!!!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runT</span>(<span class="params">Student</span>):</span></span><br><span class="line">    Student.run()</span><br><span class="line"></span><br><span class="line">StuA=Student()</span><br><span class="line">runT(StuA)</span><br><span class="line"><span class="comment"># BiuBiuBiu Running One!!!</span></span><br><span class="line"></span><br><span class="line">infA=Infor()</span><br><span class="line">runT(infA)</span><br><span class="line"><span class="comment"># BiuBiuBiu Running Two!!!</span></span><br></pre></td></tr></table></figure>
<p>传入对象,只关注对象的行为能不能实现,不关注对象的类型.其实讲到这里鸭子类型就已经很明了啦.</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2021/01/24/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/kyoner/p/11080078.html">参考博客</a></p>
</blockquote>
<p>第二次刷Leetcode_034题目时，涉及到二分查找左右边界时，又出现了算法理解不清楚的问题。发现第一次也并没有去总结，这里总结下。</p>
<a id="more"></a>

<p>二分查找的精髓就是对于细节的把控，搜索空间的定义、左右指针的变换形式，左右指针在左右边界中分别代表的含义等等。都需要细致的理解才可以。</p>
<p>常见的二分查找一个应用场景我们可以分为三种：1.查找一个数 2.查找左边界 3.查找右边界。</p>
<h2 id="二分查找基本框架"><a href="#二分查找基本框架" class="headerlink" title="二分查找基本框架"></a>二分查找基本框架</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码框架就是我们在一开始接触二分查找时所采用的框架形式。</p>
<h2 id="寻找一个数"><a href="#寻找一个数" class="headerlink" title="寻找一个数"></a>寻找一个数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上时寻找一个数时采用的代码，其有几个常见的疑问点：</p>
<p><strong>左右指针的初始值：</strong> 通常左指针初始化均为0，而右指针经常会看到初始化为$right = len(nums)$ 或者 $right = len(nums) - 1$.这两种写法，我们该如何理解呢？队之后左右指针的更新分别又存在什么样子的影响呢？</p>
<p><strong>答：</strong> 左右指针其实就是middle可能遍历的位置范围，我们可以将左右指针<strong>看作middle的搜索范围</strong>。那么根据初始化右指针的情况不同可以</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>二维前缀和</title>
    <url>/2021/01/24/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/solution/yuan-su-he-xiao-yu-deng-yu-yu-zhi-de-zheng-fang-2/">Leetcode讲解</a></p>
<p>在二维数组中涉及到大量计算某区域的算法题目，为了降低时间复杂度，对数组区域进行记忆是必不可少的，这也就提出了二维数组的前缀和（P）概念。</p>
<a id="more"></a>

<p>在得到P的同时，我们可以在 $O（1）$ 的时间复杂度内，得到任意矩形区域的和。</p>
<h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><p><strong>假设</strong>二维数组的 $ A $ 的大小为 $ m * n $ ,其数组下标的范围为$ [1 \dots m] , [1\dots n]$.</p>
<blockquote>
<p>数组下标范围与真实程序中的范围存在偏差，这样写主要为了与后面P数组对应，容易理解。</p>
</blockquote>
<p>数组 $ P $ 是 $ A $ 的前缀和数组，$ P $ 中每一个元素 $ P[i][j] $ 均符合以下定义：</p>
<ul>
<li>如果 $ i , j  $ 均大于 0 ，那么 $ P[i][j] $ 表示数组 $A $ 中以 $ [1,1] $为左上角 ， $ [i , j] $ 为右下角的矩形区域的元素和。</li>
<li>否则，$ P[i][j] $ 等于 0 .</li>
</ul>
<blockquote>
<p>在这里我们就可以发现，$ P $ 数组其实比 $ A $ 数组多了一行一列，并且是在第一行前、第一列前添加了 0 行/列， 这么做是为了计算的统一性。</p>
</blockquote>
<p><strong>任意矩形区域的计算</strong></p>
<p>在得到完整的$ P  $ 数组之后，我们可以在常数时间内得到你想要的<strong>任意的矩形区域</strong>的元素和。我们假设其矩形区域的右上角为 $ (x_1 , y_1) $ ,左下角为 $(x_2 , y_2) $ . 有<br>$$<br>sum = A[x_1\dots x_2][y_1 \dots y_2] = P[x_2][y_2] - P[x_1-1][y_2] - P[x_2][y_1-1] + P[x_1 - 1][y_1 -1]<br>$$</p>
<blockquote>
<p>上式中我们看到其大量的采用 了 - 1的形式，在面对边界时如果P数组不扩充，就会出现数组越界问题。</p>
</blockquote>
<p><strong>证明上式：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">以下图为例，当 A 的大小为 8 * 5，需要求和的矩形区域（深绿色部分）的左上角为 (3, 2)，右下角为 (5, 5) 时，该矩形区域的元素之和为 P[5][5] - P[2][5] - P[5][1] + P[2][1]。</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.leetcode-cn.com/3f83532ef2affcd3532c0b099a3e107ee8e494d0ca100fa81b097460f2167f73-1292-1%E7%9A%84%E5%89%AF%E6%9C%AC%202.png"></p>
<p><strong>数组P的获取</strong></p>
<p>上面讲了数组$ P $ 的应用，那么数组 $P  $ 到底是怎么得到的呢？</p>
<p>还是利用上面的式子有：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">我们按照行优先的顺序依次计算数组 P 中的每个元素，即当我们在计算 P[i][j] 时，数组 P 的前 i - 1 行，以及第 i 行的前 j - 1 个元素都已经计算完成。此时我们可以考虑 (i, j) 这个 1 * 1 的矩形区域，根据上面的等式，有：</span><br><span class="line">A[i][j] = P[i][j] - P[i - 1][j] - P[i][j - 1] + P[i - 1][j - 1]</span><br><span class="line">由于等式中的 A[i][j]，P[i - 1][j]，P[i][j - 1] 和 P[i - 1][j - 1] 均已知，我们可以通过：</span><br><span class="line">P[i][j] = P[i - 1][j] + P[i][j - 1] - P[i - 1][j - 1] + A[i][j]</span><br></pre></td></tr></table></figure>
<p><strong>代码实现</strong></p>
<blockquote>
<p>注意真实数组下标问题</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPresum</span>(<span class="params">nums</span>):</span></span><br><span class="line">    m = <span class="built_in">len</span>(nums)</span><br><span class="line">    n = <span class="built_in">len</span>(nums[<span class="number">0</span>])</span><br><span class="line">    P = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>) ]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> , m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            P[i][j] = nums[i-<span class="number">1</span>][j-<span class="number">1</span>] + P[i-<span class="number">1</span>][j] + P[i][j-<span class="number">1</span>] - P[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> P</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的三种遍历方式</title>
    <url>/2021/01/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>学习二叉树时，前序中序后序遍历方式是基础知识。最近再刷Leetcode时，发现很多遍历实现的基本本方式已经忘记了，这里将各种方式的原理与代码实现整理如下；</p>
<a id="more"></a>

<h2 id="三种遍历方式原理"><a href="#三种遍历方式原理" class="headerlink" title="三种遍历方式原理"></a>三种遍历方式原理</h2><p>三种遍历方式简单的一句话就是：根左右、左根右、左右根。</p>
<h3 id="相关图示："><a href="#相关图示：" class="headerlink" title="相关图示："></a>相关图示：</h3><blockquote>
<p><a href="https://www.pianshen.com/article/7106254596/">图片来源</a></p>
</blockquote>
<p>前序：<img src="https://i.loli.net/2021/01/24/X9IVJevzxlHY7wk.gif"></p>
<ul>
<li>结果：ABDHIEJCFKG</li>
</ul>
<p>中序：<img src="https://i.loli.net/2021/01/24/7A1YGlJVsypuQUh.gif"></p>
<ul>
<li>结果：HDIBEJAFKCG</li>
</ul>
<p>后序：<img src="https://i.loli.net/2021/01/24/EPcs3vLiAgp794M.gif"></p>
<ul>
<li>结果：HIDJEBKFGCA</li>
</ul>
<h3 id="如何理解前中后序"><a href="#如何理解前中后序" class="headerlink" title="如何理解前中后序"></a>如何理解前中后序</h3><p>理解前中后序的算法本身并不难，很多人直接就可以把前中后序算法结果写在纸面上。但还是要简单的说下过程：</p>
<p>首先看一张遍历图示：</p>
<p><img src="https://i.loli.net/2021/01/24/t31mXoeIgaqLcGW.jpg"></p>
<p>遍历图示显示，遍历的顺序为<strong>从根节点出发，先左子树后右子树。</strong>除了根节点与空节点外<strong>每一个节点均有三个入箭头</strong>，这三个如箭头分别表示：<strong>从父节点来、从左子树返回、从右子树返回</strong>。我们可以认为在<strong>递归算法中</strong>，每个节点均被遍历了三遍，但是哪一遍<strong>访问节点</strong>，决定了前、中、后序算法。</p>
<blockquote>
<p>非递归算法中，是否遍历了三遍、我无法确定。就算是使用栈实现遍历时，不同的算法策略也不尽相同。</p>
</blockquote>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><h4 id="节点定义："><a href="#节点定义：" class="headerlink" title="节点定义："></a>节点定义：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h4 id="构成树代码"><a href="#构成树代码" class="headerlink" title="构成树代码"></a>构成树代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = TreeNode(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">B = TreeNode(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">C = TreeNode(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">D = TreeNode(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">E = TreeNode(<span class="string">&quot;E&quot;</span>)</span><br><span class="line">F = TreeNode(<span class="string">&quot;F&quot;</span>)</span><br><span class="line">G = TreeNode(<span class="string">&quot;G&quot;</span>)</span><br><span class="line">H = TreeNode(<span class="string">&quot;H&quot;</span>)</span><br><span class="line">I = TreeNode(<span class="string">&quot;I&quot;</span>)</span><br><span class="line">J = TreeNode(<span class="string">&quot;J&quot;</span>)</span><br><span class="line">K = TreeNode(<span class="string">&quot;K&quot;</span>)</span><br><span class="line">A.left = B</span><br><span class="line">A.right = C</span><br><span class="line">B.left = D</span><br><span class="line">B.right = E</span><br><span class="line">D.left = H</span><br><span class="line">D.right = I</span><br><span class="line">E.right = J</span><br><span class="line">C.left = F</span><br><span class="line">C.right = G</span><br><span class="line">F.right = K</span><br></pre></td></tr></table></figure>


<h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><h5 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">frontorderTraversal</span>(<span class="params">root</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frontorder</span>(<span class="params">tree</span>):</span></span><br><span class="line">        res.append(tree.val)</span><br><span class="line">        <span class="keyword">if</span> tree.left:</span><br><span class="line">            frontorder(tree.left)</span><br><span class="line">        <span class="keyword">if</span> tree.right:</span><br><span class="line">            frontorder(tree.right)</span><br><span class="line">    frontorder(root)</span><br><span class="line">    <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure>
<h5 id="通用框架——先序"><a href="#通用框架——先序" class="headerlink" title="通用框架——先序"></a>通用框架——先序</h5><blockquote>
<p>这里的通用框架是在刷leetcode过程中，发现的一种类似于递归方式的，只需要更改部分代码，即可从先序转为中序或后序。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">frontorderTraversal</span>(<span class="params"> root</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    1. 递归法可以一行代码完成，无需讨论；</span></span><br><span class="line"><span class="string">    2. 迭代法一般需要通过一个栈保存节点顺序，我们这里直接使用列表</span></span><br><span class="line"><span class="string">      - 首先，我要按照中序遍历的顺序存入栈，这边用的逆序，方便从尾部开始处理</span></span><br><span class="line"><span class="string">      - 在存入栈时加入一个是否需要深化的参数</span></span><br><span class="line"><span class="string">      - 在回头取值时，这个参数应该是否，即直接取值</span></span><br><span class="line"><span class="string">      - 简单调整顺序，即可实现前序和后序遍历</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 迭代法</span></span><br><span class="line">    result = []</span><br><span class="line">    stack = [(<span class="number">1</span>, root)]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        go_deeper, node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> go_deeper:</span><br><span class="line">            <span class="comment"># 左右节点还需继续深化，并且入栈是先右后左</span></span><br><span class="line">            stack.append((<span class="number">1</span>, node.right))</span><br><span class="line">            <span class="comment"># 节点自身已遍历，回头可以直接取值</span></span><br><span class="line">            </span><br><span class="line">            stack.append((<span class="number">1</span>, node.left))</span><br><span class="line">            stack.append((<span class="number">0</span>, node))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(node.val)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>


<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><h5 id="递归：-1"><a href="#递归：-1" class="headerlink" title="递归："></a>递归：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">root</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">tree</span>):</span></span><br><span class="line">        <span class="keyword">if</span> tree.left:</span><br><span class="line">            inorder(tree.left)</span><br><span class="line">        res.append(tree.val)</span><br><span class="line">        <span class="keyword">if</span> tree.right:</span><br><span class="line">            inorder(tree.right)</span><br><span class="line">    inorder(root)</span><br><span class="line">    <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure>
<h5 id="通用框架——中序"><a href="#通用框架——中序" class="headerlink" title="通用框架——中序"></a>通用框架——中序</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params"> root</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    stack = [(<span class="number">1</span>, root)]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        go_deeper, node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> go_deeper:</span><br><span class="line">            <span class="comment"># 左右节点还需继续深化，并且入栈是先右后左</span></span><br><span class="line">            stack.append((<span class="number">1</span>, node.right))</span><br><span class="line">            <span class="comment"># 节点自身已遍历，回头可以直接取值</span></span><br><span class="line">            stack.append((<span class="number">0</span>, node))</span><br><span class="line">            stack.append((<span class="number">1</span>, node.left))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(node.val)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h5 id="教材法"><a href="#教材法" class="headerlink" title="教材法"></a>教材法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = []</span><br><span class="line">        curr = root</span><br><span class="line">        <span class="keyword">while</span>  stack  <span class="keyword">or</span> curr  :</span><br><span class="line">            <span class="comment"># 这里面写while也可以，或者写if都是可以的</span></span><br><span class="line">            <span class="comment"># 这里的代码有优化过</span></span><br><span class="line">            <span class="keyword">while</span>(curr):</span><br><span class="line">                stack.append(curr)</span><br><span class="line">                curr = curr.left</span><br><span class="line">            curr = stack.pop()</span><br><span class="line">            res.append(curr.val)</span><br><span class="line">            curr = curr.right     </span><br><span class="line">        <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure>


<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归:"></a>递归:</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backorderTraversal</span>(<span class="params">root</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backorder</span>(<span class="params">tree</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> tree.left:</span><br><span class="line">            backorder(tree.left)</span><br><span class="line">        <span class="keyword">if</span> tree.right:</span><br><span class="line">            backorder(tree.right)</span><br><span class="line">        res.append(tree.val)</span><br><span class="line">    backorder(root)</span><br><span class="line">    <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure>
<h5 id="通用框架——后序"><a href="#通用框架——后序" class="headerlink" title="通用框架——后序"></a>通用框架——后序</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backorderTraversal</span>(<span class="params"> root</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    stack = [(<span class="number">1</span>, root)]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        go_deeper, node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> go_deeper:</span><br><span class="line">            stack.append((<span class="number">0</span>, node))</span><br><span class="line">            <span class="comment"># 左右节点还需继续深化，并且入栈是先右后左</span></span><br><span class="line">            stack.append((<span class="number">1</span>, node.right))</span><br><span class="line">            <span class="comment"># 节点自身已遍历，回头可以直接取值</span></span><br><span class="line">            </span><br><span class="line">            stack.append((<span class="number">1</span>, node.left))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(node.val)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀树</title>
    <url>/2021/01/24/%E5%89%8D%E7%BC%80%E6%A0%91/</url>
    <content><![CDATA[<h2 id="前缀树的概念"><a href="#前缀树的概念" class="headerlink" title="前缀树的概念"></a>前缀树的概念</h2><blockquote>
<p><a href="https://www.jianshu.com/p/e9610f67b54c">参考地址</a></p>
</blockquote>
<p>前缀树也称之为单词查找树，Trie树，是一种N叉树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。<strong>它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高</strong>。</p>
<a id="more"></a>

<p><img src="D:\nutStore\Learning\leetcode\pictures\trie.webp"></p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符；</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><blockquote>
<p>可以最大限度地减少无谓的字符串比较，故可以用于词频统计和大量字符串排序。</p>
<p>　　跟哈希表比较：</p>
<p>　　　　1，最坏情况时间复杂度比hash表好</p>
<p>　　　　2，没有冲突，除非一个key对应多个值（除key外的其他信息）</p>
<p>　　　　3，自带排序功能（类似Radix Sort），中序遍历trie可以得到排序。</p>
<p>1，虽然不同单词共享前缀，但其实trie是一个以空间换时间的算法。其每一个字符都可能包含至多字符集大小数目的指针（不包含卫星数据）。</p>
<p>每个结点的子树的根节点的组织方式有几种。1&gt;如果默认包含所有字符集，则查找速度快但浪费空间（特别是靠近树底部叶子）。2&gt;如果用链接法(如左儿子右兄弟)，则节省空间但查找需顺序（部分）遍历链表。3&gt;<em>alphabet reduction</em>: 减少字符宽度以减少字母集个数。,4&gt;对字符集使用bitmap，再配合链接法。</p>
<p>2，如果数据存储在外部存储器等较慢位置，Trie会较hash速度慢（hash访问O(1)次外存，Trie访问O(树高)）。</p>
<p>3，长的浮点数等会让链变得很长。可用bitwise trie改进。</p>
</blockquote>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>前缀树本身是一种<strong>数据结构</strong>，是一种树形结构。常见的实现方式包括：1.字典 2.数组。通常其节点由两部分组成：</p>
<ol>
<li>字符数据</li>
<li>单词尾椎标识</li>
</ol>
<h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><h3 id="搜索操作"><a href="#搜索操作" class="headerlink" title="搜索操作"></a>搜索操作</h3><ol>
<li>从根结点开始一次搜索；</li>
<li>取得要查找关键词的第一个字母，并根据该字母选择对应的子树并转到该子树继续进行检索；</li>
<li>在相应的子树上，取得要查找关键词的第二个字母,并进一步选择对应的子树进行检索。</li>
<li>迭代过程……</li>
<li>在某个结点处，关键词的所有字母已被取出，则读取附在该结点上的信息，即完成查找。</li>
</ol>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><ol>
<li>从头到尾遍历字符串的每一个字符</li>
<li>从根节点开始插入，若该字符存在，那就不用插入新节点，要是不存在，则插入新节点</li>
<li>然后顺着插入的节点一直按照上述方法插入剩余的节点</li>
<li>为了统计每一个字符串出现的次数，应该在最后一个节点插入后occurances++，表示这个字符串出现的次数增加一次</li>
</ol>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h4 id="字典实现"><a href="#字典实现" class="headerlink" title="字典实现"></a>字典实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.root = &#123;<span class="string">&quot;End&quot;</span>:<span class="literal">False</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Inserts a word into the trie.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        curNode = self.root</span><br><span class="line">        <span class="keyword">for</span>  c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> curNode.keys()  :</span><br><span class="line">                curNode[c] = &#123;<span class="string">&quot;End&quot;</span>:<span class="literal">False</span>&#125;</span><br><span class="line">            curNode = curNode[c]</span><br><span class="line">        curNode[<span class="string">&quot;End&quot;</span>] = <span class="literal">True</span>     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if the word is in the trie.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        curNode = self.root</span><br><span class="line">        <span class="keyword">for</span>  c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> curNode.keys()  :</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            curNode = curNode[c]</span><br><span class="line">        <span class="keyword">if</span> curNode[<span class="string">&quot;End&quot;</span>] :</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        curNode = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> curNode.keys():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curNode = curNode[c]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h4 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.root = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">27</span>) ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Inserts a word into the trie.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        curNode = self.root</span><br><span class="line">        <span class="keyword">for</span>  c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> curNode[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)] ==<span class="number">0</span>  :</span><br><span class="line">                curNode[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)] = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">27</span>) ]</span><br><span class="line">            curNode = curNode[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)]</span><br><span class="line">        curNode[<span class="number">26</span>] = <span class="literal">True</span>     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if the word is in the trie.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        curNode = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> curNode[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curNode = curNode[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)]</span><br><span class="line">        <span class="keyword">if</span> curNode[<span class="number">26</span>] :</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        curNode = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> curNode[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curNode = curNode[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序简介与用处</title>
    <url>/2021/01/24/%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%80%E4%BB%8B%E4%B8%8E%E7%94%A8%E5%A4%84/</url>
    <content><![CDATA[<p>堆排序实在数据结构中常见的排序算法，但许久未看已经忘得差不多啦。这里简单的将相关概念记录如下：</p>
<a id="more"></a>

<blockquote>
<p>[参考博客]（<a href="https://www.cnblogs.com/lanhaicode/p/10546257.html%EF%BC%89">https://www.cnblogs.com/lanhaicode/p/10546257.html）</a></p>
</blockquote>
<h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p><strong>堆是利用完全二叉树的结构进行维护的一位数组</strong>，我们可以将其看作是一维数组也可以看作是完全二叉树，物理上是线性结构，理论上是非线性结构。</p>
<p><strong>大顶堆</strong>：每个节点值<strong>大于或等于</strong>左右子节点的值<br><strong>小顶堆</strong>：每个节点值<strong>小于或等于</strong>左右子节点的值<br>这也是堆最重要的特性</p>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p><img src="https://i.loli.net/2020/05/03/aueKbsSfq5Ux8d2.png"></p>
<p>我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子.<img src="https://i.loli.net/2020/05/03/cQMLjeoiRzyCrvX.png"></p>
<p><strong>公式定义：</strong></p>
<p><strong>大顶堆：</strong>arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2] </p>
<p><strong>小顶堆：</strong>arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2] </p>
<h2 id="相关易混淆概念"><a href="#相关易混淆概念" class="headerlink" title="相关易混淆概念"></a>相关易混淆概念</h2><p><strong>平衡树</strong>：比如AVL、红黑树等，其要求左子树节点&lt;根&lt;右子树节点，并且左右子树均符合此定义。也就是说其<strong>整棵树都是有序</strong>的。</p>
<p><strong>为什么不用树存储而使用数组：</strong>1.树存储本身浪费空间 2.堆逻辑上为完全二叉树，这对于数组而言不浪费空间。</p>
<p><strong>堆不适合搜索：</strong>虽然二叉树是适合搜索的，但是堆并不合适，这也是堆部分有序造成的困扰。</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是堆最常见的应用方式，堆排序的过程由三个步骤迭代完成。</p>
<ol>
<li><p>堆的构建</p>
<blockquote>
<p>初始堆的构建，是堆所有的非叶子节点进行调整，时间复杂度为$ O(n) $，自下而上</p>
</blockquote>
</li>
<li><p>出堆</p>
</li>
<li><p>堆调整</p>
<blockquote>
<p>堆调整只需要更改部分节点变化的节点即可，时间复杂度为$ O(log(n)) $ ,是自上而下的</p>
</blockquote>
<p><strong>升序</strong> ： 使用大顶堆</p>
<blockquote>
<p>每个结点的值都<strong>大于</strong>或<strong>等于</strong>其左右孩子结点的值，我们把<strong>大顶堆构建完毕后根节点的值一定是最大的，然后把根节点的和最后一个元素（也可以说最后一个节点）交换位置，那么末尾元素此时就是最大元素了（理解这点很重要）</strong></p>
</blockquote>
<ol>
<li>先n个元素的无序序列，构建成大顶堆</li>
<li>将根节点与最后一个元素交换位置，（<strong>将最大元素”沉”到数组末端</strong>）</li>
<li>交换过后可能不再满足大顶堆的条件，所以需要将剩下的n-1个元素重新构建成大顶堆</li>
<li>重复第二步、第三步直到整个数组排序完成</li>
</ol>
<p><strong>降序</strong> :使用小顶堆</p>
</li>
</ol>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><blockquote>
<p>代码中展示了通过一个大顶堆,构建升序的过程,具体的展示可以见 排序算法总结.md,gif图生动的展示了过程.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建大顶堆的节点交换函数,作为辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oneStep</span>(<span class="params">nums , n , i</span>):</span></span><br><span class="line">    index = i</span><br><span class="line">    left = i*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    right = i*<span class="number">2</span> + <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; n <span class="keyword">and</span> nums[left] &gt; nums[index]:</span><br><span class="line">        index = left</span><br><span class="line">    <span class="keyword">if</span> right &lt; n <span class="keyword">and</span> nums[right] &gt; nums[index]:</span><br><span class="line">        index = right</span><br><span class="line">    <span class="keyword">if</span> index != i:</span><br><span class="line">        nums[i] , nums[index] = nums[index] , nums[i]</span><br><span class="line">        oneStep(nums , n , index)</span><br><span class="line"><span class="comment"># 构建堆函数,自下而上</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildHeap</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)//<span class="number">2</span>-<span class="number">1</span> , -<span class="number">1</span> , -<span class="number">1</span>):</span><br><span class="line">        oneStep(nums , <span class="built_in">len</span>(nums) , i)</span><br><span class="line">    </span><br><span class="line">nums = [<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>]</span><br><span class="line">buildHeap(nums)</span><br><span class="line"><span class="comment"># 不断的出堆,堆调整(自上而下)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    nums[<span class="number">0</span>] , nums[<span class="built_in">len</span>(nums)-<span class="number">1</span>-i] = nums[<span class="built_in">len</span>(nums)-<span class="number">1</span>-i] ,nums[<span class="number">0</span>]</span><br><span class="line">    oneStep(nums , <span class="built_in">len</span>(nums)-<span class="number">1</span>-i , <span class="number">0</span>)</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划——股票专题解法</title>
    <url>/2021/01/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E8%82%A1%E7%A5%A8%E4%B8%93%E9%A2%98%E8%A7%A3%E6%B3%95/</url>
    <content><![CDATA[<p>我自己对股票问题经常打怵，特将相关算法框架与相关题目解读总结如下：</p>
<a id="more"></a>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/">参考Leetcode解释</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>像动态规划的思想我之前是有总结过的，但是在应用方面还是很薄弱。我个人并不认为是理论的不清晰，更多的情况是由于状态的定义以及状态转移方程推导这两方面的问题，甚至有时需要将状态转移方程转换为递推式才能够更好的解决问题。</p>
<h2 id="动态规划之穷举"><a href="#动态规划之穷举" class="headerlink" title="动态规划之穷举"></a>动态规划之穷举</h2><p>不管是动态规划也好，贪心算法也罢，其实都是解决某类问题的策略，其均是在所有的可能性中探索自己的答案，并快速得到你想要的结果。<strong>穷举法</strong>是最为简单而暴力的解法，但是其平铺直述的将所有的状态展现了出来。有必要了解下股票问题的穷举法。</p>
<p>解答人在这里采用了<strong>状态</strong>来进行穷举，具体到每一天，观察存在哪几种<strong>状态</strong>，并找出每个<strong>状态</strong>对应的<strong>选择</strong>。如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> <span class="keyword">in</span> 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> <span class="keyword">in</span> 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 择优(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>
<p>上面的伪代码中展示的就是利用<strong>状态</strong>进行<strong>穷举</strong>的形式。那么<strong>股票</strong>问题中我们的<strong>状态</strong>有哪些呢？</p>
<ol>
<li>日期:T</li>
<li>交易次数:K</li>
<li>是否持有股票:1，持有； 0，不持有。</li>
</ol>
<p><strong>选择</strong>又有哪些呢？1.买入 2，卖出 3.不做动作。分别用buy,sell,rest表示前面的三种选择。<strong>但是</strong>在股票问题中并不是每一天你都可以任意进行<strong>选择</strong>，其存在某种限制：buy必须在sell后，sell必须在buy后，rest操作还取决于前一天是buy OR sell等等。<strong>选择</strong>往往由题意进行限制。</p>
<p>我们不去管什么限制，仅仅是<strong>穷举</strong>出来的形式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span> <span class="keyword">or</span> <span class="number">1</span>]</span><br><span class="line"><span class="number">0</span> &lt;= i &lt;= n-<span class="number">1</span>, <span class="number">1</span> &lt;= k &lt;= K</span><br><span class="line"><span class="comment">#n 为天数，大 K 为最多交易数</span></span><br><span class="line"><span class="comment">#此问题共 n × K × 2 种状态，全部穷举就能搞定。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; n:</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= k &lt;= K:</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> &#123;<span class="number">0</span>, <span class="number">1</span>&#125;:</span><br><span class="line">            dp[i][k][s] = <span class="built_in">max</span>(buy, sell, rest)</span><br><span class="line"><span class="comment">#比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易            </span></span><br></pre></td></tr></table></figure>
<p><strong>我们的想要的答案是：</strong>$dp[n-1][K][0]$ , 即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 $dp[n - 1][K][1]$？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。</p>
<h2 id="状态转移框架"><a href="#状态转移框架" class="headerlink" title="状态转移框架"></a>状态转移框架</h2><p>上面的<strong>穷举</strong>中其实已经暗含将问题整个<strong>状态定义</strong>为：<strong>dp[i] [w] [j]</strong> 表示第 i 天，在交易次数限制在 w 的情况下，是否持有时所能带来的最大利润。</p>
<blockquote>
<p>我们接下来思考状态之间到底是如何转移的呢？</p>
</blockquote>
<p>根据<strong>选择</strong>进行转移，我们以从是否持有状态出发，如图：</p>
<p><img src="https://pic.leetcode-cn.com/c4eb5f0aa4daf7bef4b3b8af95129bb7394ec58e1ba7b191d9104bbd8ff1ccb3-40198bf2f6894018328b250b772b4a17724a983f99ba359b798a289733bffcbc-file_1559885188422-1.png"></p>
<p>根据上图我们可以写出状态转移方程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][k][<span class="number">0</span>] , dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + price[i] )</span><br><span class="line"><span class="comment">#		      max( 做出rest选择 ， 做出sell选择 )</span></span><br><span class="line"><span class="comment">#解释：今天我没有持有股票，有两种可能：</span></span><br><span class="line"><span class="comment">#要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；</span></span><br><span class="line"><span class="comment">#要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dp[i][k][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][k][<span class="number">1</span>] , dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - price[i] )</span><br><span class="line"><span class="comment">#			 max( rest , buy )</span></span><br><span class="line"><span class="comment">#解释：今天我持有着股票，有两种可能：</span></span><br><span class="line"><span class="comment">#要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；</span></span><br><span class="line"><span class="comment">#要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。</span></span><br></pre></td></tr></table></figure>
<h2 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[-<span class="number">1</span>][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">解释：因为 i 是从 <span class="number">0</span> 开始的，所以 i = -<span class="number">1</span> 意味着还没有开始，这时候的利润当然是 <span class="number">0</span> 。</span><br><span class="line">dp[-<span class="number">1</span>][k][<span class="number">1</span>] = -infinity</span><br><span class="line">解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">解释：因为 k 是从 <span class="number">1</span> 开始的，所以 k = <span class="number">0</span> 意味着根本不允许交易，这时候利润当然是 <span class="number">0</span> 。</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line">解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实上面的边界，这么写起来是很别扭的，我们可以理解为综合考虑：i , k极端情况下的的边界分布。</p>
</blockquote>
<p>以上三部分其实就是讲解了：状态、状态转移方程、边界。相当于提出了一套用于解决股票问题的框架。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="leetcode-0121"><a href="#leetcode-0121" class="headerlink" title="leetcode_0121"></a>leetcode_0121</h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h4><blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Note that you cannot sell a stock before you buy one.</p>
</blockquote>
<p>交易次数仅限于一次,k=1</p>
<p><strong>状态定义：</strong> $dp[i][k][j] , 0 &lt; i &lt; len(prices) , 0&lt;=k&lt;=1$ 表示第 i 天 ，第 K 次交易 ， 持有或不持有，所能获得的最大利润，0 &lt; i &lt; len(prices) , 0&lt;=k&lt;=1</p>
<p><strong>状态转移方程:</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] - price[i] )</span><br><span class="line"><span class="comment"># 第 i 天的状态为1（持有）时，交易一定出现过，k=1(题目限制只能1次)：昨天已经持有，今天选择观望，或者昨天不曾持有，今天选择买入</span></span><br><span class="line"><span class="comment"># dp[i-1][0][0] 在这道题目中一定为0，故应该为</span></span><br><span class="line"><span class="comment"># PS 如果代码仍然按照第一行编写，便会出现错误的结果，所以状态转移方程也根据题目存在差异，框架仅用于切入点。</span></span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>],  - price[i] )</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] ,dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + price[i] )</span><br><span class="line"><span class="comment"># 第 i 天状态为0（不持有）时，交易已经出现，k=1(题目限制只能1次)：昨天未持有，今天选择观望，或者昨天还是持有的，今天选择卖出</span></span><br></pre></td></tr></table></figure>
<ul>
<li>为什么上面没有考虑$dp[i][0][0]$ 这是由于未曾发生交易，这是边界情况，不需要转移好嘛。</li>
</ul>
<p><strong>由于限制交易次数为1次：</strong>状态转移方程等式左侧K均为1，这说明去掉K也是不影响的。</p>
<blockquote>
<p>这里的解释很牵强，我倒认为是由于持有与不持有本身就已经代表是否发生了一次交易，这导致这道题不考虑K也是可以的。</p>
</blockquote>
<p><strong>边界转移方程优化：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">1</span>],  - price[i] )</span><br><span class="line"><span class="comment">#第 i 天已经持有了，那么i-1天已持有，今天观望，或者，i-1 天未持有，今天买入</span></span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">0</span>] ,dp[i-<span class="number">1</span>][<span class="number">1</span>] + price[i] )</span><br><span class="line"><span class="comment">#第 i 天不再持有了，那么i-1天已不再持有，今天观望，或者，i-1 天持有，今天卖出</span></span><br></pre></td></tr></table></figure>
<p><strong>边界方程：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[-<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line"><span class="comment"># 这里的-1虽然代表数组下标，表示尚未开始时的状态，但是-1本身是不合理的，我们一般会特殊处理即可。</span></span><br></pre></td></tr></table></figure>
<h4 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># dp table初始化</span></span><br><span class="line">        dp = [ [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment">#边界表示第0天的状况</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">1</span>],  - prices[i-<span class="number">1</span>] )</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">0</span>] ,dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i-<span class="number">1</span>] )</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h4 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h4><ul>
<li>时间复杂度：一次迭代完成，$O(n)$</li>
<li>空间复杂度：需要一个数组，$ O(n) $</li>
</ul>
<h3 id="leetcode-0122"><a href="#leetcode-0122" class="headerlink" title="leetcode_0122"></a>leetcode_0122</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Say you have an array prices for which the ith element is the price of a given stock on day i.</span><br><span class="line"></span><br><span class="line">Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</span><br><span class="line"></span><br><span class="line">Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.</span><br><span class="line">             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.</span><br><span class="line">             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are</span><br><span class="line">             engaging multiple transactions at the same time. You must sell before buying again.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit = 0.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">1 &lt;= prices.length &lt;= 3 * 10 ^ 4</span><br><span class="line">0 &lt;= prices[i] &lt;= 10 ^ 4</span><br></pre></td></tr></table></figure>
<p>题目中的交易次数是没有限制的。</p>
<p><strong>状态定义：</strong> $dp[i][k][j] , 0 &lt; i &lt; len(prices) , 0&lt;=k&lt;float(“inf”)$ 表示第 i 天 ，第 K 次交易 ， 持有或不持有，所能获得的最大利润</p>
<blockquote>
<p>没有变化</p>
</blockquote>
<p><strong>状态转移方程：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[i][k][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][k][<span class="number">1</span>] , dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i] ) </span><br><span class="line"><span class="comment">#第 i 天 k 次交易 持有状态 = max( 第 i-1 天 k 次交易 持有状态，选择观望 , 第 i-1 天 k-1 次交易 未持有状态，选择买入 )</span></span><br><span class="line">dp[i][k][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][k][<span class="number">0</span>] , dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">1</span>] + prices[i] )</span><br><span class="line"><span class="comment">#第 i 天 k 次交易 未持有状态 = max( 第 i-1 天 k 次交易 未持有状态，选择观望 , 第 i-1 天 k-1 次交易 持有状态，选择卖出 )</span></span><br></pre></td></tr></table></figure>
<p>由于题目中<strong>不对 K 有任何限制</strong>,那么，K的范围就是到无穷大，那么k与k-1的变化是毫无意义的，我们根本不关注到底发生了多少次，故状态转移方程修改如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">1</span>] , dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i] ) </span><br><span class="line"><span class="comment">#第 i 天 持有状态 = max( 第 i-1 天 持有状态，选择观望 , 第 i-1 天 未持有状态，选择买入 )</span></span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">0</span>] , dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i] )</span><br><span class="line"><span class="comment">#第 i 天 未持有状态 = max( 第 i-1 天 未持有状态，选择观望 , 第 i-1 天 持有状态，选择卖出 )</span></span><br></pre></td></tr></table></figure>
<p><strong>边界方程：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[-<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="算法代码-1"><a href="#算法代码-1" class="headerlink" title="算法代码"></a>算法代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">1</span>] , dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>] ) </span><br><span class="line">			<span class="comment">#第 i 天 持有状态 = max( 第 i-1 天 持有状态，选择观望 , 第 i-1 天 未持有状态，选择买入 )</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">0</span>] , dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i-<span class="number">1</span>] )</span><br><span class="line">			<span class="comment">#第 i 天 未持有状态 = max( 第 i-1 天 未持有状态，选择观望 , 第 i-1 天 持有状态，选择卖出 )</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><p>同上</p>
<h3 id="leetcode-0123"><a href="#leetcode-0123" class="headerlink" title="leetcode_0123"></a>leetcode_0123</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Say you have an array for which the ith element is the price of a given stock on day i.</span><br><span class="line"></span><br><span class="line">Design an algorithm to find the maximum profit. You may complete at most two transactions.</span><br><span class="line"></span><br><span class="line">Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [3,3,5,0,0,3,1,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</span><br><span class="line">             Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.</span><br><span class="line">             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are</span><br><span class="line">             engaging multiple transactions at the same time. You must sell before buying again.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit = 0.</span><br></pre></td></tr></table></figure>
<p>K限制在两次以内</p>
<p><strong>状态定义：</strong>$dp[i][k][j] , 0 &lt; i &lt; len(prices) , 0&lt;=k&lt;=2$</p>
<p><strong>状态转移方程：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[i][k][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][k][<span class="number">1</span>] , dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i] ) </span><br><span class="line">            <span class="comment">#第 i 天 k 次交易 持有状态 = max( 第 i-1 天 k 次交易 持有状态，选择观望 , 第 i-1 天 k-1 次交易 未持有状态，选择买入 )</span></span><br><span class="line">dp[i][k][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][k][<span class="number">0</span>] , dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i] )</span><br><span class="line">            <span class="comment">#第 i 天 k 次交易 未持有状态 = max( 第 i-1 天 k 次交易 未持有状态，选择观望 , 第 i-1 天 k-1 次交易 持有状态，选择卖出 )</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>很明显，这次状态转移方程没办法优化。</p>
</blockquote>
<p><strong>边界：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[-<span class="number">1</span>][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[-<span class="number">1</span>][k][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="算法代码-2"><a href="#算法代码-2" class="headerlink" title="算法代码"></a>算法代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [[[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 边界初始化</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            dp[<span class="number">0</span>][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[<span class="number">0</span>][k][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="comment">#迭代过程</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)+<span class="number">1</span>):</span><br><span class="line">            <span class="comment">#其实这里可以采用 for k in range(3,0,-1)</span></span><br><span class="line">            <span class="comment"># 他人的写法</span></span><br><span class="line">            dp[i][<span class="number">2</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>] + prices[i-<span class="number">1</span>])</span><br><span class="line">            dp[i][<span class="number">2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>])</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i-<span class="number">1</span>])</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], -prices[i-<span class="number">1</span>])    </span><br><span class="line">        <span class="comment"># 最大利润寻找</span></span><br><span class="line">        maxprofit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            temp = <span class="built_in">max</span>(dp[-<span class="number">1</span>][k])</span><br><span class="line">            <span class="keyword">if</span> maxprofit &lt; temp:</span><br><span class="line">                maxprofit = temp</span><br><span class="line">        <span class="keyword">return</span> maxprofit</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 迭代逻辑部分，有所更改，用了双循环</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [[[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            dp[<span class="number">0</span>][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[<span class="number">0</span>][k][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 注意K的取值也是从小到大的</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">3</span>):</span><br><span class="line">                dp[i][k][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][k][<span class="number">1</span>] , dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>] ) </span><br><span class="line">            <span class="comment">#第 i 天 k 次交易 持有状态 = max( 第 i-1 天 k 次交易 持有状态，选择观望 , 第 i-1 天 k-1 次交易 未持有状态，选择买入 )</span></span><br><span class="line">                dp[i][k][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][k][<span class="number">0</span>] , dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i-<span class="number">1</span>] )</span><br><span class="line">            <span class="comment">#第 i 天 k 次交易 未持有状态 = max( 第 i-1 天 k 次交易 未持有状态，选择观望 , 第 i-1 天 k-1 次交易 持有状态，选择卖出 )</span></span><br><span class="line">        maxprofit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            temp = <span class="built_in">max</span>(dp[-<span class="number">1</span>][k])</span><br><span class="line">            <span class="keyword">if</span> maxprofit &lt; temp:</span><br><span class="line">                maxprofit = temp</span><br><span class="line">        <span class="keyword">return</span> maxprofit</span><br></pre></td></tr></table></figure>
<h4 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a>算法分析：</h4><h3 id="leetcode-0124"><a href="#leetcode-0124" class="headerlink" title="leetcode_0124"></a>leetcode_0124</h3><p>K没有限制，就是上一题的扩展，这里不做任何解释</p>
<h4 id="算法代码-3"><a href="#算法代码-3" class="headerlink" title="算法代码"></a>算法代码</h4><blockquote>
<p>超出时间限制，暂时不想优化</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, k: <span class="built_in">int</span>, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        dp = [[[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[<span class="number">0</span>][k][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">                </span><br><span class="line">                dp[i][k][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][k][<span class="number">1</span>] , dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>] ) </span><br><span class="line">            <span class="comment">#第 i 天 k 次交易 持有状态 = max( 第 i-1 天 k 次交易 持有状态，选择观望 , 第 i-1 天 k-1 次交易 未持有状态，选择买入 )</span></span><br><span class="line">                dp[i][k][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][k][<span class="number">0</span>] , dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i-<span class="number">1</span>] )</span><br><span class="line">            <span class="comment">#第 i 天 k 次交易 未持有状态 = max( 第 i-1 天 k 次交易 未持有状态，选择观望 , 第 i-1 天 k-1 次交易 持有状态，选择卖出 )</span></span><br><span class="line">        maxprofit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>):</span><br><span class="line">            temp = <span class="built_in">max</span>(dp[-<span class="number">1</span>][k])</span><br><span class="line">            <span class="keyword">if</span> maxprofit &lt; temp:</span><br><span class="line">                maxprofit = temp</span><br><span class="line">        <span class="keyword">return</span> maxprofit</span><br></pre></td></tr></table></figure>
<h3 id="leetcode-0309"><a href="#leetcode-0309" class="headerlink" title="leetcode_0309"></a>leetcode_0309</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Say you have an array for which the ith element is the price of a given stock on day i.</span><br><span class="line"></span><br><span class="line">Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</span><br><span class="line"></span><br><span class="line">You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</span><br><span class="line">After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [1,2,3,0,2]</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: transactions = [buy, sell, cooldown, buy, sell]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>状态定义：</strong> $dp[i][k][j] , 0 &lt; i &lt; len(prices) , 0&lt;=k&lt;float(“inf”)$ 表示第 i 天 ，第 K 次交易 ， 持有或不持有，所能获得的最大利润</p>
<p><strong>状态转移方程：</strong>很明显，并不需要记录K值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>] , dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line"><span class="comment">#  第 i 天 未持有状态 = max( 第 i-1 天 未持有状态，选择观望 , 第 i-1 天持有状态，选择卖出 )</span></span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>] , dp[i-<span class="number">2</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line"><span class="comment">#  第 i 天 持有状态 = max( 第 i-1 天 持有状态，选择观望 , 第 i-1 天 未持有状态，选择买入 )</span></span><br></pre></td></tr></table></figure>
<p><strong>边界方程：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[-<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="算法代码-4"><a href="#算法代码-4" class="headerlink" title="算法代码"></a>算法代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 这里这么处理仅仅是处理一开始不愿意初始化罢了，一开始是没有前天的好嘛，我们的数组只虚拟了一天，也就是dp[0]这一天</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">                dp[i][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">1</span>] , dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>] )</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">1</span>] , dp[i-<span class="number">2</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>] ) </span><br><span class="line">			<span class="comment">#第 i 天 持有状态 = max( 第 i-1 天 持有状态，选择观望 , 第 i-1 天 未持有状态，选择买入 )</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">0</span>] , dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i-<span class="number">1</span>] )</span><br><span class="line">			<span class="comment">#第 i 天 未持有状态 = max( 第 i-1 天 未持有状态，选择观望 , 第 i-1 天 持有状态，选择卖出 )</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h4 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h4><h3 id="leetcode-0714"><a href="#leetcode-0714" class="headerlink" title="leetcode_0714"></a>leetcode_0714</h3><p><strong>状态定义：</strong>什么的都与0122题一摸一样</p>
<p><strong>状态转移方程：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 卖出的时候扣除费用就好 </span></span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">1</span>] , dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>] ) </span><br><span class="line"><span class="comment">#第 i 天 持有状态 = max( 第 i-1 天 持有状态，选择观望 , 第 i-1 天 未持有状态，选择买入 )</span></span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">0</span>] , dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i-<span class="number">1</span>] - fee )</span><br><span class="line"><span class="comment">#第 i 天 未持有状态 = max( 第 i-1 天 未持有状态，选择观望 , 第 i-1 天 持有状态，选择卖出,并扣除费用 )</span></span><br></pre></td></tr></table></figure>
<p><strong>边界：</strong>一样</p>
<h4 id="算法代码："><a href="#算法代码：" class="headerlink" title="算法代码："></a>算法代码：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>], fee: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">1</span>] , dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>] ) </span><br><span class="line">			<span class="comment">#第 i 天 持有状态 = max( 第 i-1 天 持有状态，选择观望 , 第 i-1 天 未持有状态，选择买入 )</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">0</span>] , dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i-<span class="number">1</span>] - fee )</span><br><span class="line">			<span class="comment">#第 i 天 未持有状态 = max( 第 i-1 天 未持有状态，选择观望 , 第 i-1 天 持有状态，选择卖出,并扣除费用 )</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h4 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h4>]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划算法解释</title>
    <url>/2021/01/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<p>初次见到动态规划是在王道论坛划水的时候，见到时简直一脸懵逼。最近在刷Leetcode发现大量的题目建议采用动态规划的解法，遂将相关概念整理如下。</p>
<a id="more"></a>

<p>参考地址：<a href="https://www.zhihu.com/question/23995189/answer/35324479">知乎众解答</a> <a href="https://www.cnblogs.com/cthon/p/9251909.html">博客漫画引入解释</a></p>
<p>在看大家对动态规划的解读时，发现很有意思的现象，就是大家对动态规划的解读点并不一致。有的是理论型：从动态规划的本质出发，因对动态规划与其他算法的异同进行解释。有的是实战型，直接列出动态规划问题的处理模式。大部分解答甚至会将一部分算法技巧也列入动态规划之中，比如重复记忆等。个人认为这种现象的出现恰是由于动态规划本身定位就存在争论。以下的解释将从理论出发，逐步过渡到实战中的步骤或技巧。</p>
<h2 id="动态规划适用的问题与定义"><a href="#动态规划适用的问题与定义" class="headerlink" title="动态规划适用的问题与定义"></a>动态规划适用的问题与定义</h2><blockquote>
<p>主要参考知乎中[<a href="https://www.zhihu.com/people/anchor89">王勐</a>]的回答</p>
</blockquote>
<p>动态规划是对<strong>某一类问题</strong>的解决算法思路，这类问题具有两个特点：</p>
<ol>
<li><strong>最优子结构</strong> : 每个阶段的最优状态，由之前某阶段的一个或者几个状态得到</li>
<li><strong>无后效性</strong> :而不管这些状态是怎么得到的。</li>
</ol>
<p>一开始看不懂上面在说什么，接着向下看即可。很多解答中还提到了<strong>重复子问题</strong>，并将其列入动态规划的定义之中，我个人认为那并不是核心特点。要清楚动态规划的定位，那么首先需要弄清楚一系列的相关概念，例如递推、贪心、递归、搜索等等。</p>
<h3 id="问题导入"><a href="#问题导入" class="headerlink" title="问题导入"></a>问题导入</h3><p>在处理很多问题时，其实我们可以引入<strong>时间步</strong>的概念，比如迷宫问题，可以假设一个时间步走一次。那么每个时间步我们称其为<strong>阶段</strong>，而一个阶段可以有多种<strong>状态</strong>，比如你在第 $n$ 步可以自由的选择向尚未走过的多个方向前进，导致你的状态产生多个。</p>
<blockquote>
<p>比如说我想计算第100个非波那契数，每一个非波那契数就是这个问题的一个状态，每求一个新数字只需要之前的两个状态。所以同一个时刻，最多只需要保存两个状态，空间复杂度就是常数；每计算一个新状态所需要的时间也是常数且状态是线性递增的，所以时间复杂度也是线性的。</p>
<p>上面这种状态计算很直接，只需要依照固定的模式从旧状态计算出新状态就行（a[i]=a[i-1]+a[i-2]），不需要考虑是不是需要更多的状态，也不需要选择哪些旧状态来计算新状态。对于这样的解法，我们叫<strong>递推</strong>。</p>
</blockquote>
<p>上面是其回答的原句，比我自己举得例子要更加直观。<strong>阶段</strong>就是随着问题的开展，在某个时刻可能会得到的不同状态的集合。非波那契数列中，每一步会计算得到一个新数字，所以每个阶段只有一个状态。而迷宫问题，你可以有多种选择，自然你的阶段状态数是多个。从头开始走了几步就是第几个阶段，走了n步所处的位置我们称为一个状态，而走了n步所有可能到达的位置的集合就是这个阶段的所有可能的状态。虽然说起来很绕口，但是很好理解。</p>
<h3 id="相关算法的适用问题"><a href="#相关算法的适用问题" class="headerlink" title="相关算法的适用问题"></a>相关算法的适用问题</h3><p>有了阶段，针对不同问题，计算新状态的方式是不同的，就需要不同的算法，从而衍生出递推、贪心、动归等等。</p>
<p>假设：问题存在n个阶段，并且每个阶段存在多个状态，不同阶段的状态数不一定相同，一个阶段的一个状态可以得到下个阶段的所有状态中的几个。</p>
<p>共识：要计算出最终阶段的状态数，必然其经历了<strong>之前每个阶段</strong>的部分状态。</p>
<p>分歧：不同的问题对之前阶段状态的需求不同，导致了不同的算法。</p>
<h4 id="贪心算法适用问题"><a href="#贪心算法适用问题" class="headerlink" title="贪心算法适用问题"></a>贪心算法适用问题</h4><p>贪心算法的特点便是<strong>鼠目寸光</strong>，“下一步的最优<strong>只需要</strong>由当前最优得到”。</p>
<p>例如棋盘问题：从棋盘左上角到右下角最短需要几步。我们已经知道，某个阶段存在多个状态，你走了n步，可以到达的位置很多，但是有哪些位置可以让你在第n+1步中走得最远呢？？？答案很明显，即是在第n步中走得最远的位置。</p>
<p>这类问题特点，<strong>下一步最优是从当前最优得到的</strong>，解决此问题，只需寻出每一步的最优值即可，解决此类问题的算法为<strong>贪心</strong>，计算的方法为<strong>递推</strong>。</p>
<h4 id="搜索算法适用问题"><a href="#搜索算法适用问题" class="headerlink" title="搜索算法适用问题"></a>搜索算法适用问题</h4><p>搜索算法的特点是考虑全局问题，下一步的选择需要考虑之前<strong>所有阶段的状态</strong>。</p>
<p>例如迷宫问题，计算从起点到终点的最短路线时，只保存当前阶段的状态是不够的，题目要求你最短，故需要知道之前走过的所有位置。即使你当前阶段的位置不变，之前路线的不同会影响你之后选择的路线。这时需要保存之前每个阶段经历的状态，根据这些信息才能计算出下一个状态。每个阶段的状态或许不多，但是每个状态都可以转移到下一阶段的多个状态，所以解的复杂度就是指数的，因此时间复杂度也是指数的。刚刚提到的之前的路线会影响到下一步的选择，这个令人不开心的情况就叫做<strong>有后效性</strong>。</p>
<p>此类问题的解决方式，就是暴力解决，也就是最直观的搜索算法。</p>
<h4 id="动态规划适用问题"><a href="#动态规划适用问题" class="headerlink" title="动态规划适用问题"></a>动态规划适用问题</h4><p>有一类问题，看似需要所有状态，但其实不用。</p>
<p>例如最长上升子序列问题，</p>
<blockquote>
<p>假装我们年幼无知想用搜索去寻找最长上升子序列。怎么搜索呢？需要从头到尾依次枚举是否选择当前的数字，每选定一个数字就要去看看是不是满足“上升”的性质，这里第i个阶段就是去思考是否要选择第i个数，第i个阶段有两个状态，分别是选和不选。哈哈，依稀出现了刚刚迷宫找路的影子！咦慢着，每次当我决定要选择当前数字的时候，只需要和之前选定的一个数字比较就行了！这是和之前迷宫问题的本质不同！这就可以纵容我们不需要记录之前所有的状态啊！既然我们的选择已经不受之前状态的组合的影响了，那时间复杂度自然也不是指数的了啊！虽然我们不在乎某序列之前都是什么元素，但我们还是需要这个序列的长度的。所以我们只需要记录以某个元素结尾的LIS长度就好！因此第i个阶段的最优解只是由前i-1个阶段的最优解得到的，然后就得到了DP方程。</p>
<p><img src="D:/nutStore/Learning/leetcode/pictures/equation.svg"></p>
</blockquote>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>每个阶段只有一个状态-&gt;递推；<br>每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心；<br>每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索；<br>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。</p>
<blockquote>
<p>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到，这些状态也是上一阶段**”最优”**状态.</p>
</blockquote>
<p>这个性质叫做<strong>最优子结构</strong>；</p>
<blockquote>
<p>而不管之前这个状态是如何得到的</p>
</blockquote>
<p>这个性质叫做<strong>无后效性</strong>。</p>
<p>通过这一部分：</p>
<ol>
<li>应该理解了<strong>最优子结构</strong>、<strong>无后效性</strong>,但还是偏抽象，接下来的例子中会进一步进行解释。</li>
<li>各种算法适用的问题类型。</li>
</ol>
<h2 id="动态规划的本质"><a href="#动态规划的本质" class="headerlink" title="动态规划的本质"></a>动态规划的本质</h2><blockquote>
<p>知乎徐凯强 Andy的回答</p>
</blockquote>
<p>在这一部分，不再是单纯的理论上理解动态规划的概念，其涉及了动态规划的思考方式与本质的讨论。</p>
<h3 id="本质是什么"><a href="#本质是什么" class="headerlink" title="本质是什么"></a>本质是什么</h3><p>动态规划的本质，是对问题*<strong>状态的定义*</strong>和*<strong>状态转移方程*的定义</strong>。</p>
<p><strong>动态规划中递推式的求解方法不是动态规划的本质。</strong></p>
<blockquote>
<p> 维基百科定义</p>
<p> <strong>dynamic programming</strong> is a method for solving a complex problem by <strong>breaking it down into a collection of simpler subproblems</strong>.</p>
</blockquote>
<p>动态规划是通过<strong>拆分问题</strong>，定义问题与状态之间的关系，进而是问题能够通过递推（或分治）的方式解决。</p>
<p>作者认为<strong>如何拆分问题</strong>，是动态规划的核心。<strong>拆分问题</strong>，靠<strong>状态的定义</strong>与<strong>状态转移方程</strong>的定义。</p>
<h3 id="什么是状态的定义"><a href="#什么是状态的定义" class="headerlink" title="什么是状态的定义"></a>什么是状态的定义</h3><p>对于状态的定义就是你对问题<strong>从可拆分的角度</strong>重新对其定义。</p>
<p>例如经典的最长上升子序列问题：</p>
<blockquote>
<p>给定一个数列，长度为N，<br>求这个数列的最长上升（递增）子数列（LIS）的长度.<br>以<br>1 7 2 8 3 4<br>为例。<br>这个数列的最长递增子数列是 1 2 3 4，长度为4；<br>次长的长度为3， 包括 1 7 8; 1 2 3 等.</p>
</blockquote>
<p>此问题提出，一开始<strong>找不到子问题</strong>，需要你从其他角度，将其定义为<strong>可拆分子问题</strong>，否则没有子问题只能通过暴力方式解决。</p>
<p>重新定义为：</p>
<blockquote>
<p>给定一个数列，长度为N，<br>设<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="[公式]">为：以数列中第k项结尾的最长递增子序列的长度.<br>求<img src="https://www.zhihu.com/equation?tex=F_%7B1%7D..F_%7BN%7D" alt="[公式]"> 中的最大值.</p>
</blockquote>
<p>显然，这个新问题与原问题等价。<br>而对于<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="[公式]">来讲，<img src="https://www.zhihu.com/equation?tex=F_%7B1%7D+..+F_%7Bk-1%7D" alt="[公式]">都是<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="[公式]">的子问题：因为以第k项结尾的最长递增子序列（下称LIS），包含着以第<img src="https://www.zhihu.com/equation?tex=1..k-1" alt="[公式]">中某项结尾的LIS。</p>
<p>上述的新问题<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="[公式]">也可以叫做状态，定义中的“<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="[公式]">为数列中第k项结尾的LIS的长度”，就叫做对状态的定义。之所以把<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="[公式]">做“状态”而不是“问题” ，一是因为避免跟原问题中“问题”混淆，二是因为这个新问题是数学化定义的。</p>
<p>对问题的定义可以有多种，这只是其中一种。作者在回答中对此有其他定义，但没必要均罗列到上面。</p>
<h3 id="什么是状态转移方程"><a href="#什么是状态转移方程" class="headerlink" title="什么是状态转移方程"></a>什么是状态转移方程</h3><p>状态与状态之间的关系，就叫做<strong>状态转移方程</strong>。</p>
<p>比如，对于LIS问题，我们的第一种定义：</p>
<blockquote>
<p>设<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="[公式]">为：以数列中第k项结尾的最长递增子序列的长度.</p>
</blockquote>
<p>设A为题中数列，状态转移方程为：</p>
<blockquote>
<p><img src="https://www.zhihu.com/equation?tex=F_%7B1%7D+=+1" alt="[公式]"> （根据状态定义导出边界情况）<br><img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D=max(F_%7Bi%7D+1+%7C+A_%7Bk%7D%3EA_%7Bi%7D,+i%5Cin+(1..k-1))+" alt="[公式]"><img src="https://www.zhihu.com/equation?tex=(k%3E1)" alt="[公式]"></p>
</blockquote>
<p>用文字解释一下是：<br>以第k项结尾的LIS的长度是：保证第i项比第k项小的情况下，以第i项结尾的LIS长度加一的最大值，取遍i的所有值（i小于k）。</p>
<p>这里可以看出，这里的状态转移方程，就是定义了问题和子问题之间的关系。<br>可以看出，状态转移方程就是带有条件的递推式。</p>
<h3 id="动态规划迷思"><a href="#动态规划迷思" class="headerlink" title="动态规划迷思"></a>动态规划迷思</h3><ul>
<li><p>缓存、重叠子问题、记忆化</p>
<p>这些仅仅是在DP问题中求解递推式的<strong>技巧</strong>。以Fibonacci数列为例，计算第100项的时候，需要计算第99项和98项；在计算第101项的时候，需要第100项和第99项，这时候你还需要重新计算第99项吗？不需要，你只需要在第一次计算的时候把它记下来就可以了。</p>
<p>上述的需要再次计算的“第99项”，就叫“重叠子问题”。如果没有计算过，就按照递推式计算，如果计算过，直接使用，就像“缓存”一样，这种方法，叫做“记忆化”，这是递推式求解的技巧。这种技巧，通俗的说叫“花费空间来节省时间”。<strong>都不是动态规划的本质，**</strong>不是动态规划的核心。**</p>
</li>
<li><p>递归</p>
<p>递归是递推式求解的方法。</p>
</li>
</ul>
<h3 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h3><p>在这一部分我们对动态规划的本质有了一个直观的理解，也就是<strong>状态定义</strong> + <strong>状态转移方程</strong>。通过<strong>拆分为子问题</strong>的思想对状态进行定义，通过<strong>定义分析</strong>获得状态间的递推公式。这就是动态规划的<strong>本质</strong>。</p>
<h2 id="动态规划的样例解读"><a href="#动态规划的样例解读" class="headerlink" title="动态规划的样例解读"></a>动态规划的样例解读</h2><blockquote>
<p>知乎<a href="https://www.zhihu.com/people/ruan-xing-zhi">阮行止</a>解答</p>
</blockquote>
<h3 id="DAG最短路径"><a href="#DAG最短路径" class="headerlink" title="DAG最短路径"></a>DAG最短路径</h3><p>问题：给定一个城市的地图，所有的道路都是单行道，而且不会构成环。每条道路都有过路费，问您从S点到T点花费的最少费用。</p>
<p><img src="D:/nutStore/Learning/leetcode/pictures/DAG.jpg"></p>
<p><strong>状态定义</strong>：记$f(P)$ 为从S点到P点的最少费用。</p>
<blockquote>
<p>要想到达T点，要么经过C要么经过D</p>
</blockquote>
<p><strong>状态转移方程:</strong>$f(T) = \min{ f(C)+20 , f(D)+10}$</p>
<ul>
<li>无后效性：一旦获得$f(P)$ ，并不关心$f(P)$ 是如何得到的。</li>
<li>最优子结构：对于P，我们当然只关心到P的最小费用，即f(P)。如果我们从S走到T是 <img src="https://www.zhihu.com/equation?tex=S+%5Cto+P%5Cto+Q%5Cto+T" alt="[公式]"> ，那肯定S走到Q的最优路径是 <img src="https://www.zhihu.com/equation?tex=S%5Cto+P%5Cto+Q" alt="[公式]"> 。对一条最优的路径而言，从S走到<strong>沿途上所有的点（子问题）</strong>的最优路径，都是这条大路的一部分。这个问题的最优子结构性质是显然的。</li>
</ul>
<p>既然这两个性质都满足，那么本题可以DP。式子明显为：</p>
<p><img src="https://www.zhihu.com/equation?tex=f(P)=%5Cmin%E2%81%A1%5C%7Bf(R)+w_%7BR%E2%86%92P%7D%5C%7D" alt="[公式]"></p>
<p>其中R为有路通到P的所有的点， <img src="https://www.zhihu.com/equation?tex=w_%7BR%E2%86%92P%7D" alt="[公式]"> 为R到P的过路费。</p>
<h4 id="小结：-2"><a href="#小结：-2" class="headerlink" title="小结："></a>小结：</h4><p>原答案中作者还有其他方面的阐述，这里不表。这里展示了DP算法中状态定义以及状态转移方程的样子，可作为经典理解。</p>
<h2 id="DP问题的技巧"><a href="#DP问题的技巧" class="headerlink" title="DP问题的技巧"></a>DP问题的技巧</h2><blockquote>
<p>知乎 Mingqi 解答</p>
</blockquote>
<p>在这一部分，我们会讨论动态规划<strong>非本质</strong>的技巧，但却常常能够是代码质量得到提升。其认为动态规划的特点有三个：</p>
<blockquote>
<p>再次提及维基定义</p>
<p><strong>dynamic programming</strong> is a method for solving a complex problem by <strong>breaking it down into a collection of simpler subproblems</strong>, solving each of those subproblems <strong>just once</strong>, and <strong>storing their solutions</strong>.</p>
</blockquote>
<ol>
<li>把原来的问题分解成了几个<strong>相似的子问题</strong>。（强调“相似子问题”）</li>
<li>所有的子问题都<strong>只需要解决一次</strong>。（强调“只解决一次”）</li>
<li><strong>储存</strong>子问题的解。（强调“储存”）</li>
</ol>
<h4 id="理解存储的好处"><a href="#理解存储的好处" class="headerlink" title="理解存储的好处"></a>理解存储的好处</h4><p>以斐波那契数列(Fibonacci)的例子：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">1， 1， 2， 3， 5， 8， 13 ，21 ...</span><br></pre></td></tr></table></figure>
<p>其状态转移方程为：</p>
<p>![](D:/nutStore/Learning/leetcode/pictures/equation (1).svg)</p>
<p>我们通常是从上至下分解问题，再向上返回结果。n=6时的计算图为：</p>
<p><img src="D:/nutStore/Learning/leetcode/pictures/computeTree.jpg"></p>
<p><strong>出现大量重复计算</strong>，无法体现其<strong>子问题只解决一次</strong>的特点。可以利用<strong>存储子问题的解</strong>的方式，解决上述问题，一般利用数组存储。其计算图为：</p>
<p><img src="D:/nutStore/Learning/leetcode/pictures/computeTee2.jpg"></p>
<p>这个例子其实并不是动态规划的经典例子，其使用单纯的<strong>递推</strong>，也是一样的结果。但可以用来理解<strong>存储重复子问题</strong>的效果。</p>
<h4 id="理解动态规划算法的优势"><a href="#理解动态规划算法的优势" class="headerlink" title="理解动态规划算法的优势"></a>理解动态规划算法的优势</h4><p>这里的优势是相对于暴力解决法。还是以最长上升子数列的长度（LIS）为例：</p>
<p>给定一个数列：</p>
<p><img src="D:/nutStore/Learning/leetcode/pictures/LIS.JPG"></p>
<p>最长上升子数列为：</p>
<p><img src="D:/nutStore/Learning/leetcode/pictures/LIS2.jpg"></p>
<p>其长度为4.</p>
<p>暴力解决方式：穷举法</p>
<p><img src="D:/nutStore/Learning/leetcode/pictures/LIS3.jpg"></p>
<p>其时间复杂度为：</p>
<p>![](D:/nutStore/Learning/leetcode/pictures/equation (2).svg)</p>
<p>动态规划解决：</p>
<p><strong>状态转移方程：</strong></p>
<p><img src="https://www.zhihu.com/equation?tex=F_%7B1%7D+=+1" alt="[公式]"> （根据状态定义导出边界情况）<br><img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D=max(F_%7Bi%7D+1+%7C+A_%7Bk%7D%3EA_%7Bi%7D,+i%5Cin+(1..k-1))+" alt="[公式]"><img src="https://www.zhihu.com/equation?tex=(k%3E1)" alt="[公式]"></p>
<p>其计算图为：</p>
<p><img src="D:/nutStore/Learning/leetcode/pictures/LIS4.jpg"></p>
<p>可以看到这里的计算量相较于穷举法已经下降了很多。</p>
<p>同样的可以使用存储的方式减少计算量。</p>
<p>未使用存储：</p>
<p><img src="D:/nutStore/Learning/leetcode/pictures/LIS5.jpg"></p>
<p>使用存储：</p>
<p><img src="D:/nutStore/Learning/leetcode/pictures/LIS6.jpg"></p>
<h4 id="小结：-3"><a href="#小结：-3" class="headerlink" title="小结："></a>小结：</h4><p>在这一部分我们能够理解动态规划中<strong>存储</strong>的重要性，其是动态规划高效的核心。</p>
<p><strong>动态规划本身是将原问题通过某种定义，演变成可拆分为子问题的形式，通过解决小问题从而以递推或分治的方式解决大问题。那么其本身的形式，必然存在大量的重复子问题，通过存储的方式，可以有效的降低时间复杂度，减少不必要的计算。</strong></p>
<h2 id="DP的实践"><a href="#DP的实践" class="headerlink" title="DP的实践"></a>DP的实践</h2><p>上面的几部分内容，均针对如何更好地理解动态规划，并没有涉及深入的实践环节。像这样的解答网上也有很多，例如知乎<a href="https://www.zhihu.com/people/iamshuaidi">帅地</a>的答案就偏向于实践。</p>
<p>我个人在接触之时，也看了很多实践的帖子，我个人的感受为：很多帖子只是花式的告诉你如何操作你就解决了动态规划问题，但是你个人还是不知道如何审题，无法确认此问题是否是动态规划问题。而且很多帖子不讲DP的本质，一开始就告诉你先整个数组，用于存储，这就很懵逼，对于我这样的小白肯定是不友好的，就像做数学题只注重套路没有看到此题的本质。</p>
<p>大家所说的也是大同小异，无非是：</p>
<ol>
<li><strong>定义状态</strong> 2.<strong>寻找状态转移方程</strong> 3.<strong>寻找边界</strong> 4.<strong>存储</strong></li>
</ol>
<p>光说不做假把式，实际问题更需要灵活的解决，好吧，我去刷题啦。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2021/01/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h1><blockquote>
<p><a href="https://www.zhihu.com/search?type=content&q=%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93">知乎参考地址</a></p>
</blockquote>
<p>最近在刷Leetcode过程中，部分题目需要手写排序算法。发现很多之前学习过的排序算法，均已经玩的差不多啦。特将常见的排序算法思想与算法实现总结如下：</p>
<a id="more"></a>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><blockquote>
<p>这里直接采用<a href="https://zhuanlan.zhihu.com/p/40695917">LeetCode</a>回答所采用的准备工作，用于测试或算法部件</p>
</blockquote>
<ul>
<li>生成算法需要的数列：随机数列</li>
<li>对于一些极端情况，考虑算法的效率，需要生成基本有序的数列</li>
<li>测试算法性能的函数</li>
<li>判断数列是否有序</li>
<li>数列中元素相互交换</li>
<li>数列的拷贝</li>
</ul>
<h3 id="生成随机数列"><a href="#生成随机数列" class="headerlink" title="生成随机数列"></a>生成随机数列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateRandomArray</span>(<span class="params">n, <span class="built_in">min</span>, <span class="built_in">max</span></span>):</span></span><br><span class="line">    arr = []</span><br><span class="line">    arr = [randint(<span class="built_in">min</span>, <span class="built_in">max</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>
<h3 id="生成基本有序的数列"><a href="#生成基本有序的数列" class="headerlink" title="生成基本有序的数列"></a>生成基本有序的数列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateNearlyOrderedArray</span>(<span class="params">n, swapTimes</span>):</span></span><br><span class="line">    arr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        arr.append(i)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(swapTimes):</span><br><span class="line">        posx = randint(<span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">        posy = randint(<span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">        arr[posx], arr[posy] = arr[posy], arr[posx]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>
<h3 id="判断数列是否有序"><a href="#判断数列是否有序" class="headerlink" title="判断数列是否有序"></a>判断数列是否有序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSorted</span>(<span class="params">alist</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(alist)-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> alist[i] &gt; alist[i+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="测试算法性能"><a href="#测试算法性能" class="headerlink" title="测试算法性能"></a>测试算法性能</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = timeit.Timer(<span class="string">&#x27;testSort(&quot;某种排序算法函数&quot;, alist)&#x27;</span>, <span class="string">&#x27;from __main__ import testSort, 某种排序算法函数, alist&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;某种排序算法：%s s&#x27;</span> %t1.timeit(number=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># func表示要检测的算法函数，alist为传入的数列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testSort</span>(<span class="params">func, alist</span>):</span></span><br><span class="line">    alist =  func(alist)</span><br><span class="line">    <span class="keyword">assert</span> isSorted(alist), <span class="string">&quot;排序算法错误\n&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="数列中元素互换"><a href="#数列中元素互换" class="headerlink" title="数列中元素互换"></a>数列中元素互换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist[i], alist[j] = alist[j], alist[i]</span><br></pre></td></tr></table></figure>
<h3 id="数列拷贝"><a href="#数列拷贝" class="headerlink" title="数列拷贝"></a>数列拷贝</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接使用切片</span></span><br><span class="line"><span class="comment"># list = [8,6,2,3,1,5,7,4]</span></span><br><span class="line">alist=<span class="built_in">list</span>[:]</span><br></pre></td></tr></table></figure>


<h2 id="比较类排序"><a href="#比较类排序" class="headerlink" title="比较类排序"></a>比较类排序</h2><p>指通过比较元素间的相对次序，来完成排序的算法，但其时间复杂度<strong>无法超过$O(n\log(n))$</strong>,也称为<strong>非线性时间</strong>比较类排序。</p>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h4><h5 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h5><p>冒泡排序要对一个列表<strong>多次重复遍历</strong>。它要比较<strong>相邻</strong>的两项，并且交换顺序排错的项。每对 列表实行一次遍历，就有一个最大项排在了正确的位置。</p>
<p>大体上讲，列表的每一个数据项都会在 其相应的位置 “冒泡”。如果列表有 n 项，第一次遍历就要比较 n-1 对数据。最不理想的情况下（逆序）：需要遍历 $n-1$ 次，最理想的情况下：需要遍历$1$ 次</p>
<h5 id="算法图解"><a href="#算法图解" class="headerlink" title="算法图解"></a>算法图解</h5><p><img src="D:/nutStore/Learning/leetcode/pictures/bubbleSort.webp"></p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(alist)</span><br><span class="line">    exchange = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">            <span class="keyword">if</span> alist[j] &gt; alist[j+<span class="number">1</span>]:</span><br><span class="line">                alist[j], alist[j+<span class="number">1</span>] = alist[j+<span class="number">1</span>], alist[j]</span><br><span class="line">                exchange = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 如果发现整个排序过程中没有交换，提前结束</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exchange:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure>
<h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h5><ul>
<li><p>时间复杂度：$O(n^2)$</p>
<ul>
<li>最理想$O(n)$</li>
</ul>
</li>
<li><p>空间复杂度：$O(1)$</p>
</li>
<li><p>稳定</p>
</li>
</ul>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h5><p>很经典的排序算法。通过一趟排序将数据分割为两部分，一部分的数据均比另一部分的数据要小；再按照此方法对两部分数据分别进行快速排序，可利用递归方式实现。通常步骤：</p>
<ol>
<li>从数列中挑选一个基准；</li>
<li>重新排序数列，所有比基准小的元素放在基准前面，所有比基准大的放在基准后面（<strong>基准本身已排好</strong>）；</li>
<li>递归的把左右两区进行上述两步骤。</li>
</ol>
<h5 id="算法图解-1"><a href="#算法图解-1" class="headerlink" title="算法图解"></a>算法图解</h5><p><img src="D:/nutStore/Learning/leetcode/pictures/quickSort.webp"></p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span>(<span class="params">alist, l, r</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#当数列的大小比较小的时候，数列近乎有序的概率较大</span></span><br><span class="line">    <span class="comment"># if (r - l &lt;= 15):</span></span><br><span class="line">    <span class="comment">#     insertionSortHelp(alist, l, r)</span></span><br><span class="line">    <span class="comment">#     return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># p = partition(alist, l, r)</span></span><br><span class="line">    p = partition(alist, l, r)</span><br><span class="line"></span><br><span class="line">    quickSort(alist, l, p-<span class="number">1</span>)</span><br><span class="line">    quickSort(alist, p+<span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在alist[l...r]中寻找j,使得alist[l...j] &lt;= alist[l], alist[j+1...r] &gt;alist[l]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">alist, l, r</span>):</span></span><br><span class="line">    pos = randint(l, r)</span><br><span class="line">    alist[pos], alist[l] = alist[l], alist[pos]</span><br><span class="line">    v = alist[l]</span><br><span class="line">    <span class="comment"># v = alist[l]</span></span><br><span class="line">    <span class="comment"># j 表示v值所应当在的位置</span></span><br><span class="line">    j = l</span><br><span class="line">    i = l + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> alist[i] &lt;= v:</span><br><span class="line">            alist[j+<span class="number">1</span>],alist[i] = alist[i],alist[j+<span class="number">1</span>]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    alist[l], alist[j] = alist[j], alist[l]</span><br><span class="line">    <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure>
<h5 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h5><ul>
<li>时间复杂度：$n\log(n)$</li>
<li>空间复杂度：$n\log(n)$</li>
</ul>
<h4 id="手写上面的快排"><a href="#手写上面的快排" class="headerlink" title="手写上面的快排"></a>手写上面的快排</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span>(<span class="params">nums , l , r</span>):</span></span><br><span class="line">	<span class="keyword">if</span> l &gt;= r :</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">   	p = partition(nums , l , r)</span><br><span class="line">    </span><br><span class="line">    quickSort(nums , l , p-<span class="number">1</span>)</span><br><span class="line">    quickSort(nums , p+<span class="number">1</span> , r)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">nums , l , r</span>):</span></span><br><span class="line">    v = nums[l]</span><br><span class="line">    <span class="comment"># 表示V值所在的位置</span></span><br><span class="line">    j = l</span><br><span class="line">    <span class="comment"># 工作指针</span></span><br><span class="line">    i = l + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; v:</span><br><span class="line">          j += <span class="number">1</span></span><br><span class="line">          nums[i] , nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>] , nums[i]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    nums[j] , nums[l] = nums[l] , nums[j]</span><br><span class="line">	<span class="keyword">return</span> j</span><br></pre></td></tr></table></figure>
<p>上面partition函数中需要仔细分辨，例如一开始工作指针与V值所在位置的理解，以及最后的变化；</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="简单插入排序"><a href="#简单插入排序" class="headerlink" title="简单插入排序"></a>简单插入排序</h4><h5 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h5><p>它总是保持一个位置靠前的 已排好的子表，然后每一个新的数据项被 “插入” 到前边的子表里，排好的子表增加一项。我们认为只含有一个数据项的列表是已经排好的。每排后面一个数据（从 1 开始到 n-1），这 个的数据会和已排好子表中的数据比较。比较时，我们把之前已经排好的列表中比这个数据大的移到它的右边。当子表数据小于当前数据，或者当前数据已经和子表的所有数据比较了时，就可 以在此处插入当前数据项。</p>
<h5 id="算法图解-2"><a href="#算法图解-2" class="headerlink" title="算法图解"></a>算法图解</h5><p><img src="D:/nutStore/Learning/leetcode/pictures/insertSort.webp"></p>
<h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(alist)):</span><br><span class="line">        currentvalue=alist[i]</span><br><span class="line">        position=i</span><br><span class="line">        <span class="keyword">while</span> alist[position-<span class="number">1</span>]&gt;currentvalue <span class="keyword">and</span> position&gt;<span class="number">0</span>:</span><br><span class="line">            alist[position]=alist[position-<span class="number">1</span>]</span><br><span class="line">            position=position-<span class="number">1</span></span><br><span class="line">        alist[position]=currentvalue</span><br><span class="line">    <span class="keyword">return</span> alist </span><br></pre></td></tr></table></figure>
<h5 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h5><ul>
<li>时间复杂度：$O(n^2)$</li>
<li>空间复杂度:$O(1)$</li>
</ul>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><h5 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h5><p>这个是插入排序的修改版，根据步长由长到短分组，进行排序，直到步长为1为止，属于插入排序的一种。</p>
<h5 id="算法图解-3"><a href="#算法图解-3" class="headerlink" title="算法图解"></a>算法图解</h5><p><img src="D:/nutStore/Learning/leetcode/pictures/shellSort.webp"></p>
<h5 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shellSort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(alist)</span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap):</span><br><span class="line">            gapInsetionSort(alist, i, gap)</span><br><span class="line">        gap = gap // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> alist</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gapInsetionSort</span>(<span class="params">alist,startpos,gap</span>):</span></span><br><span class="line">    <span class="comment">#希尔排序的辅助函数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startpos+gap,<span class="built_in">len</span>(alist),gap):</span><br><span class="line">        position=i</span><br><span class="line">        currentvalue=alist[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> position&gt;startpos <span class="keyword">and</span> alist[position-gap]&gt;currentvalue:</span><br><span class="line">            alist[position]=alist[position-gap]</span><br><span class="line">            position=position-gap</span><br><span class="line">        alist[position]=currentvalue</span><br></pre></td></tr></table></figure>
<h5 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h5><ul>
<li>时间复杂度：$n\log (n)$</li>
<li></li>
</ul>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><h5 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h5><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<ul>
<li><p>初始状态：无序区为R[1..n]，有序区为空；</p>
</li>
<li><p>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</p>
</li>
<li><p>n-1趟结束，数组有序化了。</p>
</li>
</ul>
<h5 id="算法图解-4"><a href="#算法图解-4" class="headerlink" title="算法图解"></a>算法图解</h5><p><img src="D:/nutStore/Learning/leetcode/pictures/SelectSort.webp"></p>
<h5 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(alist)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 寻找[i,n]区间里的最小值</span></span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> alist[j] &lt; alist[min_index]:</span><br><span class="line">                min_index = j</span><br><span class="line">        alist[i], alist[min_index] = alist[min_index], alist[i]</span><br><span class="line">    <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure>


<h5 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h5><ul>
<li>时间复杂度：$O(n^2)$</li>
<li>空间复杂度:$O(1)$</li>
</ul>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h5 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h5><p>堆排序是一种基于二叉堆（Binary Heap）结构的排序算法，所谓二叉堆，我们通过完全二叉树来对比，只不过相比较完全二叉树而言，二叉堆的所有父节点的值都大于（或者小于）它的孩子节点，像这样：</p>
<p><img src="D:/nutStore/Learning/leetcode/pictures/heapSort.jpg"></p>
<p>首先需要引入最大堆的定义：</p>
<ul>
<li>最大堆中的最大元素值出现在根结点（堆顶）</li>
<li>堆中每个父节点的元素值都大于等于其孩子结点</li>
</ul>
<h5 id="算法图解-5"><a href="#算法图解-5" class="headerlink" title="算法图解"></a>算法图解</h5><p><img src="D:/nutStore/Learning/leetcode/pictures/heapSort.webp"></p>
<h5 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#建立堆函数：</span></span><br><span class="line"></span><br><span class="line">void heapify(<span class="built_in">int</span> arr[], <span class="built_in">int</span> n, <span class="built_in">int</span> i) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">int</span> largest = i; // 将最大元素设置为堆顶元素</span><br><span class="line">    <span class="built_in">int</span> l = <span class="number">2</span>*i + <span class="number">1</span>; // left = <span class="number">2</span>*i + <span class="number">1</span> </span><br><span class="line">    <span class="built_in">int</span> r = <span class="number">2</span>*i + <span class="number">2</span>; // right = <span class="number">2</span>*i + <span class="number">2</span> </span><br><span class="line">  </span><br><span class="line">    // 如果 left 比 root 大的话</span><br><span class="line">    <span class="keyword">if</span> (l &lt; n &amp;&amp; arr[l] &gt; arr[largest]) </span><br><span class="line">        largest = l; </span><br><span class="line">  </span><br><span class="line">    // I如果 right 比 root 大的话</span><br><span class="line">    <span class="keyword">if</span> (r &lt; n &amp;&amp; arr[r] &gt; arr[largest]) </span><br><span class="line">        largest = r; </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (largest != i) </span><br><span class="line">    &#123; </span><br><span class="line">        swap(arr[i], arr[largest]); </span><br><span class="line">  </span><br><span class="line">        // 递归地定义子堆</span><br><span class="line">        heapify(arr, n, largest); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>堆排序的方法如下，把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">void heapSort(<span class="built_in">int</span> arr[], <span class="built_in">int</span> n) </span><br><span class="line">&#123; </span><br><span class="line">    // 建立堆</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">        heapify(arr, n, i); </span><br><span class="line">  </span><br><span class="line">    // 一个个从堆顶取出元素</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i=n-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) </span><br><span class="line">    &#123; </span><br><span class="line">        swap(arr[<span class="number">0</span>], arr[i]);  </span><br><span class="line">        heapify(arr, i, <span class="number">0</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<h5 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h5><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="二路归并排序"><a href="#二路归并排序" class="headerlink" title="二路归并排序"></a>二路归并排序</h4><h5 id="算法思想-6"><a href="#算法思想-6" class="headerlink" title="算法思想"></a>算法思想</h5><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
<ul>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<p><img src="D:/nutStore/Learning/leetcode/pictures/MergeSort2.jpg"></p>
<h5 id="算法图解-6"><a href="#算法图解-6" class="headerlink" title="算法图解"></a>算法图解</h5><p><img src="D:/nutStore/Learning/leetcode/pictures/MergeSort.webp"></p>
<h5 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#之前copy了一份归并排序的算法，但那份代码包含太多优化行，导致算法思路不清晰</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">arr,l,r</span>):</span></span><br><span class="line">    <span class="comment"># l == r 时，不做任何处理，单独有序</span></span><br><span class="line">    <span class="keyword">if</span> l &lt; r :</span><br><span class="line">        m = <span class="built_in">int</span>((l + r) / <span class="number">2</span>)</span><br><span class="line">        mergeSort(arr,l,m)</span><br><span class="line">        mergeSort(arr , m+<span class="number">1</span> , r)</span><br><span class="line">        merge(arr , l ,m , r)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">arr , l , m , r</span>):</span></span><br><span class="line">    copyl = arr[l:m+<span class="number">1</span>]</span><br><span class="line">    copyr = arr[m+<span class="number">1</span>:r+<span class="number">1</span>]</span><br><span class="line">    lenl = <span class="built_in">len</span>(copyl)</span><br><span class="line">    lenr = <span class="built_in">len</span>(copyr)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    k = l</span><br><span class="line">    <span class="keyword">while</span> i &lt; lenl <span class="keyword">and</span> j &lt; lenr :</span><br><span class="line">        <span class="keyword">if</span> copyl[i] &lt; copyr[j]:</span><br><span class="line">            arr[k] = copyl[i]</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arr[k] = copyr[ j]</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; lenl :</span><br><span class="line">        arr[k] = copyl[i]</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; lenr:</span><br><span class="line">        arr[k] = copyr[j]</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>注意：这里进行小的优化，当数列的长度小于等于15的时候，我们一般认为数列此时基本有序，这时候采用直接插入排序非常快。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自底向上的归并算法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeBU</span>(<span class="params">alist</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(alist)</span><br><span class="line">    <span class="comment">#表示归并的大小</span></span><br><span class="line">    size = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> size &lt;= n:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n-size, size+size):</span><br><span class="line">            merge(alist, i, i+size-<span class="number">1</span>, <span class="built_in">min</span>(i+size+size-<span class="number">1</span>, n-<span class="number">1</span>))</span><br><span class="line">        size += size</span><br><span class="line">    <span class="keyword">return</span> alist</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并有序数列alist[start....mid] 和 alist[mid+1...end]，使之成为有序数列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">alist, start, mid, end</span>):</span></span><br><span class="line">    <span class="comment"># 复制一份</span></span><br><span class="line">    blist = alist[start:end+<span class="number">1</span>]</span><br><span class="line">    l = start</span><br><span class="line">    k = mid + <span class="number">1</span></span><br><span class="line">    pos = start</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> pos &lt;= end:</span><br><span class="line">        <span class="keyword">if</span> (l &gt; mid):</span><br><span class="line">            alist[pos] = blist[k-start]</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> (k &gt; end):</span><br><span class="line">            alist[pos] = blist[l-start]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> blist[l-start] &lt;= blist[k-start]:</span><br><span class="line">            alist[pos] = blist[l-start]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            alist[pos] = blist[k-start]</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        pos += <span class="number">1</span></span><br></pre></td></tr></table></figure>


<h5 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h5><h4 id="多路归并排序"><a href="#多路归并排序" class="headerlink" title="多路归并排序"></a>多路归并排序</h4><p>这里没有写</p>
<h2 id="非比较排序"><a href="#非比较排序" class="headerlink" title="非比较排序"></a>非比较排序</h2><p>非比较排序打破了时间复杂度$n\log n$ 的限制</p>
<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><h5 id="算法思想-7"><a href="#算法思想-7" class="headerlink" title="算法思想"></a>算法思想</h5><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<ul>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ul>
<h5 id="算法图解-7"><a href="#算法图解-7" class="headerlink" title="算法图解"></a>算法图解</h5><p><img src="D:/nutStore/Learning/leetcode/pictures/countSort.webp"></p>
<h5 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">countingSort</span><span class="params">(arr, maxValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bucket = <span class="keyword">new</span> Array(maxValue + <span class="number">1</span>),</span><br><span class="line">        sortedIndex = <span class="number">0</span>;</span><br><span class="line">        arrLen = arr.length,</span><br><span class="line">        bucketLen = maxValue + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arrLen; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bucket[arr[i]]) &#123;</span><br><span class="line">            bucket[arr[i]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bucket[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; bucketLen; j++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr[sortedIndex++] = j;</span><br><span class="line">            bucket[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="算法分析-7"><a href="#算法分析-7" class="headerlink" title="算法分析"></a>算法分析</h5><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><h5 id="算法思想-8"><a href="#算法思想-8" class="headerlink" title="算法思想"></a>算法思想</h5><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<p>桶排序的原理是将数组分到有限数量的桶中，再对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。</p>
<p>排序过程：</p>
<ol>
<li>假设待排序的一组数统一的分布在一个范围中，并将这一范围划分成几个子范围，也就是桶</li>
<li>将待排序的一组数，分档规入这些子桶，并将桶中的数据进行排序</li>
<li>将各个桶中的数据有序的合并起</li>
</ol>
<h5 id="算法图解-8"><a href="#算法图解-8" class="headerlink" title="算法图解"></a>算法图解</h5><p><img src="D:/nutStore/Learning/leetcode/pictures/buckgetSort.jpg"></p>
<h5 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">bucketSort</span><span class="params">(arr, bucketSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> i;</span><br><span class="line">    <span class="keyword">var</span> minValue = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; minValue) &#123;</span><br><span class="line">          minValue = arr[i];                <span class="comment">// 输入数据的最小值</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; maxValue) &#123;</span><br><span class="line">          maxValue = arr[i];                <span class="comment">// 输入数据的最大值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 桶的初始化</span></span><br><span class="line">    <span class="keyword">var</span> DEFAULT_BUCKET_SIZE = <span class="number">5</span>;            <span class="comment">// 设置桶的默认数量为5</span></span><br><span class="line">    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;</span><br><span class="line">    <span class="keyword">var</span> bucketCount = Math.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">var</span> buckets = <span class="keyword">new</span> Array(bucketCount);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    arr.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        insertionSort(buckets[i]);                      <span class="comment">// 对每个桶进行排序，这里使用了插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">            arr.push(buckets[i][j]);                     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="算法分析-8"><a href="#算法分析-8" class="headerlink" title="算法分析"></a>算法分析</h5><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><h5 id="算法思想-9"><a href="#算法思想-9" class="headerlink" title="算法思想"></a>算法思想</h5><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<ul>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ul>
<h5 id="算法图解-9"><a href="#算法图解-9" class="headerlink" title="算法图解"></a>算法图解</h5><p><img src="D:/nutStore/Learning/leetcode/pictures/redixSort.webp"></p>
<h5 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var counter = [];</span><br><span class="line">function radixSort(arr, maxDigit) &#123;</span><br><span class="line">    var mod = <span class="number">10</span>;</span><br><span class="line">    var dev = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(var j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            var bucket = parseInt((arr[j] % mod) / dev);</span><br><span class="line">            <span class="keyword">if</span>(counter[bucket]==null) &#123;</span><br><span class="line">                counter[bucket] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            counter[bucket].push(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        var pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(var j = <span class="number">0</span>; j &lt; counter.length; j++) &#123;</span><br><span class="line">            var value = null;</span><br><span class="line">            <span class="keyword">if</span>(counter[j]!=null) &#123;</span><br><span class="line">                <span class="keyword">while</span> ((value = counter[j].shift()) != null) &#123;</span><br><span class="line">                      arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="算法分析-9"><a href="#算法分析-9" class="headerlink" title="算法分析"></a>算法分析</h5><p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p>
<p>基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯法</title>
    <url>/2021/01/24/%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    <content><![CDATA[<h3 id="回朔法的思想："><a href="#回朔法的思想：" class="headerlink" title="回朔法的思想："></a>回朔法的思想：</h3><p>回朔法的重要思想在于： 通过枚举法，对所有可能性进行遍历。 但是枚举的顺序是 一条路走到黑，发现黑之后，退一步，再向前尝试没走过的路。直到所有路都试过。因此回朔法可以简单的理解为： 走不通就退一步的方枚举法就叫回朔法。而这里回退点也叫做回朔点。</p>
<a id="more"></a>

<h3 id="回朔关键点"><a href="#回朔关键点" class="headerlink" title="回朔关键点"></a>回朔关键点</h3><p>通过分析发现，回朔法实现的三大技术关键点分别是：</p>
<ol>
<li>一条路走到黑</li>
<li>回退一步</li>
<li>另寻他路</li>
</ol>
<h3 id="关键点的实现"><a href="#关键点的实现" class="headerlink" title="关键点的实现"></a>关键点的实现</h3><p>那么如何才能用代码实现上述三个关键点呢？</p>
<ol>
<li>for 循环</li>
<li>递归</li>
</ol>
<h4 id="解释如下"><a href="#解释如下" class="headerlink" title="解释如下"></a>解释如下</h4><ul>
<li>for循环的作用在于另寻他路： 你可以用for循环可以实现一个路径选择器的功能，该路径选择器可以逐个选择当前节点下的所有可能往下走下去的分支路径。 例如： 现在你走到了节点a，a就像个十字路口，你从上面来到达了a，可以继续向下走。若此时向下走的路有i条，那么你肯定要逐个的把这i条都试一遍才行。而for的作用就是可以让你逐个把所有向下的i个路径既不重复，也不缺失的都试一遍</li>
<li>递归可以实现一条路走到黑和回退一步： 一条路走到黑： 递归意味着继续向着for给出的路径向下走一步。 如果我们把递归放在for循环内部，那么for每一次的循环，都在给出一个路径之后，进入递归，也就继续向下走了。直到递归出口（走无可走）为止。 那么这就是一条路走到黑的实现方法。 递归从递归出口出来之后，就会实现回退一步。</li>
</ul>
<p>因此for循环和递归配合可以实现回朔： 当递归从递归出口出来之后。上一层的for循环就会继续执行了。而for循环的继续执行就会给出当前节点下的下一条可行路径。而后递归调用，就顺着这条从未走过的路径又向下走一步。这就是回朔</p>
<p>说了这么多，回朔法的通常模板是什么呢？ 递归和for又是如何配合的呢？</p>
<h4 id="回朔代码模板"><a href="#回朔代码模板" class="headerlink" title="回朔代码模板"></a>回朔代码模板</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def backward():</span><br><span class="line">    </span><br><span class="line">    if (回朔点）：# 这条路走到底的条件。也是递归出口</span><br><span class="line">        保存该结果</span><br><span class="line">        return   </span><br><span class="line">    </span><br><span class="line">    else:</span><br><span class="line">        for route in all_route_set :  逐步选择当前节点下的所有可能route</span><br><span class="line">            </span><br><span class="line">            if 剪枝条件：</span><br><span class="line">                剪枝前的操作</span><br><span class="line">                return   #不继续往下走了，退回上层，换个路再走</span><br><span class="line">            </span><br><span class="line">            else：#当前路径可能是条可行路径</span><br><span class="line">            </span><br><span class="line">                保存当前数据  #向下走之前要记住已经走过这个节点了。例如push当前节点</span><br><span class="line">        </span><br><span class="line">                self.backward() #递归发生，继续向下走一步了。</span><br><span class="line">                </span><br><span class="line">                回朔清理     # 该节点下的所有路径都走完了，清理堆栈，准备下一个递归。例如弹出当前节点</span><br></pre></td></tr></table></figure>
<p>这里剪枝操作指的是： 对于有些问题，你走着走着，若某种情况发生了，你就已经直到不能继续往下走了，再走也没有用了。而这个情况就被称之为剪枝条件。</p>
<p>而DFS就是一个最典型的回朔法的应用。</p>
<h2 id="本题代码"><a href="#本题代码" class="headerlink" title="本题代码"></a>本题代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(candidates) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        path = []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        ！！！重点！！！</span></span><br><span class="line"><span class="string">        在python中，如果传参是mutable var, 那么传参相当于引用，因此调用后，如果调用函数的内部对该传入变量进行修改，就会导致直接改变原始对象。这就是典型的privacy leak！！发生了。</span></span><br><span class="line"><span class="string">        例如在这个，list就是该mutable var，而如果以path或res 为传参，放在__DFS 中， 那么就相当于在__DFS内部，实际上用的都是一个物理地址下的res和path，类似于全局变量。</span></span><br><span class="line"><span class="string">        因此combinationSum下的局部变量path和res也在——DFS运行的过程中发生了改变。</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        利用这个性质，我们可以把mutable var当成传入参数，从而实现全局变量的效果。</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.__DFS(candidates, target, <span class="number">0</span>, path, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        DFS的实现</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__DFS</span>(<span class="params">self, candidates, target, begin, path, res</span>):</span></span><br><span class="line">        path = path.copy()</span><br><span class="line">        <span class="comment"># 递归出口 就是余数为0</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            res.append(path)   <span class="comment">#记录该符合条件的结果</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#若当前路径有可能可行。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(begin, <span class="built_in">len</span>(candidates)):  <span class="comment"># 我们现在到begin的节点上了</span></span><br><span class="line">            <span class="keyword">if</span> target - candidates[i] &lt; <span class="number">0</span>:  <span class="comment"># 剪枝条件</span></span><br><span class="line">                <span class="keyword">return</span>                      <span class="comment"># 如果当前节点就不行了，就不用继续了,这里到不用继续了即包括该depth不用继续了，也包括该节点更大到child也不用继续了，该节点pop出来</span></span><br><span class="line">            </span><br><span class="line">            path.append(candidates[i])  <span class="comment">#记录当前为止</span></span><br><span class="line">            self.__DFS(candidates, target - candidates[i], i, path, res)<span class="comment"># 向下继续走，记住递归不是return，递归到实现是调用！一旦return发生，递归停止。</span></span><br><span class="line">            path.pop()  <span class="comment"># 回朔清理。当前节点下的所有情况都进行完了，该节点也不应该在path</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2021/01/24/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p>最近在刷Leetcode（NO.399）过程中看到了并查集的概念，发现自己并不是很清楚其概念，故这里将相关概念总结如下：</p>
<a id="more"></a>

<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/93647900">知乎专栏</a>、<a href="https://www.cnblogs.com/cyanigence-oi/p/11774190.html">相关博客</a>、<a href="https://leetcode-cn.com/problems/number-of-provinces/solution/python-duo-tu-xiang-jie-bing-cha-ji-by-m-vjdr/">牛客网友解释</a></p>
</blockquote>
<h2 id="并查集的概念"><a href="#并查集的概念" class="headerlink" title="并查集的概念"></a>并查集的概念</h2><p>并查集首先是一种<strong>数据结构</strong>，在这种数据结构中其管理了一系列的<strong>不相交的集合</strong>，并且只存在<strong>合并</strong>与<strong>查询</strong>两种操作。有人将并查集如此解读：</p>
<ul>
<li>并(UNION):合并</li>
<li>查(Find): 查找</li>
<li>集(Set):一个以<strong>字典</strong>为基础的数据结构；</li>
</ul>
<p>并查集跟树有些类似，只不过跟树是相反的。在树这个数据结构里面，每个节点会记录它的子节点。在并查集里，每个节点会记录它的父节点。</p>
<h3 id="两种核心操作"><a href="#两种核心操作" class="headerlink" title="两种核心操作"></a>两种核心操作</h3><ul>
<li>合并：把两个不相交的集合合并为同一个集合</li>
<li>查询：查询当前元素所属集合。</li>
</ul>
<h3 id="并查集核心思想"><a href="#并查集核心思想" class="headerlink" title="并查集核心思想"></a>并查集核心思想</h3><p>用<strong>集合中某元素来代表此集合</strong>，通常此元素为根节点。要想找到此集合的<strong>代表元素</strong>，就需要不断的寻找<strong>父</strong>节点，直到父节点为本身时，即为代表元素。</p>
<h3 id="并查集中的概念梳理"><a href="#并查集中的概念梳理" class="headerlink" title="并查集中的概念梳理"></a>并查集中的概念梳理</h3><blockquote>
<p>来源于<a href="https://leetcode-cn.com/problems/number-of-provinces/solution/python-duo-tu-xiang-jie-bing-cha-ji-by-m-vjdr/">牛客网友解释</a></p>
</blockquote>
<ul>
<li>并查集的初始化：利用字典记录父节点信息</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        记录每个节点的父节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.father = &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>并查集的连通性：在同一棵树里(祖先节点相同)，则说明两节点连通，如下图所示：</p>
<p><img src="https://i.loli.net/2021/01/20/tr6x3aKzNfTgGuy.png" alt="image-20210120161137309"></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_connected</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    判断两节点是否相连</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> self.find(x) == self.find(y)</span><br><span class="line">  </span><br></pre></td></tr></table></figure>


<ul>
<li>添加节点：在字典实现中，需要置父节点为空即可。</li>
</ul>
<p><img src="https://i.loli.net/2021/01/20/mTuaPHWv8Oq2QJB.png" alt="image-20210120161401471"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self,x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    添加新节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> self.father:</span><br><span class="line">        self.father[x] = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>合并节点：合并节点就是将其祖先节点一致，可以任意加入对方的队伍。</p>
<p><img src="https://i.loli.net/2021/01/20/JQebsm2H3YwrqvE.png" alt="image-20210120161558452"></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self,x,y,val</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    合并两个节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    root_x,root_y = self.find(x),self.find(y)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> root_x != root_y:</span><br><span class="line">        self.father[root_x] = root_y</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<ul>
<li>查找祖先：父节点不为空：不停的迭代或者递归均可以</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self,x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    查找根节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    root = x</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> self.father[root] != <span class="literal">None</span>:</span><br><span class="line">        root = self.father[root]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>


<p>  <img src="https://i.loli.net/2021/01/20/Egq4MBtul1CiJz2.gif" alt="Union_Find"></p>
<ul>
<li><p>路径压缩：查询时启动的路径优化算法，就是将路径上所有的节点直接连接到祖先节点</p>
<p><img src="https://i.loli.net/2021/01/20/OkZcPEgNwiB3UpG.gif" alt="Union_PassZip"></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self,x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    查找根节点</span></span><br><span class="line"><span class="string">    路径压缩</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    root = x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.father[root] != <span class="literal">None</span>:</span><br><span class="line">        root = self.father[root]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 路径压缩</span></span><br><span class="line">    <span class="keyword">while</span> x != root:</span><br><span class="line">        original_father = self.father[x]</span><br><span class="line">        self.father[x] = root</span><br><span class="line">        x = original_father</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h2 id="并查集的实现："><a href="#并查集的实现：" class="headerlink" title="并查集的实现："></a>并查集的实现：</h2><h3 id="数组实现："><a href="#数组实现：" class="headerlink" title="数组实现："></a>数组实现：</h3><p>在<a href="https://zhuanlan.zhihu.com/p/93647900">知乎专栏</a>介绍中，已经利用数组实现了并查集，不推荐使用。</p>
<ul>
<li><p>找到祖先节点的标志是：本身记为父节点。</p>
</li>
<li><p>采用了递归的方式寻找祖先节点</p>
<p>这里不再赘述。并且我个人认为数组的形式天然不适合作为并查集的实现方式，而字典这种键值对的方式更加适合实现并查集。</p>
</li>
</ul>
<p><strong>不建议适用数组实现</strong></p>
<h3 id="字典实现模板"><a href="#字典实现模板" class="headerlink" title="字典实现模板"></a>字典实现模板</h3><p>这里提供字典的实现方式，并且祖先节点的标志为：自身的父节点为None时为祖先节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        记录每个节点的父节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.father = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        查找根节点</span></span><br><span class="line"><span class="string">        路径压缩</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        root = x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.father[root] != <span class="literal">None</span>:</span><br><span class="line">            root = self.father[root]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 路径压缩</span></span><br><span class="line">        <span class="keyword">while</span> x != root:</span><br><span class="line">            original_father = self.father[x]</span><br><span class="line">            self.father[x] = root</span><br><span class="line">            x = original_father</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self,x,y,val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        合并两个节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        root_x,root_y = self.find(x),self.find(y)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root_x != root_y:</span><br><span class="line">            self.father[root_x] = root_y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_connected</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        判断两节点是否相连</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.find(x) == self.find(y)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        添加新节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> self.father:</span><br><span class="line">            self.father[x] = <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树_Minimum-Spanning-Tree</title>
    <url>/2021/01/24/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-Minimum-Spanning-Tree/</url>
    <content><![CDATA[<p>最小生成树是图的应用之一，是<strong>无向有权图的最短路径</strong>算法。</p>
<a id="more"></a>

<h2 id="图的应用有哪些？"><a href="#图的应用有哪些？" class="headerlink" title="图的应用有哪些？"></a>图的应用有哪些？</h2><p>最小生成树，最短路径，关键路径，拓扑排序，关键路径等。每种应用适用的场景不同，但是却很容易混淆，原因之一就是实践的太少。</p>
<h2 id="最小生成树是什么？"><a href="#最小生成树是什么？" class="headerlink" title="最小生成树是什么？"></a>最小生成树是什么？</h2><p>生成树是<strong>图</strong>的极小连通子图，特点有二：</p>
<ol>
<li>包括<strong>所有</strong>图中顶点，n个顶点；</li>
<li>包括尽可能少的边，n-1条边。</li>
</ol>
<p>意味着增加一条边就会产生回路，减少一条边则非连通。</p>
<p>那么<strong>最小生成树就是所有生成树中，权值和最小的生成树</strong>，最小生成树的性质有三：</p>
<ol>
<li>最小生成树不唯一；</li>
<li>最小生成树边的权值和是唯一的；</li>
<li>边的数量等于定点数量-1.</li>
</ol>
<h2 id="最小生成树的算法：Prim与Kruskal"><a href="#最小生成树的算法：Prim与Kruskal" class="headerlink" title="最小生成树的算法：Prim与Kruskal"></a>最小生成树的算法：Prim与Kruskal</h2><p>Prim与Kruskal算法均是基于<strong>贪心的策略</strong>，两算法中均利用最小树中的性质：</p>
<ul>
<li><p>假设存在带权连通无向图， $ G = （V,E） $, $U$ 标识最小生成树中的节点集，$(u,v)$ 标识一条具有最小权值的边，其中$ u\in U , v\in (V-U) $ ,那么必然存在一颗包含有边$ (u,v) $ 的最小生成树。</p>
<p>上面的性质乍看一下很是不好理解，但可以直接理解为一句话：<strong>当前权值最小的边一定会被选进最小生成树中。</strong></p>
</li>
</ul>
<p>大多数的算法均采用，加入边的方式进行设计，Prim与Kruskal也不例外。</p>
<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><h4 id="算法思想：从点的角度找边"><a href="#算法思想：从点的角度找边" class="headerlink" title="算法思想：从点的角度找边"></a>算法思想：从点的角度找边</h4><p>假设：存在一个无向有权连通图$ G=(V,E) $ , $V_{t}$ 代表最小生成树中的节点，$V_{out} = V - V_t$ 代表未被选入最小生成树的节点，$ E_{t} $ 代表生成树边的集合。</p>
<p>初始$ V_t = {u_0}  , E_t ={} $,重复下个步骤：</p>
<ul>
<li>在所有$u\in V_t , v \in V_{out}$ 寻找最小的权值边$ e_{(u,v)}$ ,将此边加入到$E_{t}$中，节点$v$加入到$V_t$中。</li>
</ul>
<p>直到$V_t = V$为止。</p>
<p>时间复杂度：$O(|V|^2)$，不依赖于边$E$ , 适合于边稠密的情况。</p>
<p>算法执行步骤如下图所示：</p>
<p><img src="https://i.loli.net/2021/01/19/OBDbg3LM5qi4Gck.png" alt="Prim算法示意图"></p>
<h4 id="代码步骤"><a href="#代码步骤" class="headerlink" title="代码步骤"></a>代码步骤</h4><p>参考地址：<a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/solution/prim-and-kruskal-by-yexiso-c500/">牛客网友回答</a></p>
<p>通过维护两个数组：</p>
<ul>
<li>lowCost数组标识：$V_{t}$ 到所有节点的最小花销，如果该节点已经在$V_{t}$ 中，那么置为float(“inf”)；</li>
<li>VStatus数组标识：各节点的访问情况，初始化为0，若已访问则置为-1；</li>
</ul>
<ol>
<li>随机选择起点，加入到$V_t$中，更新lowCost与VStatus数组;</li>
<li>遍历lowCost数组，选择最小边（索引为j），将此边加入$E_{t}$,将此节点加入$V_{t}$,更新$lowCost[j]与VStatus[j]$</li>
<li>此时$V_t$ 已经发生了变化，需要更新所有的lowCost数组值；</li>
<li>重复第2步，直到所有的节点均已加入树中。</li>
</ol>
<p>如图所示：</p>
<p><img src="https://pic.leetcode-cn.com/1611023745-EuGMdh-image.png"></p>
<h4 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h4><blockquote>
<p>以Leetcode1584题为例：</p>
<p>You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].</p>
<p>The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.</p>
<p>Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Prim算法的常规实现形式，未使用堆。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostConnectPoints</span>(<span class="params">self, points: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">distance</span>(<span class="params">pointA , pointB</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(pointA[<span class="number">0</span>] - pointB[<span class="number">0</span>]) + <span class="built_in">abs</span>(pointA[<span class="number">1</span>] - pointB[<span class="number">1</span>])</span><br><span class="line">        length = <span class="built_in">len</span>(points)</span><br><span class="line">        lowCost = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">        vStatus = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">        <span class="comment"># 构造邻接矩阵方便之后的调用，非必须</span></span><br><span class="line">        costMatrix = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span> , length):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span> , length):</span><br><span class="line">                dist = distance(points[i] , points[j])</span><br><span class="line">                costMatrix[i][j] = costMatrix[j][i] = dist</span><br><span class="line">        <span class="comment"># 将第一个点加入V_t,并更新相关数组lowCost,vStatus</span></span><br><span class="line">        vStatus[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">        lowCost[<span class="number">0</span>] = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,length):</span><br><span class="line">            lowCost[j] = costMatrix[<span class="number">0</span>][j]</span><br><span class="line">        output = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 寻找n-1次边</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 找到最小的边与索引</span></span><br><span class="line">            minCost = <span class="built_in">min</span>(lowCost)</span><br><span class="line">            minIndex = lowCost.index(minCost)</span><br><span class="line">            output += minCost</span><br><span class="line">            <span class="comment"># 更新lowCost[j] , vStatus[j]</span></span><br><span class="line">            lowCost[minIndex] = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">            vStatus[minIndex] = -<span class="number">1</span></span><br><span class="line">            <span class="comment"># 更新所有的lowCost</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                <span class="keyword">if</span> vStatus[i] != -<span class="number">1</span> <span class="keyword">and</span> costMatrix[minIndex][i] &lt; lowCost[i]:</span><br><span class="line">                    lowCost[i] = costMatrix[minIndex][i]</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：$O(n^2)$,每一次在更新lowCost的复杂度均为$O(n)$.</li>
<li>空间复杂度：$O(n^2)$.</li>
</ul>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><h4 id="算法思想-从边的角度触发"><a href="#算法思想-从边的角度触发" class="headerlink" title="算法思想:从边的角度触发"></a>算法思想:从边的角度触发</h4><p>假设：存在一个无向有权连通图$ G=(V,E) $ , $V_{t}$ 代表最小生成树中的节点，$V_{out} = V - V_t$ 代表未被选入最小生成树的节点，$ E_{t} $ 代表生成树边的集合。</p>
<p>初始化：$V_t = V , V_{out} = \empty , E_t = {}$,每一个顶点是一棵树，此时的最小生成树是含有N棵树的森林。重复下面的步骤：</p>
<ul>
<li>按照图$ G$ 中权值递增的顺序从边$ E-E_t $ 选择边$e$ , 如果边并没有构成回路则添加进$E_t$ 中，否则舍弃此边。</li>
</ul>
<p>直到$E_t$ 中包含有n-1条边。</p>
<ul>
<li>时间复杂度：$ |E|log|E| $,适合变稀疏的情况。</li>
</ul>
<p>算法执行步骤如下图所示：</p>
<p><img src="https://i.loli.net/2021/01/20/O3MJvk7A4ljUmf1.png" alt="image-20210120133332552"></p>
<h4 id="代码步骤-1"><a href="#代码步骤-1" class="headerlink" title="代码步骤"></a>代码步骤</h4><p>利用<strong>并查集</strong>，很容易解决此类问题。并查集的定义与模板代码，可以看我的解释。</p>
<ol>
<li>构建一个带有并查集的类，并实现相关功能；</li>
<li>计算所有的边长，并记录顶点信息，存储在数组$E$ 中，按照边长排序；</li>
<li>初始化并查集（将所有的顶点加入到并查集中）；</li>
<li>遍历$E$,假设每一个边由$e = [len , i , j]$ 组成：<ul>
<li>如果顶点$i，j$ 属于同一个集合，那么舍弃；</li>
<li>否则进行集合合并操作，并累积output</li>
</ul>
</li>
<li>返回output</li>
</ol>
<p><img src="https://pic.leetcode-cn.com/1611021826-GzvMAP-image.png"></p>
<h4 id="算法代码-1"><a href="#算法代码-1" class="headerlink" title="算法代码"></a>算法代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 同样以1584题为例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.father = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self , x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> self.father:</span><br><span class="line">            self.father[x] = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self , x</span>):</span></span><br><span class="line">        root = x</span><br><span class="line">        <span class="keyword">while</span> self.father[root]:</span><br><span class="line">            root = self.father[root]</span><br><span class="line">        <span class="keyword">while</span> x != root:</span><br><span class="line">            originalFather = self.father[x]</span><br><span class="line">            self.father[x] = root</span><br><span class="line">            x = originalFather</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isConnect</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.find(x)== self.find(y)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self , x ,y</span>):</span></span><br><span class="line">        rootX = self.find(x)</span><br><span class="line">        rootY = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> rootX != rootY:</span><br><span class="line">            self.father[rootX] = rootY</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostConnectPoints</span>(<span class="params">self, points: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">distance</span>(<span class="params">pointA , pointB</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(pointA[<span class="number">0</span>] - pointB[<span class="number">0</span>]) + <span class="built_in">abs</span>(pointA[<span class="number">1</span>] - pointB[<span class="number">1</span>])</span><br><span class="line">        length = <span class="built_in">len</span>(points)</span><br><span class="line">        <span class="comment"># 边排序</span></span><br><span class="line">        E = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span> , length):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span> , length):</span><br><span class="line">                dist = distance(points[i] , points[j])</span><br><span class="line">                E.append([dist,i,j])</span><br><span class="line">        E.sort(key = <span class="keyword">lambda</span> k : k[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 初始化并查集</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            self.add(i)</span><br><span class="line">        </span><br><span class="line">        output = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 从小到大寻找边，如果构成回路则跳过，否则加入</span></span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> E:</span><br><span class="line">            <span class="keyword">if</span> self.isConnect(e[<span class="number">1</span>] , e[<span class="number">2</span>]):</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                output += e[<span class="number">0</span>]</span><br><span class="line">                self.merge(e[<span class="number">1</span>],e[<span class="number">2</span>])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：$O(mlog(m) + m\alpha(m))$,m为索引对的数量</li>
<li>空间复杂度：$O(n^2)$</li>
</ul>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口算法</title>
    <url>/2021/01/24/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>滑动窗口是双指针的技巧之一。滑动窗口技巧一般用于解决子字符串问题。</p>
<a id="more"></a>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/hua-dong-chuang-kou-tong-yong-si-xiang-jie-jue-zi-/">参考地址</a> ， 我个人是在刷LEETCODE438题时，采用了此框架，具体代码可以看这道题目的解析文档。</p>
</blockquote>
<h2 id="滑动窗口框架"><a href="#滑动窗口框架" class="headerlink" title="滑动窗口框架"></a>滑动窗口框架</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在此框架中，几个注意点：</p>
<ol>
<li><p>Need哈希表用于记录目标子字符串中，对应的字母与出现的频次，这代表了你的滑动窗口<strong>应当满足的最低要求</strong>。</p>
<blockquote>
<p>哈希表的应用使得对目标字符串不限于顺序，而且保留了频次。在诸多题目中，均不限于顺序。</p>
</blockquote>
</li>
<li><p>Windows哈希表用于记录<strong>当前滑动窗口</strong>内<strong>目标字符串</strong>出现的字母与频次。</p>
<blockquote>
<p>在形式上与Need哈希表的形式是一摸一样的，但这里是记录的当前滑动窗口内符合条件的字母与频次，这代表Windows既可以不满足，也可以过满足。</p>
</blockquote>
</li>
<li><p>right指针作为迭代下标</p>
</li>
<li><p>窗口扩大与窗口缩小的内部逻辑是对应的</p>
</li>
</ol>
<h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><blockquote>
<p>这里直接摘抄</p>
</blockquote>
<p>滑动窗口算法的思路是这样：</p>
<p>1、我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引左闭右开区间 [left, right) 称为一个「窗口」。</p>
<p>2、我们先不断地增加 right 指针扩大窗口 [left, right)，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。</p>
<p>3、此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right)，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。</p>
<p>4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。</p>
<p>这个思路其实也不难，<strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，</strong>也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。</p>
<p>下面画图理解一下，needs 和 window 相当于计数器，分别记录 T 中字符出现次数和「窗口」中的相应字符的出现次数。</p>
<p>初始状态：</p>
<p><img src="https://pic.leetcode-cn.com/499fb00764379df32e1dbfc29d90230d9fc7df0a1cd5c1855b0bafeb867ccfc7.png"></p>
<p>增加 right，直到窗口 [left, right] 包含了 T 中所有字符：</p>
<p><img src="https://pic.leetcode-cn.com/5389a9b4db5ebaa796fbf1ddba1724469e00ad9fc27b45688ea55eb8f581a98b.png"></p>
<p>现在开始增加 left，缩小窗口 [left, right]。</p>
<p><img src="https://pic.leetcode-cn.com/222cb6badc76bf37e91b012e338b36cbf3b698afd986ebfa94297d900b22e29c.png"></p>
<p>直到窗口中的字符串不再符合要求，left 不再继续移动。</p>
<p><img src="https://pic.leetcode-cn.com/de0164765478570d749d94db184333e3e8cff8c0632b02505f93d7bc6e973ff5.png"></p>
<p>之后重复上述过程，先移动 right，再移动 left…… 直到 right 指针到达字符串 S 的末端，算法结束。</p>
<p>现在开始套模板，只需要思考以下四个问题：</p>
<p>1、当移动 right 扩大窗口，即加入字符时，应该更新哪些数据？</p>
<blockquote>
<p>如果一个字符进入窗口，应该增加 window 计数器；</p>
</blockquote>
<p>2、什么条件下，窗口应该暂停扩大，开始移动 left 缩小窗口？</p>
<blockquote>
<p>当 valid 满足 need 时应该收缩窗口；</p>
</blockquote>
<p>3、当移动 left 缩小窗口，即移出字符时，应该更新哪些数据？</p>
<blockquote>
<p>如果一个字符将移出窗口的时候，应该减少 window 计数器</p>
</blockquote>
<p>4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？</p>
<blockquote>
<p>应该在收缩窗口的时候更新最终结果。</p>
</blockquote>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON&amp;XML&amp;YAML</title>
    <url>/2021/05/22/JSON-XML-YAML/</url>
    <content><![CDATA[<p>常见的信息标注方式有三种，分别是XML、JSON、YAML。HTML是XML的变种，也属于XML格式。下面简单的介绍比较三种信息标注方式。</p>
<a id="more"></a>

<h2 id="直入主题：三种语言简介"><a href="#直入主题：三种语言简介" class="headerlink" title="直入主题：三种语言简介"></a>直入主题：三种语言简介</h2><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><ul>
<li>XML：eXtensible Markup Language , 其构成单位是Tag标签，且标签内包含有名称属性等信息如图：</li>
</ul>
<p><img src="https://i.loli.net/2021/05/20/bXyZ1qtGU39arlQ.png"></p>
<p>​    其中空元素可通过一个&lt;&gt;表示 , 注释通过<!-- --> 表示</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#XML空元素表示</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;china.jpg&quot;</span> <span class="attr">size</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">#XML注释格式</span><br><span class="line"><span class="comment">&lt;!-- This is a comment --&gt;</span></span><br></pre></td></tr></table></figure>
<p>总结：XML格式共包含三种样式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><ul>
<li>JSON：JavaScript Object Notation , <strong>有类型</strong>的键值对表示方式</li>
</ul>
<p><img src="https://i.loli.net/2021/05/20/8gLIM2UmhzpDw4R.png"></p>
<p>总结：JSON格式包含三种样式</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#普通键值对表示</span><br><span class="line">&quot;key&quot; : &quot;Value&quot;</span><br><span class="line">#多值键值对表示</span><br><span class="line">&quot;key&quot; : [&quot;Value1&quot;,&quot;Value2&quot;]</span><br><span class="line">#键值对嵌套表示</span><br><span class="line">&quot;key&quot; : &#123;&quot;subkey&quot; : &quot;subvalue&quot;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h3><ul>
<li>YAML：Ain’t Markup Language ， 无类型键值对</li>
</ul>
<p><img src="https://i.loli.net/2021/05/20/CPzjUJMYg7dh8Gi.png"></p>
<p>  其表示各种关系情况：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#缩进表示所属关系，同Python</span></span><br><span class="line"><span class="attr">name:</span></span><br><span class="line">	<span class="attr">newName :</span> <span class="string">北京理工</span></span><br><span class="line">	<span class="attr">OldName :</span> <span class="string">延安自然科学院</span></span><br><span class="line"><span class="comment"># “-” 表达并列关系</span></span><br><span class="line"><span class="attr">name:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">北京理工大学</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">延安自然科学院</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># “|”表达整块数据</span></span><br><span class="line"><span class="attr">text:</span> <span class="string">|</span></span><br><span class="line"><span class="string">北京理工大学创立与......</span></span><br></pre></td></tr></table></figure>
<p>总结:三种表示形式如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">key :</span> <span class="string">value</span></span><br><span class="line"></span><br><span class="line"><span class="attr">key :</span> <span class="comment">#comment</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">value1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">value2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">key:</span></span><br><span class="line">	<span class="attr">subkey :</span> <span class="string">value</span> </span><br><span class="line">		</span><br></pre></td></tr></table></figure>
<h3 id="实例比较"><a href="#实例比较" class="headerlink" title="实例比较"></a>实例比较</h3><p>XML：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">firstName</span>&gt;</span>Tian<span class="tag">&lt;/<span class="name">firstName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lastName</span>&gt;</span>Song<span class="tag">&lt;/<span class="name">lastName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">streetAddr</span>&gt;</span>中关村南大街5号<span class="tag">&lt;/<span class="name">streetAddr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">city</span>&gt;</span>北京市<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">zipcode</span>&gt;</span>100081<span class="tag">&lt;/<span class="name">zipcode</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prof</span>&gt;</span>ComputerSystem<span class="tag">&lt;/<span class="name">prof</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prof</span>&gt;</span>Security<span class="tag">&lt;/<span class="name">prof</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--最早的通用标记语言，可扩展性好，但很繁琐 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用于INTERNET 信息交互与传递 --&gt;</span></span><br></pre></td></tr></table></figure>
<p>JSON:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    “firstName”: “Tian”,</span><br><span class="line">    “lastName”: “Song”,</span><br><span class="line">    “address”:&#123;“streetAddr”: “中关村南大街5号” ,</span><br><span class="line">               “city”: “北京市” ,</span><br><span class="line">               “zipcode”: “100081”&#125;,</span><br><span class="line">    “prof”:[“ComputerSystem”, “Security”]</span><br><span class="line">&#125;</span><br><span class="line">#信息有类型，适合程序处理，比XML简洁</span><br><span class="line">#用于移动英语云端与节点信息通信，无注释</span><br></pre></td></tr></table></figure>
<p>YAML:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">firstName:</span> <span class="string">Tian</span></span><br><span class="line"><span class="attr">lastName:</span> <span class="string">Song</span></span><br><span class="line"><span class="attr">address:</span></span><br><span class="line">	<span class="string">streetAddr:中关村南大街5号</span></span><br><span class="line">	<span class="string">city:北京市</span></span><br><span class="line">	<span class="attr">zipcode:</span> <span class="number">100081</span></span><br><span class="line"><span class="attr">prof:</span></span><br><span class="line"><span class="string">‐Computer</span> <span class="string">System</span></span><br><span class="line"><span class="string">‐Security</span></span><br><span class="line"><span class="comment"># 信息无类型，文本信息比例最高，可读性好</span></span><br><span class="line"><span class="comment"># 常用于各类系统配置文件，有注释易读</span></span><br></pre></td></tr></table></figure>
<h2 id="XML-JSON-YAML-对比分析"><a href="#XML-JSON-YAML-对比分析" class="headerlink" title="XML,JSON,YAML 对比分析"></a>XML,JSON,YAML 对比分析</h2><p>XML,JSON,YAML是在编程过程中常见的<strong>数据交互语言（inter-change Language）</strong>,常用于配置文件与数据传输。</p>
<p>数据交互语言也是我最近才看到的一种定义，那么其用户不外乎就是两种：机器（Python,Java,etc）与人(Developer)。根据语言的用处不同，自然要求也不一样，如下所示：</p>
<ul>
<li>配置文件时：<ul>
<li>用户：人与机器</li>
<li>要求：首要人能编写与阅读，其次机器能阅读</li>
</ul>
</li>
<li>数据传输时：<ul>
<li>用户：机器与机器</li>
<li>要求：首要机器能阅读，其次人也要阅读</li>
</ul>
</li>
</ul>
<p>常见的语言要求如下：</p>
<ul>
<li>便于人类阅读理解；</li>
<li>具有强大的表达能力，除了键值对外还能支持数组、引用等表达方式；能表达层级关系</li>
<li>便于书写，包括纯手打和使用IDE</li>
<li>存储空间小</li>
<li>…</li>
</ul>
<p>但上面提到的性质很多时刻是冲突的，例如要表达复杂的数据对象，就需要更多的语言规范，可阅读性会下降，存储空间往往会增大。这也就造成了在面向不同的要求时，大家构造出多种数据交互语言。下面这些是我在查询三者之间关系时看到的不同见解，特整理如下：</p>
<h3 id="主观感受方面"><a href="#主观感受方面" class="headerlink" title="主观感受方面"></a>主观感受方面</h3><p><a href="https://dhpo.github.io/2018/02/03/%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-XML-JSON-INI%E4%B8%8EYAML/">参考博客</a></p>
<p>上面参考博客中，作者将三种语言进行了很简单的主观对比，虽然没有很细致，但是我认为主干抓到啦，而且很明显不是那种顾左右而言它的缝合怪，需要向其学习。我简单的将自己的感想与其内容进行总结如下：</p>
<p>XML,JSON,YAML均是<strong>数据交互语言（Inter-change Language）</strong>,那么表示<strong>数据表示</strong>便是首要特点。<strong>数据表示</strong>可以笼统的分为两部分：</p>
<ol>
<li><strong>映射</strong>表示：Key-value或者说Mapping</li>
<li><strong>层次</strong>表示：层级关系或者说嵌套</li>
</ol>
<p>通常来说，能够准确表示<strong>映射</strong>关系与<strong>层次</strong>关系，就能够准确的描述数据的基本结构，这与编程语言中类的定义非常类似，只是没有方法罢了。从这个角度分析XML,JSON,YAML均能够做到，只是各有优缺点。那么我们可以从映射与层次两方面对三种数据语言进行简单分析；</p>
<h4 id="XML-1"><a href="#XML-1" class="headerlink" title="XML"></a>XML</h4><h5 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">firstName</span>&gt;</span>Tian<span class="tag">&lt;/<span class="name">firstName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lastName</span>&gt;</span>Song<span class="tag">&lt;/<span class="name">lastName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">streetAddr</span>&gt;</span>中关村南大街5号<span class="tag">&lt;/<span class="name">streetAddr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">city</span>&gt;</span>北京市<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">zipcode</span>&gt;</span>100081<span class="tag">&lt;/<span class="name">zipcode</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prof</span>&gt;</span>ComputerSystem<span class="tag">&lt;/<span class="name">prof</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prof</span>&gt;</span>Security<span class="tag">&lt;/<span class="name">prof</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--最早的通用标记语言，可扩展性好，但很繁琐 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用于INTERNET 信息交互与传递 --&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析:"></a>简单分析:</h5><p>在XML中，key-value通过<code> &lt;key&gt; value &lt;\key&gt;</code>表示，在XML中通常将<code>&lt;key&gt;</code>称为Tag，每个Tag都有对应的tag将其闭合。tag之间可以嵌套。XML的注释需要写在<code>&lt;!--</code>和<code>--&gt;</code>中，可以是多行的。</p>
<p>在上面的示例中，标签<code>&lt;person&gt;</code>的嵌套有<code>&lt;firstName&gt; &lt;lastName&gt; &lt;address&gt; &lt;prof&gt;</code>标签，层层嵌套形成了一种树状结构。在<code>value</code>中的内容通常称为data，<code>&lt;key&gt;</code>中可以添加<code>attribute</code>，称为metaData,用以标识数据的特性而不是数据内容。<code>value 与 attribute</code>的取舍问题，需要编程人员自行顶多，我在详解XML的文档中有表述。</p>
<p><strong>优点：</strong></p>
<ol>
<li>注重标记，典型树形结构；</li>
<li>以Tag为基础构造，理解简单；</li>
<li>可以注释。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>key重复，造成数据冗余，例如<code>&lt;prof&gt;</code>；</li>
<li>没有数据结构符号。</li>
</ol>
<h4 id="JSON-1"><a href="#JSON-1" class="headerlink" title="JSON"></a>JSON</h4><h5 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    “firstName”: “Tian”,</span><br><span class="line">    “lastName”: “Song”,</span><br><span class="line">    “address”:&#123;“streetAddr”: “中关村南大街5号” ,</span><br><span class="line">               “city”: “北京市” ,</span><br><span class="line">               “zipcode”: “100081”&#125;,</span><br><span class="line">    “prof”:[“ComputerSystem”, “Security”]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="简单分析："><a href="#简单分析：" class="headerlink" title="简单分析："></a>简单分析：</h5><p>在JSON中，<code>key-value</code>用过键值对<code>&quot;key&quot;:value</code>进行标识。而<code>value</code>可以是单纯的标量，也可以对象（<code>&#123;&#125;</code>）或数组（<code>[]</code>）等以此构成了层次关系，常用作<strong>数据传输</strong>，在JSON中存在两种数据结构：</p>
<ul>
<li>对象：<code>&#123;&#125;</code>标识，可表示复杂的数据结构、字典、集合等等</li>
<li>数组：<code>[]</code>标识，可表示序列（列表、数组）等</li>
</ul>
<p>但是JSON中不存在注释，减少了不必要的数据传输。</p>
<p><strong>优点：</strong></p>
<ol>
<li>数据简洁，相比XML；</li>
<li>存在数据结构；</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>没有注释，增加人的阅读难度；</li>
</ol>
<h4 id="YAML-1"><a href="#YAML-1" class="headerlink" title="YAML"></a>YAML</h4><h5 id="例子：-2"><a href="#例子：-2" class="headerlink" title="例子："></a>例子：</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">firstName:</span> <span class="string">Tian</span></span><br><span class="line"><span class="attr">lastName:</span> <span class="string">Song</span></span><br><span class="line"><span class="attr">address:</span></span><br><span class="line">	<span class="string">streetAddr:中关村南大街5号</span></span><br><span class="line">	<span class="string">city:北京市</span></span><br><span class="line">	<span class="attr">zipcode:</span> <span class="number">100081</span></span><br><span class="line"><span class="attr">prof:</span></span><br><span class="line"><span class="string">‐Computer</span> <span class="string">System</span></span><br><span class="line"><span class="string">‐Security</span></span><br><span class="line"><span class="comment"># 信息无类型，文本信息比例最高，可读性好</span></span><br><span class="line"><span class="comment"># 常用于各类系统配置文件，有注释易读</span></span><br></pre></td></tr></table></figure>
<h5 id="简单分析：-1"><a href="#简单分析：-1" class="headerlink" title="简单分析："></a>简单分析：</h5><p>YAML中<code>key-value</code>通过 <code>key:value</code>标识，通过 <code>缩进</code> 标识层级关系，常用作<strong>配置文件</strong>。</p>
<p>其特点在于，<code>key,value</code>均可以直接表示，不用像JSON那样通过双引号标识，当然你要限定使用双引号（强制类型转换）也是可以的，这一点与<code>Python</code>风格一致。存在两种数据结构，与JSON一样：</p>
<ul>
<li>对象：<code>key-value</code> 标识</li>
<li>数组：<code>-</code> 标识</li>
</ul>
<p>注释通过 <code>#</code> 标识，但是不允许多行注释存在。</p>
<p><strong>优点：</strong></p>
<ol>
<li>数据表示简洁；</li>
<li>相较于JSON，可读性更好，但也差不多；</li>
<li>存在注释(JSON)；</li>
<li>存在数据结构(XML)；</li>
<li>存在引用机制(JSON,XML)</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>缩进控制层次不方便；</li>
<li>没有多行注释(XML).</li>
</ol>
<blockquote>
<p>YAML可以说是JSON的加强版，主要体现在加入了注释和引用机制，同时省去了让人眼花的方括号和花括号。使用缩进而不是括号表达层级关系可以让我们能用肉眼看出层级关系，而不需要使用编辑器或是IDE寻找配对的括号，同时省去了不必要的空行，提高了可读性。YAML与JSON相比在加强了表达能力的同时提高了可读性，可以说是在复杂项目中最佳的配置语言了。</p>
</blockquote>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>三种<strong>数据交互语言（Inter-change Language）</strong>,因其历史局限性或者应用不同，各有其特点，但也都是一种数据的表示方式罢了，从<code>key-value</code>,<code>Mapping</code>两个角度分析看，可以迅速掌握其差异点，有利于更好的理解语言特点。对于细节差异，并不需要一一对比分析，浪费时间也没必要。</p>
<h3 id="脉络方面"><a href="#脉络方面" class="headerlink" title="脉络方面"></a>脉络方面</h3><p><a href="https://linux.cn/article-10664-1.html">参考博客</a></p>
<p>作者以历史为脉络整理了，各语言的特点与差异，可作为一种知识补充。</p>
<h3 id="数据维度方面"><a href="#数据维度方面" class="headerlink" title="数据维度方面"></a>数据维度方面</h3><p><a href="https://kyakya.icu/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-ini-yaml-toml-json-xml%E7%AD%89%E6%AF%94%E8%BE%83">参考博客</a></p>
<p>作者提到的数据维度是很有意思的角度，时间所限不一一整理啦。</p>
]]></content>
  </entry>
  <entry>
    <title>JSON Simple Research</title>
    <url>/2021/05/22/JSON-Simple-Research/</url>
    <content><![CDATA[<p>Source: <a href="https://www.w3school.com.cn/json/index.asp">w3c</a></p>
<a id="more"></a>

<h2 id="JSON是什么"><a href="#JSON是什么" class="headerlink" title="JSON是什么"></a>JSON是什么</h2><p>JSON是 JavaScript Object Notation,JS对象表示方法，是一种数据的标识格式，与XML类似，指的是数据内容。</p>
<h2 id="JSON特点"><a href="#JSON特点" class="headerlink" title="JSON特点"></a>JSON特点</h2><ul>
<li>JSON 是用来描述<strong>对象</strong>的一种语言，其标记性没有像XML那么重；</li>
<li>JSON 具有“自我描述性”（人类可读）；</li>
<li>JSON 具有层级结构（值中存在值）。</li>
</ul>
<h2 id="JSON与XML语言的主观差异"><a href="#JSON与XML语言的主观差异" class="headerlink" title="JSON与XML语言的主观差异"></a>JSON与XML语言的主观差异</h2><p>先看两个例子，有一个主观对比：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;sites&quot;</span>: [</span><br><span class="line">    &#123; <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;菜鸟教程&quot;</span> , <span class="attr">&quot;url&quot;</span>:<span class="string">&quot;www.runoob.com&quot;</span> &#125;, </span><br><span class="line">    &#123; <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;google&quot;</span> , <span class="attr">&quot;url&quot;</span>:<span class="string">&quot;www.google.com&quot;</span> &#125;, </span><br><span class="line">    &#123; <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;微博&quot;</span> , <span class="attr">&quot;url&quot;</span>:<span class="string">&quot;www.weibo.com&quot;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sites</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>菜鸟教程<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="tag">&lt;<span class="name">url</span>&gt;</span>www.runoob.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>google<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="tag">&lt;<span class="name">url</span>&gt;</span>www.google.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>微博<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="tag">&lt;<span class="name">url</span>&gt;</span>www.weibo.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sites</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>两种语言的创建目的不同，导致他们放在一起比较就不合适。<ul>
<li>JSON是面向JS<strong>对象</strong>的一种数据序列话描述语言，内容为主，格式其次；</li>
<li>XML是<strong>标记</strong>语言，以标签为基础，内容其次。<ul>
<li>能与XML进行比较HTML更加合适。<ul>
<li>HTML标签固定</li>
<li>XML标签自定义</li>
</ul>
</li>
<li>XML是一种明显的树形结构</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="JSON内两种数据"><a href="#JSON内两种数据" class="headerlink" title="JSON内两种数据"></a>JSON内两种数据</h2><ol>
<li>键值对：可表示对象、记录、字典、哈希表等</li>
<li>有序对：列表，向量，序列等</li>
</ol>
<p>这只是一种数据的理解方式，我也可以理解为三种数据：</p>
<ol>
<li>{} ： 对象</li>
<li>[] : 列表</li>
<li>标量</li>
</ol>
<h2 id="JSON语法规则"><a href="#JSON语法规则" class="headerlink" title="JSON语法规则"></a>JSON语法规则</h2><ul>
<li>数据使用键值对表示；</li>
<li>数据之间使用“，”分隔；</li>
<li>{}表示为对象</li>
<li>[]表示为数组</li>
</ul>
<h3 id="键值对的表示形式"><a href="#键值对的表示形式" class="headerlink" title="键值对的表示形式"></a>键值对的表示形式</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;firstName&quot; : &quot;John&quot;</span><br></pre></td></tr></table></figure>
<p>“字段名称” ： “值”</p>
<blockquote>
<p>注意 字段名称 采用了双引号</p>
</blockquote>
<h3 id="值的选择范围"><a href="#值的选择范围" class="headerlink" title="值的选择范围"></a>值的选择范围</h3><ul>
<li>数字(整数或者浮点数)</li>
<li>字符串（需要双引号）</li>
<li>布尔值（true/false）</li>
<li>数组 ([])</li>
<li>对象 ({})</li>
<li>null</li>
</ul>
<h3 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h3><p>JSON 对象在花括号中书写：</p>
<p>对象可以包含多个名称/值对：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">&quot;firstName&quot;</span>:<span class="string">&quot;John&quot;</span> , <span class="attr">&quot;lastName&quot;</span>:<span class="string">&quot;Doe&quot;</span> &#125;</span><br></pre></td></tr></table></figure>
<p>这一点也容易理解，与这条 JavaScript 语句等价：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">firstName = <span class="string">&quot;John&quot;</span></span><br><span class="line">lastName = <span class="string">&quot;Doe&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="JSON-数组"><a href="#JSON-数组" class="headerlink" title="JSON 数组"></a>JSON 数组</h3><p>JSON 数组在方括号中书写：</p>
<p>数组可包含多个对象：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;employees&quot;</span>: [</span><br><span class="line">&#123; <span class="attr">&quot;firstName&quot;</span>:<span class="string">&quot;John&quot;</span> , <span class="attr">&quot;lastName&quot;</span>:<span class="string">&quot;Doe&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="attr">&quot;firstName&quot;</span>:<span class="string">&quot;Anna&quot;</span> , <span class="attr">&quot;lastName&quot;</span>:<span class="string">&quot;Smith&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="attr">&quot;firstName&quot;</span>:<span class="string">&quot;Peter&quot;</span> , <span class="attr">&quot;lastName&quot;</span>:<span class="string">&quot;Jones&quot;</span> &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，对象 “employees” 是包含三个对象的数组。每个对象代表一条关于某人（有姓和名）的记录。</p>
]]></content>
  </entry>
  <entry>
    <title>XML Simple Research</title>
    <url>/2021/05/22/XML-Simple-Research/</url>
    <content><![CDATA[<p><strong>Source</strong>: <a href="https://www.w3school.com.cn/xml/index.asp">w3c</a></p>
<a id="more"></a>

<h2 id="XML定义"><a href="#XML定义" class="headerlink" title="XML定义"></a>XML定义</h2><p>xml就是一种<strong>数据的存储</strong>格式。</p>
<ul>
<li>XML 指可扩展标记语言（e<em>X</em>tensible <em>M</em>arkup <em>L</em>anguage）</li>
<li>XML 是一种<em>标记语言</em>，很类似 HTML</li>
<li>XML 的设计宗旨是<em>传输数据</em>，而非显示数据</li>
<li>XML 标签没有被预定义。您需要<em>自行定义标签</em>。</li>
<li>XML 被设计为具有<em>自我描述性</em>。</li>
<li>XML 是 <em>W3C 的推荐标准</em></li>
</ul>
<h2 id="XML的用处"><a href="#XML的用处" class="headerlink" title="XML的用处"></a>XML的用处</h2><p>用于 <strong>结构化，存储及传输</strong>数据，所以XML就是一种<strong>序列化数据表现形式</strong>，也可以认为就是数据<strong>内容</strong>，XML就是纯文本也是对的。</p>
<h2 id="XML是一种树结构"><a href="#XML是一种树结构" class="headerlink" title="XML是一种树结构"></a>XML是一种树结构</h2><p>XML文件与HTML文件结构很相似，都是利用tag进行标识的，也都是<strong>树形结构</strong>。</p>
<p><strong>XML实例：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的xml构成可以分为两层的树结构：<br><strong>根元素</strong>：描述整篇文档</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>子元素</strong>：描述根的几个子元素(（to, from, heading 以及 body）)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>根元素结尾：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从树的结构出发我们不难得出：</p>
<ol>
<li>所有元素均可以拥有子元素</li>
<li>相同层级的元素可以称为兄弟姐妹</li>
<li>元素拥有属性与文本；</li>
</ol>
<p><strong>实例：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;COOKING&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Everyday Italian<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>Giada De Laurentiis<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>30.00<span class="tag">&lt;/<span class="name">price</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;CHILDREN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;WEB&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>Erik T. Ray<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2003<span class="tag">&lt;/<span class="name">year</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>39.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>结构示意图：</strong>一本书的结构</p>
<p><img src="https://www.w3school.com.cn/i/ct_nodetree1.gif"></p>
<h2 id="XML语法格式"><a href="#XML语法格式" class="headerlink" title="XML语法格式"></a>XML语法格式</h2><p><a href="https://www.w3school.com.cn/xml/xml_syntax.asp">不赘述</a></p>
<h2 id="XML元素包括什么"><a href="#XML元素包括什么" class="headerlink" title="XML元素包括什么"></a>XML元素包括什么</h2><ol>
<li>内容：文本内容或元素内容</li>
<li>属性</li>
</ol>
<p><strong>实例：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;CHILDREN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;WEB&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>Erik T. Ray<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2003<span class="tag">&lt;/<span class="name">year</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>39.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到上面的例子中：bookstore 与 book 元素仅包含有元素内容，而 title等元素仅包含有文本内容； book 元素具备有属性。</p>
<blockquote>
<p>我尚没有见到过元素内容与文本内容兼备的元素</p>
</blockquote>
</blockquote>
<p><strong>疑问点？</strong></p>
<p>属性与子元素到底有什么差别呢？或者说什么时候用属性比较合适，而什么时候用子元素比较合适？</p>
<p><strong>结论：</strong></p>
<p>尽可能的使用子元素，除非该内容用于标识数据的数据，而不是数据本身。</p>
<p><strong>同一数据的不同表示实例：</strong></p>
<ul>
<li>第一个例子中使用了 date 属性：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span> <span class="attr">date</span>=<span class="string">&quot;08/08/2008&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<ul>
<li>第二个例子中使用了 date 元素：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">date</span>&gt;</span>08/08/2008<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<ul>
<li>第三个例子中使用了扩展的 date 元素（这是我的最爱）：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">date</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">day</span>&gt;</span>08<span class="tag">&lt;/<span class="name">day</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">month</span>&gt;</span>08<span class="tag">&lt;/<span class="name">month</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2008<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>为什么尽可能避免使用属性？</strong></p>
<ol>
<li>属性没有层级结构，不能够标识多重值，元素可以；</li>
<li>属性无法描述为树形结构，元素可以；</li>
<li>属性无法动态扩展，不利于未来变化；</li>
<li>属性不好阅读。</li>
</ol>
<p><strong>不好的XML实例：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span> <span class="attr">day</span>=<span class="string">&quot;08&quot;</span> <span class="attr">month</span>=<span class="string">&quot;08&quot;</span> <span class="attr">year</span>=<span class="string">&quot;2008&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">to</span>=<span class="string">&quot;George&quot;</span> <span class="attr">from</span>=<span class="string">&quot;John&quot;</span> <span class="attr">heading</span>=<span class="string">&quot;Reminder&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">body</span>=<span class="string">&quot;Don&#x27;t forget the meeting!&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>YAML Simple Research</title>
    <url>/2021/05/22/YAML-Simple-Research/</url>
    <content><![CDATA[<p><strong>Source：</strong> <a href="https://yaml.org/spec/1.2/spec.html">official specification</a> ， <a href="https://www.w3schools.io/file/yaml-cheatsheet-syntax/">w3c</a></p>
<a id="more"></a>

<h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>YAML is the abbreviation of “YAML Ain’t Markup Language” . Different from XML(e<em>X</em>tensible <em>M</em>arkup <em>L</em>anguage) , YAML is a kind of <strong>data serialization language</strong> , not Markup Language.</p>
<ul>
<li><strong>Different from Markup Language and Data Serialization Language</strong><ul>
<li>Markup Language: Force on data layout<ul>
<li>eg: XML , HTML</li>
</ul>
</li>
<li>Data Serialization Language: Force on data content<ul>
<li>eg: YAML , JSON，<a href="https://www.w3schools.io/file/toml-introduction/">toml</a>,<a href="https://www.w3schools.io/file/ini-extension-introduction/">ini</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>AML was designed from the start to be useful and friendly to people working with data.</p>
</blockquote>
<h3 id="Importion-points"><a href="#Importion-points" class="headerlink" title="Importion points"></a>Importion points</h3><ul>
<li>It is case sensitive</li>
<li>file extension is .yaml</li>
<li>Tabs are not allowed</li>
</ul>
<h3 id="Two-parts-of-YAML"><a href="#Two-parts-of-YAML" class="headerlink" title="Two parts of YAML"></a>Two parts of YAML</h3><ol>
<li>structural information<ul>
<li>The advantage of YAML is the structural information compressed to the minimalism;</li>
</ul>
</li>
<li>data itself<ul>
<li>can’t not be compressed</li>
</ul>
</li>
</ol>
<blockquote>
<p>自我理解：任何形式的数据标识语言，YAML,XML,HTML,JSON等，都包含有这两部分：结构化信息与数据本身。像上面提到的数据标记语言与数据序列语言，就是对这两部分侧重不同，侧重与结构就是标记语言，侧重于内容就是序列语言。各种语言标识仅仅侧重点不同，一般都具备这两项功能，这也是理解XML,YAML,JSON等语言的切入点之一。</p>
</blockquote>
<h3 id="Language-Goals"><a href="#Language-Goals" class="headerlink" title="Language Goals"></a>Language Goals</h3><ol>
<li>YAML is easily readable by humans.</li>
<li>YAML data is portable between programming languages.</li>
<li>YAML matches the [native data structures](<a href="https://yaml.org/spec/1.2/spec.html#native">https://yaml.org/spec/1.2/spec.html#native</a> data structure//) of agile languages.</li>
<li>YAML has a consistent model to support generic tools.</li>
<li>YAML supports one-pass processing.</li>
<li>YAML is expressive and extensible.</li>
<li>YAML is easy to implement and use.</li>
</ol>
<h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><ul>
<li>Configuration files </li>
<li>Internet messaging  </li>
<li>Object persistence </li>
<li>Data auditing.</li>
</ul>
<h3 id="Relation-with-JSON"><a href="#Relation-with-JSON" class="headerlink" title="Relation with JSON"></a>Relation with JSON</h3><p><strong>YAML is the superSet of JSON</strong> , that means we can transfer ALL YAML file to JSON file ,Whereas no.</p>
<h2 id="Data-Structure-in-YAML"><a href="#Data-Structure-in-YAML" class="headerlink" title="Data Structure in YAML"></a>Data Structure in YAML</h2><p>In YAML, data structures can be adequately represented with three basic primitives (consist with python):</p>
<ul>
<li>mapping: hashes、dictionaries，etc<ul>
<li>Mapping use a colon and space(“: “) to mark each “key: value “pair.</li>
</ul>
</li>
<li>seqences: array、list , etc<ul>
<li>sequences indicate each item with a dash and space(“- “)</li>
</ul>
</li>
<li>scalars: string、number , etc<ul>
<li>basic element</li>
</ul>
</li>
<li>comments: begin with an octothorpe(also called a “hash”, “sharp”, “pound”, or “number sign” - [“**<code>#</code>**”](<a href="https://yaml.org/spec/1.2/spec.html##">https://yaml.org/spec/1.2/spec.html##</a> comment//)).<ul>
<li>not support multline comment</li>
</ul>
</li>
</ul>
<h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h2><h3 id="Collections-Scope"><a href="#Collections-Scope" class="headerlink" title="Collections Scope"></a>Collections Scope</h3><p>There are two ways to represent the scope of collection:</p>
<h4 id="1-indent"><a href="#1-indent" class="headerlink" title="1.indent"></a>1.indent</h4><blockquote>
<p>similar with python language, that the reason way YAML is minimalist data representation.</p>
</blockquote>
<p><strong>examples:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  Sequence of Scalars</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Mark</span> <span class="string">McGwire</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Sammy</span> <span class="string">Sosa</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Ken</span> <span class="string">Griffey</span></span><br><span class="line"><span class="comment">#  Mapping Scalars to Scalar</span></span><br><span class="line"><span class="attr">hr:</span>  <span class="number">65</span>    <span class="comment"># Home runs</span></span><br><span class="line"><span class="attr">avg:</span> <span class="number">0.278</span> <span class="comment"># Batting average</span></span><br><span class="line"><span class="attr">rbi:</span> <span class="number">147</span>   <span class="comment"># Runs Batted In</span></span><br><span class="line"><span class="comment"># Mapping Scalars to Sequences</span></span><br><span class="line"><span class="attr">american:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Boston</span> <span class="string">Red</span> <span class="string">Sox</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Detroit</span> <span class="string">Tigers</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">New</span> <span class="string">York</span> <span class="string">Yankees</span></span><br><span class="line"><span class="attr">national:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">New</span> <span class="string">York</span> <span class="string">Mets</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Chicago</span> <span class="string">Cubs</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Atlanta</span> <span class="string">Braves</span></span><br><span class="line"><span class="comment"># Sequence of Mappings  </span></span><br><span class="line"><span class="bullet">-</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Mark</span> <span class="string">McGwire</span></span><br><span class="line">  <span class="attr">hr:</span>   <span class="number">65</span></span><br><span class="line">  <span class="attr">avg:</span>  <span class="number">0.278</span></span><br><span class="line"><span class="bullet">-</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Sammy</span> <span class="string">Sosa</span></span><br><span class="line">  <span class="attr">hr:</span>   <span class="number">63</span></span><br><span class="line">  <span class="attr">avg:</span>  <span class="number">0.288</span></span><br></pre></td></tr></table></figure>
<h4 id="2-flow-style"><a href="#2-flow-style" class="headerlink" title="2. flow style"></a>2. flow style</h4><p>using explicit <a href="https://yaml.org/spec/1.2/spec.html#indicator//">indicators</a> rather than <a href="https://yaml.org/spec/1.2/spec.html#space/indentation/">indentation</a> to denote scope.</p>
<p>example:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The flow sequence is written as a comma separated list within square brackets.  </span></span><br><span class="line"><span class="bullet">-</span> [<span class="string">name</span>        , <span class="string">hr</span>, <span class="string">avg</span>  ]</span><br><span class="line"><span class="bullet">-</span> [<span class="string">Mark</span> <span class="string">McGwire</span>, <span class="number">65</span>, <span class="number">0.278</span>]</span><br><span class="line"><span class="bullet">-</span> [<span class="string">Sammy</span> <span class="string">Sosa</span>  , <span class="number">63</span>, <span class="number">0.288</span>]</span><br><span class="line"><span class="comment">#  flow mapping uses curly braces.</span></span><br><span class="line"><span class="attr">Mark McGwire:</span> &#123;<span class="attr">hr:</span> <span class="number">65</span>, <span class="attr">avg:</span> <span class="number">0.278</span>&#125;</span><br><span class="line"><span class="attr">Sammy Sosa:</span> &#123;</span><br><span class="line">    <span class="attr">hr:</span> <span class="number">63</span>,</span><br><span class="line">    <span class="attr">avg:</span> <span class="number">0.288</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h3><h4 id="document-start-and-end"><a href="#document-start-and-end" class="headerlink" title="document start and end"></a>document start and end</h4><ol>
<li><p>YAML use three dashes (“—“) to separate  <a href="https://yaml.org/spec/1.2/spec.html#directive//">directives</a> from <a href="https://yaml.org/spec/1.2/spec.html#document//">document</a> <a href="https://yaml.org/spec/1.2/spec.html#content//">content</a> :</p>
<p>for example : two documents in a stream , each with a leading comment</p>
</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ranking of 1998 home runs</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Mark</span> <span class="string">McGwire</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Sammy</span> <span class="string">Sosa</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Ken</span> <span class="string">Griffey</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Team ranking</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Chicago</span> <span class="string">Cubs</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">St</span> <span class="string">Louis</span> <span class="string">Cardinals</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>“—“ : start signal of document , “…” : end signal of document:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">time: 20:03:20</span><br><span class="line">player: Sammy Sosa</span><br><span class="line">action: strike (miss)</span><br><span class="line">...</span><br><span class="line">---</span><br><span class="line">time: 20:03:47</span><br><span class="line">player: Sammy Sosa</span><br><span class="line">action: grand slam</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="ref-in-YAML"><a href="#ref-in-YAML" class="headerlink" title="ref in YAML"></a>ref in YAML</h4><p>Repeated <a href="https://yaml.org/spec/1.2/spec.html#node//">nodes</a> (objects) are first <a href="https://yaml.org/spec/1.2/spec.html#alias/identified/">identified</a> by an <a href="https://yaml.org/spec/1.2/spec.html#anchor//">anchor</a> (marked with the ampersand - [“**<code>&amp;</code>**”](<a href="https://yaml.org/spec/1.2/spec.html#&amp;">https://yaml.org/spec/1.2/spec.html#&amp;</a> anchor//)), and are then <a href="https://yaml.org/spec/1.2/spec.html#alias//">aliased</a> (referenced with an asterisk - [“**<code>\*</code>**”](<a href="https://yaml.org/spec/1.2/spec.html#">https://yaml.org/spec/1.2/spec.html#</a>* alias//)) thereafter.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Single Document with Two Comments</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">hr:</span> <span class="comment"># 1998 hr ranking</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Mark</span> <span class="string">McGwire</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Sammy</span> <span class="string">Sosa</span></span><br><span class="line"><span class="attr">rbi:</span></span><br><span class="line">  <span class="comment"># 1998 rbi ranking</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Sammy</span> <span class="string">Sosa</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ken</span> <span class="string">Griffey</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#  Node for “Sammy Sosa” appears twice in this document</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">hr:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Mark</span> <span class="string">McGwire</span></span><br><span class="line">  <span class="comment"># Following node labeled SS</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&amp;SS</span> <span class="string">Sammy</span> <span class="string">Sosa</span></span><br><span class="line"><span class="attr">rbi:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">*SS</span> <span class="comment"># Subsequent occurrence</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ken</span> <span class="string">Griffey</span></span><br></pre></td></tr></table></figure>
<h3 id="complex-mapping-key"><a href="#complex-mapping-key" class="headerlink" title="complex mapping key"></a>complex mapping key</h3><p>A question mark and space ([“**<code>? </code>**”](<a href="https://yaml.org/spec/1.2/spec.html#">https://yaml.org/spec/1.2/spec.html#</a>? mapping key//)) indicate a complex <a href="https://yaml.org/spec/1.2/spec.html#mapping//">mapping</a> <a href="https://yaml.org/spec/1.2/spec.html#key//">key</a>. Within a <a href="https://yaml.org/spec/1.2/spec.html#style/block/collection">block collection</a>, [key: value pairs](<a href="https://yaml.org/spec/1.2/spec.html#key">https://yaml.org/spec/1.2/spec.html#key</a>: value pair//) can start immediately following the [dash](<a href="https://yaml.org/spec/1.2/spec.html#-">https://yaml.org/spec/1.2/spec.html#-</a> block sequence entry//), [colon](<a href="https://yaml.org/spec/1.2/spec.html#">https://yaml.org/spec/1.2/spec.html#</a>: mapping value//), or [question mark](<a href="https://yaml.org/spec/1.2/spec.html#">https://yaml.org/spec/1.2/spec.html#</a>? mapping key//).</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Mapping between Sequences</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">?</span> <span class="bullet">-</span> <span class="string">Detroit</span> <span class="string">Tigers</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Chicago</span> <span class="string">cubs</span></span><br><span class="line"><span class="string">:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">2001-07-23</span></span><br><span class="line"></span><br><span class="line"><span class="string">?</span> [ <span class="string">New</span> <span class="string">York</span> <span class="string">Yankees</span>,</span><br><span class="line">    <span class="string">Atlanta</span> <span class="string">Braves</span> ]</span><br><span class="line"><span class="string">:</span> [ <span class="number">2001-07-02</span>, <span class="number">2001-08-12</span>,</span><br><span class="line">    <span class="number">2001-08-14</span> ]</span><br><span class="line"><span class="comment"># Compact Nested Mapping    </span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># Products purchased</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">item    :</span> <span class="string">Super</span> <span class="string">Hoop</span></span><br><span class="line">  <span class="attr">quantity:</span> <span class="number">1</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">item    :</span> <span class="string">Basketball</span></span><br><span class="line">  <span class="attr">quantity:</span> <span class="number">4</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">item    :</span> <span class="string">Big</span> <span class="string">Shoes</span></span><br><span class="line">  <span class="attr">quantity:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="Scalar"><a href="#Scalar" class="headerlink" title="Scalar"></a>Scalar</h3><h4 id="scalar-with-block-notation"><a href="#scalar-with-block-notation" class="headerlink" title="scalar with block notation"></a>scalar with block notation</h4><p><a href="https://www.jianshu.com/p/d439a82ca7f8">More Details</a> shown in this blog.</p>
<h5 id="literial-Style"><a href="#literial-Style" class="headerlink" title="literial Style"></a>literial Style</h5><p>using denotation(“|”) , all the  line breaks are significant;</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># In literial style , all the newlines are preserved</span></span><br><span class="line"><span class="string">---</span> <span class="string">|</span></span><br><span class="line">  <span class="string">\//||\/||</span></span><br><span class="line">  <span class="string">//</span> <span class="string">||</span>  <span class="string">||__</span></span><br></pre></td></tr></table></figure>
<h5 id="folded-Style"><a href="#folded-Style" class="headerlink" title="folded Style"></a>folded Style</h5><p>Alternatively , they can be written with the folded style (denoted with “&gt;”),each line break is folded to a space unless it ends an empty or a more indented line.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  In the folded scalars,  newlines become spaces</span></span><br><span class="line"><span class="string">---</span> <span class="string">&gt;</span></span><br><span class="line">  <span class="string">Mark</span> <span class="string">McGwire&#x27;s</span></span><br><span class="line">  <span class="string">year</span> <span class="string">was</span> <span class="string">crippled</span></span><br><span class="line">  <span class="string">by</span> <span class="string">a</span> <span class="string">knee</span> <span class="string">injury.</span></span><br><span class="line"><span class="comment"># Folded newlines are preserved for &quot;more indented&quot; and blank lines</span></span><br><span class="line"></span><br><span class="line"><span class="string">Example</span> <span class="number">2.14</span><span class="string">.</span>  <span class="string">In</span> <span class="string">the</span> <span class="string">folded</span> <span class="string">scalars,</span></span><br><span class="line"><span class="string">newlines</span> <span class="string">become</span> <span class="string">spaces</span></span><br><span class="line"></span><br><span class="line"><span class="string">---</span> <span class="string">&gt;</span></span><br><span class="line">  <span class="string">Mark</span> <span class="string">McGwire&#x27;s</span></span><br><span class="line">  <span class="string">year</span> <span class="string">was</span> <span class="string">crippled</span></span><br><span class="line">  <span class="string">by</span> <span class="string">a</span> <span class="string">knee</span> <span class="string">injury.</span></span><br><span class="line"></span><br><span class="line"><span class="string">Example</span> <span class="number">2.15</span><span class="string">.</span>  <span class="string">Folded</span> <span class="string">newlines</span> <span class="string">are</span> <span class="string">preserved</span></span><br><span class="line"><span class="string">for</span> <span class="string">&quot;more indented&quot;</span> <span class="string">and</span> <span class="string">blank</span> <span class="string">lines</span></span><br><span class="line"></span><br><span class="line"><span class="string">---</span> <span class="string">&gt;</span></span><br><span class="line"> <span class="string">Sammy</span> <span class="string">Sosa</span> <span class="string">completed</span> <span class="string">another</span></span><br><span class="line"> <span class="string">fine</span> <span class="string">season</span> <span class="string">with</span> <span class="string">great</span> <span class="string">stats.</span></span><br><span class="line"></span><br><span class="line">   <span class="number">63</span> <span class="string">Home</span> <span class="string">Runs</span></span><br><span class="line">   <span class="number">0.288</span> <span class="string">Batting</span> <span class="string">Average</span></span><br><span class="line"></span><br><span class="line"> <span class="string">What</span> <span class="string">a</span> <span class="string">year!</span></span><br></pre></td></tr></table></figure>
<h4 id="flow-scalars"><a href="#flow-scalars" class="headerlink" title="flow scalars"></a>flow scalars</h4><p>There are three ways to express <strong>flow scalars</strong>: <br>1.Plain text 2. Double-quoted 3.Single Quoted<br>Features: All <a href="https://yaml.org/spec/1.2/spec.html#style/flow/scalar">flow scalars</a> can span multiple lines; [line breaks](<a href="https://yaml.org/spec/1.2/spec.html#line">https://yaml.org/spec/1.2/spec.html#line</a> break//) are always [folded](<a href="https://yaml.org/spec/1.2/spec.html#line">https://yaml.org/spec/1.2/spec.html#line</a> folding//).</p>
<h5 id="Plain-Text"><a href="#Plain-Text" class="headerlink" title="Plain Text"></a>Plain Text</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Multi-line Flow Scalars</span><br><span class="line">plain:</span><br><span class="line">  This unquoted scalar</span><br><span class="line">  spans many lines.</span><br><span class="line"></span><br><span class="line">quoted: &quot;So does this</span><br><span class="line">  quoted scalar.\n&quot;</span><br><span class="line">  </span><br><span class="line"># Aboved is the same as , from my understanding </span><br><span class="line">plain:   This unquoted scalar spans many lines.</span><br><span class="line"></span><br><span class="line">quoted: &quot;So does this quoted scalar.\n&quot;</span><br></pre></td></tr></table></figure>
<h5 id="Quoted-Scalars"><a href="#Quoted-Scalars" class="headerlink" title="Quoted Scalars"></a>Quoted Scalars</h5><p>The <a href="https://yaml.org/spec/1.2/spec.html#style/flow/double-quoted">double-quoted style</a> provides [escape sequences](<a href="https://yaml.org/spec/1.2/spec.html#escaping/in">https://yaml.org/spec/1.2/spec.html#escaping/in</a> double-quoted scalars/). The <a href="https://yaml.org/spec/1.2/spec.html#style/flow/">single-quoted style</a> is useful when [escaping](<a href="https://yaml.org/spec/1.2/spec.html#escaping/in">https://yaml.org/spec/1.2/spec.html#escaping/in</a> double-quoted scalars/) is not needed.</p>
<blockquote>
<p>双引号用于强制类型转换？？</p>
</blockquote>
<p>For examples:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Quoted Scalars</span></span><br><span class="line"><span class="attr">unicode:</span> <span class="string">&quot;Sosa did fine.\u263A&quot;</span></span><br><span class="line"><span class="attr">control:</span> <span class="string">&quot;\b1998\t1999\t2000\n&quot;</span></span><br><span class="line"><span class="attr">hex esc:</span> <span class="string">&quot;\x0d\x0a is \r\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">single:</span> <span class="string">&#x27;&quot;Howdy!&quot; he cried.&#x27;</span></span><br><span class="line"><span class="attr">quoted:</span> <span class="string">&#x27; # Not a &#x27;</span><span class="string">&#x27;comment&#x27;</span><span class="string">&#x27;.&#x27;</span></span><br><span class="line"><span class="attr">tie-fighter:</span> <span class="string">&#x27;|\-*-/|&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h3><p>In YAML, <a href="https://yaml.org/spec/1.2/spec.html#tag/non-specific/">untagged nodes</a> are given a type depending on the <a href="https://yaml.org/spec/1.2/spec.html#application//">application</a>. The examples in this specification generally use the <a href="https://yaml.org/spec/1.2/spec.html#tag/repository/seq"><strong><code>seq</code></strong></a>, <a href="https://yaml.org/spec/1.2/spec.html#tag/repository/map"><strong><code>map</code></strong></a> and <a href="https://yaml.org/spec/1.2/spec.html#tag/repository/str"><strong><code>str</code></strong></a> types from the <a href="https://yaml.org/spec/1.2/spec.html#schema/failsafe/">fail safe schema</a>. A few examples also use the <a href="https://yaml.org/spec/1.2/spec.html#tag/repository/int"><strong><code>int</code></strong></a>, <a href="https://yaml.org/spec/1.2/spec.html#tag/repository/float"><strong><code>float</code></strong></a>, and <a href="https://yaml.org/spec/1.2/spec.html#tag/repository/null"><strong><code>null</code></strong></a> types from the <a href="https://yaml.org/spec/1.2/spec.html#schema/JSON/">JSON schema</a>. The <a href="https://yaml.org/spec/1.2/spec.html#tag/repository/">repository</a> includes additional types such as <a href="https://yaml.org/type/binary.html"><strong><code>binary</code></strong></a>, <a href="https://yaml.org/type/omap.html"><strong><code>omap</code></strong></a>, <a href="https://yaml.org/type/set.html"><strong><code>set</code></strong></a> and others.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># integers</span><br><span class="line">canonical: 12345</span><br><span class="line">decimal: +12345</span><br><span class="line">octal: 0o14</span><br><span class="line">hexadecimal: 0xC</span><br><span class="line"></span><br><span class="line"># Floating points</span><br><span class="line">canonical: 1.23015e+3</span><br><span class="line">exponential: 12.3015e+02</span><br><span class="line">fixed: 1230.15</span><br><span class="line">negative infinity: -.inf</span><br><span class="line">not a number: .NaN</span><br><span class="line"></span><br><span class="line"># Miscellaneous</span><br><span class="line">null:</span><br><span class="line">booleans: [ true, false ]</span><br><span class="line">string: &#39;012345&#39;</span><br><span class="line"></span><br><span class="line"># Timestamps</span><br><span class="line">canonical: 2001-12-15T02:59:43.1Z</span><br><span class="line">iso8601: 2001-12-14t21:59:43.10-05:00</span><br><span class="line">spaced: 2001-12-14 21:59:43.10 -5</span><br><span class="line">date: 2002-12-14</span><br></pre></td></tr></table></figure>
<p>Explicit typing is denoted with a <a href="https://yaml.org/spec/1.2/spec.html#tag//">tag</a> using the exclamation point ([“**<code>!</code>**”](<a href="https://yaml.org/spec/1.2/spec.html#">https://yaml.org/spec/1.2/spec.html#</a>! tag indicator//)) symbol. <a href="https://yaml.org/spec/1.2/spec.html#tag/global/">Global tags</a> are URIs and may be specified in a <a href="https://yaml.org/spec/1.2/spec.html#tag/shorthand/">tag shorthand</a> notation using a <a href="https://yaml.org/spec/1.2/spec.html#tag/handle/">handle</a>. <a href="https://yaml.org/spec/1.2/spec.html#application//">Application</a>-specific <a href="https://yaml.org/spec/1.2/spec.html#tag/local/">local tags</a> may also be used.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  Various Explicit Tags</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">not-date:</span> <span class="type">!!str</span> <span class="number">2002-04-28</span></span><br><span class="line"></span><br><span class="line"><span class="attr">picture:</span> <span class="type">!!binary</span> <span class="string">|</span></span><br><span class="line"> <span class="string">R0lGODlhDAAMAIQAAP//9/X</span></span><br><span class="line"> <span class="string">17unp5WZmZgAAAOfn515eXv</span></span><br><span class="line"> <span class="string">Pz7Y6OjuDg4J+fn5OTk6enp</span></span><br><span class="line"> <span class="string">56enmleECcgggoBADs=</span></span><br><span class="line"></span><br><span class="line"><span class="attr">application specific tag:</span> <span class="type">!something</span> <span class="string">|</span></span><br><span class="line"> <span class="string">The</span> <span class="string">semantics</span> <span class="string">of</span> <span class="string">the</span> <span class="string">tag</span></span><br><span class="line"> <span class="string">above</span> <span class="string">may</span> <span class="string">be</span> <span class="string">different</span> <span class="string">for</span></span><br><span class="line"> <span class="string">different</span> <span class="string">documents.</span></span><br><span class="line"><span class="comment"># Glbal tags</span></span><br><span class="line"></span><br><span class="line"><span class="string">%TAG</span> <span class="string">!</span> <span class="string">tag:clarkevans.com,2002:</span></span><br><span class="line"><span class="string">---</span> <span class="type">!shape</span></span><br><span class="line">  <span class="comment"># Use the ! handle for presenting</span></span><br><span class="line">  <span class="comment"># tag:clarkevans.com,2002:circle</span></span><br><span class="line"><span class="bullet">-</span> <span class="type">!circle</span></span><br><span class="line">  <span class="attr">center:</span> <span class="string">&amp;ORIGIN</span> &#123;<span class="attr">x:</span> <span class="number">73</span>, <span class="attr">y:</span> <span class="number">129</span>&#125;</span><br><span class="line">  <span class="attr">radius:</span> <span class="number">7</span></span><br><span class="line"><span class="bullet">-</span> <span class="type">!line</span></span><br><span class="line">  <span class="attr">start:</span> <span class="meta">*ORIGIN</span></span><br><span class="line">  <span class="attr">finish:</span> &#123; <span class="attr">x:</span> <span class="number">89</span>, <span class="attr">y:</span> <span class="number">102</span> &#125;</span><br><span class="line"><span class="bullet">-</span> <span class="type">!label</span></span><br><span class="line">  <span class="attr">start:</span> <span class="meta">*ORIGIN</span></span><br><span class="line">  <span class="attr">color:</span> <span class="number">0xFFEEBB</span></span><br><span class="line">  <span class="attr">text:</span> <span class="string">Pretty</span> <span class="string">vector</span> <span class="string">drawing.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Unordered Sets</span></span><br><span class="line"><span class="comment"># Sets are represented as a</span></span><br><span class="line"><span class="comment"># Mapping where each key is</span></span><br><span class="line"><span class="comment"># associated with a null value</span></span><br><span class="line"><span class="string">---</span> <span class="type">!!set</span></span><br><span class="line"><span class="string">?</span> <span class="string">Mark</span> <span class="string">McGwire</span></span><br><span class="line"><span class="string">?</span> <span class="string">Sammy</span> <span class="string">Sosa</span></span><br><span class="line"><span class="string">?</span> <span class="string">Ken</span> <span class="string">Griff</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ordered Mappings</span></span><br><span class="line"><span class="comment"># Ordered maps are represented as</span></span><br><span class="line"><span class="comment"># A sequence of mappings, with</span></span><br><span class="line"><span class="comment"># each mapping having one key</span></span><br><span class="line"><span class="string">---</span> <span class="type">!!omap</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">Mark McGwire:</span> <span class="number">65</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">Sammy Sosa:</span> <span class="number">63</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">Ken Griffy:</span> <span class="number">58</span></span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>动态规划_背包问题_完全背包理论</title>
    <url>/2022/05/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<ul>
<li>参考:  <a href="https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html">代码随想录</a></li>
</ul>
<a id="more"></a>

<p>在掌握<strong>完全背包</strong>之前需要掌握<strong>01背包</strong>, 对于<strong>01背包</strong>问题的讨论,可以参考之前的文档; 这里在讲解<strong>完全背包</strong>, 主要以对比 <strong>01背包</strong>的方式进行;</p>
<h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><p>背包问题结构如下图;</p>
<p><img src="https://s2.loli.net/2022/05/22/PDlFgj2qEYGmT9u.png" alt="image-20220522163758857"></p>
<p>可以发现<strong>完全背包</strong>相比较于<strong>01背包</strong>,唯一的不同点在于, 每件物品的数量时无限的;具体定义为:</p>
<p>问题定义: 有<code>N</code>件物品,和一个容量(衡量单位为重量)为<code>W</code> 的背包, 物品<code>i</code> 的重量为 <code>weight[i]</code>, 价值为 <code>value[i]</code>. 每件物品<strong>数量无限制</strong>, 问这个背包可以装的最大价值是多少?</p>
<h2 id="问题理解"><a href="#问题理解" class="headerlink" title="问题理解"></a>问题理解</h2><p>这里以一道题目作为引子, 题目与 <strong>01背包</strong>类似, 只是物品数量无限制;</p>
<p>背包的容量为4, 物品的重量与价值如下表:</p>
<table>
<thead>
<tr>
<th></th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody><tr>
<td>物品 0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品 1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品 2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody></table>
<p>要求返回背包的最大价值; </p>
<h3 id="一维数组解法"><a href="#一维数组解法" class="headerlink" title="一维数组解法"></a>一维数组解法</h3><p>由于已经有了 <strong>01背包</strong> 的铺垫, 这里不再讨论 二维数组解法;</p>
<h4 id="动态规划三步走"><a href="#动态规划三步走" class="headerlink" title="动态规划三步走"></a>动态规划三步走</h4><blockquote>
<p>这里的三步走跟 <code>01背包</code> 是一摸一样, 所以说完全背包与01背包的差距并没有体现在动态规划的定义上,而是体现在遍历顺序方面;</p>
</blockquote>
<p><strong>状态定义:</strong> <code>dp[j]</code> 定义为容量为 <code>j</code> 的背包所能够获得的最大价值;</p>
<p><strong>状态转移方程:</strong> 在遍历过程中,也是对物品<code>i</code>的取舍问题:</p>
<blockquote>
<p>注意这里对于物品的取舍是有陷阱的, 这里指的时当前对物品的取舍; 如果保证物品仅取舍一次,就是01背包问题, 如果保证物品尽可能的去取舍那就是完全背包问题;</p>
</blockquote>
<ul>
<li>不放物品: <code>dp[j]</code> 不需要更新,本质与上述一致;</li>
<li>放物品: <code>dp[j] = dp[j-weight[i]]+value[i]</code>;</li>
</ul>
<p>综上: <code>dp[j] = max(dp[j], dp[j-weight[i]] + value[i])</code></p>
<p><strong>边界</strong></p>
<p>对于一维数组的边界,也就是<code>dp[0]</code> 那么直接为<code>0</code> 即可;</p>
<h4 id="初始化与遍历顺序"><a href="#初始化与遍历顺序" class="headerlink" title="初始化与遍历顺序"></a>初始化与遍历顺序</h4><p><strong>数组初始化</strong></p>
<p>状态定义为容量为 <code>j</code> 的背包所能够获得的最大价值, 那么在初始时赋值为0即可;</p>
<p><strong>遍历顺序</strong> </p>
<p>在<code>01背包</code>的对应讨论部分, 我们已经知道对于背包的遍历, 如果正序遍历, 那么是<strong>完全背包</strong>, 如果是逆序遍历那么是<strong>01背包</strong>; 我们可以通过实践填充表格,印证这个结论; </p>
<p>在<strong>01背包</strong>中遍历顺序是固定的: 先遍历物品, 再遍历背包容量; (背包容量逆序遍历);而对于<strong>完全背包</strong>中的遍历顺序是任选的: 既可以先物品后容量, 也可以先容量后物品; </p>
<ul>
<li><p>先物品后容量的遍历:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span> ;i &lt; <span class="built_in">len</span>(weight) ; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j:= weight[i] ; j &lt;= bagWeight ; j++ &#123;</span><br><span class="line">        dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>先容量后物品的遍历:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> j:= <span class="number">0</span> ; j &lt;= bagWeight ; j++ &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> j &gt;= weight[i] &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么<strong>完全背包</strong> 就没有这样的限制呢? 这是由于<strong>完全背包</strong>在遍历到当前点时, 需要保证左上方数据已经完全决定了即可; 相比较于 <strong>01背包</strong> 的逆序遍历背包容量, <strong>完全背包</strong> 采用顺序遍历, 不管是哪一种优先遍历,均可以保证左上侧已经最终确定;</p>
</li>
</ul>
<h4 id="算法实例"><a href="#算法实例" class="headerlink" title="算法实例"></a>算法实例</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test_CompletePack1 先遍历物品, 在遍历背包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_CompletePack1</span><span class="params">(weight, value []<span class="keyword">int</span>, bagWeight <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义dp数组 和初始化</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, bagWeight+<span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 遍历顺序</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">		<span class="comment">// 正序会多次添加 value[i]</span></span><br><span class="line">		<span class="keyword">for</span> j := weight[i]; j &lt;= bagWeight; j++ &#123;</span><br><span class="line">			<span class="comment">// 推导公式</span></span><br><span class="line">			dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">			<span class="comment">// debug</span></span><br><span class="line">			<span class="comment">//fmt.Println(dp)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[bagWeight]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test_CompletePack2 先遍历背包, 在遍历物品</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_CompletePack2</span><span class="params">(weight, value []<span class="keyword">int</span>, bagWeight <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义dp数组 和初始化</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, bagWeight+<span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 遍历顺序</span></span><br><span class="line">	<span class="comment">// j从0 开始</span></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= bagWeight; j++ &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> j &gt;= weight[i] &#123;</span><br><span class="line">				<span class="comment">// 推导公式</span></span><br><span class="line">				dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// debug</span></span><br><span class="line">			<span class="comment">//fmt.Println(dp)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[bagWeight]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	weight := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	price := []<span class="keyword">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">	fmt.Println(test_CompletePack1(weight, price, <span class="number">4</span>))</span><br><span class="line">	fmt.Println(test_CompletePack2(weight, price, <span class="number">4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划_背包问题_01背包理论</title>
    <url>/2022/05/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-01%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<ul>
<li>参考: <a href="https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html">代码随想录</a>, <a href="">背包九讲</a></li>
</ul>
<a id="more"></a>

<h2 id="何为背包问题"><a href="#何为背包问题" class="headerlink" title="何为背包问题"></a>何为背包问题</h2><p>背包问题是一类算法题目,其通常可以应用动态规划的方式进行处理,其解题思路汇总为<strong>背包问题</strong>.<strong>背包问题</strong> 有多种, 可以总结如下图:</p>
<p><img src="https://s2.loli.net/2022/05/22/PDlFgj2qEYGmT9u.png" alt="image-20220522163758857"></p>
<p>leetcode 中并没有对背包问题进行深度考核, 题目集中于 <strong>01背包</strong> 与 <strong>完全背包</strong>, 上图中可以发现,完全背包问题就是01背包中的1无限制, 所以<strong>01背包</strong>是背包问题中的基础;</p>
<h2 id="01背包问题定义"><a href="#01背包问题定义" class="headerlink" title="01背包问题定义"></a>01背包问题定义</h2><p>有<code>N</code>件物品,和一个容量(衡量单位为重量)为<code>W</code> 的背包, 物品<code>i</code> 的重量为 <code>weight[i]</code>, 价值为 <code>value[i]</code>. 每件物品<strong>仅能够装一次</strong>, 问这个背包可以装的最大价值是多少?</p>
<img src="https://s2.loli.net/2022/05/22/7Zwcz9SYMLdC3qk.png" alt="image-20220522163311986" style="zoom:50%;" />

<p>题目中的物品只有两个状态,取或者不取,那么利用回溯搜索的方式是可以解决的,但是时间复杂度是指数级别;所以利用动态规划处理是优选. 为了学习并了解<strong>01背包</strong>问题, 我采用代码随想录中的例子理解;</p>
<h2 id="问题理解"><a href="#问题理解" class="headerlink" title="问题理解"></a>问题理解</h2><h3 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h3><p>背包的容量为4, 物品的重量与价值如下表:</p>
<table>
<thead>
<tr>
<th></th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody><tr>
<td>物品 0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品 1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品 2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody></table>
<p>要求返回背包的最大价值;</p>
<h3 id="二维dp数组解法"><a href="#二维dp数组解法" class="headerlink" title="二维dp数组解法"></a>二维dp数组解法</h3><h4 id="动态规划三步走"><a href="#动态规划三步走" class="headerlink" title="动态规划三步走"></a>动态规划三步走</h4><p><strong>状态定义:</strong> <code>dp[i][j]</code> 表示为从 <code>[0,i]</code> 物品中选择放入容量为<code>j</code> 的背包中的最大价值, 那么最终的答案就是dp数组中右下角的数字;</p>
<blockquote>
<p>状态的定义,上面的参考均没有解释为什么这么设计;</p>
</blockquote>
<p>那么dp数组为二维数组:</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>物品 0:</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>物品 1:</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>物品 2:</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>状态转移方程:</strong> 由于每一件物品的状态要么放,要么不放, 我们可以从这个角度推出状态转移方程来:</p>
<ul>
<li>不放物品<code>i</code>: 此时 <code>dp[i][j]</code> 等价于 <code>dp[i-1][j]</code>;</li>
<li>放物品<code>i</code>: 此时 <code>dp[i][j] =dp[i-1][j-weight[i]] + value[i]</code>, 简单解释下: <code>dp[i-1][j-weight[i]]</code> 也就是在<code>[0, i-1]</code>的物品中放置在容量为<code>[j-weight[i]]</code> 的背包上的最大价值;</li>
</ul>
<p>所以递推公式为:<code>dp[i][j] = max( dp[i-1][j], dp[i-1][j-weight[i]] + value[i] )</code></p>
<p><strong>边界情况:</strong></p>
<p>边界的处理也是动态规划问题中着重点,因为其与问题的定义是息息相关的. 问题定义是 <code>dp[i][j]</code> 表示物品<code>[0,i]</code>放置在容量为<code>j</code>的背包中的最大价值;对于二维数组的边界情况, 我们需要处理的是<code>dp[0][j]</code> 与 <code>dp[i][0]</code> 的情况;</p>
<ul>
<li><code>dp[0][j]</code> : 指的是对于第一件物品放置在容量为<code>j</code>的背包上的最大价值; 那么当<code>j</code> 小于<code>weight[0]</code> 时, 为<code>0</code> , 否则为 <code>value[0]</code>;</li>
<li><code>dp[i][0]</code>: 指的是对容量为<code>0</code> 的背包,放置前<code>i</code>件物品的最大价值, 那么应全部为<code>0</code>;</li>
</ul>
<p>也就是如下表:</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>物品 0:</td>
<td>0</td>
<td>15</td>
<td>15</td>
<td>15</td>
<td>15</td>
</tr>
<tr>
<td>物品 1:</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>物品 2:</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<h4 id="初始化与遍历顺序"><a href="#初始化与遍历顺序" class="headerlink" title="初始化与遍历顺序"></a>初始化与遍历顺序</h4><p><strong>数组的初始化</strong></p>
<p>首先数组的边界数组与上述一致,其次其他位置的数字在遍历过程中均会被重新赋值,所以其他位置可以为任意数字, 一般采用初始化为<code>0</code>;</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>物品 0:</td>
<td>0</td>
<td>15</td>
<td>15</td>
<td>15</td>
<td>15</td>
</tr>
<tr>
<td>物品 1:</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>物品 2:</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; weight[<span class="number">0</span>]; j++) &#123;  </span><br><span class="line">    dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>数组的遍历顺序</strong></p>
<p>对于二维数组,我们有两种选择,优先遍历物品或者优先遍历背包重量,对于本问题的状态定义来说,两种方式均是可以的;简单解释一下: 由状态转移方程<code>dp[i][j] = max( dp[i-1][j], dp[i-1][j-weight[i]] + value[i] )</code>, 我们发现,当前位置仅与左上方有关系, 我们需要保证的就是在遍历到当前位置时,上方与左前方位置均已确定即可;这里采用代码随想录中的两张图片,方便理解:</p>
<p><strong>优先物品,其次背包:</strong></p>
<p><img src="https://s2.loli.net/2022/05/04/DIS3FwHOckuztGg.png" alt="image-20220504163205790"></p>
<p><strong>优先背包,其次物品:</strong></p>
<p><img src="https://s2.loli.net/2022/05/04/eoTYC1pFmZndyis.png" alt="image-20220504163154411"></p>
<p>不过依照常见的遍历习惯,优先物品遍历,也就是优先行遍历是最常用的方式;<strong>对于背包问题,遍历顺序是需要讲究的,不可盲目按照习惯处理.</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; weight.size(); i++) &#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j]; </span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="算法实例"><a href="#算法实例" class="headerlink" title="算法实例"></a>算法实例</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_2_wei_bag_problem1</span><span class="params">(weight, value []<span class="keyword">int</span>, bagweight <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义dp数组</span></span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(weight))</span><br><span class="line">	<span class="keyword">for</span> i, _ := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, bagweight+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	<span class="keyword">for</span> j := bagweight; j &gt;= weight[<span class="number">0</span>]; j-- &#123;</span><br><span class="line">		dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-weight[<span class="number">0</span>]] + value[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 递推公式</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">		<span class="comment">//正序,也可以倒序</span></span><br><span class="line">		<span class="keyword">for</span>  j := weight[i];j&lt;= bagweight ; j++ &#123;</span><br><span class="line">			dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weight[i]]+value[i])</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="built_in">len</span>(weight)<span class="number">-1</span>][bagweight]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	weight := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">	value := []<span class="keyword">int</span>&#123;<span class="number">15</span>,<span class="number">20</span>,<span class="number">30</span>&#125;</span><br><span class="line">	test_2_wei_bag_problem1(weight,value,<span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="一维dp数组解法"><a href="#一维dp数组解法" class="headerlink" title="一维dp数组解法"></a>一维dp数组解法</h3><p>上面的二维数组解法中,从状态转移方程中可以发现<code>dp[i][j]</code> 仅取决于上一行<code>dp[i-1]</code>那么利用<strong>滚动数组</strong>处理一定是可行的.这也是<strong>01背包</strong>中最常适用的处理方式;</p>
<h4 id="动态规划三步走-1"><a href="#动态规划三步走-1" class="headerlink" title="动态规划三步走"></a>动态规划三步走</h4><p><strong>状态定义:</strong> <code>dp[j]</code> 定义为容量为 <code>j</code> 的背包所能够获得的最大价值;</p>
<p><strong>状态转移方程:</strong> 这里与上面的介绍是一致的, 在遍历过程中,也是对物品<code>i</code>的取舍问题:</p>
<ul>
<li>不放物品: <code>dp[j]</code> 不需要更新,本质与上述一致;</li>
<li>放物品: <code>dp[j] = dp[j-weight[i]]+value[i]</code>;</li>
</ul>
<p>综上: <code>dp[j] = max(dp[j], dp[j-weight[i]] + value[i])</code></p>
<p><strong>边界</strong></p>
<p>对于一维数组的边界,也就是<code>dp[0]</code> 那么直接为<code>0</code> 即可;</p>
<h4 id="初始化与遍历顺序-1"><a href="#初始化与遍历顺序-1" class="headerlink" title="初始化与遍历顺序"></a>初始化与遍历顺序</h4><p><strong>数组初始化</strong></p>
<p>目前的状态定义为: <code>dp[j]</code> 为容量为<code>j</code> 的背包所能获得的最大价值; 那么在初始时, <code>[1 : n]</code> 为<code>0</code>即可, 这表示初始时背包还没有放物品,那就是0; </p>
<p>如果状态定义为: <code>dp[j]</code> 为容量<code>j</code> 的背包装满能获得的最大价值, 那么初始时, 没有装满的情况应当为 <code>-∞</code> ,这表示一开始没有装, 自然应当为<code>-∞</code>; </p>
<p>对于初始化的讨论, 不可以简单的粗暴赋值, 一般取决于状态定义, 状态转移方程; 需要符合逻辑模型的定义;之后会进行整理;</p>
<p><strong>遍历顺序</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里直接给出伪代码的结论:</p>
<ul>
<li><p>不同于二维数组物品的遍历从<code>1</code>开始, 一维是从<code>0</code>开始遍历,这是由于一维数组的边界仅为<code>dp[0]</code>,没有涵盖当前情况;</p>
</li>
<li><p>不同于二维数组容量采用从小到大的方式遍历, 一位数组的遍历顺序是<strong>从大到小</strong>处理;</p>
<p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">举一个例子：物品0的重量weight[0] &#x3D; 1，价值value[0] &#x3D; 15</span><br><span class="line"></span><br><span class="line">如果正序遍历</span><br><span class="line"></span><br><span class="line">dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</span><br><span class="line"></span><br><span class="line">dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 30</span><br><span class="line"></span><br><span class="line">此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</span><br><span class="line"></span><br><span class="line">为什么倒序遍历，就可以保证物品只放入一次呢？</span><br><span class="line"></span><br><span class="line">倒序就是先算dp[2]</span><br><span class="line"></span><br><span class="line">dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 15 （dp数组已经都初始化为0）</span><br><span class="line"></span><br><span class="line">dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</span><br></pre></td></tr></table></figure></li>
<li><p>所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。</p>
<p><strong>那么问题又来了，为什么二维dp数组历的时候不用倒序呢？</strong></p>
<p>因为对于二维dp，<code>dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！</code></p>
</li>
</ul>
<p>上面代码中优先遍历的物品,再遍历的背包容量, 这也是<strong>01背包</strong> 唯一允许的遍历方式; 那么为什么不能够优先遍历背包容量,再遍历物品呢?问题的点在于背包容量一定是倒序的, 这保证了<strong>01背包</strong> 的问题性质, 如果优先遍历背包容量, 那这里的唯一性将导致问题变为: <strong>仅在背包中放置一个物品所获得的最大价值;</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 错误的01背包遍历顺序:</span><br><span class="line">&#x2F;&#x2F; 优先倒序遍历背包,将导致问题定义不一致</span><br><span class="line">for j:&#x3D; bagWeight; j &gt;&#x3D; weight[i] ; j-- &#123;</span><br><span class="line">    for i :&#x3D; 0; i&lt;len(weight); i++ &#123;</span><br><span class="line">        if j &gt;&#x3D; weight[i] &#123;</span><br><span class="line">            dp[j] &#x3D; max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="算法实例-1"><a href="#算法实例-1" class="headerlink" title="算法实例"></a>算法实例</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_1_wei_bag_problem</span><span class="params">(weight, value []<span class="keyword">int</span>, bagWeight <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义 and 初始化</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="keyword">int</span>,bagWeight+<span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 递推顺序</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span> ;i &lt; <span class="built_in">len</span>(weight) ; i++ &#123;</span><br><span class="line">		<span class="comment">// 这里必须倒序,区别二维,因为二维dp保存了i的状态</span></span><br><span class="line">		<span class="keyword">for</span> j:= bagWeight; j &gt;= weight[i] ; j-- &#123;</span><br><span class="line">			<span class="comment">// 递推公式</span></span><br><span class="line">			dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//fmt.Println(dp)</span></span><br><span class="line">	<span class="keyword">return</span> dp[bagWeight]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	weight := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">	value := []<span class="keyword">int</span>&#123;<span class="number">15</span>,<span class="number">20</span>,<span class="number">30</span>&#125;</span><br><span class="line">	test_1_wei_bag_problem(weight,value,<span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_Learning_Effective_Go_Docs.md</title>
    <url>/2021/09/25/Go-Learning-Effective-Go-Docs/</url>
    <content><![CDATA[<p>EffectiveGo_简单笔记</p>
<p><strong>地址:</strong> <a href="https://golang.google.cn/doc/effective_go">教材</a></p>
<a id="more"></a>

<p>可用于快速了解GO语言.</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Effective_Go provide:</p>
<ul>
<li><strong>Go language</strong> properties and idioms</li>
<li><strong>Established conventions</strong> for programming in Go</li>
</ul>
<p>This document gives tips for writting clear,idiomatic Go code.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Go standard package is a short path to understand <strong>Excellent Go Code</strong>. Fortunately many lib provide self-contained executable example you can run directly from the golang.org web site,such as <a href="https://golang.org/pkg/strings/#example_Map">this one</a>.</p>
<h2 id="Formatting"><a href="#Formatting" class="headerlink" title="Formatting"></a>Formatting</h2><p>Formatting issues are the most contentious but the least consequential. While in real life, every one may adapt different code style. The best way is Every developer adapt same code style.</p>
<p>In Go language, the machine could take care of most formatting issues. The <strong>gofmt</strong> program could read Go code and emits the source in a standard style. The standard style may include: indentation and vertical alignment, retaining and if necessary reformatting comments. </p>
<p><strong>Example Code: before</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span> <span class="comment">// name of the object</span></span><br><span class="line">    value <span class="keyword">int</span> <span class="comment">// its value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>After gofmt:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	name  <span class="keyword">string</span> <span class="comment">// name of the object</span></span><br><span class="line">	value <span class="keyword">int</span>    <span class="comment">// its value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Formatting include:</p>
<ul>
<li>Indentation: GO use TAB as default</li>
<li>Line length: No length limit</li>
<li>Parentheses: Control structures(if, for, switch) do not have parenthese in their syntax</li>
</ul>
<h2 id="Commentary"><a href="#Commentary" class="headerlink" title="Commentary"></a>Commentary</h2><p>Go provides block(/* */) comments and line comments(//). line comments is the same as other language, While block coments may serve as package comments.</p>
<h3 id="Types"><a href="#Types" class="headerlink" title="Types:"></a><strong>Types:</strong></h3><ul>
<li><p>package comments: Appear before top-level declarations </p>
<blockquote>
<p>For multi-file packages, the package comment only needs to be present in one file, and any one will do. The package comment should introduce the package and provide information relevant to the package as a whole. It will appear first on the <code>godoc</code> page and should set up the detailed documentation that follows.</p>
</blockquote>
</li>
<li><p>doc comments: Apeear above the declarations.</p>
<blockquote>
<p>In go, every export(Capital Letter start) needs doc comments</p>
</blockquote>
</li>
<li><p>general comments: others</p>
</li>
</ul>
<h3 id="Conventions"><a href="#Conventions" class="headerlink" title="Conventions"></a>Conventions</h3><p><strong>godoc</strong> process Go source files to extract documentation about the package. The document quality is based on the comments quality. So thire are some rules we need to obey:</p>
<ul>
<li><p>Package Comments:  introduce the package and provide information relevant to the package as a whole. It will appear first on the <code>godoc</code> page and should set up the detailed documentation that follows.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Package regexp implements a simple library for regular expressions.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The syntax of the regular expressions accepted is:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    regexp:</span></span><br><span class="line"><span class="comment">        concatenation &#123; &#x27;|&#x27; concatenation &#125;</span></span><br><span class="line"><span class="comment">    concatenation:</span></span><br><span class="line"><span class="comment">        &#123; closure &#125;</span></span><br><span class="line"><span class="comment">    closure:</span></span><br><span class="line"><span class="comment">        term [ &#x27;*&#x27; | &#x27;+&#x27; | &#x27;?&#x27; ]</span></span><br><span class="line"><span class="comment">    term:</span></span><br><span class="line"><span class="comment">        &#x27;^&#x27;</span></span><br><span class="line"><span class="comment">        &#x27;$&#x27;</span></span><br><span class="line"><span class="comment">        &#x27;.&#x27;</span></span><br><span class="line"><span class="comment">        character</span></span><br><span class="line"><span class="comment">        &#x27;[&#x27; [ &#x27;^&#x27; ] character-ranges &#x27;]&#x27;</span></span><br><span class="line"><span class="comment">        &#x27;(&#x27; regexp &#x27;)&#x27;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> regexp</span><br></pre></td></tr></table></figure>
<p>If package is simple, the package comments can be brief:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package path implements utility routines for</span></span><br><span class="line"><span class="comment">// manipulating slash-separated filename paths.</span></span><br></pre></td></tr></table></figure></li>
<li><p>Doc comments: The first sentence should be a one-sentence summary that starts with <strong>the name being declared</strong>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Compile parses a regular expression and returns, if successful,</span></span><br><span class="line"><span class="comment">// a Regexp that can be used to match against text.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compile</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="params">(*Regexp, error)</span></span> &#123;</span><br></pre></td></tr></table></figure></li>
<li><p>Comments do not need extra formatting such as banners of stars.</p>
</li>
</ul>
<h2 id="Names"><a href="#Names" class="headerlink" title="Names"></a>Names</h2><p>Name, in Go language, has syntax effect: the visibility of a name outside a package is determined by whether its first character is upper case. </p>
<h3 id="Package-Name"><a href="#Package-Name" class="headerlink" title="Package Name"></a>Package Name</h3><ul>
<li>Package Name is an accessor for the content.</li>
<li>convention:<ul>
<li>packages are given lower case, single-word names;</li>
<li>No underscore,No mixedCaps</li>
<li>the package name is the base name of its source directory; <ul>
<li>the package in <code>src/encoding/base64</code> is imported as <code>&quot;encoding/base64&quot;</code> but has name <code>base64</code>, not <code>encoding_base64</code> and not <code>encodingBase64</code>.</li>
</ul>
</li>
</ul>
</li>
<li>The importer of a package will use the name to refer to its contents, so exported names in the package can use that fact to avoid repetition.</li>
</ul>
<h3 id="Interface-Name"><a href="#Interface-Name" class="headerlink" title="Interface Name"></a>Interface Name</h3><p>By convention, one-method interfaces are named by the method name plus an -er suffix or similar modification to construct an agent noun: <code>Reader</code>, <code>Writer</code>, <code>Formatter</code>, <code>CloseNotifier</code> etc.</p>
<h3 id="MixedCap"><a href="#MixedCap" class="headerlink" title="MixedCap"></a>MixedCap</h3><p>the convention in Go is to use <code>MixedCaps</code> or <code>mixedCaps</code> rather than underscores to write multiword names.</p>
<h2 id="Semicolons"><a href="#Semicolons" class="headerlink" title="Semicolons"></a>Semicolons</h2><p>In Go language, Semicolons(;) is used to terminate statement. The lexer would add semicolons autumatically based on some rules:</p>
<p><strong>Rules:</strong></p>
<ul>
<li><p>Add semicolons : if the newline comes after a token that could end a statement, insert a semicolon:</p>
<ul>
<li>identifier: <code>int</code> , <code>string</code>  </li>
<li>basic literial: a number or const string  </li>
<li>some tokens: <code>break continue fallthrough return ++ -- ) &#125;</code></li>
</ul>
</li>
<li><p>Omit semicolons: Closing identifier, such as</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="keyword">for</span> &#123; dst &lt;- &lt;-src &#125; &#125;()</span><br></pre></td></tr></table></figure></li>
<li><p>you cannot put the opening brace of a control structure (<code>if</code>, <code>for</code>, <code>switch</code>, or <code>select</code>) on the next line. If you do, a semicolon will be inserted before the brace, which could cause unwanted effects. </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// right</span></span><br><span class="line"><span class="keyword">if</span> i &lt; f() &#123;</span><br><span class="line">    g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//wrong</span></span><br><span class="line"><span class="keyword">if</span> i &lt; f()  <span class="comment">// wrong!</span></span><br><span class="line">&#123;           <span class="comment">// wrong!</span></span><br><span class="line">    g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Idiomatic</strong>:</p>
<ul>
<li><code>;</code>,Go programs have semicolons only in places such as <code>for</code> loop clauses, to separate the initializer, condition, and continuation elements. </li>
<li><code>;</code>, separate multiple statements on a line, should you write code that way.</li>
</ul>
<h2 id="Control-structures"><a href="#Control-structures" class="headerlink" title="Control structures"></a>Control structures</h2><p>In Go language, there is only <code>if , for , switch</code> as control structure while no <code>do, while</code> loop. </p>
<ul>
<li>Same with other language: <code>break,continue</code> statements is the same as others</li>
<li>Different :<ul>
<li>in <code>switch</code> structure, <code>type</code> is optional label</li>
<li><code>select</code></li>
</ul>
</li>
</ul>
<p><strong>Syntax</strong> in Go: No need parentheses while the body must always be brace-delimited.</p>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><ul>
<li><p>Ordinary syntan: Writting simple <code>if</code> in multiple lines.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Intersting syntax: <code>if</code> with initialization statement</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := file.Chmod(<span class="number">0664</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Print(err)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li></li>
</ul>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>There are three forms in <code>for</code> syntaxs:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Like a C for</span></span><br><span class="line"><span class="keyword">for</span> init; condition; post &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Like a C while</span></span><br><span class="line"><span class="keyword">for</span> condition &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Like a C for(;;)</span></span><br><span class="line"><span class="keyword">for</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="for-with-range"><a href="#for-with-range" class="headerlink" title="for with range:"></a><strong>for with range:</strong></h4><p>range statements is a good way to loop array, slice, map, channel, the syntax is :</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you only need the first item in the range (the key or index), drop the second:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> m &#123;</span><br><span class="line">    <span class="keyword">if</span> key.expired() &#123;</span><br><span class="line">        <span class="built_in">delete</span>(m, key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you only need the second item in the range (the value), use the <em>blank identifier</em>, an underscore, to discard the first:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> array &#123;</span><br><span class="line">    sum += value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Range does more work for <code>string</code>:Breaking out individual Unicode code points by parsing the UTF-8. Erroneous encodings consume one byte and produce the replacement rune U+FFFD.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> pos, char := <span class="keyword">range</span> <span class="string">&quot;日本\x80語&quot;</span> &#123; <span class="comment">// \x80 is an illegal UTF-8 encoding</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;character %#U starts at byte position %d\n&quot;</span>, char, pos)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//character U+65E5 &#x27;日&#x27; starts at byte position 0</span></span><br><span class="line"><span class="comment">//character U+672C &#x27;本&#x27; starts at byte position 3</span></span><br><span class="line"><span class="comment">//character U+FFFD &#x27;�&#x27; starts at byte position 6</span></span><br><span class="line"><span class="comment">//character U+8A9E &#x27;語&#x27; starts at byte position 7</span></span><br></pre></td></tr></table></figure>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch has the same mwaning as other language. In go language, if the <code>switch</code> has no expression it switches on <code>true</code>. It’s therefore possible—and idiomatic—to write an <code>if</code>-<code>else</code>-<code>if</code>-<code>else</code> chain as a <code>switch</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unhex</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>There is no automatic fall through, but cases can be presented in comma-separated lists.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shouldEscape</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> c &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;&amp;&#x27;</span>, <span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Type-switch"><a href="#Type-switch" class="headerlink" title="Type switch"></a>Type switch</h4><p>A switch can also be used to discover the dynamic type of an interface variable. Such a <em>type switch</em> uses the syntax of a type assertion with the keyword <code>type</code> inside the parentheses. If the switch declares a variable in the expression, the variable will have the corresponding type in each clause. It’s also idiomatic to reuse the name in such cases, in effect declaring a new variable with the same name but a different type in each case.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">t = functionOfSomeType()</span><br><span class="line"><span class="keyword">switch</span> t := t.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;unexpected type %T\n&quot;</span>, t)     <span class="comment">// %T prints whatever type t has</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;boolean %t\n&quot;</span>, t)             <span class="comment">// t has type bool</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;integer %d\n&quot;</span>, t)             <span class="comment">// t has type int</span></span><br><span class="line"><span class="keyword">case</span> *<span class="keyword">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;pointer to boolean %t\n&quot;</span>, *t) <span class="comment">// t has type *bool</span></span><br><span class="line"><span class="keyword">case</span> *<span class="keyword">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;pointer to integer %d\n&quot;</span>, *t) <span class="comment">// t has type *int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>Three unusual features in Go Functions:</p>
<h3 id="Multiple-return-values"><a href="#Multiple-return-values" class="headerlink" title="Multiple return values"></a>Multiple return values</h3><p>Like PYTHON, functions in go could return multiple values. A standard example in package <code>os</code> is <code>Write</code> method:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *File)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">it returns the number of bytes written and a non-nil error when n != len(b).</span><br></pre></td></tr></table></figure>
<h3 id="Named-result-parameters"><a href="#Named-result-parameters" class="headerlink" title="Named result parameters"></a>Named result parameters</h3><p>The return parameters of a Go function can be given names and used as regular variables, just like incoming parameters. When named, they are initialized to the ZERO values for their types when the function begins; if the function executes a <code>return</code> statement with no arguments, the current values of the result parameters are used as the returned values.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextInt</span><span class="params">(b []<span class="keyword">byte</span>, pos <span class="keyword">int</span>)</span> <span class="params">(value, nextPos <span class="keyword">int</span>)</span></span> &#123;</span><br></pre></td></tr></table></figure>
<ul>
<li>Make code shorter and clearer</li>
</ul>
<p>Because named results are initialized and tied to an unadorned return, they can simplify as well as clarify. Here’s a version of <code>io.ReadFull</code> that uses them well:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFull</span><span class="params">(r Reader, buf []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(buf) &gt; <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> nr <span class="keyword">int</span></span><br><span class="line">        nr, err = r.Read(buf)</span><br><span class="line">        n += nr</span><br><span class="line">        buf = buf[nr:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h3><p>Go’s <code>defer</code> statement schedules a function call (the <em>deferred</em> function) to be run immediately before the function executing the <code>defer</code> returns. It’s an unusual but effective way to deal with situations such as resources that must be released regardless of which path a function takes to return. The canonical examples are unlocking a mutex or closing a file.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Contents returns the file&#x27;s contents as a string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contents</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()  <span class="comment">// f.Close will run when we&#x27;re finished.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result []<span class="keyword">byte</span></span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := f.Read(buf[<span class="number">0</span>:])</span><br><span class="line">        result = <span class="built_in">append</span>(result, buf[<span class="number">0</span>:n]...) <span class="comment">// append is discussed later.</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err  <span class="comment">// f will be closed if we return here.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(result), <span class="literal">nil</span> <span class="comment">// f will be closed if we return here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li> First, it guarantees that you will never forget to close the file, a mistake that’s easy to make if you later edit the function to add a new return path. </li>
<li> Second, it means that the close sits near the open, which is much clearer than placing it at the end of the function.</li>
</ul>
<p>Deferred functions are executed in LIFO order,</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;entering:&quot;</span>, s)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">un</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;leaving:&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> un(trace(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">    fmt.Println(<span class="string">&quot;in a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> un(trace(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">    fmt.Println(<span class="string">&quot;in b&quot;</span>)</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">entering: b</span><br><span class="line">in b</span><br><span class="line">entering: a</span><br><span class="line">in a</span><br><span class="line">leaving: a</span><br><span class="line">leaving: b</span><br></pre></td></tr></table></figure>
<h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><h3 id="Allocation"><a href="#Allocation" class="headerlink" title="Allocation"></a>Allocation</h3><p>Three allocation methods in Go language, <code>new</code> <code>make</code> <code>composite literals</code>; While <code>new</code> and <code>make</code> are build in functions, <code>composite literals</code> is a kind of initialise format. Different allocation method with different feature.</p>
<p><strong><code>new</code></strong>: build in function, allocate memory , <strong>zeros</strong> it, ,return the pointer(*T) of type <code>T</code>.</p>
<ul>
<li><p>Apply Type: Any</p>
</li>
<li><p>Basic Format: <code>new(type)</code></p>
<ul>
<li><p>Zeros struct:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SyncedBuffer <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock    sync.Mutex</span><br><span class="line">    buffer  bytes.Buffer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p *SyncedBuffer = <span class="built_in">new</span>(SyncedBuffer) <span class="comment">// type *SyncedBuffer</span></span><br><span class="line">p := <span class="built_in">new</span>(SyncedBuffer)  <span class="comment">// type *SyncedBuffer</span></span><br></pre></td></tr></table></figure></li>
<li><p>Zeros slice:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *[]<span class="keyword">int</span> = <span class="built_in">new</span>([]<span class="keyword">int</span>)       <span class="comment">// allocates slice structure; *p == nil; </span></span><br><span class="line">p := <span class="built_in">new</span>([]<span class="keyword">int</span>)					<span class="comment">//allocates slice structure; *p == nil; </span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong><code>make</code></strong>:build in function,  allocate memory, <strong>initialized</strong> it, return the value(T) of type <code>T</code> .</p>
<ul>
<li><p>Aapply Type: only slices, maps, channels</p>
</li>
<li><p>Basic Format: <code>make(type , length , capacity)</code></p>
<ul>
<li><p>Initialized Slice:</p>
<p>A slice, for example, is a three-item descriptor containing a pointer to the data (inside an array), the length, and the capacity, and until those items are initialized, the slice is <code>nil</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>allocates an array of 100 ints and then creates a slice structure with length 10 and a capacity of 100 pointing at the first 10 elements of the array. When making a slice, the capacity can be omitted;</p>
</li>
</ul>
</li>
</ul>
<p><strong><code>composite literals</code></strong>:  a kind of initialise format, allocate memory, <strong>initialized</strong> it , return the value(T) of type <code>T</code></p>
<ul>
<li><p>Apply Type: Any</p>
</li>
<li><p>Basic Format: <code>Type&#123;value_0, ..., value_n&#125;</code> or <code>Type&#123;item_y : value_x, item_x: value_x, ... &#125;</code></p>
<ul>
<li><p>Initialized Slice:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> figure out </span></span><br><span class="line">s := []<span class="keyword">string</span>      &#123;Enone: <span class="string">&quot;no error&quot;</span>, Eio: <span class="string">&quot;Eio&quot;</span>, Einval: <span class="string">&quot;invalid argument&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Initialized Struct:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> *<span class="title">File</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    f := File&#123;fd, name, <span class="literal">nil</span>, <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;f</span><br><span class="line">    <span class="comment">//  equals to:   return &amp;File&#123;fd, name, nil, 0&#125;</span></span><br><span class="line">    <span class="comment">//  equals to:  return &amp;File&#123;fd: fd, name: name&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Data-structure"><a href="#Data-structure" class="headerlink" title="Data structure"></a>Data structure</h3></li>
</ul>
</li>
</ul>
<h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p>Array is primarily as the building block for Slice.</p>
<p><strong>Features:</strong></p>
<ul>
<li>Arrays are values. Assigning one array to another copies all the elements.</li>
<li>In particular, if you pass an array to a function, it will receive a <em>copy</em> of the array, not a pointer to it.</li>
<li>The size of an array is part of its type. The types <code>[10]int</code> and <code>[20]int</code> are distinct.</li>
</ul>
<p>The value property can be useful but also expensive; if you want C-like behavior and efficiency, you can pass a pointer to the array.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func Sum(a *[3]float64) (sum float64) &#123;</span><br><span class="line">    for _, v :&#x3D; range *a &#123;</span><br><span class="line">        sum +&#x3D; v</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array :&#x3D; [...]float64&#123;7.0, 8.5, 9.1&#125;</span><br><span class="line">x :&#x3D; Sum(&amp;array)  &#x2F;&#x2F; Note the explicit address-of operator</span><br></pre></td></tr></table></figure>
<p>But even this style isn’t idiomatic Go. Use slices instead.</p>
<h4 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h4><p>Slice wrap arrays to give a more general, powerful and convinent interface to sequence of data. Most array programming in GO is done with slices rather than simple arrays.</p>
<p><strong>Features:</strong></p>
<ul>
<li>Slices hold the references to an underlaying array<ul>
<li>if you assign one slice to another, both refer to the same array.</li>
<li>If a functions take Slice argument, changes it makes to the slices elements will be visible to the caller.</li>
</ul>
</li>
</ul>
<p>The length of a slice may be changed as long as it still fits within the limits of the underlying array; just assign it to a slice of itself. The <em>capacity</em> of a slice, accessible by the built-in function <code>cap</code>, reports the maximum length the slice may assume. Here is a function to append data to a slice. If the data exceeds the capacity, the slice is reallocated. The resulting slice is returned. The function uses the fact that <code>len</code> and <code>cap</code> are legal when applied to the <code>nil</code> slice, and return 0.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func Append(slice, data []byte) []byte &#123;</span><br><span class="line">    l :&#x3D; len(slice)</span><br><span class="line">    if l + len(data) &gt; cap(slice) &#123;  &#x2F;&#x2F; reallocate</span><br><span class="line">        &#x2F;&#x2F; Allocate double what&#39;s needed, for future growth.</span><br><span class="line">        newSlice :&#x3D; make([]byte, (l+len(data))*2)</span><br><span class="line">        &#x2F;&#x2F; The copy function is predeclared and works for any slice type.</span><br><span class="line">        copy(newSlice, slice)</span><br><span class="line">        slice &#x3D; newSlice</span><br><span class="line">    &#125;</span><br><span class="line">    slice &#x3D; slice[0:l+len(data)]</span><br><span class="line">    copy(slice[l:], data)</span><br><span class="line">    return slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We must return the slice afterwards because, although <code>Append</code> can modify the elements of <code>slice</code>, the slice itself (the run-time data structure holding the pointer, length, and capacity) is passed by value.</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><strong>What Map ?</strong></p>
<p>The key can be of any type for which the equality operator is defined, such as integers, floating point and complex numbers, strings, pointers, interfaces (as long as the dynamic type supports equality), structs and arrays. Slices cannot be used as map keys, because equality is not defined on them. Like slices, maps hold references to an underlying data structure. If you pass a map to a function that changes the contents of the map, the changes will be visible in the caller.</p>
<p><strong>initialize Map</strong></p>
<p>Maps can be constructed using the usual composite literal syntax with colon-separated key-value pairs, so it’s easy to build them during initialization.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timeZone = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;UTC&quot;</span>:  <span class="number">0</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">    <span class="string">&quot;EST&quot;</span>: <span class="number">-5</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">    <span class="string">&quot;CST&quot;</span>: <span class="number">-6</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">    <span class="string">&quot;MST&quot;</span>: <span class="number">-7</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">    <span class="string">&quot;PST&quot;</span>: <span class="number">-8</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Features</strong></p>
<ul>
<li><p><strong>get value:</strong> simliar with slice</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">offset := timeZone[<span class="string">&quot;EST&quot;</span>]</span><br></pre></td></tr></table></figure></li>
<li><p><strong>apply the key which not in map</strong> : return zeros of value type</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">attended := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>&#123;</span><br><span class="line">    <span class="string">&quot;Ann&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;Joe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> attended[person] &#123; <span class="comment">// will be false if person is not in the map</span></span><br><span class="line">    fmt.Println(person, <span class="string">&quot;was at the meeting&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>two var is accept : <strong>get gistinguish a missing entry from zeros value</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> seconds <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">seconds, ok = timeZone[tz]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">offset</span><span class="params">(tz <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> seconds, ok := timeZone[tz]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> seconds</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">&quot;unknown time zone:&quot;</span>, tz)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Omit value:</strong> <code>_</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, present := timeZone[tz]</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Delete map entry</strong>:<code>delete</code> function</p>
<p>SAFE function even if the key is already absent from the map.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(timeZone, <span class="string">&quot;PDT&quot;</span>)  <span class="comment">// Now on Standard Time</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h2><h3 id="constant"><a href="#constant" class="headerlink" title="constant"></a>constant</h3><ul>
<li><p>CreateTime: compile time</p>
</li>
<li><p>can only be: <code>numbers</code>,<code>characters</code>,<code>string</code>,<code>booleans</code></p>
</li>
<li><p>Define location: could be defined as locals in <strong>functions</strong></p>
</li>
<li><p>constant expression: only constant expression</p>
<ul>
<li><code>1&lt;&lt;3</code> : Correct </li>
<li><code>math.Sin(math.Pi)</code>: Wrong</li>
</ul>
</li>
<li><p>enumerated constant: <code>iota</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteSize <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _           = <span class="literal">iota</span> <span class="comment">// ignore first value by assigning to blank identifier</span></span><br><span class="line">    KB ByteSize = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    MB</span><br><span class="line">    GB</span><br><span class="line">    TB</span><br><span class="line">    PB</span><br><span class="line">    EB</span><br><span class="line">    ZB</span><br><span class="line">    YB</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="variable"><a href="#variable" class="headerlink" title="variable"></a>variable</h3></li>
<li><p>CreateTime: Runtime</p>
</li>
<li><p>can be any type</p>
</li>
<li><p>initializer can be a general expression computed at run time.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    home   = os.Getenv(<span class="string">&quot;HOME&quot;</span>)</span><br><span class="line">    user   = os.Getenv(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">    gopath = os.Getenv(<span class="string">&quot;GOPATH&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="init-function"><a href="#init-function" class="headerlink" title="init function"></a>init function</h3><ul>
<li><p>Call Time:After all the variable declarations in the package have evaluated;</p>
</li>
<li><p>a common use of <code>init</code> functions is to verify or repair correctness of the program state before real execution begins.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> user == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;$USER not set&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> home == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        home = <span class="string">&quot;/home/&quot;</span> + user</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> gopath == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        gopath = home + <span class="string">&quot;/go&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// gopath may be overridden by --gopath flag on command line.</span></span><br><span class="line">    flag.StringVar(&amp;gopath, <span class="string">&quot;gopath&quot;</span>, gopath, <span class="string">&quot;override default GOPATH&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2></li>
</ul>
<p>Methods can be divited into two types: Values methods OR Pointer methods.For Example:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// values method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(slice ByteSlice)</span> <span class="title">Append</span><span class="params">(data []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="comment">// Body exactly the same as the Append function defined above.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pointer method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ByteSlice)</span> <span class="title">Append</span><span class="params">(data []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    slice := *p</span><br><span class="line">    <span class="comment">// Body as above, without the return.</span></span><br><span class="line">    *p = slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Difference:</strong> The rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers.</p>
<ul>
<li>pointer methods can modify the receiver</li>
<li>value methods will receive a copy of value, so the change will be discard</li>
</ul>
<p>In GO language the pointer method is recommend. When the value is addressable, the complier would rewrite that expression for us. For example, coder wirte <code>b.write</code>, the complier would rewrite it to <code>(&amp;b).write</code>.</p>
<h2 id="Interface-and-other-types"><a href="#Interface-and-other-types" class="headerlink" title="Interface and other types"></a>Interface and other types</h2><h2 id="The-blank-identifier"><a href="#The-blank-identifier" class="headerlink" title="The blank identifier"></a>The blank identifier</h2><p>The blank identifier <code>_</code> can be assigned with any value of any type, with the value discarded harmlessly.</p>
<h3 id="usage-scenario"><a href="#usage-scenario" class="headerlink" title="usage scenario"></a>usage scenario</h3><ul>
<li><p>The blank identifier in multiple assignment</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err := os.Stat(path); os.IsNotExist(err) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s does not exist\n&quot;</span>, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Unused imports and variables: half-written program</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = fmt.Printf <span class="comment">// For debugging; delete when done.</span></span><br><span class="line"><span class="keyword">var</span> _ io.Reader    <span class="comment">// For debugging; delete when done.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fd, err := os.Open(<span class="string">&quot;test.go&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> use fd.</span></span><br><span class="line">    _ = fd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>import for side effect</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;net/http/pprof&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>interface checks</p>
<p>…</p>
</li>
</ul>
<h2 id="Embedding"><a href="#Embedding" class="headerlink" title="Embedding"></a>Embedding</h2><p>In GO language there is no typical, type-driver notion of subclassing, while it have the ability to borrow the implementation by <code>embedding</code> types with interface or struct.</p>
<h3 id="embedding-in-interface"><a href="#embedding-in-interface" class="headerlink" title="embedding in interface"></a>embedding in interface</h3><p>Interface embedding is simple.For example, we define two basic interface <code>Reader</code> <code>Writer</code> ,and embedding them into complex interface <code>ReadWriter</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// embedding in interface</span></span><br><span class="line"><span class="comment">// ReadWriter is the interface that combines the Reader and Writer interfaces.</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This says just what it looks like: A <code>ReadWriter</code> can do what a <code>Reader</code> does <em>and</em> what a <code>Writer</code> does; it is a union of the embedded interfaces. Only interfaces can be embedded within interfaces.</p>
<h3 id="embedding-in-struct"><a href="#embedding-in-struct" class="headerlink" title="embedding in struct"></a>embedding in struct</h3><p> Embedding in struct is far-reaching than interface. Two steps in struct way:</p>
<ol>
<li><p>struct definition with embedding</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    reader *Reader</span><br><span class="line">    writer *Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>provide forwarding methods</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *ReadWriter)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rw.reader.Read(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="difference-from-subclassing"><a href="#difference-from-subclassing" class="headerlink" title="difference from subclassing"></a>difference from subclassing</h3></li>
</ol>
<p>There’s an important way in which embedding differs from subclassing. When we embed a type, the methods of that type become methods of the outer type, but when they are invoked the receiver of the method is the inner type, not the outer one. In our example, when the <code>Read</code> method of a <code>bufio.ReadWriter</code> is invoked, it has exactly the same effect as the forwarding method written out above; the receiver is the <code>reader</code> field of the <code>ReadWriter</code>, not the <code>ReadWriter</code> itself.</p>
<h2 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h2><h2 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h2><h2 id="A-web-server"><a href="#A-web-server" class="headerlink" title="A web server"></a>A web server</h2>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划_背包问题_初始化与遍历顺序的讨论</title>
    <url>/2022/05/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/</url>
    <content><![CDATA[<ul>
<li>参考: <a href="https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html">代码随想录</a></li>
</ul>
<a id="more"></a>

<p>最近在跟着 <a href="https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html">代码随想录</a> 刷了两遍背包问题, 初步掌握了 <strong>01背包</strong> 与 <strong>完全背包</strong> 问题模型, 并且已编写相关理论总结; 然而我对于动态规划的初始了解中仅重点关注了: 状态定义, 状态转移方程, 边界问题; 近期做题发现, 初始化与遍历顺序亦对问题有着关键性的形象; 这里对初始化与遍历顺序进行简单的讨论;</p>
<h2 id="引子-背包问题该如何定义"><a href="#引子-背包问题该如何定义" class="headerlink" title="引子: 背包问题该如何定义"></a>引子: 背包问题该如何定义</h2><p>背包问题,可以分为<strong>纯背包问题</strong>与<strong>背包衍生问题</strong>; 不同的问题定义,自然会存在不同的问题模型; </p>
<p>对于<strong>纯背包问题</strong> 就是可以转换符合 <strong>01背包</strong>, <strong>完全背包</strong>, <strong>多重背包</strong>等, 其问题定义往往是这样的: </p>
<ul>
<li>01背包: 有<code>N</code>件物品,和一个容量(衡量单位为重量)为<code>W</code> 的背包, 物品<code>i</code> 的重量为 <code>weight[i]</code>, 价值为 <code>value[i]</code>. 每件物品<strong>仅能够装一次</strong>, 问这个<strong>背包可以装的最大价值是多少</strong>?</li>
<li>完全背包: 有<code>N</code>件物品,和一个容量(衡量单位为重量)为<code>W</code> 的背包, 物品<code>i</code> 的重量为 <code>weight[i]</code>, 价值为 <code>value[i]</code>. 每件物品<strong>数量无限制</strong>, 问这个<strong>背包可以装的最大价值是多少</strong>?</li>
<li>多重背包: 有<code>N</code>件物品,和一个容量(衡量单位为重量)为<code>W</code> 的背包, 物品<code>i</code> 的重量为 <code>weight[i]</code>, 价值为 <code>value[i]</code>. 每件物品<strong>数量有自己的限制</strong>, 问这个<strong>背包可以装的最大价值是多少</strong>?</li>
</ul>
<p>对于<strong>背包衍生问题</strong>, 其本质上也是背包问题, 只是问题的定义略有不同, 比如:</p>
<ul>
<li>01背包衍生: 有<code>N</code>件物品,和一个容量(衡量单位为重量)为<code>W</code> 的背包, 物品<code>i</code> 的重量为 <code>weight[i]</code>, 价值为 <code>value[i]</code>. 每件物品<strong>仅能够装一次</strong>, 问这个<strong>背包恰好装满</strong>的最大价值?</li>
<li>01背包衍生: 有<code>N</code>件物品,和一个容量(衡量单位为重量)为<code>W</code> 的背包, 物品<code>i</code> 的重量为 <code>weight[i]</code>, 价值为 <code>value[i]</code>. 每件物品<strong>仅能够装一次</strong>, 问这个<strong>背包恰好装满</strong>的组合数?</li>
<li>完全背包衍生: 有<code>N</code>件物品,和一个容量(衡量单位为重量)为<code>W</code> 的背包, 物品<code>i</code> 的重量为 <code>weight[i]</code>, 价值为 <code>value[i]</code>. 每件物品<strong>数量无限制</strong>, 问这个<strong>背包恰好装满</strong>的最大价值?</li>
<li>完全背包衍生: 有<code>N</code>件物品,和一个容量(衡量单位为重量)为<code>W</code> 的背包, 物品<code>i</code> 的重量为 <code>weight[i]</code>, 价值为 <code>value[i]</code>. 每件物品<strong>数量无限制</strong>, 问这个<strong>背包恰好装满</strong>的组合数?</li>
<li>完全背包衍生: 有<code>N</code>件物品,和一个容量(衡量单位为重量)为<code>W</code> 的背包, 物品<code>i</code> 的重量为 <code>weight[i]</code>, 价值为 <code>value[i]</code>. 每件物品<strong>数量无限制</strong>, 问这个<strong>背包恰好装满</strong>的排列数?</li>
<li>… 还可以很多很多</li>
</ul>
<p>对于<strong>背包衍生问题</strong>在实际的题目中是更常出现的事情, 归根到底其考察的是对于动态规划中五个关键点的理解到不到位:分别是状态定义, 状态转移方程, 边界定义, 初始化, 遍历顺序; 而对于状态定义, 状态转移方程, 边界定义 这三点不在本篇的讨论范围; 而初始化与遍历顺序会因问题不同, 有所限制; 瞎猫碰到死耗子是经常的事儿, 这导致动态规划算法中我个人一致不重视其逻辑理解, 这也是本篇的初衷;</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化问题指的是除了边界位置外的 <code>dp</code> 数组的初始化问题;</p>
<p>初始化问题就我当前刷过的题目而言, 并没有一个实际的标准; 其往往需要需要根据<strong>状态定义</strong>, <strong>状态转移方程</strong> 而定, 而状态的定义又与题目中问题的定义息息相关; 这里举两个例子感受一下:</p>
<ul>
<li><a href="https://leetcode.cn/problems/combination-sum-iv/">目标排列数</a> : 定义为<code>dp[j]</code> 和为 <code>j</code> 的排列数; 状态转移为: <code>dp[j] += dp[j-numsp[i]]</code>; 初始化 <code>0</code> 就是合适的;</li>
<li><a href="https://leetcode.cn/problems/coin-change/">最少零钱和</a>: 定义为 <code>dp[j]</code> 表示组成<code>j</code> 面额的组合中数量最少的值; 状态转移为: <code>dp[j] = min(dp[j], dp[j-coin] + 1)</code>; 初始化为最大值是合适的 <code>(1 &lt;&lt; 32) - 1</code>;</li>
</ul>
<p>无需特定去查看当前题目描述, </p>
<ul>
<li>关于<strong>状态定义</strong>对初始化的影响: <ul>
<li>如果是恰好背满的情况, 那么应当初始化为<code>-∞</code>, 比较合适. 这说明在初始时, dp[1] 是不合法的状态,应当为<code>-∞</code>;</li>
<li>如果是尽可能的装满, 那么应当初始化为<code>0</code>, 因为<code>dp[1]</code>初始时还没有价值, 也是合法的;</li>
</ul>
</li>
<li>关于<strong>状态转移</strong>对初始化的影响:<ul>
<li>如果状态转移方程中包括 <code>min, max</code> 等标识符, 那么应保证<code>min, max</code> 时可以有效取值. 比如<code>min</code> 情况, 取<code>0</code> 是不合适的,因为<code>0</code>已经时小值了,这隐藏了真实的逻辑结果; <code>max</code> 同理; 这并没有定论, 只是需要符合题意;</li>
</ul>
</li>
</ul>
<h2 id="遍历顺序"><a href="#遍历顺序" class="headerlink" title="遍历顺序"></a>遍历顺序</h2><p>对于背包问题遍历顺序可以分为两个点进行讨论: 1.正序逆序问题; 2.先物品,先背包问题;</p>
<p><strong>正序逆序问题:</strong></p>
<p>正序与逆序本身没有问题, 问题在于其与<strong>状态转移方程</strong>是嘻嘻相关的; 一般的状态转移方程是与<strong>左上方</strong>的状态有关, 我以此为例讨论, 例如<code>01背包</code> 的状态转移方程为 <code>dp[j] = max(dp[j], dp[j-weight[i]] + value[i])</code>, 其仅与上方与左前方的状态有关;</p>
<ul>
<li><p>如果采用正序遍历: 那就是无限取值, 适用于<strong>完全背包</strong>问题;</p>
<blockquote>
<p>这是因为在遍历过程中, 状态转移方程仅考虑到当前位置能否取值, 没有记录当前物品是否已经取过值了;而前方的数组是已经经历过取值问题了, 所以是无限取值问题;这也就是一维滚动数组的问题;</p>
</blockquote>
</li>
<li><p>如果采用逆序遍历: 那就是仅取值一次, 适用于<strong>01背包</strong>问题;</p>
<blockquote>
<p>这在遍历过程中,从后向前遍历, 对于当前位置而言,前方数组还没有判定过, 当前获得物品就是第一次获得;这就是背包问题;</p>
</blockquote>
</li>
</ul>
<p><strong>先背包先物品问题</strong></p>
<p>对于背包问题,存在两种遍历顺序: 先遍历物品, 再遍历背包; 或者 先遍历背包再遍历物品; </p>
<p>他们的差别点在于:</p>
<ul>
<li><p>先遍历物品再遍历背包: 这是一种<strong>组合</strong>问题, 如果题目中要求获得组合数, 那么必须如此遍历;</p>
<p>至于为何是组合问题呢? 因为优先遍历物品, 也就是说最终结果一定是 <code>&#123;物品1, 物品2, 物品3&#125;</code>的结果;</p>
</li>
<li><p>先遍历背包再遍历物品: 这是一种<strong>排列</strong>问题;, 如果题目中要求获得排列数, 那么必须如此遍历;</p>
<p>至于为何是排列问题呢? 因为优先遍历背包, 也就是说最终结果是 <code>&#123;物品1, 物品2, 物品3&#125;</code>, <code>&#123;物品3, 物品2, 物品1&#125;</code>等的结果;对于每一个背包位置均经历了<code>物品1, 物品2, 物品3</code> 的多次洗礼;</p>
</li>
</ul>
<p>对于<code>01背包</code>仅能够优先遍历物品;<br>对于<code>纯完全背包</code>问题如何遍历是一样的;<br>对于<code>组合型完全背包</code>: 仅能够优先遍历物品;<br>对于<code>排列型完全背包</code>: 仅能够优先遍历背包;</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>GO_Learning_TDD_introduction</title>
    <url>/2022/06/28/GO-Learning-TDD-introduction/</url>
    <content><![CDATA[<h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p><strong>TDD</strong> is the abbreviation of <strong><a href="https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/hello-world">Test Drive Development</a></strong>. In my view, that is a kind of develop procedure or develop  concept. From the point of develop procedure, TDD can be divided into a circle:</p>
<a id="more"></a>

<ul>
<li>Write a test</li>
<li>Make the complie pass</li>
<li>Run the test, see that it fails and check the error message is meaningful</li>
<li>Write enough code to make the test pass</li>
<li>Refactor</li>
</ul>
<p>The circle aboved can be called <strong>code flow</strong>. In long term, that will help developer.</p>
<h3 id="Goodness"><a href="#Goodness" class="headerlink" title="Goodness"></a>Goodness</h3><ul>
<li>Make sure code module is self-contained;</li>
<li>Test first make sure you have a clear goal</li>
</ul>
<h3 id="Badness"><a href="#Badness" class="headerlink" title="Badness"></a>Badness</h3><ul>
<li>Tedious</li>
</ul>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p><a href="https://github.com/quii/learn-go-with-tests/tree/main/hello-world">Hello World</a> is a good start to understand TDD producre. </p>
<h3 id="Write-a-Simple-Test"><a href="#Write-a-Simple-Test" class="headerlink" title="Write a Simple Test"></a>Write a Simple Test</h3><p>Implement the simplest feature. </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHello</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    got := Hello()</span><br><span class="line">    want := <span class="string">&quot;Hello, world&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> got != want &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;got %q want %q&quot;</span>, got, want)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Implement-Simple-Code-Feature"><a href="#Implement-Simple-Code-Feature" class="headerlink" title="Implement Simple Code Feature"></a>Implement Simple Code Feature</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(Hello())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Run-The-Test"><a href="#Run-The-Test" class="headerlink" title="Run The Test"></a>Run The Test</h3><p>This part we need to check some points :</p>
<ul>
<li><em>Write a failing test and see it fail</em> so we know we have written a <em>relevant</em> test for our requirements and seen that it produces an <em>easy to understand description of the failure</em></li>
<li>Writing the smallest amount of code to make it pass so we know we have working software</li>
<li><em>Then</em> refactor, backed with the safety of our tests to ensure we have well-crafted code that is easy to work with</li>
</ul>
<p>Enrich the test and go back to the first step;</p>
<h4 id="More-Complate-Test"><a href="#More-Complate-Test" class="headerlink" title="More Complate Test"></a>More Complate Test</h4><p>For Hello World , We want infer Some Name , not just “world”,like “Hello QingZhi”. So we chang the Test file, like this:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHello</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    assertCorrectMessage := <span class="function"><span class="keyword">func</span><span class="params">(t testing.TB, got, want <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        t.Helper()</span><br><span class="line">        <span class="keyword">if</span> got != want &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;got %q want %q&quot;</span>, got, want)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.Run(<span class="string">&quot;saying hello to people&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        got := Hello(<span class="string">&quot;Chris&quot;</span>)</span><br><span class="line">        want := <span class="string">&quot;Hello, Chris&quot;</span></span><br><span class="line">        assertCorrectMessage(t, got, want)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    t.Run(<span class="string">&quot;empty string defaults to &#x27;World&#x27;&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        got := Hello(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        want := <span class="string">&quot;Hello, World&quot;</span></span><br><span class="line">        assertCorrectMessage(t, got, want)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="More-Complate-Code"><a href="#More-Complate-Code" class="headerlink" title="More Complate Code"></a>More Complate Code</h4><p>Not much word , just look at the feature code:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> englishHelloPrefix = <span class="string">&quot;Hello, &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        name = <span class="string">&quot;World&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> englishHelloPrefix + name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Run-the-test-again"><a href="#Run-the-test-again" class="headerlink" title="Run the test again"></a>Run the test again</h4><p>Check the feature code is suitable with test goal. And Enrich feature again, like add other country language :Chinese “你好, QingZhi”.</p>
<h5 id="Complate-Test"><a href="#Complate-Test" class="headerlink" title="Complate Test"></a>Complate Test</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHello</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	assertCorrectMessage := <span class="function"><span class="keyword">func</span><span class="params">(t testing.TB, got, want <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">		t.Helper()</span><br><span class="line">		<span class="keyword">if</span> got != want &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;got %q want %q&quot;</span>, got, want)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t.Run(<span class="string">&quot;to a person&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">		got := Hello(<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">		want := <span class="string">&quot;Hello, Chris&quot;</span></span><br><span class="line">		assertCorrectMessage(t, got, want)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	t.Run(<span class="string">&quot;empty string&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">		got := Hello(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">		want := <span class="string">&quot;Hello, World&quot;</span></span><br><span class="line">		assertCorrectMessage(t, got, want)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	t.Run(<span class="string">&quot;in Spanish&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">		got := Hello(<span class="string">&quot;Elodie&quot;</span>, spanish)</span><br><span class="line">		want := <span class="string">&quot;Hola, Elodie&quot;</span></span><br><span class="line">		assertCorrectMessage(t, got, want)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	t.Run(<span class="string">&quot;in French&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">		got := Hello(<span class="string">&quot;Lauren&quot;</span>, french)</span><br><span class="line">		want := <span class="string">&quot;Bonjour, Lauren&quot;</span></span><br><span class="line">		assertCorrectMessage(t, got, want)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Complate-Code"><a href="#Complate-Code" class="headerlink" title="Complate Code"></a>Complate Code</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> spanish = <span class="string">&quot;Spanish&quot;</span></span><br><span class="line"><span class="keyword">const</span> french = <span class="string">&quot;French&quot;</span></span><br><span class="line"><span class="keyword">const</span> englishHelloPrefix = <span class="string">&quot;Hello, &quot;</span></span><br><span class="line"><span class="keyword">const</span> spanishHelloPrefix = <span class="string">&quot;Hola, &quot;</span></span><br><span class="line"><span class="keyword">const</span> frenchHelloPrefix = <span class="string">&quot;Bonjour, &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello returns a personalised greeting in a given language.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(name <span class="keyword">string</span>, language <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		name = <span class="string">&quot;World&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> greetingPrefix(language) + name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greetingPrefix</span><span class="params">(language <span class="keyword">string</span>)</span> <span class="params">(prefix <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> language &#123;</span><br><span class="line">	<span class="keyword">case</span> french:</span><br><span class="line">		prefix = frenchHelloPrefix</span><br><span class="line">	<span class="keyword">case</span> spanish:</span><br><span class="line">		prefix = spanishHelloPrefix</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		prefix = englishHelloPrefix</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(Hello(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Run-the-Final-Test"><a href="#Run-the-Final-Test" class="headerlink" title="Run the Final Test"></a>Run the Final Test</h5><p>Final part , get the GREAT  Hello World.</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO_Learning_HOW_TO_SET_UP_GO_PROJECT</title>
    <url>/2022/06/28/GO-Learning-HOW-TO-SET-UP-GO-PROJECT/</url>
    <content><![CDATA[<p><a href="https://www.topgoer.com/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E9%85%8D%E7%BD%AEgopath.html">GO Chinese Docs</a>, <a href="https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/install-go">TDD</a></p>
<a id="more"></a>

<h2 id="Old-Style-GOPATH"><a href="#Old-Style-GOPATH" class="headerlink" title="Old Style: GOPATH"></a>Old Style: GOPATH</h2><h3 id="Project-item-in-GO"><a href="#Project-item-in-GO" class="headerlink" title="Project item in GO"></a>Project item in GO</h3><ul>
<li><code>GOPATH </code> is a kind of environment variable, that means the path of GO project;<ul>
<li><code>GOPATH</code> is recommended as only one in one system;</li>
<li><code>src, pkg, bin</code> is recommend as the subdirectory as <code>GOPATH</code>;<ul>
<li><code>src</code>: store the source code of GO project; When we use version control tools like <code>git , svn etc</code> ,what only need is control the file in <code>GOPATH\src</code> directory;</li>
<li><code>pkg</code>: store the cache file;</li>
<li><code>bin</code>: store the executable file;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="GO-project-structure"><a href="#GO-project-structure" class="headerlink" title="GO project structure"></a>GO project structure</h3><h4 id="Personal"><a href="#Personal" class="headerlink" title="Personal"></a>Personal</h4><p><img src="https://i.loli.net/2021/09/14/K28WAopxMuNrDbf.png" alt="image-20210914004010297"></p>
<p>In go language, package is the unit of caller. While different developer may meet with naming conflict, if they both develop <code>someName</code> package with the same go structure. Using <code>github</code> info is recommend as personal go structure, like :</p>
<p><img src="https://i.loli.net/2021/09/14/9GfAg5LSWeEod73.png" alt="image-20210914004028032"></p>
<p>This way we could get others package with confidence, for example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get gihub.com&#x2F;GuardingDog&#x2F;GoLearning</span><br></pre></td></tr></table></figure>
<h4 id="company"><a href="#company" class="headerlink" title="company"></a>company</h4><p><img src="https://i.loli.net/2021/09/14/EQlaUPWYhxGHo5z.png" alt="image-20210914004056239"></p>
<h2 id="New-Fashion-Modules"><a href="#New-Fashion-Modules" class="headerlink" title="New Fashion: Modules"></a>New Fashion: Modules</h2><p>Go 1.11 introduced <a href="https://github.com/golang/go/wiki/Modules">Modules</a>. This approach is the default build mode since Go 1.16, therefore the use of <code>GOPATH</code> is not recommended.</p>
<p>Modules aim to solve problems related to dependency management, version selection and reproducible builds; they also enable users to run Go code outside of <code>GOPATH</code>.</p>
<p>Using Modules is pretty straightforward. Select any directory outside <code>GOPATH</code> as the root of your project, and create a new module with the <code>go mod init</code> command.</p>
<p>A <code>go.mod</code> file will be generated, containing the module path, a Go version, and its dependency requirements, which are the other modules needed for a successful build.</p>
<p>If no <code>&lt;modulepath&gt;</code> is specified, <code>go mod init</code> will try to guess the module path from the directory structure, but it can also be overrided, by supplying an argument.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir my-project</span><br><span class="line">cd my-project</span><br><span class="line">go mod init &lt;modulepath&gt;</span><br></pre></td></tr></table></figure>
<p>A <code>go.mod</code> file could look like this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module cmd</span><br><span class="line"></span><br><span class="line">go 1.16</span><br></pre></td></tr></table></figure>
<p>The built-in documentation provides an overview of all available <code>go mod</code> commands.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go help mod</span><br><span class="line">go help mod init</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO_Learning_Fundamental_Array_Slice_Map</title>
    <url>/2022/06/29/GO-Learning-Fundamental-Array-Slice-Map/</url>
    <content><![CDATA[<ul>
<li>Reference: <a href="https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/arrays-and-slices">TDD</a>, <a href="https://golang.google.cn/doc/effective_go#arrays">Effective Go</a>, <a href="https://www.topgoer.com/go%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84Array.html">Go Chinese Docs</a>, <a href="https://gobyexample.com/arrays">Go By Example</a></li>
</ul>
<a id="more"></a>

<h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p>Array is primarily as the building block for Slice.</p>
<p><strong>Features:</strong></p>
<ul>
<li>Arrays are values. Assigning one array to another copies all the elements.</li>
<li>In particular, if you pass an array to a function, it will receive a <em>copy</em> of the array, not a pointer to it.</li>
<li>The size of an array is part of its type. The types <code>[10]int</code> and <code>[20]int</code> are distinct.</li>
</ul>
<p>The value property can be useful but also expensive; if you want C-like behavior and efficiency, you can pass a pointer to the array.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func Sum(a *[3]float64) (sum float64) &#123;</span><br><span class="line">    for _, v :&#x3D; range *a &#123;</span><br><span class="line">        sum +&#x3D; v</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array :&#x3D; [...]float64&#123;7.0, 8.5, 9.1&#125;</span><br><span class="line">x :&#x3D; Sum(&amp;array)  &#x2F;&#x2F; Note the explicit address-of operator</span><br></pre></td></tr></table></figure>
<p>But even this style isn’t idiomatic Go. Use slices instead.</p>
<h4 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h4><p>Slice wrap arrays to give a more general, powerful and convinent interface to sequence of data. Most array programming in GO is done with slices rather than simple arrays.</p>
<p><strong>Features:</strong></p>
<ul>
<li>Slices hold the references to an underlaying array<ul>
<li>if you assign one slice to another, both refer to the same array.</li>
<li>If a functions take Slice argument, changes it makes to the slices elements will be visible to the caller.</li>
</ul>
</li>
</ul>
<p>The length of a slice may be changed as long as it still fits within the limits of the underlying array; just assign it to a slice of itself. The <em>capacity</em> of a slice, accessible by the built-in function <code>cap</code>, reports the maximum length the slice may assume. Here is a function to append data to a slice. If the data exceeds the capacity, the slice is reallocated. The resulting slice is returned. The function uses the fact that <code>len</code> and <code>cap</code> are legal when applied to the <code>nil</code> slice, and return 0.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func Append(slice, data []byte) []byte &#123;</span><br><span class="line">    l :&#x3D; len(slice)</span><br><span class="line">    if l + len(data) &gt; cap(slice) &#123;  &#x2F;&#x2F; reallocate</span><br><span class="line">        &#x2F;&#x2F; Allocate double what&#39;s needed, for future growth.</span><br><span class="line">        newSlice :&#x3D; make([]byte, (l+len(data))*2)</span><br><span class="line">        &#x2F;&#x2F; The copy function is predeclared and works for any slice type.</span><br><span class="line">        copy(newSlice, slice)</span><br><span class="line">        slice &#x3D; newSlice</span><br><span class="line">    &#125;</span><br><span class="line">    slice &#x3D; slice[0:l+len(data)]</span><br><span class="line">    copy(slice[l:], data)</span><br><span class="line">    return slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We must return the slice afterwards because, although <code>Append</code> can modify the elements of <code>slice</code>, the slice itself (the run-time data structure holding the pointer, length, and capacity) is passed by value.</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><strong>What Map ?</strong></p>
<p>The key can be of any type for which the equality operator is defined, such as integers, floating point and complex numbers, strings, pointers, interfaces (as long as the dynamic type supports equality), structs and arrays. Slices cannot be used as map keys, because equality is not defined on them. Like slices, maps hold references to an underlying data structure. If you pass a map to a function that changes the contents of the map, the changes will be visible in the caller.</p>
<p><strong>initialize Map</strong></p>
<p>Maps can be constructed using the usual composite literal syntax with colon-separated key-value pairs, so it’s easy to build them during initialization.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timeZone = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;UTC&quot;</span>:  <span class="number">0</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">    <span class="string">&quot;EST&quot;</span>: <span class="number">-5</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">    <span class="string">&quot;CST&quot;</span>: <span class="number">-6</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">    <span class="string">&quot;MST&quot;</span>: <span class="number">-7</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">    <span class="string">&quot;PST&quot;</span>: <span class="number">-8</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Features</strong></p>
<ul>
<li><p><strong>get value:</strong> simliar with slice</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">offset := timeZone[<span class="string">&quot;EST&quot;</span>]</span><br></pre></td></tr></table></figure></li>
<li><p><strong>apply the key which not in map</strong> : return zeros of value type</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">attended := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>&#123;</span><br><span class="line">    <span class="string">&quot;Ann&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;Joe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> attended[person] &#123; <span class="comment">// will be false if person is not in the map</span></span><br><span class="line">    fmt.Println(person, <span class="string">&quot;was at the meeting&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>two var is accept : <strong>get gistinguish a missing entry from zeros value</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> seconds <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">seconds, ok = timeZone[tz]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">offset</span><span class="params">(tz <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> seconds, ok := timeZone[tz]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> seconds</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">&quot;unknown time zone:&quot;</span>, tz)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Omit value:</strong> <code>_</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, present := timeZone[tz]</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Delete map entry</strong>:<code>delete</code> function</p>
<p>SAFE function even if the key is already absent from the map.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(timeZone, <span class="string">&quot;PDT&quot;</span>)  <span class="comment">// Now on Standard Time</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO_Learning_Fundamental_Concurrency_Goroutine</title>
    <url>/2022/06/29/GO-Learning-Fundamental-Concurrency-Goroutine/</url>
    <content><![CDATA[<ul>
<li>Refs:  <a href="https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/structs-methods-and-interfaces">TDD</a>, <a href="https://www.topgoer.com/go%E5%9F%BA%E7%A1%80/%E7%BB%93%E6%9E%84%E4%BD%93.html">Go Chinese Docs</a>, <a href="https://golang.iswbm.com/c04/c04_01.html">Go Chinese Docs2</a></li>
</ul>
<a id="more"></a>

<p>Put GO in front of target function is the only way to tell Go complier “start a new goroutine here”.</p>
<h2 id="Concurrency-Definition"><a href="#Concurrency-Definition" class="headerlink" title="Concurrency Definition"></a>Concurrency Definition</h2><p>The GO language naturally supports multiple concurrency. Concurrency means <strong>Having More Than One Thing In Process</strong>; </p>
<h2 id="Goroutine-Definition"><a href="#Goroutine-Definition" class="headerlink" title="Goroutine Definition"></a>Goroutine Definition</h2><p>An operation that does not block in GO will run in a separate process called a <strong>goroutine</strong>. What’s <strong>goroutine</strong>?</p>
<ul>
<li>Goroutine is the way in Go language to reach Concurrency level for programmer.</li>
</ul>
<p>Similar concepts: <strong>Process, Threads, Coroutines</strong>; </p>
<ul>
<li>Process: the basic unit of resource allocation;</li>
<li>Threads: the basic unit of program execution, like CPU ;</li>
<li>Coroutine: lightweight threads that switch more quickly;</li>
</ul>
<p>I don’t want to explain the detail difference between similar concepts, that has been finished with others; What we should know is <strong>Goroutine</strong> is most similar with <strong>Coroutine</strong>, while they are different with switcher;</p>
<ul>
<li><strong>Coroutine</strong>: the switch with other <strong>coroutine</strong> is operate by <strong>operation system level</strong>, which would <strong>cost more</strong> execution resource;</li>
<li><strong>Goroutine</strong>: the switch with other <strong>goroutine</strong> is operate by <strong>user level</strong>, which would <strong>cost less</strong> execution resource;</li>
</ul>
<h2 id="Usage-Goroutine"><a href="#Usage-Goroutine" class="headerlink" title="Usage Goroutine"></a>Usage Goroutine</h2><p>In go language, keyword <strong>go</strong> means a goroutine; just put the keyword go in front of target function; The Go complier will recognize it as goroutine;  For example, there is a function which used to check URL status, called WebsiteChecker:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WebsiteChecker</span> <span class="params">(url <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		response, err := http.Head(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> response.StatusCode != http.StatusOK &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">url := <span class="string">&quot;http://www.facebook.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.Use WebsiteChecker with no goroutine</span></span><br><span class="line"><span class="comment">// do somthing before</span></span><br><span class="line">WebsiteChecker(url)</span><br><span class="line"><span class="comment">// do somethind after</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.Use WebsiteChecker with goroutine</span></span><br><span class="line"><span class="comment">// do somthing before</span></span><br><span class="line"><span class="keyword">go</span> WebsiteChecker(url)</span><br><span class="line"><span class="comment">// do somethind after</span></span><br></pre></td></tr></table></figure>
<p><strong>Tips:</strong> the main function is (default) a goroutine; It is the parent goroutine of other goroutine in this process; If the parent goroutine is finished (killed or other finished states), the child goroutine will finished immediately; If child go routine is finished, the parent goroutine doesn’t matter;</p>
<h3 id="WebsiteChecker-Case"><a href="#WebsiteChecker-Case" class="headerlink" title="WebsiteChecker Case"></a>WebsiteChecker Case</h3><p>This case is form <a href="https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/concurrency">TDD tutorial</a>. In this part, i just compare the performance after goroutine.</p>
<h4 id="Basic-Function-Implement-Website-Checker"><a href="#Basic-Function-Implement-Website-Checker" class="headerlink" title="Basic Function Implement : Website Checker:"></a>Basic Function Implement : Website Checker:</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckWebsite</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	response, err := http.Head(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> response.StatusCode != http.StatusOK &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Use-Website-Checker-with-no-goroutine"><a href="#Use-Website-Checker-with-no-goroutine" class="headerlink" title="Use Website Checker with no goroutine:"></a>Use Website Checker with no goroutine:</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WebsiteChecker <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckWebsites</span><span class="params">(wc WebsiteChecker, urls []<span class="keyword">string</span>)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">bool</span></span> &#123;</span><br><span class="line">	results := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">		results[url] = wc(url)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Use-Website-Checker-with-goroutine"><a href="#Use-Website-Checker-with-goroutine" class="headerlink" title="Use Website Checker with goroutine"></a>Use Website Checker with goroutine</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WebsiteChecker <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckWebsites</span><span class="params">(wc WebsiteChecker, urls []<span class="keyword">string</span>)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">bool</span></span> &#123;</span><br><span class="line">	results := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(u <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">			results[u] = wc(u)</span><br><span class="line">		&#125;(url)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	<span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Compare-with-test"><a href="#Compare-with-test" class="headerlink" title="Compare with test"></a>Compare with test</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slowWebsiteChecker</span><span class="params">(_ <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">20</span> * time.Millisecond)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCheckWebsites</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	urls := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(urls); i++ &#123;</span><br><span class="line">		urls[i] = <span class="string">&quot;a url&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		CheckWebsites(slowWebsiteChecker, urls)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go test -bench&#x3D;.</span><br><span class="line">&#x2F;&#x2F; before goroutine</span><br><span class="line">goos: linux</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com&#x2F;GuardingDog&#x2F;tdd&#x2F;concurrency&#x2F;v1</span><br><span class="line">cpu: Intel(R) Xeon(R) Platinum 8361HC CPU @ 2.60GHz</span><br><span class="line">BenchmarkCheckWebsites-2               1        2013483386 ns&#x2F;op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com&#x2F;GuardingDog&#x2F;tdd&#x2F;concurrency&#x2F;v1       2.018s</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; after goroutine</span><br><span class="line">goos: linux</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com&#x2F;GuardingDog&#x2F;tdd&#x2F;concurrency&#x2F;v3</span><br><span class="line">cpu: Intel(R) Xeon(R) Platinum 8361HC CPU @ 2.60GHz</span><br><span class="line">BenchmarkCheckWebsites-2              57          20275547 ns&#x2F;op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com&#x2F;GuardingDog&#x2F;tdd&#x2F;concurrency&#x2F;v3       1.182s</span><br></pre></td></tr></table></figure>
<p>From above <code>CLI</code>, before goroutine the process cost <code>2013483386 ns ~ 2 s</code> each loop; after goroutine the process cost <code>20275547 ns ~ 20 ms ~ 0.02s</code> each loop; A hundred times better performance;</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO_Learning_Fundamental_Data_Structure</title>
    <url>/2022/06/29/GO-Learning-Fundamental-Data-Structure/</url>
    <content><![CDATA[<ul>
<li>Reference: <a href="https://www.topgoer.com/go%E5%9F%BA%E7%A1%80/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B.html">Go Chinese Docs</a>, <a href="https://mojotv.cn/tutorial/golang-data-type">Bolg_1</a>, <a href="https://www.cnblogs.com/52php/p/6727082.html#:~:text=%E5%9C%A8%20Go%20%E8%AF%AD%E8%A8%80%E4%B8%AD%EF%BC%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%9C%89%20%E5%88%87%E7%89%87%20%28slice%29%20%E3%80%81%20%E5%AD%97%E5%85%B8%20%28map%29,%E5%87%BD%E6%95%B0%20%28func%29%20%E4%BB%A5%E5%8F%8A%20%E9%80%9A%E9%81%93%20%28chan%29%20%E3%80%82.%20%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%89%80%E4%BB%A5%E5%8F%AF%E4%BB%A5%E5%BC%95%E7%94%A8%EF%BC%8C%E6%98%AF%E5%9B%A0%E4%B8%BA%E6%88%91%E4%BB%AC%E5%88%9B%E5%BB%BA%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%8C%E5%85%B6%E5%AE%9E%E6%98%AF%E4%B8%80%E4%B8%AA%E6%A0%87%E5%A4%B4%E5%80%BC%EF%BC%8C%E6%A0%87%E5%A4%B4%E5%80%BC%E9%87%8C%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%EF%BC%8C%E6%8C%87%E5%90%91%E5%BA%95%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%BD%93%E6%88%91%E4%BB%AC%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BC%A0%E9%80%92%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%97%B6%EF%BC%8C%E5%85%B6%E5%AE%9E%E4%BC%A0%E9%80%92%E7%9A%84%E6%98%AF%E8%BF%99%E4%B8%AA%E6%A0%87%E5%A4%B4%E5%80%BC%E7%9A%84%E5%89%AF%E6%9C%AC%EF%BC%8C%E5%AE%83%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%B9%B6%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%A4%8D%E5%88%B6%E4%BC%A0%E9%80%92%EF%BC%8C%E8%BF%99%E4%B9%9F%E6%98%AF%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E9%80%92%E9%AB%98%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0%E3%80%82.%20%E6%9C%AC%E8%B4%A8%E4%B8%8A%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%90%86%E8%A7%A3%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E9%83%BD%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%8C%E5%8F%AA%E4%B8%8D%E8%BF%87%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E9%80%92%E7%9A%84%E6%98%AF%E4%B8%80%E4%B8%AA%E6%8C%87%E5%90%91%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%8C%E6%89%80%E4%BB%A5%E6%88%91%E4%BB%AC%E5%9C%A8%E6%93%8D%E4%BD%9C%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E5%85%B1%E4%BA%AB%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%9A%84%E5%80%BC%EF%BC%8C%E8%BF%9B%E8%80%8C%E5%BD%B1%E5%93%8D%E5%88%B0%E6%89%80%E6%9C%89%E5%BC%95%E7%94%A8%E5%88%B0%E8%BF%99%E4%B8%AA%E5%85%B1%E4%BA%AB%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E9%87%8F%E3%80%82.">Bolg_2</a> <a href="https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/structs-methods-and-interfaces">TDD</a></li>
</ul>
<a id="more"></a>

<h3 id="Fundamental-Type"><a href="#Fundamental-Type" class="headerlink" title="Fundamental Type"></a>Fundamental Type</h3><p>Go language contain Seven types of fundamental data structure: <strong>Boolean, Integer, Float, Complex Number, Character, String, Error</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Actual Type</th>
<th>Length(byte)</th>
<th>Default Value</th>
<th>Remark</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
<td>bool</td>
<td>1</td>
<td>false</td>
<td></td>
</tr>
<tr>
<td>Integer</td>
<td>int,uint</td>
<td>4 or 8</td>
<td>0</td>
<td>32 bits or 64 bits</td>
</tr>
<tr>
<td>Integer</td>
<td>int8, uint8</td>
<td>1</td>
<td>0</td>
<td>-128<del>127, 0</del>255,  byte is the alias of uint8</td>
</tr>
<tr>
<td>Integer</td>
<td>int16, uint16</td>
<td>2</td>
<td>0</td>
<td>-32768 ~ 32767, 0 ~ 65535</td>
</tr>
<tr>
<td>Integer</td>
<td>int32, uint32</td>
<td>4</td>
<td>0</td>
<td>-2.1 billion ~ 2.1 billion, 0 ~ 4.2 billion , rune is the alias of int32</td>
</tr>
<tr>
<td>Integer</td>
<td>int64, uint64</td>
<td>8</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>Float</td>
<td>float32</td>
<td>4</td>
<td>0.0</td>
<td></td>
</tr>
<tr>
<td>Float</td>
<td>float64</td>
<td>8</td>
<td>0.0</td>
<td></td>
</tr>
<tr>
<td>Complex</td>
<td>complex64</td>
<td>8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Complex</td>
<td>complex128</td>
<td>16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Character</td>
<td>byte</td>
<td>1</td>
<td>0</td>
<td>byte is the same as uint8</td>
</tr>
<tr>
<td>Character</td>
<td>rune</td>
<td>4</td>
<td>0</td>
<td>Unicode Code Point, the same as int32</td>
</tr>
<tr>
<td>String</td>
<td>string</td>
<td></td>
<td>“”</td>
<td>UTF-8 string</td>
</tr>
</tbody></table>
<h4 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h4><p>Go language use value propagation as transfer method. That means Go use the copy the value to transfer data. The fundamental type is <strong>Unchangeable</strong>，if you modify fundamental type , Go will create new value and return this , the original var is not changed. </p>
<p>For Example:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	name := <span class="string">&quot;Bob&quot;</span></span><br><span class="line">	fmt.Println(modify(name))</span><br><span class="line">	fmt.Println(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	name = name + name</span><br><span class="line">	<span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// BobBob</span></span><br><span class="line"><span class="comment">// Bob</span></span><br></pre></td></tr></table></figure>
<p> Fundamental type value is the copy value, so the original value never change actually, So that is the <strong>Thread-safe</strong> type.</p>
<h3 id="Compound-Data-Structure"><a href="#Compound-Data-Structure" class="headerlink" title="Compound Data Structure"></a>Compound Data Structure</h3><p>Go language contain seven types of compound data structure: <strong>Pointer, Array, Slice, Map, Channel, Struct, Interface .</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Actual Type</th>
<th>Default Value</th>
<th>Remark</th>
</tr>
</thead>
<tbody><tr>
<td>Array</td>
<td>array</td>
<td></td>
<td>Value Type</td>
</tr>
<tr>
<td>Slice</td>
<td>slice</td>
<td>nil</td>
<td>Reference Type</td>
</tr>
<tr>
<td>Map</td>
<td>map</td>
<td>nil</td>
<td>Reference Type</td>
</tr>
<tr>
<td>Channel</td>
<td>channel</td>
<td>nil</td>
<td>Reference Type</td>
</tr>
<tr>
<td>Struct</td>
<td>struct</td>
<td></td>
<td>Value Type</td>
</tr>
<tr>
<td>Interface</td>
<td>interface</td>
<td>nil</td>
<td>Reference Type</td>
</tr>
<tr>
<td>Function</td>
<td>function</td>
<td>nil</td>
<td>Reference Type</td>
</tr>
</tbody></table>
<h4 id="Reference-Type"><a href="#Reference-Type" class="headerlink" title="Reference Type"></a>Reference Type</h4><p>Reference is the opposite with fundamental type: Any modify operation will change the value of variable that reference it . Reference type variable contain the pointer to the underlying data structure. In go language, transfer value copy is also used in reference type, while is only copy the pointer part. </p>
<p>For Example:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ages := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;Bob&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line">	fmt.Println(ages)</span><br><span class="line">	modifyMap(ages)</span><br><span class="line">	fmt.Println(ages)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyMap</span><span class="params">(ageMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	ageMap[<span class="string">&quot;Bob&quot;</span>] = <span class="number">81</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//map[Bob:18]</span></span><br><span class="line"><span class="comment">//map[Bob:81]</span></span><br></pre></td></tr></table></figure>
<h4 id="Struct-Type"><a href="#Struct-Type" class="headerlink" title="Struct Type"></a>Struct Type</h4><p> <a href="https://golang.org/ref/spec#Struct_types">A struct</a> is just a named collection of fields where you can store data. Declare a struct like this:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The inner type in struct could be any type: Fundamental type or Reference type. In actual use stage, if the value would be changed, reference type is recommend, on the contrary fundamental type is better.</p>
<p>Transfer struct type in function is also value propagation, Go language allow us transfer struct value of struct pointer, they has the similar feature with fundamental type and reference type.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	bob := Person&#123;name: <span class="string">&quot;Bob&quot;</span>, age: <span class="number">18</span>&#125;</span><br><span class="line">	fmt.Println(bob)</span><br><span class="line">	modify(bob)</span><br><span class="line">	fmt.Println(bob)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(person Person)</span></span> &#123;</span><br><span class="line">	person.age = person.age + <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&#123;Bob 18&#125;</span></span><br><span class="line"><span class="comment">//&#123;Bob 18&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	bob := Person&#123;name: <span class="string">&quot;Bob&quot;</span>, age: <span class="number">18</span>&#125;</span><br><span class="line">	fmt.Println(bob)</span><br><span class="line">	modify(&amp;bob)</span><br><span class="line">	fmt.Println(bob)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(person *Person)</span></span> &#123;</span><br><span class="line">	person.age = person.age + <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&#123;Bob 18&#125;</span></span><br><span class="line"><span class="comment">//&#123;Bob 28&#125;</span></span><br></pre></td></tr></table></figure>
<p>If the struct contain reference type, the reference type value <strong>will not be changed</strong> , if you pass the struct value .For Example:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name   <span class="keyword">string</span></span><br><span class="line">	age    <span class="keyword">int</span></span><br><span class="line">	friend []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	bob := Person&#123;name: <span class="string">&quot;Bob&quot;</span>, age: <span class="number">18</span>, friend: []<span class="keyword">string</span>&#123;<span class="string">&quot;jack&quot;</span>&#125;&#125;</span><br><span class="line">	fmt.Println(bob)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p \n&quot;</span>, &amp;bob.friend)</span><br><span class="line">	modify(bob)</span><br><span class="line">	fmt.Println(bob)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(person Person)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p \n&quot;</span>, &amp;person.friend)</span><br><span class="line">	person.friend = []<span class="keyword">string</span>&#123;<span class="string">&quot;black&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">\\ &#123;Bob <span class="number">18</span> [jack]&#125;</span><br><span class="line">\\ <span class="number">0xc00008e168</span> </span><br><span class="line">\\ <span class="number">0xc00008e1c8</span> </span><br><span class="line">\\ &#123;Bob <span class="number">18</span> [jack]&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Interface-Type"><a href="#Interface-Type" class="headerlink" title="Interface Type"></a>Interface Type</h4><p><a href="https://golang.org/ref/spec#Interface_types">Interfaces</a> are a very powerful concept in statically typed languages like Go because they allow you to make functions that can be used with different types and create highly-decoupled code whilst still maintaining type-safety.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Shape is implemented by anything that can tell us its Area.</span></span><br><span class="line"><span class="keyword">type</span> Shape <span class="keyword">interface</span> &#123;</span><br><span class="line">	Area() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rectangle has the dimensions of a rectangle.</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	Width  <span class="keyword">float64</span></span><br><span class="line">	Height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Area returns the area of the rectangle.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.Width * r.Height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perimeter returns the perimeter of a rectangle.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Perimeter</span><span class="params">(rectangle Rectangle)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span> * (rectangle.Width + rectangle.Height)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Circle represents a circle...</span></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	Radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Area returns the area of the circle.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Pi * c.Radius * c.Radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Triangle represents the dimensions of a triangle.</span></span><br><span class="line"><span class="keyword">type</span> Triangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	Base   <span class="keyword">float64</span></span><br><span class="line">	Height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Area returns the area of the triangle.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Triangle)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (c.Base * c.Height) * <span class="number">0.5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Self-Define-Type"><a href="#Self-Define-Type" class="headerlink" title="Self Define Type"></a>Self Define Type</h4><p><code>type</code> is also used to define self fundamental type, we can use is as struct . Like define unique function.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Bitcoin <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Bitcoin)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d BTC&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO_Learning_Fundamental_Dependency_Injection</title>
    <url>/2022/06/29/GO-Learning-Fundamental-Dependency-Injection/</url>
    <content><![CDATA[<p>Reference: <a href="https://en.wikipedia.org/wiki/Dependency_injection">DI Wiki</a>, <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">DIP</a>,<a href="https://www.youtube.com/watch?v=IKD2-MAkXyQ">YouTuBe</a>, <a href="https://www.youtube.com/watch?v=tW6UHD81SG0">YouTuBe</a>, <a href="https://blog.csdn.net/lengyue1084/article/details/118729846">Blog</a>, <a href="https://segmentfault.com/a/1190000040436488">Blog</a></p>
<a id="more"></a>

<h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>What is dependency injection, the literal meaning is <strong>Inject the dependencies</strong>. </p>
<ul>
<li><p>What is Dependency?</p>
<p>The Dependency is <strong>other object</strong> that your class need functional.</p>
</li>
<li><p>What is Injection?</p>
<p>Injection means you <strong>pushed</strong> the dependency into your class.</p>
<ul>
<li>Recommend: push dependency as parameter or use setter method;</li>
<li>Not Recommend: new dependency in your class;</li>
</ul>
</li>
</ul>
<p>In the wiki introduction, the Dependency injection involves four roles， which i will use it to explain the DI concept;</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">- the **service** objects to be used</span><br><span class="line">	Any object that may be used can be considered a service.</span><br><span class="line">- the **client** object, whose behavior depends on the services it uses</span><br><span class="line">	Any object that uses other objects can be considered a client.</span><br><span class="line">- the [**interfaces**](https:<span class="comment">//en.wikipedia.org/wiki/Interface_(object-oriented_programming)) that define how the client may use the services</span></span><br><span class="line">  The interfaces are the types the client expects its dependencies to be.</span><br><span class="line">- the **injector**, which constructs the services and injects them into the client</span><br><span class="line">	The injector introduces services to the client. Often, it also constructs the client. An injector may connect a <span class="built_in">complex</span> object graph by treating the same object as both a client at one point and as a service at another</span><br><span class="line">                       </span><br><span class="line">As an analogy,</span><br><span class="line">- service - an electric, gas, hybrid, or diesel car</span><br><span class="line">- client - a driver who uses the car the same way regardless of the engine</span><br><span class="line">- <span class="keyword">interface</span> - [automatic transmission](https:<span class="comment">//en.wikipedia.org/wiki/Automatic_transmission), which ensures the driver does not have to understand details of shifting gears</span></span><br><span class="line">- injector - the parent who bought the car <span class="keyword">for</span> the driver and decided which kind</span><br></pre></td></tr></table></figure>
<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>The reason why DI is important? <strong>DIP</strong> dependency inversion principle;</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>The above description is too abstract to understand; In one word, DI is a kind of design mode:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">The intent behind dependency injection is to achieve separation of concerns of construction and use of objects. This can increase readability and code reuse.</span><br><span class="line">- wiki</span><br></pre></td></tr></table></figure>
<p>Here is a scenario, a server API would use DB model to get some information;</p>
<ul>
<li><p>Bad programming style</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// some fields definition</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span><span class="title">GetData</span><span class="params">(id <span class="keyword">string</span>)</span> <span class="title">string</span></span>&#123;</span><br><span class="line">  db := <span class="built_in">new</span>(mysql)</span><br><span class="line">  <span class="keyword">return</span> db.queryData(id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewService</span><span class="params">()</span> *<span class="title">Service</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Service&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service := NewService()</span><br><span class="line">service.Run()</span><br></pre></td></tr></table></figure></li>
<li><p>After Dependency Injection</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// some fields definition</span></span><br><span class="line">  db *MYSQLClient</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span><span class="title">GetData</span><span class="params">(id <span class="keyword">string</span>)</span> <span class="title">string</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s.db.queryData(id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewService</span><span class="params">()</span> *<span class="title">Service</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Service&#123;db: NewMySQLClient(mySqlUrl)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service := NewService(<span class="string">&quot;mysql://url&quot;</span>)</span><br><span class="line">service.Run()</span><br></pre></td></tr></table></figure></li>
<li><p>After Dependency Inversion Principle</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DataSource <span class="keyword">interface</span> &#123;</span><br><span class="line">  GetDataById(id <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mySql <span class="keyword">struct</span> &#123;</span><br><span class="line">  m *MySqlClient</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *mysql)</span> <span class="title">GetDataById</span><span class="params">(id <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> m.m.Exec(<span class="string">&quot;select data from table where id = ?&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMySQL</span><span class="params">(addr <span class="keyword">string</span>)</span> *<span class="title">mySql</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;mySql&#123;m: NewMySQLClient(addr)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> redis <span class="keyword">struct</span> &#123;</span><br><span class="line">  r *RedisClient</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RedisClient)</span> <span class="title">GetDataById</span><span class="params">(id <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> r.r.Do(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;table_&quot;</span>+id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRedis</span><span class="params">(addr <span class="keyword">string</span>)</span> *<span class="title">redis</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;redis&#123;r: NewRedisClient(addr)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// some fields definition</span></span><br><span class="line">  db DataSource</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span><span class="title">GetData</span><span class="params">(id <span class="keyword">string</span>)</span> <span class="title">string</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s.db.GetDataById(id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewService</span><span class="params">(addr <span class="keyword">string</span>)</span> *<span class="title">Service</span></span>&#123;</span><br><span class="line">  <span class="comment">// Redis </span></span><br><span class="line">  <span class="keyword">return</span> &amp;Service&#123;db: NewRedis(myRedisUrl)&#125;</span><br><span class="line">  <span class="comment">// Mysql</span></span><br><span class="line">  <span class="keyword">return</span> &amp;Service&#123;db: NewMySQL(myRedisUrl)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service := NewService()</span><br><span class="line">service.Run()</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO_Learning_Fundamental_Pointer</title>
    <url>/2022/06/29/GO-Learning-Fundamental-Pointer/</url>
    <content><![CDATA[<ul>
<li>Reference: <a href="https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/structs-methods-and-interfaces">TDD</a>, <a href="https://www.topgoer.com/go%E5%9F%BA%E7%A1%80/%E7%BB%93%E6%9E%84%E4%BD%93.html">Go Chinese Docs</a>, </li>
</ul>
<a id="more"></a>

<h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>Every var has memory address and value, Pointer is the variable that store the address as its value. In Go language, <code>&amp;</code> means toke <strong>address</strong> operation, while <code>*</code> means get  the <strong>value</strong> from address operation. <strong>Pointer</strong> is a kind of variable that store the address of corresponding variable. </p>
<h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ptr := &amp;v</span><br><span class="line"><span class="comment">// v: token address variable, type T</span></span><br><span class="line"><span class="comment">// ptr: pointer variable, named as the pointer of T, type: *T</span></span><br></pre></td></tr></table></figure>
<p>Example:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    b := &amp;a</span><br><span class="line">    fmt.Printf(<span class="string">&quot;a:%d ptr:%p\n&quot;</span>, a, &amp;a) <span class="comment">// a:10 ptr:0xc00001a078</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;b:%p type:%T\n&quot;</span>, b, b) <span class="comment">// b:0xc00001a078 type:*int</span></span><br><span class="line">    fmt.Println(&amp;b)                    <span class="comment">// 0xc00000e018</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/04/PY2nUxj8bc7wQMf.png" alt="image-20211004001357927"></p>
<p><strong>Token Address:</strong> <code>&amp;</code> get pointer</p>
<p><strong>Get the value of pointer</strong>: <code>*</code> get value of pointer infered</p>
<p><a href="https://gobyexample.com/pointers">Pointers</a> let us <em>point</em> to some values and then let us change them.</p>
<p>Go copies values when you pass them to functions/methods, so if you’re writing a function that needs to mutate state you’ll need it to take a pointer to the thing you want to change.</p>
<p>The fact that Go takes a copy of values is useful a lot of the time but sometimes you won’t want your system to make a copy of something, in which case you need to pass a reference. Examples include referencing very large data structures or things where only one instance is necessary (like database connection pools).</p>
<p>Pointers can be nil</p>
<p>When a function returns a pointer to something, you need to make sure you check if it’s nil or you might raise a runtime exception - the compiler won’t help you here.</p>
<p>Useful for when you want to describe a value that could be missing</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO_Learning_Fundamental_Type</title>
    <url>/2022/06/29/GO-Learning-Fundamental-Type/</url>
    <content><![CDATA[<ul>
<li>Reference: <a href="https://www.topgoer.com/go%E5%9F%BA%E7%A1%80/%E7%BB%93%E6%9E%84%E4%BD%93.html">Go Chinese Docs</a>, <a href="https://zhuanlan.zhihu.com/p/106625495">Blog</a></li>
</ul>
<a id="more"></a>

<p><code>type</code> is a <strong>keyword</strong> in Go language. In my practical project, Type is the most common keyword, while it’s usage could be vary. Here list <strong>five usage</strong> of keyword <code>type</code>.</p>
<h2 id="Type-Alias"><a href="#Type-Alias" class="headerlink" title="Type Alias"></a>Type Alias</h2><p>Type alias , just as its name implies, user could infer original type with type alias. <code>rune</code> and  <code>byte</code> is classical implement of type alias；</p>
<ul>
<li><p>Syntax</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> type_alias = original_type</span><br></pre></td></tr></table></figure></li>
<li><p>Example</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> bype = <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">var</span> u <span class="keyword">uint8</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;type of b:%T\n&quot;</span>, b) <span class="comment">// type of b:uint8</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;type of u:%T\n&quot;</span>, u) <span class="comment">// type of u:uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Type-Define"><a href="#Type-Define" class="headerlink" title="Type Define"></a>Type Define</h2></li>
</ul>
<p>Type define allow user define self type with some intents. Compare to original type, self type define may has the follow advantage: 1. More Descriptive 2. Binding Specific Method:  etc;</p>
<ul>
<li><p>Syntax:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type define_name original_type</span><br></pre></td></tr></table></figure></li>
<li><p>Example:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// Compare int, BitCoin is more specific, show more intent.</span></span><br><span class="line"><span class="keyword">type</span> BitCoin <span class="keyword">int</span></span><br><span class="line"><span class="comment">// Customize the unique implementation</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b BitCoin)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d BTC&quot;</span>, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// multi way to init type bitcoin</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	bitCoin1 := BitCoin(<span class="number">999</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type of bitCoin1: %T\n&quot;</span>, bitCoin1)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;self define print output %s\n&quot;</span>, bitCoin1)</span><br><span class="line">	<span class="comment">// type of bitCoin1: main.BitCoin</span></span><br><span class="line">  <span class="comment">// self define print output 999 BTC</span></span><br><span class="line">  </span><br><span class="line">	<span class="keyword">var</span> bitCoin2 BitCoin</span><br><span class="line">	bitCoin2 = <span class="number">100</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;type of bitCoin2: %T\n&quot;</span>, bitCoin2)</span><br><span class="line">  <span class="comment">// type of bitCoin2: main.BitCoin</span></span><br><span class="line">  <span class="comment">// self define print output 100 BTC</span></span><br><span class="line">  </span><br><span class="line">	<span class="keyword">var</span> bitCoin3 BitCoin = <span class="number">100</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;type of bitcoin3: %T\n&quot;</span>, bitCoin3)</span><br><span class="line">  <span class="comment">// type of bitcoin3: main.BitCoin</span></span><br><span class="line">  <span class="comment">// self define print output 100 BTC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Struct-Define"><a href="#Struct-Define" class="headerlink" title="Struct Define"></a>Struct Define</h2><p><a href="https://golang.org/ref/spec#Struct_types">A struct</a> is just a named collection of fields where you can store data. The detail feature will introduce in other MD file.</p>
</li>
<li><p>Syntax</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Struct_name <span class="keyword">struct</span>&#123;</span><br><span class="line">  field1 type1</span><br><span class="line">  field2 type2</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Example:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// define struct</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	Width  <span class="keyword">float64</span></span><br><span class="line">	Height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define method binding instance Rectangle</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.Height * r.Width</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// I hope you&#x27;ll agree that passing a Rectangle to a function conveys our intent more clearly, but there are more benefits of using structs that we will cover later.</span></span><br></pre></td></tr></table></figure>
<h2 id="Interface-Define"><a href="#Interface-Define" class="headerlink" title="Interface Define"></a>Interface Define</h2></li>
</ul>
<p><a href="https://golang.org/ref/spec#Interface_types">Interfaces</a> are a very powerful concept in statically typed languages like Go because they allow you to make functions that can be used with different types and create highly-decoupled code whilst still maintaining type-safety.</p>
<ul>
<li><p>Syntax</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> interface_name <span class="keyword">interface</span> &#123;</span><br><span class="line">	method return_value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Example:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shape <span class="keyword">interface</span> &#123;</span><br><span class="line">	Area() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	Width  <span class="keyword">float64</span></span><br><span class="line">	Height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.Height * r.Width</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	Radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.Radius * c.Radius * math.Pi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Triangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	Height <span class="keyword">float64</span></span><br><span class="line">	Down   <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Triangle)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> t.Height * t.Down / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Wait-what"><a href="#Wait-what" class="headerlink" title="Wait, what?"></a>Wait, what?</h2><p>This is quite different to interfaces in most other programming languages. Normally you have to write code to say <code>My type Foo implements interface Bar</code>.</p>
<p>But in our case</p>
<ul>
<li><code>Rectangle</code> has a method called <code>Area</code> that returns a <code>float64</code> so it satisfies the <code>Shape</code> interface</li>
<li><code>Circle</code> has a method called <code>Area</code> that returns a <code>float64</code> so it satisfies the <code>Shape</code> interface</li>
<li><code>string</code> does not have such a method, so it doesn’t satisfy the interface</li>
<li>etc.</li>
</ul>
<p>In Go <strong>interface resolution is implicit</strong>. If the type you pass in matches what the interface is asking for, it will compile.</p>
<h2 id="Decoupling"><a href="#Decoupling" class="headerlink" title="Decoupling"></a>Decoupling</h2><p>Notice how our helper does not need to concern itself with whether the shape is a <code>Rectangle</code> or a <code>Circle</code> or a <code>Triangle</code>. By declaring an interface, the helper is <em>decoupled</em> from the concrete types and only has the method it needs to do its job.</p>
<p>This kind of approach of using interfaces to declare <strong>only what you need</strong> is very important in software design and will be covered in more detail in later sections.</p>
</li>
</ul>
<h2 id="Type-Find"><a href="#Type-Find" class="headerlink" title="Type Find"></a>Type Find</h2><p>Type judge is a common usage in programming. <code>i.(type)</code></p>
<ul>
<li><p>Syntax</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">instance.(type)</span><br></pre></td></tr></table></figure></li>
<li><p>Example</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">// 实现数据类型的判断</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkType</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;string&quot;</span></span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;int&quot;</span></span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;float64&quot;</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;unknown&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 验证</span></span><br><span class="line">  v1 := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">  v2 := <span class="number">33</span></span><br><span class="line">  v3 := <span class="number">45.2</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;the type of v1 is %s\n&quot;</span>, checkType(v1))</span><br><span class="line">  fmt.Printf(<span class="string">&quot;the type of v2 is %s\n&quot;</span>, checkType(v2))</span><br><span class="line">  fmt.Printf(<span class="string">&quot;the type of v3 is %s\n&quot;</span>, checkType(v3))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO_Learning_Package Definition</title>
    <url>/2022/06/29/GO-Learning-Package-Definition/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://dave.cheney.net/2014/12/01/five-suggestions-for-setting-up-a-go-project">Blog</a></p>
</blockquote>
<a id="more"></a>

<h2 id="Package-is-the-unit-of-go-language"><a href="#Package-is-the-unit-of-go-language" class="headerlink" title="Package is the unit of go language"></a>Package is the unit of go language</h2><p>In GO language, Package is the Basic unit while other language’s unit usually be file. For example,we have two hello World software in different language , Their directory tree is :</p>
<ul>
<li>GO</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">root :</span></span><br><span class="line">	<span class="attr">hello :</span></span><br><span class="line">		<span class="string">hello.go</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Python</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">root :</span></span><br><span class="line">	<span class="attr">hello :</span></span><br><span class="line">		<span class="string">hello.py</span></span><br></pre></td></tr></table></figure>
<p>In go, the syntax to use hello world func is :</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> root.hello </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	hello world()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In Python, the syntan to use hello world func is :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> root.hello.hello</span><br><span class="line"></span><br><span class="line">func main():</span><br><span class="line">	hello.hello world()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="What-is-Package"><a href="#What-is-Package" class="headerlink" title="What is Package"></a>What is Package</h2><p>Package is a <strong>directory</strong> which including <strong>.go source file</strong>. Some features of package in Go:</p>
<h3 id="Features"><a href="#Features" class="headerlink" title="Features:"></a>Features:</h3><ul>
<li><p>Package name is match with directory name. If your package is called logger, your directory may be like:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$GOPATH&#x2F;src&#x2F;github.com&#x2F;yourname&#x2F;logger</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>Package name</strong> is recommend as <strong>lower case.</strong></p>
</li>
<li><p>Package names, and thus the package’s directory, **should contain only letters, numbers **if you must, but absolutely no punctuation. Package name is part of type , func , var , const which export by this package.</p>
</li>
</ul>
</li>
<li><p>All files in a package’s directory should have <strong>the same package declaration</strong>.</p>
<ul>
<li>Testing file is a exception; For testing, your test files, those ending with <code>_test.go</code>, <em>may</em> declare themselves to be in the same package, but with <code>_test</code> appended to the package declaration.</li>
</ul>
</li>
</ul>
<h3 id="Main-package"><a href="#Main-package" class="headerlink" title="Main package"></a>Main package</h3><p>Main package is actually <strong>commands</strong>, these carry the declaration of <code>package main</code>. It also conforms to the previous package specification,</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO_Learning_Fundamental_Integers</title>
    <url>/2022/06/29/GO-Learning-Fundamental-Integers/</url>
    <content><![CDATA[<ul>
<li>reference: <a href="https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/integers">TDD</a>, <a href="https://golang.google.cn/doc/effective_go">Effective Go</a>. <a href="https://www.topgoer.com/go%E5%9F%BA%E7%A1%80/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B.html">Go Chinese Docs</a></li>
</ul>
<a id="more"></a>

<p>Control structures</p>
<p>In Go language, there is only <code>if , for , switch</code> as control structure while no <code>do, while</code> loop. </p>
<ul>
<li>Same with other language: <code>break,continue</code> statements is the same as others</li>
<li>Different :<ul>
<li>in <code>switch</code> structure, <code>type</code> is optional label</li>
<li><code>select</code></li>
</ul>
</li>
</ul>
<p><strong>Syntax</strong> in Go: No need parentheses while the body must always be brace-delimited.</p>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><ul>
<li><p>Ordinary syntan: Writting simple <code>if</code> in multiple lines.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Intersting syntax: <code>if</code> with initialization statement</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := file.Chmod(<span class="number">0664</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Print(err)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li></li>
</ul>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>There are three forms in <code>for</code> syntaxs:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Like a C for</span></span><br><span class="line"><span class="keyword">for</span> init; condition; post &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Like a C while</span></span><br><span class="line"><span class="keyword">for</span> condition &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Like a C for(;;)</span></span><br><span class="line"><span class="keyword">for</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="for-with-range"><a href="#for-with-range" class="headerlink" title="for with range:"></a><strong>for with range:</strong></h4><p>range statements is a good way to loop array, slice, map, channel, the syntax is :</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you only need the first item in the range (the key or index), drop the second:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> m &#123;</span><br><span class="line">    <span class="keyword">if</span> key.expired() &#123;</span><br><span class="line">        <span class="built_in">delete</span>(m, key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you only need the second item in the range (the value), use the <em>blank identifier</em>, an underscore, to discard the first:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> array &#123;</span><br><span class="line">    sum += value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Range does more work for <code>string</code>:Breaking out individual Unicode code points by parsing the UTF-8. Erroneous encodings consume one byte and produce the replacement rune U+FFFD.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> pos, char := <span class="keyword">range</span> <span class="string">&quot;日本\x80語&quot;</span> &#123; <span class="comment">// \x80 is an illegal UTF-8 encoding</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;character %#U starts at byte position %d\n&quot;</span>, char, pos)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//character U+65E5 &#x27;日&#x27; starts at byte position 0</span></span><br><span class="line"><span class="comment">//character U+672C &#x27;本&#x27; starts at byte position 3</span></span><br><span class="line"><span class="comment">//character U+FFFD &#x27;�&#x27; starts at byte position 6</span></span><br><span class="line"><span class="comment">//character U+8A9E &#x27;語&#x27; starts at byte position 7</span></span><br></pre></td></tr></table></figure>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch has the same mwaning as other language. In go language, if the <code>switch</code> has no expression it switches on <code>true</code>. It’s therefore possible—and idiomatic—to write an <code>if</code>-<code>else</code>-<code>if</code>-<code>else</code> chain as a <code>switch</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unhex</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>There is no automatic fall through, but cases can be presented in comma-separated lists.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shouldEscape</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> c &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;&amp;&#x27;</span>, <span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Type-switch"><a href="#Type-switch" class="headerlink" title="Type switch"></a>Type switch</h4><p>A switch can also be used to discover the dynamic type of an interface variable. Such a <em>type switch</em> uses the syntax of a type assertion with the keyword <code>type</code> inside the parentheses. If the switch declares a variable in the expression, the variable will have the corresponding type in each clause. It’s also idiomatic to reuse the name in such cases, in effect declaring a new variable with the same name but a different type in each case.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">t = functionOfSomeType()</span><br><span class="line"><span class="keyword">switch</span> t := t.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;unexpected type %T\n&quot;</span>, t)     <span class="comment">// %T prints whatever type t has</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;boolean %t\n&quot;</span>, t)             <span class="comment">// t has type bool</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;integer %d\n&quot;</span>, t)             <span class="comment">// t has type int</span></span><br><span class="line"><span class="keyword">case</span> *<span class="keyword">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;pointer to boolean %t\n&quot;</span>, *t) <span class="comment">// t has type *bool</span></span><br><span class="line"><span class="keyword">case</span> *<span class="keyword">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;pointer to integer %d\n&quot;</span>, *t) <span class="comment">// t has type *int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO_Learning_Fundamental_Struct</title>
    <url>/2022/06/29/GO-Learning-Fundamental-Struct/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_Fundamental_Learning_Basic Control Flow</title>
    <url>/2022/06/29/Go-Fundamental-Learning-Basic-Control-Flow/</url>
    <content><![CDATA[<h2 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h2><p>There are three kinds of basic control flow code blocks in Go:</p>
<ul>
<li><code>if-else</code>: two-way conditional  execution block.</li>
<li><code>switch-case</code>: multi-way conditional execution block;</li>
<li><code>for</code>: loop block</li>
</ul>
<a id="more"></a>

<p>There are also some control flow block which use as certain kinds of types in Go:</p>
<ul>
<li><code>for-range</code>: loop block for <code>container</code> types;</li>
<li><code>type-switch</code>: multi-way conditional execution block for <code>interface</code> type;</li>
<li><code>select-case</code>:block for channel types;</li>
</ul>
<h2 id="Execution-Jump-Statements"><a href="#Execution-Jump-Statements" class="headerlink" title="Execution Jump Statements"></a>Execution Jump Statements</h2><p>Go support <code>break</code>, <code>continue</code>, <code>goto</code>, <code>fallthrough</code> as jump statements;</p>
<ul>
<li><code>break</code> :Except <code>if-else</code> other five control flow statements is breakable, we can use break to end the block in advance.</li>
<li><code>continue</code>: continue is use to stop current loop step and continue next step, for <code>for</code> statement or <code>for-range</code> statement;</li>
</ul>
<h2 id="Basic-Control-Flow"><a href="#Basic-Control-Flow" class="headerlink" title="Basic Control Flow"></a>Basic Control Flow</h2><h3 id="If-else"><a href="#If-else" class="headerlink" title="If-else"></a>If-else</h3><h4 id="Basic-Format"><a href="#Basic-Format" class="headerlink" title="Basic Format"></a>Basic Format</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> InitSimpleStatement; Condition &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h4><ul>
<li>The <code>else</code> statement is optional;</li>
<li><code>InitSimpleStatement</code> is optional;</li>
<li><code>Condition</code> must be an expression which result a bool value;</li>
</ul>
<h4 id="Implicit-code-block"><a href="#Implicit-code-block" class="headerlink" title="Implicit code block"></a>Implicit code block</h4><p>Each <code>if-else</code> control flow forms with three block : </p>
<ul>
<li>one implicit code block;</li>
<li>one <code>if</code> branch explicit code block;</li>
<li>one optional <code>else</code> branch code block;</li>
</ul>
<p>If the <code>InitSimpleStatement</code> in a <code>if-else</code> code block is a short variable declaration, then the declared variables will be viewed as being declared in the top nesting implicit code block of the <code>if-else</code> code block.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> h := time.Now().Hour(); h &lt; <span class="number">12</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Now is AM time.&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> h &gt; <span class="number">19</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Now is evening time.&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Now is afternoon time.&quot;</span>)</span><br><span class="line">		h := h <span class="comment">// the right one is declared above</span></span><br><span class="line">		<span class="comment">// The just new declared &quot;h&quot; variable</span></span><br><span class="line">		<span class="comment">// shadows the above same-name one.</span></span><br><span class="line">		_ = h</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// h is not visible here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="For"><a href="#For" class="headerlink" title="For"></a>For</h3><h4 id="Basic-Format-1"><a href="#Basic-Format-1" class="headerlink" title="Basic Format"></a>Basic Format</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> InitSimpleStatement; Condition; PostSimpleStatement &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Feature-1"><a href="#Feature-1" class="headerlink" title="Feature"></a>Feature</h4><ul>
<li>The three portions are all optional.</li>
<li>The <code>InitSimpleStatement</code> in a <code>for</code> loop block will be executed (only once) before executing other statements in the <code>for</code> loop block.</li>
<li>If the <code>InitSimpleStatement</code> and <code>PostSimpleStatement</code> portions are both absent (just view them as blank statements), their nearby two semicolons can be omitted. </li>
<li>If the <code>Condition</code> portion is absent, compilers will view it as <code>true</code>.</li>
</ul>
<h4 id="Implicit-code-block-1"><a href="#Implicit-code-block-1" class="headerlink" title="Implicit code block"></a>Implicit code block</h4><p>Each <code>for</code> control flow forms at least two code blocks, one is implicit and one is explicit. The explicit one is nested in the implicit one.</p>
<h3 id="Switch-case"><a href="#Switch-case" class="headerlink" title="Switch-case"></a>Switch-case</h3><h4 id="Basic-Format-2"><a href="#Basic-Format-2" class="headerlink" title="Basic Format"></a>Basic Format</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> InitSimpleStatement; CompareOperand0 &#123;</span><br><span class="line"><span class="keyword">case</span> CompareOperandList1:</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line"><span class="keyword">case</span> CompareOperandList2:</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> CompareOperandListN:</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Feature-2"><a href="#Feature-2" class="headerlink" title="Feature"></a>Feature</h4><ul>
<li> The <code>CompareOperand0</code> portion is an expression which is viewed as a typed value (if it is an untyped value, then it is viewed as a type value of its default type), hence it can’t be an untyped <code>nil</code>.</li>
<li> Each of the <code>CompareOperandListX</code> (<code>X</code> may represent from <code>1</code> to <code>N</code>) portions must be a comma separated expression list. Each of these expressions shall be comparable with <code>CompareOperand0</code>;</li>
<li> There can be at most one <code>default</code> branch in a <code>switch-case</code> control flow block.</li>
</ul>
<h4 id="Implicit-code-block-2"><a href="#Implicit-code-block-2" class="headerlink" title="Implicit code block"></a>Implicit code block</h4><ul>
<li>Each <code>case CompareOperandListX:</code> or <code>default:</code> opens (and is followed by) an implicit code block. The implicit code block and that <code>case CompareOperandListX:</code> or <code>default:</code> forms a branch. Each such branch is optional to be present</li>
<li>Besides the branch code blocks, each <code>switch-case</code> control flow forms two code blocks, one is implicit and one is explicit. The explicit one is nested in the implicit one. All the branch code blocks are nested in the explicit one (and nested in the implicit one indirectly).</li>
</ul>
<p>….</p>
<h3 id="For-range"><a href="#For-range" class="headerlink" title="For-range"></a>For-range</h3><h3 id="Type-switch"><a href="#Type-switch" class="headerlink" title="Type-switch"></a>Type-switch</h3><h3 id="Select-case"><a href="#Select-case" class="headerlink" title="Select-case"></a>Select-case</h3>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_Fundamental_Learning_Defer Function Call</title>
    <url>/2022/06/29/Go-Fundamental-Learning-Defer-Function-Call/</url>
    <content><![CDATA[<ul>
<li>Reference: <a href="https://blog.boot.dev/golang/defer-golang/">blog1</a>, <a href="https://www.geeksforgeeks.org/defer-keyword-in-golang/">blog2</a>,<a href="https://www.digitalocean.com/community/tutorials/understanding-defer-in-go">blog3</a>,<a href="https://go101.org/article/control-flows-more.html">blog4</a></li>
</ul>
<h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p><code>defer</code> statement is the keyword of go language. <code>defer</code> statement would delay the execution of function, method and anonymous method until the innermost call function return. Attention please, the <strong>arguments of defer function evaluate instantly</strong> while the execution is delay. Example is shown in the below part. </p>
<a id="more"></a>

<h2 id="Basic-Usage"><a href="#Basic-Usage" class="headerlink" title="Basic Usage"></a>Basic Usage</h2><p>Using the keyword <code>defer</code> before a function call, to imply a delayed ‘function’. The ‘function’ means 1. Function call, 2. Method call , 3. Anonymous method call.</p>
<h3 id="Usage-Format"><a href="#Usage-Format" class="headerlink" title="Usage Format"></a>Usage Format</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> funcName(arguments)</span><br></pre></td></tr></table></figure>
<h3 id="Usage-With-Different-Object"><a href="#Usage-With-Different-Object" class="headerlink" title="Usage With Different Object"></a>Usage With Different Object</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span> <span class="title">func_name</span><span class="params">(parameter_list Type)</span><span class="title">return_type</span></span>&#123;</span><br><span class="line"><span class="comment">// Code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Method</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span> <span class="params">(receiver Type)</span> <span class="title">method_name</span><span class="params">(parameter_list)</span></span>&#123;</span><br><span class="line"><span class="comment">// Code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span> <span class="params">(parameter_list)</span><span class="params">(return_type)</span></span>&#123;</span><br><span class="line"><span class="comment">// code</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>Here is a example to show the basic usage of defer:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Functions</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mul</span><span class="params">(a1, a2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	res := a1 * a2</span><br><span class="line">	fmt.Println(<span class="string">&quot;Result: &quot;</span>, res)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello, Defer!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mul(<span class="number">1</span>, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> mul(<span class="number">9</span>, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">	show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Result:  9</span></span><br><span class="line"><span class="comment">// Hello, Defer!</span></span><br><span class="line"><span class="comment">// Result:  81</span></span><br></pre></td></tr></table></figure>
<h3 id="Usage-Scenario"><a href="#Usage-Scenario" class="headerlink" title="Usage Scenario"></a>Usage Scenario</h3><h4 id="Clean-up-Resource"><a href="#Clean-up-Resource" class="headerlink" title="Clean up Resource"></a>Clean up Resource</h4><p>In programming, remember clean up all the resources(close file , disconnect tcp etc) is not a easy thing. With <code>defer</code> keyword the clean up part will always be executed. Here is a close file example, which compare <code>defer</code> difference with different code style:</p>
<ul>
<li><p>without <code>defer</code> keyword, close file clause is duplicate:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := write(<span class="string">&quot;readme.txt&quot;</span>, <span class="string">&quot;This is a readme file&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;failed to write file:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(fileName <span class="keyword">string</span>, text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	file, err := os.Create(fileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	_, err = io.WriteString(file, text)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		file.Close()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	file.Close()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>with <code>defer</code> keyword, the complier always remember close file;</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := write(<span class="string">&quot;readme.txt&quot;</span>, <span class="string">&quot;This is a readme file&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;failed to write file:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(fileName <span class="keyword">string</span>, text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	file, err := os.Create(fileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	_, err = io.WriteString(file, text)</span><br><span class="line">	<span class="keyword">defer</span> file.Close() 	<span class="comment">// defer keyword</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Deal-With-recover-function"><a href="#Deal-With-recover-function" class="headerlink" title="Deal With recover function"></a>Deal With <code>recover</code> function</h4></li>
</ul>
<blockquote>
<p>The example above is a complicated and non-idiomatic way to handle runtime problems that would have been better dealt with by just passing <code>error</code> values. I understand that there are definitely edge-cases where use of <code>panic()</code> and <code>recover()</code> might make sense. That said, I’ve been writing Go professionally for about 5 years now and I’ve never felt a sufficient need, especially in application code. Do your best to refactor your project so you can just return <code>error</code>s like the good designers intended.</p>
<p>_Lane Wagner</p>
</blockquote>
<p>Clean up operation is not necessary with <code>defer</code> keyword, for a well programmed code could achieve the same effect. While <code>defer</code> is the necessary part of build-in function <code>recover</code> .</p>
<p>In go language, the <code>panic</code> and <code>recover</code> mechanism is used to stop <code>panic</code> spread. If a panicking goroutine exit without being recovered, it will cause the whole program crash. In other language, try/catch mechanism has the similar effect. Thanks to the <code>recover</code> mechanism, the below goroutine did not collapse.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recoverWithMessage</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;recovered from&quot;</span>, r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fullName</span><span class="params">(firstName *<span class="keyword">string</span>, lastName *<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> recoverWithMessage()</span><br><span class="line">	<span class="keyword">if</span> firstName == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;first name cannot be nil&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> lastName == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;last name cannot be nil&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s %s\n&quot;</span>, *firstName, *lastName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	firstName := <span class="string">&quot;Sun&quot;</span></span><br><span class="line">	lastName := <span class="string">&quot;Qingzhi&quot;</span></span><br><span class="line">	fmt.Println(fullName(&amp;firstName, &amp;lastName))</span><br><span class="line">	fmt.Println(fullName(&amp;firstName, <span class="literal">nil</span>))</span><br><span class="line">	fmt.Println(fullName(<span class="literal">nil</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Sun Qingzhi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// recovered from last name cannot be nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// recovered from first name cannot be nil</span></span><br></pre></td></tr></table></figure>

<h2 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h2><ul>
<li><p>Call Sequence of Defer Function</p>
<p>The Sequence of Defer Function is <code>FILO</code>.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Actually the goroutine hold two function call stack;</span><br><span class="line">- For a deferred function call, the invocation moment is the moment when it is pushed into the defer-call stack of its caller goroutine.</span><br><span class="line">- For a goroutine function call, the invocation moment is the moment when the corresponding goroutine is created.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Functions</span><br><span class="line">func mul(a1, a2 int) int &#123;</span><br><span class="line"></span><br><span class="line">	res :&#x3D; a1 * a2</span><br><span class="line">	fmt.Println(&quot;Result: &quot;, res)</span><br><span class="line">	return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	mul(1, 9)</span><br><span class="line">	defer mul(6, 9)</span><br><span class="line">	defer mul(5, 9)</span><br><span class="line">	defer mul(4, 9)</span><br><span class="line">	defer mul(3, 9)</span><br><span class="line">	defer mul(2, 9)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Result:  9</span><br><span class="line">&#x2F;&#x2F; Result:  18</span><br><span class="line">&#x2F;&#x2F; Result:  27</span><br><span class="line">&#x2F;&#x2F; Result:  36</span><br><span class="line">&#x2F;&#x2F; Result:  45</span><br><span class="line">&#x2F;&#x2F; Result:  54</span><br></pre></td></tr></table></figure></li>
<li><p>Could Modify Named Return Result of Nesting Functions.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Triple</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		r += n <span class="comment">// modify the return value</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> n + n <span class="comment">// &lt;=&gt; r = n + n; return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(Triple(<span class="number">5</span>)) <span class="comment">// 15</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Evaluation-Moment"><a href="#Evaluation-Moment" class="headerlink" title="Evaluation Moment"></a>Evaluation Moment</h2></li>
</ul>
<p><code>defer</code> function call would evaluate the arguments instantly and delayed the execution of function body.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Unlike other higher-order functions in Go, when you “pass” a function to the defer keyword, you pass an entire function call, not just the name of the function. This allows the function’s arguments to be evaluated immediately. The defer keyword just ensures that the body of the function won’t run until the parent function returns.</span><br><span class="line">_Lane Wagner</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Functions</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mul</span><span class="params">(a1, a2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	res := a1 * a2</span><br><span class="line">	fmt.Println(<span class="string">&quot;Result: &quot;</span>, res)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">9</span></span><br><span class="line">	<span class="keyword">defer</span> mul(a, <span class="number">9</span>)</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;The argument evaluatment is instantly,\nNow a is %v, \n&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The argument evaluatment is instantly,</span></span><br><span class="line"><span class="comment">// Now a is 1, </span></span><br><span class="line"><span class="comment">// Result:  81</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_Fundamental_Learning_Build In Type And Literal Value</title>
    <url>/2022/06/29/Go-Fundamental-Learning-Build-In-Type-And-Literal-Value/</url>
    <content><![CDATA[<ul>
<li><a href="https://go101.org/article/basic-types-and-value-literals.html">Reference</a>, <a href="https://naotu.baidu.com/file/aa8694ea5ea8f95a6da9c6622d546bf7">x-mind</a></li>
</ul>
<a id="more"></a>

<h2 id="Build-in-type"><a href="#Build-in-type" class="headerlink" title="Build in type"></a>Build in type</h2><p>There are 17 build in type in Golong; We can use them without import any package</p>
<h3 id="Boolean-1"><a href="#Boolean-1" class="headerlink" title="Boolean  (1)"></a>Boolean  (1)</h3><ul>
<li><code>bool</code>: defalut value is <code>false</code></li>
</ul>
<h3 id="String-1"><a href="#String-1" class="headerlink" title="String (1)"></a>String (1)</h3><ul>
<li><code>string</code>: default value is empty string  ``;</li>
</ul>
<h3 id="Numeric-15"><a href="#Numeric-15" class="headerlink" title="Numeric (15)"></a>Numeric (15)</h3><p><strong>Interger numeric type (11)</strong></p>
<ul>
<li><code>int8, uint8, int32, uint32, int64, uint64, int, uint, uintprt</code></li>
</ul>
<p><strong>Float point type (2)</strong></p>
<ul>
<li><code>float32, float64</code></li>
</ul>
<p><strong>Complex type (2)</strong></p>
<ul>
<li><code>complex64, complex128</code></li>
</ul>
<h2 id="Memory-Size"><a href="#Memory-Size" class="headerlink" title="Memory Size"></a>Memory Size</h2><p>If a value occupies N bits in memory, we say the size of value is N bits. The size of all values of a type is always the same, So the value size means the type size.<br>Byte size is often used to measure memory, One byte equal to eight bits. So the size the `int32 is four bytes. The picture show the size of different type.</p>
<p><img src="C:\Users\QingZhi\AppData\Roaming\Typora\typora-user-images\image-20220502155346311.png" alt="image-20220502155346311"></p>
<h2 id="Zeros-Value-of-Build-In-type"><a href="#Zeros-Value-of-Build-In-type" class="headerlink" title="Zeros Value of Build In type"></a>Zeros Value of Build In type</h2><p>Zeros value is also the default value ;</p>
<p><strong>bool</strong>: <code>false</code><br><strong>numeric</strong>: <code>0</code><br><strong>String</strong>: <code>&quot;&quot;</code></p>
<h2 id="Basic-Value-Literals"><a href="#Basic-Value-Literals" class="headerlink" title="Basic Value Literals"></a>Basic Value Literals</h2><p>A literal of a value is a <strong>text representation</strong> of the value in code. A value may have many lliterals. The literals denoting values of basic types are called basic value literals.</p>
<h3 id="Boolean-Value-Literals"><a href="#Boolean-Value-Literals" class="headerlink" title="Boolean Value Literals"></a>Boolean Value Literals</h3><p><code>false</code> and <code>true</code> could view as the boolean literals.</p>
<h3 id="Numeric-Value-Literals"><a href="#Numeric-Value-Literals" class="headerlink" title="Numeric Value Literals"></a>Numeric Value Literals</h3><p><strong>Integer value literals</strong></p>
<p>There are four integer value literal forms, the decimal form, the octal form, the hex form and the binary form. For example  the value 15 could represent as  follow:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0xF</span> <span class="comment">// the hex form (starts with a &quot;0x&quot; or &quot;0X&quot;)</span></span><br><span class="line"><span class="number">0XF</span></span><br><span class="line"></span><br><span class="line"><span class="number">017</span> <span class="comment">// the octal form (starts with a &quot;0&quot;, &quot;0o&quot; or &quot;0O&quot;)</span></span><br><span class="line"><span class="number">0</span>o17</span><br><span class="line"><span class="number">0</span>O17</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>b1111 <span class="comment">// the binary form (starts with a &quot;0b&quot; or &quot;0B&quot;)</span></span><br><span class="line"><span class="number">0</span>B1111</span><br><span class="line"></span><br><span class="line"><span class="number">15</span> <span class="comment">// the decimal form (starts without a &quot;0&quot;)</span></span><br></pre></td></tr></table></figure>
<p><strong>Floating-point value literals</strong></p>
<ul>
<li>Reference : Go 101</li>
</ul>
<p><strong>Imaginary value literals</strong></p>
<ul>
<li>Reference : Go 101</li>
</ul>
<p><strong>Tips:</strong></p>
<ul>
<li><p>Use <code>_</code> in numeric literal for better readability;</p>
<p>underscores <code>_</code> can appear in integer, floating-point and imaginary literals as digit separators to enhance code readability. But please note, in a numeric literal,</p>
<ul>
<li>any <code>_</code> is not allowed to be used as the first or the last character of the literal,</li>
<li>the two sides of any <code>_</code> must be either literal prefixes (such as <code>0X</code>) or legal digit characters.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Legal ones:</span></span><br><span class="line"><span class="number">6</span>_9          <span class="comment">// == 69</span></span><br><span class="line"><span class="number">0</span>_33_77_22   <span class="comment">// == 0337722</span></span><br><span class="line"><span class="number">0</span>x_Bad_Face  <span class="comment">// == 0xBadFace</span></span><br><span class="line"><span class="number">0</span>X_1F_FFP<span class="number">-16</span> <span class="comment">// == 0X1FFFP-16</span></span><br><span class="line"><span class="number">0</span>b1011_0111 + <span class="number">0xA</span>_B.Fp2i</span><br><span class="line"></span><br><span class="line"><span class="comment">// Illegal ones:</span></span><br><span class="line">_69        <span class="comment">// _ can&#x27;t appear as the first character</span></span><br><span class="line"><span class="number">69</span>_        <span class="comment">// _ can&#x27;t appear as the last character</span></span><br><span class="line"><span class="number">6</span>__9       <span class="comment">// one side of _ is a illegal character</span></span><br><span class="line"><span class="number">0</span>_xBadFace <span class="comment">// &quot;x&quot; is not a legal octal digit</span></span><br><span class="line"><span class="number">1</span>_<span class="number">.5</span>       <span class="comment">// &quot;.&quot; is not a legal octal digit</span></span><br><span class="line"><span class="number">1.</span>_5       <span class="comment">// &quot;.&quot; is not a legal octal digit</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>**rune value literals **</p>
<p>Rune types are special integer types, so all rune values can be denoted by integer literals. On the ather hand, many values of all kinds of integer could represend by rune literal .</p>
<p>A rune value is intended to store a Unicode code point. Generally, we can view a code point as a Unicode character, but we should know that some Unicode characters are composed of more than one code points each.</p>
<p>A rune literal is expressed as one or more characters enclosed in a pair of quotes. The enclosed characters denote one Unicode code point value. There are some minor variants of the rune literal form. The most popular form of rune literals is just to enclose the characters denoted by rune values between two single quotes. For example</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span> <span class="comment">// an English character</span></span><br><span class="line"><span class="string">&#x27;π&#x27;</span></span><br><span class="line"><span class="string">&#x27;众&#x27;</span> <span class="comment">// a Chinese character</span></span><br></pre></td></tr></table></figure>
<p>The following rune literal variants are equivalent to <code>&#39;a&#39;</code> (the Unicode value of character <code>a</code> is 97).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 141 is the octal representation of decimal number 97.</span><br><span class="line">&#39;\141&#39;</span><br><span class="line">&#x2F;&#x2F; 61 is the hex representation of decimal number 97.</span><br><span class="line">&#39;\x61&#39;</span><br><span class="line">&#39;\u0061&#39;</span><br><span class="line">&#39;\U00000061&#39;</span><br></pre></td></tr></table></figure>
<p>Please note, <code>\</code> must be followed by exactly three octal digits to represent a byte value, <code>\x</code> must be followed by exactly two hex digits to represent a byte value, <code>\u</code> must be followed by exactly four hex digits to represent a rune value, and <code>\U</code> must be followed by exactly eight hex digits to represent a rune value. Each such octal or hex digit sequence must represent a legal Unicode code point, otherwise, it fails to compile.</p>
<p>The following program will print 7 <code>true</code> texts.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="number">0</span>o17 == <span class="string">&#x27;\x0F&#x27;</span>)</span><br><span class="line">	<span class="built_in">println</span>(<span class="number">97</span> == <span class="string">&#x27;\x61&#x27;</span>)</span><br><span class="line">	<span class="built_in">println</span>(<span class="number">0x61</span> == <span class="string">&#x27;\x61&#x27;</span>)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&#x27;a&#x27;</span> == <span class="number">97</span>)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&#x27;a&#x27;</span> == <span class="string">&#x27;\141&#x27;</span>)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&#x27;a&#x27;</span> == <span class="string">&#x27;\x61&#x27;</span>)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&#x27;a&#x27;</span> == <span class="string">&#x27;\u0061&#x27;</span>)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&#x27;a&#x27;</span> == <span class="string">&#x27;\U00000061&#x27;</span>)</span><br><span class="line">	<span class="built_in">println</span>(<span class="number">0x61</span> == <span class="string">&#x27;\x61&#x27;</span>)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&#x27;\u4f17&#x27;</span> == <span class="string">&#x27;众&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="String-value-literals"><a href="#String-value-literals" class="headerlink" title="String value literals"></a>String value literals</h3><p>String values in Go are UTF-8 encoded. In fact, all Go source files must be UTF-8 encoding compatible.</p>
<p>There are two forms of string value literals, interpreted string literal (double quotes form) and raw string literal (back quotes form). For example, the following two string literals are equivalent:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The interpreted form.</span></span><br><span class="line"><span class="string">&quot;Hello\nworld!\n\&quot;你好世界\&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The raw form.</span></span><br><span class="line"><span class="string">`Hello</span></span><br><span class="line"><span class="string">world!</span></span><br><span class="line"><span class="string">&quot;你好世界&quot;`</span></span><br></pre></td></tr></table></figure>
<p>In the above interpreted string literal, each <code>\n</code> character pair will be escaped as one newline character, and each <code>\&quot;</code> character pair will be escaped as one double quote character. Most of such escape character pairs are the same as the escape character pairs used in rune literals introduced above, except that <code>\&quot;</code> is only legal in interpreted string literals and ``` is only legal in rune literals.</p>
<p>The character sequence of <code>\</code>, <code>\x</code>, <code>\u</code> and <code>\U</code> followed by several octal or hex digits introduced in the last section can also be used in interpreted string literals.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The following interpreted string literals are equivalent.</span></span><br><span class="line"><span class="string">&quot;\141\142\143&quot;</span></span><br><span class="line"><span class="string">&quot;\x61\x62\x63&quot;</span></span><br><span class="line"><span class="string">&quot;\x61b\x63&quot;</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The following interpreted string literals are equivalent.</span></span><br><span class="line"><span class="string">&quot;\u4f17\xe4\xba\xba&quot;</span></span><br><span class="line">      <span class="comment">// The Unicode of 众 is 4f17, which is</span></span><br><span class="line">      <span class="comment">// UTF-8 encoded as three bytes: e4 bc 97.</span></span><br><span class="line"><span class="string">&quot;\xe4\xbc\x97\u4eba&quot;</span></span><br><span class="line">      <span class="comment">// The Unicode of 人 is 4eba, which is</span></span><br><span class="line">      <span class="comment">// UTF-8 encoded as three bytes: e4 ba ba.</span></span><br><span class="line"><span class="string">&quot;\xe4\xbc\x97\xe4\xba\xba&quot;</span></span><br><span class="line"><span class="string">&quot;众人&quot;</span></span><br></pre></td></tr></table></figure>
<p>Please note that each English character (code point) is represented with one byte, but each Chinese character (code point) is represented with three bytes.</p>
<p>In a raw string literal, no character sequences will be escaped. The back quote character is not allowed to appear in a raw string literal. To get better cross-platform compatibility, carriage return characters (Unicode code point <code>0x0D</code>) inside raw string literals will be discarded.</p>
<p>Zero values of string types can be denoted as <code>&quot;&quot;</code> or ```` in literal.</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_Fundamental_Learning_Keyword_Identifiers</title>
    <url>/2022/06/29/Go-Fundamental-Learning-Keyword-Identifiers/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Keywords"><a href="#Keywords" class="headerlink" title="Keywords"></a>Keywords</h2><p><strong>keywords</strong> are <strong>original</strong> ideneifiers which help complier to understand and parse user code</p>
<ul>
<li><p>Declare keywords</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>, <span class="function"><span class="keyword">func</span>, <span class="title">import</span>, <span class="title">package</span>, <span class="title">type</span>, <span class="title">var</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>Type denotation keywords</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">chan</span>, <span class="keyword">interface</span>, <span class="keyword">map</span>, <span class="keyword">struct</span></span><br></pre></td></tr></table></figure></li>
<li><p>Control flow keywords</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span>, <span class="keyword">case</span>, <span class="keyword">continue</span>, <span class="keyword">default</span>, <span class="keyword">else</span>, <span class="keyword">fallthrough</span>, <span class="keyword">for</span>, <span class="keyword">goto</span>, <span class="keyword">if</span>, <span class="keyword">range</span>, <span class="keyword">return</span>, <span class="keyword">select</span>, <span class="keyword">switch</span>, <span class="keyword">defer</span>, <span class="keyword">go</span></span><br></pre></td></tr></table></figure>
<h2 id="Idenfiers"><a href="#Idenfiers" class="headerlink" title="Idenfiers"></a>Idenfiers</h2></li>
</ul>
<p>Idenfiers ,defined by user, is used to idenfie something. Compose by : Unicode Letter , Unicode Number, Underscore <code>_</code>;</p>
<ul>
<li><p><strong>Keywords can not be used as idenfiers</strong></p>
</li>
<li><p><strong>Idenfier <code>_</code> is a special idenfier, called blank idenfier</strong></p>
</li>
<li><p><strong>Export (Public) identifier is start with upper case unicode Letter</strong> </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Player_9</span><br><span class="line">DoSomething</span><br><span class="line">VERSION</span><br><span class="line">Ĝo</span><br><span class="line">Π</span><br></pre></td></tr></table></figure></li>
<li><p><strong>UnExport (Private) identifier do not start with upper case unicode letter</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_</span><br><span class="line">_status</span><br><span class="line">memStat</span><br><span class="line">book</span><br><span class="line">π</span><br><span class="line">一个类型</span><br><span class="line">변수</span><br><span class="line">エラ</span><br></pre></td></tr></table></figure></li>
<li><p><strong>illegal identifier</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Starting with a Unicode digit.</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">3</span>apples</span><br><span class="line"></span><br><span class="line"><span class="comment">// Containing Unicode characters not</span></span><br><span class="line"><span class="comment">// satisfying the requirements.</span></span><br><span class="line">a.b</span><br><span class="line">*ptr</span><br><span class="line">$name</span><br><span class="line">a@b.c</span><br><span class="line"></span><br><span class="line"><span class="comment">// These are keywords.</span></span><br><span class="line"><span class="keyword">type</span></span><br><span class="line"><span class="keyword">range</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_Fundamental_Learning_Operators</title>
    <url>/2022/06/29/Go-Fundamental-Learning-Operators/</url>
    <content><![CDATA[<ul>
<li><a href="https://go101.org/article/operators.html#:~:text=Go%20supports%20five%20basic%20binary%20arithmetic%20operators%3A%20The,explain%20how%20these%20operator%20operations%20work%20in%20detail.">Reference</a></li>
</ul>
<a id="more"></a>

<h2 id="Defination"><a href="#Defination" class="headerlink" title="Defination"></a>Defination</h2><p>An <code>Operator</code> in a programming language is a symbol that tell the compiler to perform specific mathematical, relation or logical operation and got the result.</p>
<h3 id="Binary-Operator-Unary-Operator"><a href="#Binary-Operator-Unary-Operator" class="headerlink" title="Binary Operator || Unary Operator"></a>Binary Operator || Unary Operator</h3><p>A binary operator operation takes two operands and a unary operator operation takes only one operand.</p>
<h2 id="Operators-Precedence-In-Go"><a href="#Operators-Precedence-In-Go" class="headerlink" title="Operators Precedence In Go"></a>Operators Precedence In Go</h2><p>The following is the operator precedence in Go. </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">*   /   %   &lt;&lt;  &gt;&gt;  &amp;   &amp;^  <span class="comment">// first</span></span><br><span class="line">+   -   |   ^ <span class="comment">// second</span></span><br><span class="line">==  !=  &lt;   &lt;=  &gt;   &gt;= <span class="comment">// third</span></span><br><span class="line">&amp;&amp; <span class="comment">// fourth</span></span><br><span class="line">|| <span class="comment">// fifth</span></span><br></pre></td></tr></table></figure>
<p>Top ones have higher precedence. The operators in the same line have the same precedence. Of course <code>()</code> is used to promote precedence.</p>
<h2 id="Operators-in-Go"><a href="#Operators-in-Go" class="headerlink" title="Operators in Go"></a>Operators in Go</h2><h3 id="Operators-feature"><a href="#Operators-feature" class="headerlink" title="Operators feature"></a>Operators feature</h3><table>
<thead>
<tr>
<th>Type</th>
<th>Operator</th>
<th>Name</th>
<th>Feature</th>
</tr>
</thead>
<tbody><tr>
<td>Arithmetic_Binary_Basic</td>
<td>+</td>
<td>addition</td>
<td>Two Operands must be both values of the same numeric type.</td>
</tr>
<tr>
<td>Arithmetic_Binary_Basic</td>
<td>-</td>
<td>subtraction</td>
<td>Same with above one</td>
</tr>
<tr>
<td>Arithmetic_Binary_Basic</td>
<td>*</td>
<td>multiplication</td>
<td>Same with above one</td>
</tr>
<tr>
<td>Arithmetic_Binary_Basic</td>
<td>/</td>
<td>division</td>
<td>Same with above one</td>
</tr>
<tr>
<td>Arithmetic_Binary_Basic</td>
<td>%</td>
<td>remainder</td>
<td>Two Operands must be both values of the same integer type.</td>
</tr>
<tr>
<td>Arithmetic_Binary_Bitwise</td>
<td>&amp;</td>
<td>bitwise and</td>
<td>Same with above one</td>
</tr>
<tr>
<td>Arithmetic_Binary_Bitwise</td>
<td>|</td>
<td>bitwise or</td>
<td>Same with above one</td>
</tr>
<tr>
<td>Arithmetic_Binary_Bitwise</td>
<td>^</td>
<td>bitwise xor</td>
<td>Same with above one</td>
</tr>
<tr>
<td>Arithmetic_Binary_Bitwise</td>
<td>&amp;^</td>
<td>bitwise clear</td>
<td>Same with above one</td>
</tr>
<tr>
<td>Arithmetic_Binary_Bitwise</td>
<td>&lt;&lt;</td>
<td>bitwise left shift</td>
<td>The left operand must be an integer and the right operand must be also an integer</td>
</tr>
<tr>
<td>Arithmetic_Binary_Bitwise</td>
<td>&gt;&gt;</td>
<td>bitwise right shift</td>
<td>Same with above one</td>
</tr>
<tr>
<td>Arithmetic_Unary</td>
<td>+</td>
<td>positive</td>
<td><code>+n</code> is equivalent to <code>0 + n</code>.</td>
</tr>
<tr>
<td>Arithmetic_Unary</td>
<td>-</td>
<td>negative</td>
<td><code>-n</code> is equivalent to <code>0 - n</code>.</td>
</tr>
<tr>
<td>Arithmetic_Unary</td>
<td>^</td>
<td>bitwise complement</td>
<td><code>^n</code> is equivalent to <code>m ^ n</code>, where <code>m</code> is a value all of which bits are 1. For example, if the type of <code>n</code> is <code>int8</code>, then <code>m</code> is <code>-1</code>, and if the type of <code>n</code> is <code>uint8</code>, then <code>m</code> is <code>0xFF</code>.</td>
</tr>
<tr>
<td>String_Binary</td>
<td>+</td>
<td>string concatenation</td>
<td>The two operands must be both values of the same string type.</td>
</tr>
<tr>
<td>Boolean_Binary</td>
<td>&amp;&amp;</td>
<td>boolean and</td>
<td>The two operands must be both values of the same boolean type.</td>
</tr>
<tr>
<td>Boolean_Binary</td>
<td>||</td>
<td>boolean or</td>
<td>Same with above one</td>
</tr>
<tr>
<td>Boolean_Unary</td>
<td>!</td>
<td>boolean not</td>
<td>The type of the only operand must be a boolean type.</td>
</tr>
<tr>
<td>Comparsion_Binary</td>
<td>==</td>
<td>equal to</td>
<td>Generally, the types of its two operands must be the same</td>
</tr>
<tr>
<td>Comparsion_Binary</td>
<td>!=</td>
<td>not qeual to</td>
<td>Same with above one</td>
</tr>
<tr>
<td>Comparsion_Binary</td>
<td>&lt;</td>
<td>less thann</td>
<td>The two operands must be both values of the same integer type, floating-point type or string type.</td>
</tr>
<tr>
<td>Comparsion_Binary</td>
<td>&lt;=</td>
<td>less than or equal to</td>
<td>Same with above one</td>
</tr>
<tr>
<td>Comparsion_Binary</td>
<td>&gt;</td>
<td>larger than</td>
<td>Same with above one</td>
</tr>
<tr>
<td>Comparsion_Binary</td>
<td>&gt;=</td>
<td>larger than or equal to</td>
<td>Same with above one</td>
</tr>
</tbody></table>
<h3 id="Arithmetic-Operators-Tips"><a href="#Arithmetic-Operators-Tips" class="headerlink" title="Arithmetic Operators Tips"></a>Arithmetic Operators Tips</h3><p>There is some tips about arithmetic operators.</p>
<p><strong>About OverFlows</strong></p>
<p>Overflows are not allowed for typed constants but are allowed for non-constant and untyped constant, ether the values are intermediate or final results;</p>
<ul>
<li>Allowed:<ul>
<li>Untyped constant: the value wil not be truncated</li>
<li>Non constant: the vlue will be truncated;</li>
</ul>
</li>
<li>Not Allowed:<ul>
<li>Typed constant</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1.Results are non-constant, the result are allow with overflow condition</span></span><br><span class="line">	<span class="keyword">var</span> a, b <span class="keyword">uint8</span> = <span class="number">255</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> c = a + b</span><br><span class="line">	<span class="keyword">var</span> d = a &lt;&lt; <span class="number">1</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Over flow with non constant, the result with be truncated %v \n&quot;</span>, c)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Over flow with non constant, the result with be truncated %v \n&quot;</span>, d)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.Results are untyped constant, the result are allow with overflow condition</span></span><br><span class="line">	<span class="keyword">const</span> X = <span class="number">0x1FFFFFFF</span> * <span class="number">0x1FFFFFFF</span> <span class="comment">// overflow int, complie ok</span></span><br><span class="line">	<span class="keyword">const</span> R = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x1FFFFFFF</span>        <span class="comment">// overflow rune, complie ok</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Over flow with untyped constant, the result with be wrapped %v \n&quot;</span>, X)</span><br><span class="line">	<span class="comment">// fmt.Printf(&quot;Over flow with untyped constant, the result with be wrapped %v \n&quot;, R)</span></span><br><span class="line">	<span class="comment">// const R untyped rune = 52076478367</span></span><br><span class="line">	<span class="comment">//overflow rune cannot use R (untyped rune constant 52076478367) as rune value in argument to fmt.Printf (overflows)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3.Results are typed constant, the result are not allow with overflow condition</span></span><br><span class="line">	<span class="keyword">const</span> Y = <span class="number">128</span> - <span class="keyword">int8</span>(<span class="number">1</span>)  <span class="comment">// error: 128 overflows int8</span></span><br><span class="line">	<span class="keyword">const</span> Z = <span class="keyword">uint8</span>(<span class="number">255</span>) + <span class="number">1</span> <span class="comment">// error: 256 overflow uint8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>About the results of arithmetic operator operations</strong></p>
<p>Except bitwise shift operations, the result of a binary arithmetic operator operation</p>
<ul>
<li><p>is a typed value of the same type of the two operands if the two operands are both typed values of the same type.</p>
</li>
<li><p>is a typed value of the same type of the typed operand if only one of the two operands is a typed value.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In the computation, the other (untyped) value will be deduced as a value of the type of the typed operand. In other words, the untyped operand will be implicitly converted to the type of the typed operand.</span><br></pre></td></tr></table></figure></li>
<li><p>is still an untyped value if both of the two operands are untyped. The default type of the result value is one of the two default types and it is the one appears latter in this list: <code>int</code>, <code>rune</code>, <code>float64</code>, <code>complex128</code>. For example, if the default type of one untyped operand is <code>int</code>, and the other one is <code>rune</code>, then the default type of the result untyped value is <code>rune</code>.</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Three untyped values</span></span><br><span class="line">	<span class="comment">// There default types are : int rune(int32) complex</span></span><br><span class="line">	<span class="keyword">const</span> X, Y, Z = <span class="number">6</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">31i</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Default types are %T, %T, %T \n&quot;</span>, X, Y, Z)</span><br><span class="line">	<span class="comment">// Default types are int, int32, complex128</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Two typed values</span></span><br><span class="line">	<span class="keyword">var</span> a, b <span class="keyword">int</span> = X, Y</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Precendence: int&lt; rune&lt; flloat64&lt; complex128</span></span><br><span class="line">	<span class="comment">// type d is the default type rune</span></span><br><span class="line">	d := X + Y</span><br><span class="line">	<span class="comment">// type e is the variable type int</span></span><br><span class="line">	e := Y - a</span><br><span class="line">	<span class="comment">// type f it the variable type a and b , int</span></span><br><span class="line">	f := a * b</span><br><span class="line">	<span class="comment">// type g is the default type complex</span></span><br><span class="line">	g := Z * Y</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Types are %T, %T, %T, %T \n&quot;</span>, d, e, f, g)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Default types are int, int32, complex128 </span></span><br><span class="line"><span class="comment">// Types are int32, int, int, complex128 </span></span><br></pre></td></tr></table></figure>
<p><strong>About integer division and remainder operations</strong></p>
<p>Assume <code>x, y</code> are two operands with the same integer type, the quotient <code>q, x/y</code> and the remainder <code>r , x % y</code> satisfy <code>x = q * y + r</code>, where <code>|r| &lt; |y|</code>;</p>
<ul>
<li>the sign of <code>r</code> is always the same with <code>x</code>;</li>
<li>the result of <code>q</code> it toword to zero.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="number">5</span>/<span class="number">3</span>, <span class="number">5</span>%<span class="number">3</span>)     <span class="comment">// 1, 2</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="number">-5</span>/<span class="number">3</span>, <span class="number">-5</span>%<span class="number">3</span>)   <span class="comment">// -1, -2</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="number">5</span>/<span class="number">-3</span>, <span class="number">5</span>%<span class="number">-3</span>)   <span class="comment">// -1, 2</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="number">-5</span>/<span class="number">-3</span>, <span class="number">-5</span>%<span class="number">-3</span>) <span class="comment">// 1, -2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Using <code>op=</code> for binary arithmetic operators</strong></p>
<p>For a binary arithmetic operator <code>op</code>, <code>x = x op y</code> can be shortened to <code>x op= y</code>. In the short form, <code>x</code> will be only evaluated once.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="keyword">int8</span> = <span class="number">3</span>, <span class="number">5</span></span><br><span class="line">a += b</span><br><span class="line"><span class="built_in">println</span>(a) <span class="comment">// 8</span></span><br><span class="line">a *= a</span><br><span class="line"><span class="built_in">println</span>(a) <span class="comment">// 64</span></span><br><span class="line">a /= b</span><br><span class="line"><span class="built_in">println</span>(a) <span class="comment">// 12</span></span><br><span class="line">a %= b</span><br><span class="line"><span class="built_in">println</span>(a) <span class="comment">// 2</span></span><br><span class="line">b &lt;&lt;= <span class="keyword">uint</span>(a)</span><br><span class="line"><span class="built_in">println</span>(b) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_Fundamentall_Learning_Package import</title>
    <url>/2022/06/29/Go-Fundamentall-Learning-Package-import/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_Learning_Fundamental_Allocation</title>
    <url>/2022/06/29/Go-Learning-Fundamental-Allocation/</url>
    <content><![CDATA[<ul>
<li>Reference: <a href="https://golang.google.cn/doc/effective_go#allocation_new">effective go</a></li>
</ul>
<a id="more"></a>

<h3 id="Allocation"><a href="#Allocation" class="headerlink" title="Allocation"></a>Allocation</h3><p>Three allocation methods in Go language, <code>new</code> <code>make</code> <code>composite literals</code>; While <code>new</code> and <code>make</code> are build in functions, <code>composite literals</code> is a kind of initialise format. Different allocation method with different feature.</p>
<p><strong><code>new</code></strong>: build in function, allocate memory , <strong>zeros</strong> it, ,return the pointer(*T) of type <code>T</code>.</p>
<ul>
<li><p>Apply Type: Any</p>
</li>
<li><p>Basic Format: <code>new(type)</code></p>
<ul>
<li><p>Zeros struct:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SyncedBuffer <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock    sync.Mutex</span><br><span class="line">    buffer  bytes.Buffer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p *SyncedBuffer = <span class="built_in">new</span>(SyncedBuffer) <span class="comment">// type *SyncedBuffer</span></span><br><span class="line">p := <span class="built_in">new</span>(SyncedBuffer)  <span class="comment">// type *SyncedBuffer</span></span><br></pre></td></tr></table></figure></li>
<li><p>Zeros slice:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *[]<span class="keyword">int</span> = <span class="built_in">new</span>([]<span class="keyword">int</span>)       <span class="comment">// allocates slice structure; *p == nil; </span></span><br><span class="line">p := <span class="built_in">new</span>([]<span class="keyword">int</span>)					<span class="comment">//allocates slice structure; *p == nil; </span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong><code>make</code></strong>:build in function,  allocate memory, <strong>initialized</strong> it, return the value(T) of type <code>T</code> .</p>
<ul>
<li><p>Aapply Type: only slices, maps, channels</p>
</li>
<li><p>Basic Format: <code>make(type , length , capacity)</code></p>
<ul>
<li><p>Initialized Slice:</p>
<p>A slice, for example, is a three-item descriptor containing a pointer to the data (inside an array), the length, and the capacity, and until those items are initialized, the slice is <code>nil</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>allocates an array of 100 ints and then creates a slice structure with length 10 and a capacity of 100 pointing at the first 10 elements of the array. When making a slice, the capacity can be omitted;</p>
</li>
</ul>
</li>
</ul>
<p><strong><code>composite literals</code></strong>:  a kind of initialise format, allocate memory, <strong>initialized</strong> it , return the value(T) of type <code>T</code></p>
<ul>
<li><p>Apply Type: Any</p>
</li>
<li><p>Basic Format: <code>Type&#123;value_0, ..., value_n&#125;</code> or <code>Type&#123;item_y : value_x, item_x: value_x, ... &#125;</code></p>
<ul>
<li><p>Initialized Slice:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> figure out </span></span><br><span class="line">s := []<span class="keyword">string</span>      &#123;Enone: <span class="string">&quot;no error&quot;</span>, Eio: <span class="string">&quot;Eio&quot;</span>, Einval: <span class="string">&quot;invalid argument&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Initialized Struct:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> *<span class="title">File</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    f := File&#123;fd, name, <span class="literal">nil</span>, <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;f</span><br><span class="line">    <span class="comment">//  equals to:   return &amp;File&#123;fd, name, nil, 0&#125;</span></span><br><span class="line">    <span class="comment">//  equals to:  return &amp;File&#123;fd: fd, name: name&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_Learning_Fundamental_Concurrency_Reflection</title>
    <url>/2022/06/29/Go-Learning-Fundamental-Concurrency-Reflection/</url>
    <content><![CDATA[<p><strong><a href="https://github.com/quii/learn-go-with-tests/tree/main/reflection">You can find all the code for this chapter here</a></strong></p>
<p><a href="https://twitter.com/peterbourgon/status/1011403901419937792?s=09">From Twitter</a></p>
<blockquote>
<p>golang challenge: write a function <code>walk(x interface&#123;&#125;, fn func(string))</code> which takes a struct <code>x</code> and calls <code>fn</code> for all strings fields found inside. difficulty level: recursively.</p>
</blockquote>
<a id="more"></a>

<p>To do this we will need to use <em>reflection</em>.</p>
<blockquote>
<p>Reflection in computing is the ability of a program to examine its own structure, particularly through types; it’s a form of metaprogramming. It’s also a great source of confusion.</p>
</blockquote>
<p>From <a href="https://blog.golang.org/laws-of-reflection">The Go Blog: Reflection</a></p>
<h2 id="What-is-interface"><a href="#What-is-interface" class="headerlink" title="What is interface?"></a>What is <code>interface</code>?</h2><p>We have enjoyed the type-safety that Go has offered us in terms of functions that work with known types, such as <code>string</code>, <code>int</code> and our own types like <code>BankAccount</code>.</p>
<p>This means that we get some documentation for free and the compiler will complain if you try and pass the wrong type to a function.</p>
<p>You may come across scenarios though where you want to write a function where you don’t know the type at compile time.</p>
<p>Go lets us get around this with the type <code>interface&#123;&#125;</code> which you can think of as just <em>any</em> type.</p>
<p>So <code>walk(x interface&#123;&#125;, fn func(string))</code> will accept any value for <code>x</code>.</p>
<h3 id="So-why-not-use-interface-for-everything-and-have-really-flexible-functions"><a href="#So-why-not-use-interface-for-everything-and-have-really-flexible-functions" class="headerlink" title="So why not use interface for everything and have really flexible functions?"></a>So why not use <code>interface</code> for everything and have really flexible functions?</h3><ul>
<li>As a user of a function that takes <code>interface</code> you lose type safety. What if you meant to pass <code>Foo.bar</code> of type <code>string</code> into a function but instead did <code>Foo.baz</code> which is an <code>int</code>? The compiler won’t be able to inform you of your mistake. You also have no idea <em>what</em> you’re allowed to pass to a function. Knowing that a function takes a <code>UserService</code> for instance is very useful.</li>
<li>As a writer of such a function, you have to be able to inspect <em>anything</em> that has been passed to you and try and figure out what the type is and what you can do with it. This is done using <em>reflection</em>. This can be quite clumsy and difficult to read and is generally less performant (as you have to do checks at runtime).</li>
</ul>
<p>In short only use reflection if you really need to.</p>
<p>If you want polymorphic functions, consider if you could design it around an interface (not <code>interface</code>, confusingly) so that users can use your function with multiple types if they implement whatever methods you need for your function to work.</p>
<p>Our function will need to be able to work with lots of different things. As always we’ll take an iterative approach, writing tests for each new thing we want to support and refactoring along the way until we’re done.</p>
<h2 id="Write-the-test-first"><a href="#Write-the-test-first" class="headerlink" title="Write the test first"></a>Write the test first</h2><p>We’ll want to call our function with a struct that has a string field in it (<code>x</code>). Then we can spy on the function (<code>fn</code>) passed in to see if it is called.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestWalk</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    expected := <span class="string">&quot;Chris&quot;</span></span><br><span class="line">    <span class="keyword">var</span> got []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    x := <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">    &#125;&#123;expected&#125;</span><br><span class="line"></span><br><span class="line">    walk(x, <span class="function"><span class="keyword">func</span><span class="params">(input <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        got = <span class="built_in">append</span>(got, input)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(got) != <span class="number">1</span> &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;wrong number of function calls, got %d want %d&quot;</span>, <span class="built_in">len</span>(got), <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>We want to store a slice of strings (<code>got</code>) which stores which strings were passed into <code>fn</code> by <code>walk</code>. Often in previous chapters, we have made dedicated types for this to spy on function/method invocations but in this case, we can just pass in an anonymous function for <code>fn</code> that closes over <code>got</code>.</li>
<li>We use an anonymous <code>struct</code> with a <code>Name</code> field of type string to go for the simplest “happy” path.</li>
<li>Finally, call <code>walk</code> with <code>x</code> and the spy and for now just check the length of <code>got</code>, we’ll be more specific with our assertions once we’ve got something very basic working.</li>
</ul>
<h2 id="Try-to-run-the-test"><a href="#Try-to-run-the-test" class="headerlink" title="Try to run the test"></a>Try to run the test</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;reflection_test.go:21:2: undefined: walk</span><br></pre></td></tr></table></figure>
<h2 id="Write-the-minimal-amount-of-code-for-the-test-to-run-and-check-the-failing-test-output"><a href="#Write-the-minimal-amount-of-code-for-the-test-to-run-and-check-the-failing-test-output" class="headerlink" title="Write the minimal amount of code for the test to run and check the failing test output"></a>Write the minimal amount of code for the test to run and check the failing test output</h2><p>We need to define <code>walk</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Try and run the test again</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestWalk</span><br><span class="line">--- FAIL: TestWalk (0.00s)</span><br><span class="line">    reflection_test.go:19: wrong number of function calls, got 0 want 1</span><br><span class="line">FAIL</span><br></pre></td></tr></table></figure>
<h2 id="Write-enough-code-to-make-it-pass"><a href="#Write-enough-code-to-make-it-pass" class="headerlink" title="Write enough code to make it pass"></a>Write enough code to make it pass</h2><p>We can call the spy with any string to make this pass.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    fn(<span class="string">&quot;I still can&#x27;t believe South Korea beat Germany 2-0 to put them last in their group&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The test should now be passing. The next thing we’ll need to do is make a more specific assertion on what our <code>fn</code> is being called with.</p>
<h2 id="Write-the-test-first-1"><a href="#Write-the-test-first-1" class="headerlink" title="Write the test first"></a>Write the test first</h2><p>Add the following to the existing test to check the string passed to <code>fn</code> is correct</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> got[<span class="number">0</span>] != expected &#123;</span><br><span class="line">    t.Errorf(<span class="string">&quot;got %q, want %q&quot;</span>, got[<span class="number">0</span>], expected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Try-to-run-the-test-1"><a href="#Try-to-run-the-test-1" class="headerlink" title="Try to run the test"></a>Try to run the test</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestWalk</span><br><span class="line">--- FAIL: TestWalk (0.00s)</span><br><span class="line">    reflection_test.go:23: got &#39;I still can&#39;t believe South Korea beat Germany 2-0 to put them last in their group&#39;, want &#39;Chris&#39;</span><br><span class="line">FAIL</span><br></pre></td></tr></table></figure>
<h2 id="Write-enough-code-to-make-it-pass-1"><a href="#Write-enough-code-to-make-it-pass-1" class="headerlink" title="Write enough code to make it pass"></a>Write enough code to make it pass</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := reflect.ValueOf(x)</span><br><span class="line">    field := val.Field(<span class="number">0</span>)</span><br><span class="line">    fn(field.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This code is <em>very unsafe and very naive</em>, but remember: our goal when we are in “red” (the tests failing) is to write the smallest amount of code possible. We then write more tests to address our concerns.</p>
<p>We need to use reflection to have a look at <code>x</code> and try and look at its properties.</p>
<p>The <a href="https://godoc.org/reflect">reflect package</a> has a function <code>ValueOf</code> which returns us a <code>Value</code> of a given variable. This has ways for us to inspect a value, including its fields which we use on the next line.</p>
<p>We then make some very optimistic assumptions about the value passed in</p>
<ul>
<li>We look at the first and only field, there may be no fields at all which would cause a panic</li>
<li>We then call <code>String()</code> which returns the underlying value as a string but we know it would be wrong if the field was something other than a string.</li>
</ul>
<h2 id="Refactor"><a href="#Refactor" class="headerlink" title="Refactor"></a>Refactor</h2><p>Our code is passing for the simple case but we know our code has a lot of shortcomings.</p>
<p>We’re going to be writing a number of tests where we pass in different values and checking the array of strings that <code>fn</code> was called with.</p>
<p>We should refactor our test into a table based test to make this easier to continue testing new scenarios.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestWalk</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    cases := []<span class="keyword">struct</span>&#123;</span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        Input <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">        ExpectedCalls []<span class="keyword">string</span></span><br><span class="line">    &#125; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;Struct with one string field&quot;</span>,</span><br><span class="line">            <span class="keyword">struct</span> &#123;</span><br><span class="line">                Name <span class="keyword">string</span></span><br><span class="line">            &#125;&#123; <span class="string">&quot;Chris&quot;</span>&#125;,</span><br><span class="line">            []<span class="keyword">string</span>&#123;<span class="string">&quot;Chris&quot;</span>&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, test := <span class="keyword">range</span> cases &#123;</span><br><span class="line">        t.Run(test.Name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            <span class="keyword">var</span> got []<span class="keyword">string</span></span><br><span class="line">            walk(test.Input, <span class="function"><span class="keyword">func</span><span class="params">(input <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">                got = <span class="built_in">append</span>(got, input)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> !reflect.DeepEqual(got, test.ExpectedCalls) &#123;</span><br><span class="line">                t.Errorf(<span class="string">&quot;got %v, want %v&quot;</span>, got, test.ExpectedCalls)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now we can easily add a scenario to see what happens if we have more than one string field.</p>
<h2 id="Write-the-test-first-2"><a href="#Write-the-test-first-2" class="headerlink" title="Write the test first"></a>Write the test first</h2><p>Add the following scenario to the <code>cases</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Struct with two string fields&quot;</span>,</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        City <span class="keyword">string</span></span><br><span class="line">    &#125;&#123;<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;London&quot;</span>&#125;,</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;London&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Try-to-run-the-test-2"><a href="#Try-to-run-the-test-2" class="headerlink" title="Try to run the test"></a>Try to run the test</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestWalk&#x2F;Struct_with_two_string_fields</span><br><span class="line">    --- FAIL: TestWalk&#x2F;Struct_with_two_string_fields (0.00s)</span><br><span class="line">        reflection_test.go:40: got [Chris], want [Chris London]</span><br></pre></td></tr></table></figure>
<h2 id="Write-enough-code-to-make-it-pass-2"><a href="#Write-enough-code-to-make-it-pass-2" class="headerlink" title="Write enough code to make it pass"></a>Write enough code to make it pass</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;val.NumField(); i++ &#123;</span><br><span class="line">        field := val.Field(i)</span><br><span class="line">        fn(field.String())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>val</code> has a method <code>NumField</code> which returns the number of fields in the value. This lets us iterate over the fields and call <code>fn</code> which passes our test.</p>
<h2 id="Refactor-1"><a href="#Refactor-1" class="headerlink" title="Refactor"></a>Refactor</h2><p>It doesn’t look like there’s any obvious refactors here that would improve the code so let’s press on.</p>
<p>The next shortcoming in <code>walk</code> is that it assumes every field is a <code>string</code>. Let’s write a test for this scenario.</p>
<h2 id="Write-the-test-first-3"><a href="#Write-the-test-first-3" class="headerlink" title="Write the test first"></a>Write the test first</h2><p>Add the following case</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Struct with non string field&quot;</span>,</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        Age  <span class="keyword">int</span></span><br><span class="line">    &#125;&#123;<span class="string">&quot;Chris&quot;</span>, <span class="number">33</span>&#125;,</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;Chris&quot;</span>&#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="Try-to-run-the-test-3"><a href="#Try-to-run-the-test-3" class="headerlink" title="Try to run the test"></a>Try to run the test</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestWalk&#x2F;Struct_with_non_string_field</span><br><span class="line">    --- FAIL: TestWalk&#x2F;Struct_with_non_string_field (0.00s)</span><br><span class="line">        reflection_test.go:46: got [Chris &lt;int Value&gt;], want [Chris]</span><br></pre></td></tr></table></figure>
<h2 id="Write-enough-code-to-make-it-pass-3"><a href="#Write-enough-code-to-make-it-pass-3" class="headerlink" title="Write enough code to make it pass"></a>Write enough code to make it pass</h2><p>We need to check that the type of the field is a <code>string</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.NumField(); i++ &#123;</span><br><span class="line">        field := val.Field(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> field.Kind() == reflect.String &#123;</span><br><span class="line">            fn(field.String())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We can do that by checking its <a href="https://godoc.org/reflect#Kind"><code>Kind</code></a>.</p>
<h2 id="Refactor-2"><a href="#Refactor-2" class="headerlink" title="Refactor"></a>Refactor</h2><p>Again it looks like the code is reasonable enough for now.</p>
<p>The next scenario is what if it isn’t a “flat” <code>struct</code>? In other words, what happens if we have a <code>struct</code> with some nested fields?</p>
<h2 id="Write-the-test-first-4"><a href="#Write-the-test-first-4" class="headerlink" title="Write the test first"></a>Write the test first</h2><p>We have been using the anonymous struct syntax to declare types ad-hocly for our tests so we could continue to do that like so</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Nested fields&quot;</span>,</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="keyword">string</span></span><br><span class="line">        Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">            Age  <span class="keyword">int</span></span><br><span class="line">            City <span class="keyword">string</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#123;<span class="string">&quot;Chris&quot;</span>, <span class="keyword">struct</span> &#123;</span><br><span class="line">        Age  <span class="keyword">int</span></span><br><span class="line">        City <span class="keyword">string</span></span><br><span class="line">    &#125;&#123;<span class="number">33</span>, <span class="string">&quot;London&quot;</span>&#125;&#125;,</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;London&quot;</span>&#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>But we can see that when you get inner anonymous structs the syntax gets a little messy. <a href="https://github.com/golang/go/issues/12854">There is a proposal to make it so the syntax would be nicer</a>.</p>
<p>Let’s just refactor this by making a known type for this scenario and reference it in the test. There is a little indirection in that some of the code for our test is outside the test but readers should be able to infer the structure of the <code>struct</code> by looking at the initialisation.</p>
<p>Add the following type declarations somewhere in your test file</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    Profile Profile</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">    City <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now we can add this to our cases which reads a lot clearer than before</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Nested fields&quot;</span>,</span><br><span class="line">    Person&#123;</span><br><span class="line">        <span class="string">&quot;Chris&quot;</span>,</span><br><span class="line">        Profile&#123;<span class="number">33</span>, <span class="string">&quot;London&quot;</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;London&quot;</span>&#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="Try-to-run-the-test-4"><a href="#Try-to-run-the-test-4" class="headerlink" title="Try to run the test"></a>Try to run the test</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestWalk&#x2F;Nested_fields</span><br><span class="line">    --- FAIL: TestWalk&#x2F;Nested_fields (0.00s)</span><br><span class="line">        reflection_test.go:54: got [Chris], want [Chris London]</span><br></pre></td></tr></table></figure>
<p>The problem is we’re only iterating on the fields on the first level of the type’s hierarchy.</p>
<h2 id="Write-enough-code-to-make-it-pass-4"><a href="#Write-enough-code-to-make-it-pass-4" class="headerlink" title="Write enough code to make it pass"></a>Write enough code to make it pass</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.NumField(); i++ &#123;</span><br><span class="line">        field := val.Field(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> field.Kind() == reflect.String &#123;</span><br><span class="line">            fn(field.String())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> field.Kind() == reflect.Struct &#123;</span><br><span class="line">            walk(field.Interface(), fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The solution is quite simple, we again inspect its <code>Kind</code> and if it happens to be a <code>struct</code> we just call <code>walk</code> again on that inner <code>struct</code>.</p>
<h2 id="Refactor-3"><a href="#Refactor-3" class="headerlink" title="Refactor"></a>Refactor</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.NumField(); i++ &#123;</span><br><span class="line">        field := val.Field(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> field.Kind() &#123;</span><br><span class="line">        <span class="keyword">case</span> reflect.String:</span><br><span class="line">            fn(field.String())</span><br><span class="line">        <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">            walk(field.Interface(), fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When you’re doing a comparison on the same value more than once <em>generally</em> refactoring into a <code>switch</code> will improve readability and make your code easier to extend.</p>
<p>What if the value of the struct passed in is a pointer?</p>
<h2 id="Write-the-test-first-5"><a href="#Write-the-test-first-5" class="headerlink" title="Write the test first"></a>Write the test first</h2><p>Add this case</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Pointers to things&quot;</span>,</span><br><span class="line">    &amp;Person&#123;</span><br><span class="line">        <span class="string">&quot;Chris&quot;</span>,</span><br><span class="line">        Profile&#123;<span class="number">33</span>, <span class="string">&quot;London&quot;</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;London&quot;</span>&#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="Try-to-run-the-test-5"><a href="#Try-to-run-the-test-5" class="headerlink" title="Try to run the test"></a>Try to run the test</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestWalk&#x2F;Pointers_to_things</span><br><span class="line">panic: reflect: call of reflect.Value.NumField on ptr Value [recovered]</span><br><span class="line">    panic: reflect: call of reflect.Value.NumField on ptr Value</span><br></pre></td></tr></table></figure>
<h2 id="Write-enough-code-to-make-it-pass-5"><a href="#Write-enough-code-to-make-it-pass-5" class="headerlink" title="Write enough code to make it pass"></a>Write enough code to make it pass</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> val.Kind() == reflect.Ptr &#123;</span><br><span class="line">        val = val.Elem()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.NumField(); i++ &#123;</span><br><span class="line">        field := val.Field(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> field.Kind() &#123;</span><br><span class="line">        <span class="keyword">case</span> reflect.String:</span><br><span class="line">            fn(field.String())</span><br><span class="line">        <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">            walk(field.Interface(), fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You can’t use <code>NumField</code> on a pointer <code>Value</code>, we need to extract the underlying value before we can do that by using <code>Elem()</code>.</p>
<h2 id="Refactor-4"><a href="#Refactor-4" class="headerlink" title="Refactor"></a>Refactor</h2><p>Let’s encapsulate the responsibility of extracting the <code>reflect.Value</code> from a given <code>interface&#123;&#125;</code> into a function.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := getValue(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.NumField(); i++ &#123;</span><br><span class="line">        field := val.Field(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> field.Kind() &#123;</span><br><span class="line">        <span class="keyword">case</span> reflect.String:</span><br><span class="line">            fn(field.String())</span><br><span class="line">        <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">            walk(field.Interface(), fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getValue</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">reflect</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line">    val := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> val.Kind() == reflect.Ptr &#123;</span><br><span class="line">        val = val.Elem()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This actually adds <em>more</em> code but I feel the abstraction level is right.</p>
<ul>
<li>Get the <code>reflect.Value</code> of <code>x</code> so I can inspect it, I don’t care how.</li>
<li>Iterate over the fields, doing whatever needs to be done depending on its type.</li>
</ul>
<p>Next, we need to cover slices.</p>
<h2 id="Write-the-test-first-6"><a href="#Write-the-test-first-6" class="headerlink" title="Write the test first"></a>Write the test first</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Slices&quot;</span>,</span><br><span class="line">    []Profile &#123;</span><br><span class="line">        &#123;<span class="number">33</span>, <span class="string">&quot;London&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">34</span>, <span class="string">&quot;Reykjavík&quot;</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;London&quot;</span>, <span class="string">&quot;Reykjavík&quot;</span>&#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="Try-to-run-the-test-6"><a href="#Try-to-run-the-test-6" class="headerlink" title="Try to run the test"></a>Try to run the test</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestWalk&#x2F;Slices</span><br><span class="line">panic: reflect: call of reflect.Value.NumField on slice Value [recovered]</span><br><span class="line">    panic: reflect: call of reflect.Value.NumField on slice Value</span><br></pre></td></tr></table></figure>
<h2 id="Write-the-minimal-amount-of-code-for-the-test-to-run-and-check-the-failing-test-output-1"><a href="#Write-the-minimal-amount-of-code-for-the-test-to-run-and-check-the-failing-test-output-1" class="headerlink" title="Write the minimal amount of code for the test to run and check the failing test output"></a>Write the minimal amount of code for the test to run and check the failing test output</h2><p>This is similar to the pointer scenario before, we are trying to call <code>NumField</code> on our <code>reflect.Value</code> but it doesn’t have one as it’s not a struct.</p>
<h2 id="Write-enough-code-to-make-it-pass-6"><a href="#Write-enough-code-to-make-it-pass-6" class="headerlink" title="Write enough code to make it pass"></a>Write enough code to make it pass</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := getValue(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> val.Kind() == reflect.Slice &#123;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; val.Len(); i++ &#123;</span><br><span class="line">            walk(val.Index(i).Interface(), fn)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.NumField(); i++ &#123;</span><br><span class="line">        field := val.Field(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> field.Kind() &#123;</span><br><span class="line">        <span class="keyword">case</span> reflect.String:</span><br><span class="line">            fn(field.String())</span><br><span class="line">        <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">            walk(field.Interface(), fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Refactor-5"><a href="#Refactor-5" class="headerlink" title="Refactor"></a>Refactor</h2><p>This works but it’s yucky. No worries, we have working code backed by tests so we are free to tinker all we like.</p>
<p>If you think a little abstractly, we want to call <code>walk</code> on either</p>
<ul>
<li>Each field in a struct</li>
<li>Each <em>thing</em> in a slice</li>
</ul>
<p>Our code at the moment does this but doesn’t reflect it very well. We just have a check at the start to see if it’s a slice (with a <code>return</code> to stop the rest of the code executing) and if it’s not we just assume it’s a struct.</p>
<p>Let’s rework the code so instead we check the type <em>first</em> and then do our work.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := getValue(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> val.Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;val.NumField(); i++ &#123;</span><br><span class="line">            walk(val.Field(i).Interface(), fn)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> reflect.Slice:</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;val.Len(); i++ &#123;</span><br><span class="line">            walk(val.Index(i).Interface(), fn)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> reflect.String:</span><br><span class="line">        fn(val.String())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Looking much better! If it’s a struct or a slice we iterate over its values calling <code>walk</code> on each one. Otherwise, if it’s a <code>reflect.String</code> we can call <code>fn</code>.</p>
<p>Still, to me it feels like it could be better. There’s repetition of the operation of iterating over fields/values and then calling <code>walk</code> but conceptually they’re the same.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := getValue(x)</span><br><span class="line"></span><br><span class="line">    numberOfValues := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> getField <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">reflect</span>.<span class="title">Value</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> val.Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.String:</span><br><span class="line">        fn(val.String())</span><br><span class="line">    <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">        numberOfValues = val.NumField()</span><br><span class="line">        getField = val.Field</span><br><span class="line">    <span class="keyword">case</span> reflect.Slice:</span><br><span class="line">        numberOfValues = val.Len()</span><br><span class="line">        getField = val.Index</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; numberOfValues; i++ &#123;</span><br><span class="line">        walk(getField(i).Interface(), fn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If the <code>value</code> is a <code>reflect.String</code> then we just call <code>fn</code> like normal.</p>
<p>Otherwise, our <code>switch</code> will extract out two things depending on the type</p>
<ul>
<li>How many fields there are</li>
<li>How to extract the <code>Value</code> (<code>Field</code> or <code>Index</code>)</li>
</ul>
<p>Once we’ve determined those things we can iterate through <code>numberOfValues</code> calling <code>walk</code> with the result of the <code>getField</code> function.</p>
<p>Now we’ve done this, handling arrays should be trivial.</p>
<h2 id="Write-the-test-first-7"><a href="#Write-the-test-first-7" class="headerlink" title="Write the test first"></a>Write the test first</h2><p>Add to the cases</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Arrays&quot;</span>,</span><br><span class="line">    [<span class="number">2</span>]Profile &#123;</span><br><span class="line">        &#123;<span class="number">33</span>, <span class="string">&quot;London&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">34</span>, <span class="string">&quot;Reykjavík&quot;</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;London&quot;</span>, <span class="string">&quot;Reykjavík&quot;</span>&#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="Try-to-run-the-test-7"><a href="#Try-to-run-the-test-7" class="headerlink" title="Try to run the test"></a>Try to run the test</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestWalk&#x2F;Arrays</span><br><span class="line">    --- FAIL: TestWalk&#x2F;Arrays (0.00s)</span><br><span class="line">        reflection_test.go:78: got [], want [London Reykjavík]</span><br></pre></td></tr></table></figure>
<h2 id="Write-enough-code-to-make-it-pass-7"><a href="#Write-enough-code-to-make-it-pass-7" class="headerlink" title="Write enough code to make it pass"></a>Write enough code to make it pass</h2><p>Arrays can be handled the same way as slices, so just add it to the case with a comma</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := getValue(x)</span><br><span class="line"></span><br><span class="line">    numberOfValues := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> getField <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">reflect</span>.<span class="title">Value</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> val.Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.String:</span><br><span class="line">        fn(val.String())</span><br><span class="line">    <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">        numberOfValues = val.NumField()</span><br><span class="line">        getField = val.Field</span><br><span class="line">    <span class="keyword">case</span> reflect.Slice, reflect.Array:</span><br><span class="line">        numberOfValues = val.Len()</span><br><span class="line">        getField = val.Index</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; numberOfValues; i++ &#123;</span><br><span class="line">        walk(getField(i).Interface(), fn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The next type we want to handle is <code>map</code>.</p>
<h2 id="Write-the-test-first-8"><a href="#Write-the-test-first-8" class="headerlink" title="Write the test first"></a>Write the test first</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Maps&quot;</span>,</span><br><span class="line">    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;Foo&quot;</span>: <span class="string">&quot;Bar&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Baz&quot;</span>: <span class="string">&quot;Boz&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="keyword">string</span>&#123;<span class="string">&quot;Bar&quot;</span>, <span class="string">&quot;Boz&quot;</span>&#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="Try-to-run-the-test-8"><a href="#Try-to-run-the-test-8" class="headerlink" title="Try to run the test"></a>Try to run the test</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestWalk&#x2F;Maps</span><br><span class="line">    --- FAIL: TestWalk&#x2F;Maps (0.00s)</span><br><span class="line">        reflection_test.go:86: got [], want [Bar Boz]</span><br></pre></td></tr></table></figure>
<h2 id="Write-enough-code-to-make-it-pass-8"><a href="#Write-enough-code-to-make-it-pass-8" class="headerlink" title="Write enough code to make it pass"></a>Write enough code to make it pass</h2><p>Again if you think a little abstractly you can see that <code>map</code> is very similar to <code>struct</code>, it’s just the keys are unknown at compile time.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := getValue(x)</span><br><span class="line"></span><br><span class="line">    numberOfValues := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> getField <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">reflect</span>.<span class="title">Value</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> val.Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.String:</span><br><span class="line">        fn(val.String())</span><br><span class="line">    <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">        numberOfValues = val.NumField()</span><br><span class="line">        getField = val.Field</span><br><span class="line">    <span class="keyword">case</span> reflect.Slice, reflect.Array:</span><br><span class="line">        numberOfValues = val.Len()</span><br><span class="line">        getField = val.Index</span><br><span class="line">    <span class="keyword">case</span> reflect.Map:</span><br><span class="line">        <span class="keyword">for</span> _, key := <span class="keyword">range</span> val.MapKeys() &#123;</span><br><span class="line">            walk(val.MapIndex(key).Interface(), fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; numberOfValues; i++ &#123;</span><br><span class="line">        walk(getField(i).Interface(), fn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>However, by design you cannot get values out of a map by index. It’s only done by <em>key</em>, so that breaks our abstraction, darn.</p>
<h2 id="Refactor-6"><a href="#Refactor-6" class="headerlink" title="Refactor"></a>Refactor</h2><p>How do you feel right now? It felt like maybe a nice abstraction at the time but now the code feels a little wonky.</p>
<p><em>This is OK!</em> Refactoring is a journey and sometimes we will make mistakes. A major point of TDD is it gives us the freedom to try these things out.</p>
<p>By taking small steps backed by tests this is in no way an irreversible situation. Let’s just put it back to how it was before the refactor.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">    val := getValue(x)</span><br><span class="line"></span><br><span class="line">    walkValue := <span class="function"><span class="keyword">func</span><span class="params">(value reflect.Value)</span></span> &#123;</span><br><span class="line">        walk(value.Interface(), fn)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> val.Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.String:</span><br><span class="line">        fn(val.String())</span><br><span class="line">    <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i&lt; val.NumField(); i++ &#123;</span><br><span class="line">            walkValue(val.Field(i))</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> reflect.Slice, reflect.Array:</span><br><span class="line">        <span class="keyword">for</span> i:= <span class="number">0</span>; i&lt;val.Len(); i++ &#123;</span><br><span class="line">            walkValue(val.Index(i))</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> reflect.Map:</span><br><span class="line">        <span class="keyword">for</span> _, key := <span class="keyword">range</span> val.MapKeys() &#123;</span><br><span class="line">            walkValue(val.MapIndex(key))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We’ve introduced <code>walkValue</code> which DRYs up the calls to <code>walk</code> inside our <code>switch</code> so that they only have to extract out the <code>reflect.Value</code>s from <code>val</code>.</p>
<h3 id="One-final-problem"><a href="#One-final-problem" class="headerlink" title="One final problem"></a>One final problem</h3><p>Remember that maps in Go do not guarantee order. So your tests will sometimes fail because we assert that the calls to <code>fn</code> are done in a particular order.</p>
<p>To fix this, we’ll need to move our assertion with the maps to a new test where we do not care about the order.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t.Run(<span class="string">&quot;with maps&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    aMap := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;Foo&quot;</span>: <span class="string">&quot;Bar&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Baz&quot;</span>: <span class="string">&quot;Boz&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> got []<span class="keyword">string</span></span><br><span class="line">    walk(aMap, <span class="function"><span class="keyword">func</span><span class="params">(input <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        got = <span class="built_in">append</span>(got, input)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    assertContains(t, got, <span class="string">&quot;Bar&quot;</span>)</span><br><span class="line">    assertContains(t, got, <span class="string">&quot;Boz&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Here is how <code>assertContains</code> is defined</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertContains</span><span class="params">(t testing.TB, haystack []<span class="keyword">string</span>, needle <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">    t.Helper()</span><br><span class="line">    contains := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> haystack &#123;</span><br><span class="line">        <span class="keyword">if</span> x == needle &#123;</span><br><span class="line">            contains = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !contains &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;expected %+v to contain %q but it didn&#x27;t&quot;</span>, haystack, needle)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The next type we want to handle is <code>chan</code>.</p>
<h2 id="Write-the-test-first-9"><a href="#Write-the-test-first-9" class="headerlink" title="Write the test first"></a>Write the test first</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t.Run(<span class="string">&quot;with channels&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">		aChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> Profile)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			aChannel &lt;- Profile&#123;<span class="number">33</span>, <span class="string">&quot;Berlin&quot;</span>&#125;</span><br><span class="line">			aChannel &lt;- Profile&#123;<span class="number">34</span>, <span class="string">&quot;Katowice&quot;</span>&#125;</span><br><span class="line">			<span class="built_in">close</span>(aChannel)</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> got []<span class="keyword">string</span></span><br><span class="line">		want := []<span class="keyword">string</span>&#123;<span class="string">&quot;Berlin&quot;</span>, <span class="string">&quot;Katowice&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		walk(aChannel, <span class="function"><span class="keyword">func</span><span class="params">(input <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">			got = <span class="built_in">append</span>(got, input)</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !reflect.DeepEqual(got, want) &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;got %v, want %v&quot;</span>, got, want)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Try-to-run-the-test-9"><a href="#Try-to-run-the-test-9" class="headerlink" title="Try to run the test"></a>Try to run the test</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--- FAIL: TestWalk (0.00s)</span><br><span class="line">    --- FAIL: TestWalk&#x2F;with_channels (0.00s)</span><br><span class="line">        reflection_test.go:115: got [], want [Berlin Katowice]</span><br></pre></td></tr></table></figure>
<h2 id="Write-enough-code-to-make-it-pass-9"><a href="#Write-enough-code-to-make-it-pass-9" class="headerlink" title="Write enough code to make it pass"></a>Write enough code to make it pass</h2><p>We can iterate through all values sent through channel until it was closed with Recv()</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">	val := getValue(x)</span><br><span class="line"></span><br><span class="line">	walkValue := <span class="function"><span class="keyword">func</span><span class="params">(value reflect.Value)</span></span> &#123;</span><br><span class="line">		walk(value.Interface(), fn)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> val.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.String:</span><br><span class="line">		fn(val.String())</span><br><span class="line">	<span class="keyword">case</span> reflect.Struct:</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.NumField(); i++ &#123;</span><br><span class="line">			walkValue(val.Field(i))</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Slice, reflect.Array:</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.Len(); i++ &#123;</span><br><span class="line">			walkValue(val.Index(i))</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Map:</span><br><span class="line">		<span class="keyword">for</span> _, key := <span class="keyword">range</span> val.MapKeys() &#123;</span><br><span class="line">			walkValue(val.MapIndex(key))</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Chan:</span><br><span class="line">		<span class="keyword">for</span> v, ok := val.Recv(); ok; v, ok = val.Recv() &#123;</span><br><span class="line">			walk(v.Interface(), fn)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The next type we want to handle is <code>func</code>.</p>
<h2 id="Write-the-test-first-10"><a href="#Write-the-test-first-10" class="headerlink" title="Write the test first"></a>Write the test first</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t.Run(<span class="string">&quot;with function&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">		aFunction := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(Profile, Profile)</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> Profile&#123;<span class="number">33</span>, <span class="string">&quot;Berlin&quot;</span>&#125;, Profile&#123;<span class="number">34</span>, <span class="string">&quot;Katowice&quot;</span>&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> got []<span class="keyword">string</span></span><br><span class="line">		want := []<span class="keyword">string</span>&#123;<span class="string">&quot;Berlin&quot;</span>, <span class="string">&quot;Katowice&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		walk(aFunction, <span class="function"><span class="keyword">func</span><span class="params">(input <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">			got = <span class="built_in">append</span>(got, input)</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !reflect.DeepEqual(got, want) &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;got %v, want %v&quot;</span>, got, want)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Try-to-run-the-test-10"><a href="#Try-to-run-the-test-10" class="headerlink" title="Try to run the test"></a>Try to run the test</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--- FAIL: TestWalk (0.00s)</span><br><span class="line">    --- FAIL: TestWalk&#x2F;with_function (0.00s)</span><br><span class="line">        reflection_test.go:132: got [], want [Berlin Katowice]</span><br></pre></td></tr></table></figure>
<h2 id="Write-enough-code-to-make-it-pass-10"><a href="#Write-enough-code-to-make-it-pass-10" class="headerlink" title="Write enough code to make it pass"></a>Write enough code to make it pass</h2><p>Non zero-argument functions do not seem to make a lot of sense in this scenario. But we should allow for arbitrary return values.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;, fn <span class="keyword">func</span>(input <span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">	val := getValue(x)</span><br><span class="line"></span><br><span class="line">	walkValue := <span class="function"><span class="keyword">func</span><span class="params">(value reflect.Value)</span></span> &#123;</span><br><span class="line">		walk(value.Interface(), fn)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> val.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.String:</span><br><span class="line">		fn(val.String())</span><br><span class="line">	<span class="keyword">case</span> reflect.Struct:</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.NumField(); i++ &#123;</span><br><span class="line">			walkValue(val.Field(i))</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Slice, reflect.Array:</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.Len(); i++ &#123;</span><br><span class="line">			walkValue(val.Index(i))</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Map:</span><br><span class="line">		<span class="keyword">for</span> _, key := <span class="keyword">range</span> val.MapKeys() &#123;</span><br><span class="line">			walkValue(val.MapIndex(key))</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Chan:</span><br><span class="line">		<span class="keyword">for</span> v, ok := val.Recv(); ok; v, ok = val.Recv() &#123;</span><br><span class="line">			walk(v.Interface(), fn)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Func:</span><br><span class="line">		valFnResult := val.Call(<span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">for</span> _, res := <span class="keyword">range</span> valFnResult &#123;</span><br><span class="line">			walk(res.Interface(), fn)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Wrapping-up"><a href="#Wrapping-up" class="headerlink" title="Wrapping up"></a>Wrapping up</h2><ul>
<li>Introduced some of the concepts from the <code>reflect</code> package.</li>
<li>Used recursion to traverse arbitrary data structures.</li>
<li>Did an in retrospect bad refactor but didn’t get too upset about it. By working iteratively with tests it’s not such a big deal.</li>
<li>This only covered a small aspect of reflection. <a href="https://blog.golang.org/laws-of-reflection">The Go blog has an excellent post covering more details</a>.</li>
<li>Now that you know about reflection, do your best to avoid using it.</li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_Learning_Fundamental_Concurrency_Channel</title>
    <url>/2022/06/29/Go-Learning-Fundamental-Concurrency-Channel/</url>
    <content><![CDATA[<ul>
<li>Refs: <a href="https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/concurrency">TDD</a>, <a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/goroutine.html">Go Chinese Doc</a></li>
</ul>
<a id="more"></a>

<blockquote>
<p>Channel  to help organize and control the communication between the different processes, allowing us to avoid a race condition bug.</p>
</blockquote>
<blockquote>
<p>Go语言的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。</p>
</blockquote>
<h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>Channel is a type of GO FUNDAMENTAL DATA STRUCTURE, that use to communicate with different Goroutine;</p>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>channel data structure is refs type;</p>
<h3 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.var</span><br><span class="line">var ch chan int</span><br><span class="line">ch &#x3D; make(chan int)</span><br><span class="line">&#x2F;&#x2F; 2. make</span><br><span class="line">ch :&#x3D; make(chan int)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_Learning_Fundamental_Init</title>
    <url>/2022/06/29/Go-Learning-Fundamental-Init/</url>
    <content><![CDATA[<ul>
<li>Reference: <a href="https://gobyexample.com/variables">Go With Example</a>, <a href="https://golang.google.cn/doc/effective_go#initialization">Effective Go</a>, <a href="https://www.topgoer.com/go%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F.html">Go Chinese Docs</a>,<a href="https://www.jianshu.com/p/08d6a4216e96">Blog</a></li>
</ul>
<a id="more"></a>

<p>In Go language, Complex structures can be built during initialization and the ordering issues among initialized objects, even among different packages, are handled correctly.</p>
<h2 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h2><h3 id="variable"><a href="#variable" class="headerlink" title="variable"></a>variable</h3><p>In Go, <em>variables</em> are explicitly declared and used by the compiler to e.g. check type-correctness of function calls.</p>
<ul>
<li><p>Create Time: Runtime</p>
</li>
<li><p>can be any type</p>
</li>
<li><p>initializer can be a general expression computed at run time.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    home   = os.Getenv(<span class="string">&quot;HOME&quot;</span>)</span><br><span class="line">    user   = os.Getenv(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">    gopath = os.Getenv(<span class="string">&quot;GOPATH&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>Multi declare methods:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// declare format: var var_name var_type</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> isOk <span class="keyword">bool</span></span><br><span class="line"><span class="comment">// declare multi varablie at once</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="keyword">string</span></span><br><span class="line">    b <span class="keyword">int</span></span><br><span class="line">    c <span class="keyword">bool</span></span><br><span class="line">    d <span class="keyword">float32</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>Multi initialization methods:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// fundamental init method: var var_name var_type = var_value</span></span><br><span class="line">  	<span class="keyword">var</span> x <span class="keyword">int</span>  = <span class="number">0</span></span><br><span class="line">  <span class="comment">// var var_name = var_value :Go will infer the type of initialized variables</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&quot;initial&quot;</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">  <span class="comment">// delcare and init multi variable at once</span></span><br><span class="line">    <span class="keyword">var</span> b, c <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    fmt.Println(b, c)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> d = <span class="literal">true</span></span><br><span class="line">    fmt.Println(d)</span><br><span class="line"> <span class="comment">// Variables declared without a corresponding initialization are zero-valued.</span></span><br><span class="line">    <span class="keyword">var</span> e <span class="keyword">int</span></span><br><span class="line">    fmt.Println(e)</span><br><span class="line"> <span class="comment">// The := syntax is shorthand for declaring and initializing a variable</span></span><br><span class="line">    f := <span class="string">&quot;apple&quot;</span></span><br><span class="line">    fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// initial</span></span><br><span class="line"><span class="comment">// 1 2</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// apple</span></span><br></pre></td></tr></table></figure>
<h2 id="Constant"><a href="#Constant" class="headerlink" title="Constant"></a>Constant</h2></li>
<li><p>Create Time: compile time</p>
</li>
<li><p>can only be: <code>numbers</code>,<code>characters</code>,<code>string</code>,<code>booleans</code></p>
</li>
<li><p>Define location: could be defined as locals in <strong>functions</strong></p>
</li>
<li><p>constant expression: only constant expression</p>
<ul>
<li><code>1&lt;&lt;3</code> : Correct </li>
<li><code>math.Sin(math.Pi)</code>: Wrong</li>
</ul>
</li>
<li><p>Multi init methods:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// A const statement can appear anywhere a var statement can.</span></span><br><span class="line"><span class="keyword">const</span> s <span class="keyword">string</span> = <span class="string">&quot;constant&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">		<span class="comment">// A numeric constant has no type until it’s given one, such as by an explicit conversion.</span></span><br><span class="line">    <span class="keyword">const</span> n = <span class="number">500000000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> d = <span class="number">3e20</span> / n</span><br><span class="line">    fmt.Println(d)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="keyword">int64</span>(d))</span><br><span class="line">  	<span class="comment">// A number can be given a type by using it in a context that requires one, such as a variable assignment or function call. For example, here math.Sin expects a float64.</span></span><br><span class="line">    fmt.Println(math.Sin(n))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// constant</span></span><br><span class="line"><span class="comment">// 6e+11</span></span><br><span class="line"><span class="comment">// 600000000000</span></span><br><span class="line"><span class="comment">// -0.28470407323754404</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>enumerated constant: <code>iota</code>, <a href="https://www.jianshu.com/p/08d6a4216e96">iota</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteSize <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _           = <span class="literal">iota</span> <span class="comment">// ignore first value by assigning to blank identifier</span></span><br><span class="line">    KB ByteSize = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    MB</span><br><span class="line">    GB</span><br><span class="line">    TB</span><br><span class="line">    PB</span><br><span class="line">    EB</span><br><span class="line">    ZB</span><br><span class="line">    YB</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h2></li>
<li><p>Call Time:After all the variable declarations in the package have evaluated;</p>
</li>
<li><p>a common use of <code>init</code> functions is to verify or repair correctness of the program state before real execution begins.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> user == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;$USER not set&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> home == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        home = <span class="string">&quot;/home/&quot;</span> + user</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> gopath == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        gopath = home + <span class="string">&quot;/go&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// gopath may be overridden by --gopath flag on command line.</span></span><br><span class="line">    flag.StringVar(&amp;gopath, <span class="string">&quot;gopath&quot;</span>, gopath, <span class="string">&quot;override default GOPATH&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_Learning_Fundamental_Constant</title>
    <url>/2022/06/29/Go-Learning-Fundamental-Constant/</url>
    <content><![CDATA[<p><strong>Reference:</strong> <a href="https://go101.org/article/constants-and-variables.html">Blog_1</a>, <a href="https://golangbot.com/constants/">Blog_2</a>, <a href="https://learnetutorials.com/golang/constants">Blog_3</a>, <a href="https://press.rebus.community/programmingfundamentals/chapter/constants-and-variables/">Blog_4</a>, <a href="https://www.geeksforgeeks.org/constants-go-language/">Blog_5</a>, <a href="https://www.geeksforgeeks.org/constants-go-language/">Blog_6</a>, <a href="https://naotu.baidu.com/file/5d61976f504328b7bb09b5ccd0ff8bd4">Mind</a></p>
<a id="more"></a>

<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><h2 id="Defination"><a href="#Defination" class="headerlink" title="Defination"></a>Defination</h2><p>A <strong>Constant</strong> is a value that can’t be changged during program life cycle; This is a contrasted concept with a <strong>variable</strong> which can be changed during program running;</p>
<h3 id="Difference-of-Constant-And-Variable"><a href="#Difference-of-Constant-And-Variable" class="headerlink" title="Difference of Constant And Variable"></a>Difference of Constant And Variable</h3><ul>
<li><strong>Constant:</strong> the value is constant, value can not be change during running time;</li>
<li><strong>Variable:</strong> the value can vary, value can change during running time;</li>
</ul>
<h3 id="Literal-constant-And-Defined-constant"><a href="#Literal-constant-And-Defined-constant" class="headerlink" title="Literal constant And Defined constant"></a>Literal constant And Defined constant</h3><p>Constants are used in two ways: <strong>literal constant, named constant</strong>; When associated with an identifier, a constant is said to be named, the terms “constant” and “named constant” are ofen used interchangeably;</p>
<ul>
<li><p><strong>Literal constant (Unnamed constant)</strong> : is the value which typed into program. For example:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100.0</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>Named constant</strong>:  is the constant represented by a name. For example:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">100</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">100.0</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="Declare-Constant-in-Go"><a href="#Declare-Constant-in-Go" class="headerlink" title="Declare Constant in Go"></a>Declare Constant in Go</h2></li>
</ul>
<p>In Go language, <code>const</code> is the keyword to declare a constant; </p>
<h3 id="Typed-amp-amp-Untyped-Const"><a href="#Typed-amp-amp-Untyped-Const" class="headerlink" title="Typed &amp;&amp; Untyped Const"></a>Typed &amp;&amp; Untyped Const</h3><p>Constants can be declared with or without a type in Go;</p>
<ul>
<li><p>Syntax of Typed constant:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> variableName <span class="keyword">type</span> = value</span><br></pre></td></tr></table></figure>
<p>Typed constant work like immutable variables can inter-operate only with the same type;</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Typed const can operate with same type&quot;</span>)</span><br><span class="line">	<span class="keyword">const</span> typedNum <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">	result1 := b + typedNum</span><br><span class="line">	fmt.Printf(<span class="string">&quot;typedNum + int result %v , result type %T \n&quot;</span>, result1, result1)</span><br><span class="line">	<span class="comment">// var a float64 = 20.0</span></span><br><span class="line">	<span class="comment">// result := a + typedNum Error: mismatch types</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Syntax of UnTyped constant:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> variableName = value</span><br></pre></td></tr></table></figure>
<p>UnTyped constant work like literals can inter–operate with similar types;</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Untyped const can operate with similer type&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> untypedNum = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">float64</span> = <span class="number">20.0</span></span><br><span class="line">	result := a + untypedNum</span><br><span class="line">	fmt.Printf(<span class="string">&quot;untypedNum + float64 result %v , result type %T \n&quot;</span>, result, result)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">	result1 := b + untypedNum</span><br><span class="line">	fmt.Printf(<span class="string">&quot;untypedNum + int result %v , result type %T \n&quot;</span>, result1, result1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Untyped const can operate with similer type</span></span><br><span class="line"><span class="comment">// untypedNum + float64 result 30 , result type float64 </span></span><br><span class="line"><span class="comment">// untypedNum + int result 30 , result type int</span></span><br></pre></td></tr></table></figure>
<h3 id="Multiple-const"><a href="#Multiple-const" class="headerlink" title="Multiple const"></a>Multiple const</h3></li>
</ul>
<p>Multiple constants are grouped into a block. Using the flow syntax to decalre multiple constant variables.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ()</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Multiple const is declared with syntax of `const()`&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		NAME   = <span class="string">&quot;QINGZHI&quot;</span></span><br><span class="line">		AGE    = <span class="number">20</span></span><br><span class="line">		ISMALE = <span class="literal">true</span></span><br><span class="line">		HIGHT  = <span class="number">175.8</span></span><br><span class="line">	)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;consts is %v, %v, %v, %v \n&quot;</span>, NAME, AGE, ISMALE, HIGHT)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Multiple const is declared with syntax of `const()`</span></span><br><span class="line"><span class="comment">// consts is QINGZHI, 20, true, 175.8 </span></span><br></pre></td></tr></table></figure>
<h2 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h2><ul>
<li>Upppercase letters are most preferred to represent a constant variable;</li>
<li>Constant variables are declared inside as well as outside of a function;</li>
<li>Constant variable can not be redeclared;</li>
<li>The value of a constant should be known at complie time;</li>
</ul>
<h2 id="Various-Types-of-Constant"><a href="#Various-Types-of-Constant" class="headerlink" title="Various Types of Constant"></a>Various Types of Constant</h2><h3 id="Three-Types-of-constants-in-Go"><a href="#Three-Types-of-constants-in-Go" class="headerlink" title="Three Types of constants in Go"></a>Three Types of constants in Go</h3><ul>
<li>Reference by <a href="https://www.geeksforgeeks.org/constants-go-language/">Blog</a></li>
</ul>
<h4 id="String-Constants"><a href="#String-Constants" class="headerlink" title="String Constants"></a>String Constants</h4><ul>
<li>Go support two type of string literal, the “” double-quote style and the `` back-quote;</li>
</ul>
<h4 id="Boolean-Constants"><a href="#Boolean-Constants" class="headerlink" title="Boolean Constants"></a>Boolean Constants</h4><ul>
<li>Defination:  two untyped constants <code>true</code> and <code>false</code>.</li>
</ul>
<h4 id="Numeric-Constants"><a href="#Numeric-Constants" class="headerlink" title="Numeric Constants"></a>Numeric Constants</h4><ul>
<li><p>Defination: three type of numeric constants: <code>integers</code>, <code>floats</code>, <code>complex</code>;</p>
</li>
<li><p>integer Constant:</p>
<ul>
<li>A prefix specifies the base or radix: 0x or 0X for hexadecimal, 0 for octal, and nothing for decimal.</li>
<li>An integer literal can also have a <em>suffix</em> that is a combination of U(upper case) and L(upper case), for unsigned and long, respectively</li>
<li>It can be a <em>decimal, octal, or hexadecimal constant</em>.</li>
<li>An int can store at maximum a 64-bit integer, and sometimes less.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">85</span>         <span class="comment">/* decimal */</span></span><br><span class="line"><span class="number">0213</span>       <span class="comment">/* octal */</span></span><br><span class="line"><span class="number">0x4b</span>       <span class="comment">/* hexadecimal */</span></span><br><span class="line"><span class="number">30</span>         <span class="comment">/* int */</span></span><br><span class="line"><span class="number">30</span>u        <span class="comment">/* unsigned int */</span></span><br><span class="line"><span class="number">30</span>l        <span class="comment">/* long */</span></span><br><span class="line"><span class="number">30</span>ul       <span class="comment">/* unsigned long */</span></span><br><span class="line"><span class="number">212</span>         <span class="comment">/* Legal */</span></span><br><span class="line"><span class="number">215</span>u        <span class="comment">/* Legal */</span></span><br><span class="line"><span class="number">0xFee</span>L      <span class="comment">/* Legal */</span></span><br><span class="line"><span class="number">078</span>         <span class="comment">/* Illegal: 8 is not an octal digit */</span></span><br><span class="line"><span class="number">032</span>UU       <span class="comment">/* Illegal: cannot repeat a suffix */</span></span><br></pre></td></tr></table></figure></li>
<li><p>Complex constant</p>
</li>
<li><p>Floating type constant</p>
<ul>
<li>A floating type constant has an <em>integer part, a decimal point, a fractional part, and an exponent part</em>.</li>
<li>Can be represent floating constant either in decimal form or exponential form.</li>
<li><em>While</em> representing using the decimal form, you must include the decimal point, the exponent, or both.</li>
<li>And while representing using the <em>exponential</em> form, must include the integer part, the fractional part, or both.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">3.14159</span>       <span class="comment">/* Legal */</span></span><br><span class="line"><span class="number">314159E-5</span>L    <span class="comment">/* Legal */</span></span><br><span class="line"><span class="number">510</span>E          <span class="comment">/* Illegal: incomplete exponent */</span></span><br><span class="line"><span class="number">210</span>f          <span class="comment">/* Illegal: no decimal or exponent */</span></span><br><span class="line">.e55          <span class="comment">/* Illegal: missing integer or fraction */</span></span><br></pre></td></tr></table></figure>
<h3 id="Default-type-of-literal-constant"><a href="#Default-type-of-literal-constant" class="headerlink" title="Default type of literal constant"></a>Default type of literal constant</h3></li>
</ul>
<p>Default type of literal constant is determined by its literal form:</p>
<ul>
<li>The default type of a string literal is <code>string</code>.</li>
<li>The default type of a boolean literal is <code>bool</code>.</li>
<li>The default type of an integer literal is <code>int</code>.</li>
<li>The default type of a rune literal is <code>rune</code> (a.k.a., <code>int32</code>).</li>
<li>The default type of a floating-point literal is <code>float64</code>.</li>
<li>If a literal contains an imaginary part, then its default type is <code>complex128</code>.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Default type of a literal constant is determined by its literal form`&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		literalString  = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">		literalBool    = <span class="literal">true</span></span><br><span class="line">		literalInteget = <span class="number">100</span></span><br><span class="line">		literalRune    = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">		litaralFloat   = <span class="number">100.0</span></span><br><span class="line">		literalComplex = <span class="number">5</span> + <span class="number">6i</span></span><br><span class="line">	)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;literalString %T \nliteralBool %T \nliteralInteget %T \nliteralRune %T \nlitaralFloat %T \nliteralComplex %T \n&quot;</span>,</span><br><span class="line">		literalString, literalBool, literalInteget, literalRune, litaralFloat, literalComplex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Default type of a literal constant is determined by its literal form`</span></span><br><span class="line"><span class="comment">// literalString string </span></span><br><span class="line"><span class="comment">// literalBool bool </span></span><br><span class="line"><span class="comment">// literalInteget int </span></span><br><span class="line"><span class="comment">// literalRune int32 </span></span><br><span class="line"><span class="comment">// litaralFloat float64 </span></span><br><span class="line"><span class="comment">// literalComplex complex128 </span></span><br></pre></td></tr></table></figure>
<h3 id="Literal-constant-type-is-untype"><a href="#Literal-constant-type-is-untype" class="headerlink" title="Literal constant type is untype"></a>Literal constant type is untype</h3><p><code>Literal constant type is untype</code> means the type is flexable, could transfer to similer type; </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> a = <span class="number">5</span></span><br><span class="line">	<span class="keyword">var</span> intVar <span class="keyword">int</span> = a</span><br><span class="line">	<span class="keyword">var</span> int32Var <span class="keyword">int32</span> = a</span><br><span class="line">	<span class="keyword">var</span> float64Var <span class="keyword">float64</span> = a</span><br><span class="line">	<span class="keyword">var</span> complex64Var <span class="keyword">complex64</span> = a</span><br><span class="line">	fmt.Println(<span class="string">&quot;intVar&quot;</span>, intVar, <span class="string">&quot;\nint32Var&quot;</span>, int32Var, <span class="string">&quot;\nfloat64Var&quot;</span>, float64Var, <span class="string">&quot;\ncomplex64Var&quot;</span>, complex64Var)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// intVar 5 </span></span><br><span class="line"><span class="comment">// int32Var 5 </span></span><br><span class="line"><span class="comment">// float64Var 5 </span></span><br><span class="line"><span class="comment">// complex64Var (5+0i)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_Learning_Fundamental_Interface</title>
    <url>/2022/06/29/Go-Learning-Fundamental-Interface/</url>
    <content><![CDATA[<ul>
<li>Reference: <a href="https://golangbot.com/interfaces-part-1/">Blog</a>, <a href="https://golangbot.com/interfaces-part-2/">Blog</a>, <a href="https://medium.com/rungo/interfaces-in-go-ab1601159b3a">Blog</a>, <a href="https://golangbyexample.com/interface-in-golang/">Blog</a></li>
</ul>
<a id="more"></a>

<h2 id="What-is-Interface"><a href="#What-is-Interface" class="headerlink" title="What is Interface"></a>What is Interface</h2><p>An Interface in go is <strong>a set of method signatures</strong>; </p>
<h3 id="What’s-method-signature"><a href="#What’s-method-signature" class="headerlink" title="What’s method signature?"></a>What’s method signature?</h3><p>In my view, method signature is the abstract common represent of method; It declare method behavior and do not care abort special implement details;Here is a <strong>animal</strong> interface which include two method signatures: <strong>breathe</strong> , <strong>walk</strong>;</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">	breathe()</span><br><span class="line">	walk()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A method signature would include:</p>
<ul>
<li>Name of method;</li>
<li>Number of arguments and type of each argument;</li>
<li>Number of return values and type of each return value;</li>
</ul>
<h3 id="How-does-struct-implement-a-Interface-in-go"><a href="#How-does-struct-implement-a-Interface-in-go" class="headerlink" title="How does struct implement a Interface in go?"></a>How does struct implement a Interface in go?</h3><p>When a type provides <strong>definition for all the methods in the interface</strong>, it is said to implement the interface; So the implement interface in go is implicit; </p>
<p>That is also called <strong>duck typing</strong>; In programming duck typing means we do not check type instead we check the only presence os some attributes or methods;</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">If it walks like a duck and quack like a duck then it must be duck</span><br></pre></td></tr></table></figure>
<h2 id="Declaring-and-implementing-an-interface"><a href="#Declaring-and-implementing-an-interface" class="headerlink" title="Declaring and implementing an interface"></a>Declaring and implementing an interface</h2><p>Like we defined before, any type implement breathe and walk method, It is said to implement a animal interfac; For example we construct a lion struct which implement animal interface; </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">    breathe()</span><br><span class="line">    walk()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> lion <span class="keyword">struct</span> &#123;</span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l lion)</span> <span class="title">breathe</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Lion breathes&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l lion)</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Lion walk&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a animal</span><br><span class="line">    a = lion&#123;age: <span class="number">10</span>&#125;</span><br><span class="line">    a.breathe()</span><br><span class="line">    a.walk()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lion breathes</span><br><span class="line">Lion walk</span><br></pre></td></tr></table></figure>
<p>We declare a variable of animal interface type</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a animal</span><br></pre></td></tr></table></figure>
<p>Then we assign an instance of lion struct to it.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a = lion&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Assigning an instance of <strong>lion</strong> struct to a variable of <strong>animal</strong> interface type works because <strong>lion</strong> struct implements both <strong>breathe</strong> and <strong>walk</strong> method of the animal. The type is not checked during this assignment, instead, it is enough to check that the type assigned does implement <strong>breathe</strong> and <strong>walk</strong> method. The concept is similar to duck typing, a <strong>lion</strong> can <strong>breathe</strong> and <strong>walk</strong> like an <strong>animal</strong> and hence it is an <strong>animal</strong>.</p>
<h2 id="Practical-use-of-Interface"><a href="#Practical-use-of-Interface" class="headerlink" title="Practical use of Interface"></a>Practical use of Interface</h2><p>The above example explain how to create and implement interfaces, but it didn’t really show the practical use of an interface; Instead of <code>animal.breathe()</code>, it would also worked if we use <code>lion.breathe()</code>; Now let’s look at a practical use of interface;</p>
<p>We will write a simple program that calculates the total expense for a company based on the individual salaries of the employees. For brevity, we have assumed that all expenses are in USD.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SalaryCalculator <span class="keyword">interface</span> &#123;  </span><br><span class="line">    CalculateSalary() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Permanent <span class="keyword">struct</span> &#123;  </span><br><span class="line">    empId    <span class="keyword">int</span></span><br><span class="line">    basicpay <span class="keyword">int</span></span><br><span class="line">    pf       <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Contract <span class="keyword">struct</span> &#123;  </span><br><span class="line">    empId    <span class="keyword">int</span></span><br><span class="line">    basicpay <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//salary of permanent employee is the sum of basic pay and pf</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Permanent)</span> <span class="title">CalculateSalary</span><span class="params">()</span> <span class="title">int</span></span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> p.basicpay + p.pf</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//salary of contract employee is the basic pay alone</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Contract)</span> <span class="title">CalculateSalary</span><span class="params">()</span> <span class="title">int</span></span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> c.basicpay</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">total expense is calculated by iterating through the SalaryCalculator slice and summing  </span></span><br><span class="line"><span class="comment">the salaries of the individual employees  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">totalExpense</span><span class="params">(s []SalaryCalculator)</span></span> &#123;  </span><br><span class="line">    expense := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        expense = expense + v.CalculateSalary()</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Total Expense Per Month $%d&quot;</span>, expense)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    pemp1 := Permanent&#123;</span><br><span class="line">        empId:    <span class="number">1</span>,</span><br><span class="line">        basicpay: <span class="number">5000</span>,</span><br><span class="line">        pf:       <span class="number">20</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    pemp2 := Permanent&#123;</span><br><span class="line">        empId:    <span class="number">2</span>,</span><br><span class="line">        basicpay: <span class="number">6000</span>,</span><br><span class="line">        pf:       <span class="number">30</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    cemp1 := Contract&#123;</span><br><span class="line">        empId:    <span class="number">3</span>,</span><br><span class="line">        basicpay: <span class="number">3000</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    employees := []SalaryCalculator&#123;pemp1, pemp2, cemp1&#125;</span><br><span class="line">    totalExpense(employees)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://play.golang.org/p/3DZQH_Xh_Pl">Run in playground</a></p>
<p>Line no. 7 of the above program declares the <code>SalaryCalculator</code> interface with a single method <code>CalculateSalary() int</code>.</p>
<p>We have two kinds of employees in the company, <code>Permanent</code> and <code>Contract</code> defined by <a href="https://golangbot.com/structs/">structs</a> in line no. 11 and 17. The salary of permanent employees is the sum of the <code>basicpay</code> and <code>pf</code> whereas for contract employees it’s just the basic pay <code>basicpay</code>. This is expressed in the corresponding <code>CalculateSalary</code> methods in line. no 23 and 28 respectively. By declaring this method, both <code>Permanent</code> and <code>Contract</code> structs now implement the <code>SalaryCalculator</code> interface.</p>
<p>The <code>totalExpense</code> <a href="https://golangbot.com/functions/">function</a> declared in line no.36 expresses the beauty of interfaces. This method takes a <a href="https://golangbot.com/arrays-and-slices/">slice</a> of SalaryCalculator interface <code>[]SalaryCalculator</code> as a parameter. In line no. 59 we pass a slice that contains both <code>Permanent</code> and <code>Contract</code> types to the <code>totalExpense</code> function. The <code>totalExpense</code> function calculates the expense by calling the <code>CalculateSalary</code> method of the corresponding type. This is done in line. no 39.</p>
<p>The program outputs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Total Expense Per Month $14050  </span><br></pre></td></tr></table></figure>
<p>The biggest advantage of this is that <code>totalExpense</code> can be extended to any new employee type without any code changes. Let’s say the company adds a new type of employee <code>Freelancer</code> with a different salary structure. This <code>Freelancer</code> can just be passed in the slice argument to <code>totalExpense</code> without even a single line of code change to the <code>totalExpense</code> function. This method will do what it’s supposed to do as <code>Freelancer</code> will also implement the <code>SalaryCalculator</code> interface :).</p>
<p>Let’s modify this program and add the new <code>Freelancer</code> employee. Salary for the Freelancer is the product of rate per hour and total no of hours worked.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SalaryCalculator <span class="keyword">interface</span> &#123;  </span><br><span class="line">    CalculateSalary() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Permanent <span class="keyword">struct</span> &#123;  </span><br><span class="line">    empId    <span class="keyword">int</span></span><br><span class="line">    basicpay <span class="keyword">int</span></span><br><span class="line">    pf       <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Contract <span class="keyword">struct</span> &#123;  </span><br><span class="line">    empId    <span class="keyword">int</span></span><br><span class="line">    basicpay <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Freelancer <span class="keyword">struct</span> &#123;  </span><br><span class="line">    empId       <span class="keyword">int</span></span><br><span class="line">    ratePerHour <span class="keyword">int</span></span><br><span class="line">    totalHours  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//salary of permanent employee is sum of basic pay and pf</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Permanent)</span> <span class="title">CalculateSalary</span><span class="params">()</span> <span class="title">int</span></span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> p.basicpay + p.pf</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//salary of contract employee is the basic pay alone</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Contract)</span> <span class="title">CalculateSalary</span><span class="params">()</span> <span class="title">int</span></span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> c.basicpay</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//salary of freelancer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Freelancer)</span> <span class="title">CalculateSalary</span><span class="params">()</span> <span class="title">int</span></span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> f.ratePerHour * f.totalHours</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">total expense is calculated by iterating through the SalaryCalculator slice and summing  </span></span><br><span class="line"><span class="comment">the salaries of the individual employees  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">totalExpense</span><span class="params">(s []SalaryCalculator)</span></span> &#123;  </span><br><span class="line">    expense := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        expense = expense + v.CalculateSalary()</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Total Expense Per Month $%d&quot;</span>, expense)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    pemp1 := Permanent&#123;</span><br><span class="line">        empId:    <span class="number">1</span>,</span><br><span class="line">        basicpay: <span class="number">5000</span>,</span><br><span class="line">        pf:       <span class="number">20</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    pemp2 := Permanent&#123;</span><br><span class="line">        empId:    <span class="number">2</span>,</span><br><span class="line">        basicpay: <span class="number">6000</span>,</span><br><span class="line">        pf:       <span class="number">30</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    cemp1 := Contract&#123;</span><br><span class="line">        empId:    <span class="number">3</span>,</span><br><span class="line">        basicpay: <span class="number">3000</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    freelancer1 := Freelancer&#123;</span><br><span class="line">        empId:       <span class="number">4</span>,</span><br><span class="line">        ratePerHour: <span class="number">70</span>,</span><br><span class="line">        totalHours:  <span class="number">120</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    freelancer2 := Freelancer&#123;</span><br><span class="line">        empId:       <span class="number">5</span>,</span><br><span class="line">        ratePerHour: <span class="number">100</span>,</span><br><span class="line">        totalHours:  <span class="number">100</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    employees := []SalaryCalculator&#123;pemp1, pemp2, cemp1, freelancer1, freelancer2&#125;</span><br><span class="line">    totalExpense(employees)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://play.golang.org/p/J48P5g8ArLn">Run in playground</a></p>
<p>We have added the <code>Freelancer</code> struct in line no. 22 and declared the <code>CalculateSalary</code> method in line no. 39. No other code change is required in the <code>totalExpense</code> method since <code>Freelancer</code> struct also implements the <code>SalaryCalculator</code> interface. We added a couple of <code>Freelancer</code> employees in the <code>main</code> method. This program prints,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Total Expense Per Month $32450  </span><br></pre></td></tr></table></figure>
<h2 id="Interface-are-implemented-implicitly"><a href="#Interface-are-implemented-implicitly" class="headerlink" title="Interface are implemented implicitly"></a>Interface are implemented implicitly</h2><p>There is no explicit declaration that a type implements an interface. In fact, in Go there doesn’t exist any <strong>“implements”</strong> keyword similar to Java. A type implements an interface if it implements all the methods of the interface.</p>
<p>As seen above, It is correct to define a variable of an interface type and we can assign any concrete type value to this variable if the concrete type implements all the methods of the interface.</p>
<p>There is no explicit declaration that says that <strong>lion</strong> struct implements the <strong>animal</strong> interface. During compilation, go notices that <strong>lion</strong> struct implements all methods of <strong>animal</strong> interface hence it is allowed. Any other type which implements all methods of the <strong>animal</strong> interface becomes of that interface type.</p>
<p>Let’s see a more complex example of another type implementing the animal interface.</p>
<p>If we define a <strong>dog</strong> struct and it implements the <strong>breathe</strong> and <strong>walk</strong> method then it will also be an animal.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">    breathe()</span><br><span class="line">    walk()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> lion <span class="keyword">struct</span> &#123;</span><br><span class="line">     age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l lion)</span> <span class="title">breathe</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Lion breathes&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l lion)</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Lion walk&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">     age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l dog)</span> <span class="title">breathe</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Dog breathes&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l dog)</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Dog walk&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a animal</span><br><span class="line">    </span><br><span class="line">    a = lion&#123;age: <span class="number">10</span>&#125;</span><br><span class="line">    a.breathe()</span><br><span class="line">    a.walk()</span><br><span class="line">  </span><br><span class="line">    a = dog&#123;age: <span class="number">5</span>&#125;</span><br><span class="line">    a.breathe()</span><br><span class="line">    a.walk()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Lion breathes</span><br><span class="line">Lion walk</span><br><span class="line">Dog breathes</span><br><span class="line">Dog walk</span><br></pre></td></tr></table></figure>
<p>Both <strong>lion</strong> and <strong>dog</strong> implement the breathe and walk method hence they are of animal type and can correctly be assigned to a variable of interface type.</p>
<p>The <strong>animal</strong> interface variable a was assigned a <strong>lion</strong> instance first and then the same variable was assigned a <strong>dog</strong> instance. So the type which interface variable refers to is dynamic. It dynamically holds a reference to the underlying type.</p>
<p>Two important points to note:</p>
<ul>
<li>The interface static check is done during compile time – means that if a type doesn’t implement all the methods of an interface, then assigning the type instance to a variable of that interface type will raise an error during compile time. Eg. on deleting the walk method defined on lion struct, below error will be raised during the assignment</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cannot use lion literal (<span class="keyword">type</span> lion) as <span class="keyword">type</span> animal in assignment:</span><br></pre></td></tr></table></figure>
<ul>
<li>The correct method based on the type of instance is called at run time – means that the method of either lion or dog is called depending upon whether interface variable refers to an instance of lion or dog. If it refers to an instance of lion, then lion’s method is called and if it refers to an instance of dog, then dog’s method is called. That is also proven from the output. This is a way to achieve runtime polymorphism in Go.</li>
</ul>
<p>It is also to be noted that the methods defined by the type, should match the entire signature of methods in the interface ie., it should match</p>
<ul>
<li><p>Name of the method</p>
</li>
<li><p>Number of arguments and type of each argument</p>
</li>
<li><p>Number of return values and type of each return value</p>
</li>
</ul>
<p>Imagine that <strong>animal</strong> interface has another method <strong>speed</strong> which returns the int value of speed of the animal</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">    breathe()</span><br><span class="line">    walk()</span><br><span class="line">    speed() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If the <strong>lion</strong> struct has <strong>speed</strong> method as below which does not return the int value, then the <strong>lion</strong> struct will not implement <strong>animal</strong> interface</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l lion)</span> <span class="title">speed</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>Below compilation error will be raised on assigning the lion instance to a variable of type animal</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cannot use lion literal (<span class="keyword">type</span> lion) as <span class="keyword">type</span> animal in assignment:</span><br><span class="line">        lion does not implement animal (wrong <span class="keyword">type</span> <span class="keyword">for</span> speed method)</span><br><span class="line">                have speed()</span><br><span class="line">                want speed() <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p>So in essence, method signatures are important while implementing an interface</p>
<h2 id="Interface-as-argument-to-a-function"><a href="#Interface-as-argument-to-a-function" class="headerlink" title="Interface as argument to a function"></a>Interface as argument to a function</h2><p>A function can accept an argument of an interface type. Any type which implements that interface can be passed as that argument to that function. For example, in the below code, we have <strong>callBreathe</strong> and <strong>callWalk</strong> function which accept an argument of <strong>animal</strong> interface type. Both <strong>lion</strong> and <strong>dog</strong> instance can be passed to this function. We create an instance of both lion and dog type and pass it to the function.</p>
<p>It works similarly to the assignment we discussed above. During compilation no type is checked while calling the function, instead, it is enough to check that the type passed to the function does implement <strong>breathe</strong> and <strong>walk</strong> method.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">	breathe()</span><br><span class="line">	walk()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> lion <span class="keyword">struct</span> &#123;</span><br><span class="line">     age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l lion)</span> <span class="title">breathe</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Lion breathes&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l lion)</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Lion walk&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">     age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l dog)</span> <span class="title">breathe</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Dog breathes&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l dog)</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Dog walk&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	l := lion&#123;age: <span class="number">10</span>&#125;</span><br><span class="line">	callBreathe(l)</span><br><span class="line">	callWalk(l)</span><br><span class="line"></span><br><span class="line">	d := dog&#123;age: <span class="number">5</span>&#125;</span><br><span class="line">	callBreathe(d)</span><br><span class="line">	callWalk(d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callBreathe</span><span class="params">(a animal)</span></span> &#123;</span><br><span class="line">	a.breathe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callWalk</span><span class="params">(a animal)</span></span> &#123;</span><br><span class="line">	a.breathe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Lion breathes</span><br><span class="line">Lion walk</span><br><span class="line">Dog breathes</span><br><span class="line">Dog walk</span><br></pre></td></tr></table></figure>
<p>In the above code, we have <strong>callBreathe</strong> and <strong>callWalk</strong> function which accept an argument of <strong>animal</strong> interface type. Both <strong>lion</strong> and <strong>dog</strong> instance can be passed to this function. We create an instance of both <strong>lion</strong> and <strong>dog</strong> type and pass it to the function. During compilation no type is checked while calling the function, instead, it is enough to check that the type passed to the function does implement <strong>breathe</strong> and <strong>walk</strong> method.</p>
<h2 id="Non-struct-Custom-Type-Implementing-an-interface"><a href="#Non-struct-Custom-Type-Implementing-an-interface" class="headerlink" title="Non-struct Custom Type Implementing an interface"></a>Non-struct Custom Type Implementing an interface</h2><p>So far we have only seen examples of struct type implementing an interface. It is also perfectly ok for any non-struct custom type to implement an interface. Let’s see an example</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">	breathe()</span><br><span class="line">	walk()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">breathe</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Cat breathes&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Cat walk&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a animal</span><br><span class="line"></span><br><span class="line">	a = cat(<span class="string">&quot;smokey&quot;</span>)</span><br><span class="line">	a.breathe()</span><br><span class="line">	a.walk()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Cat breathes</span><br><span class="line">Cat walk</span><br></pre></td></tr></table></figure>
<p>The above program illustrates the concept that any custom type can also implement an interface. The <strong>cat</strong> is of string type and it implements the <strong>breathe</strong> and <strong>walk</strong> method hence it is correct to assign an instance of <strong>cat</strong> type to a variable of <strong>animal</strong> type.</p>
<h2 id="Interface-inner-representation"><a href="#Interface-inner-representation" class="headerlink" title="Interface inner representation"></a>Interface inner representation</h2><p>Like any other variable, an interface variable is represented by a type and value. Interface value, in turn under the hood, consists of two tuple</p>
<ul>
<li>Underlying Type</li>
<li>Underlying Value</li>
</ul>
<p>See below diagram which illustrates what we mentioned above</p>
<p><img src="https://s2.loli.net/2022/01/23/ADpmqL3zXlbwskn.png" alt="image-20220123183736969"></p>
<p>For eg in case of lion struct implementing the animal interface would be like below</p>
<p><img src="https://s2.loli.net/2022/01/23/EQCzcRdZWB7sl8L.png" alt="image-20220123183750961"></p>
<p>Golang provides format identifiers to print the underlying type and underlying value represented by the interface value.</p>
<ul>
<li><p>%T can be used to print the concrete type of the interface value</p>
</li>
<li><p>%v can be used to print the concrete value of the interface value.</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">    breathe()</span><br><span class="line">    walk()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> lion <span class="keyword">struct</span> &#123;</span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l lion)</span> <span class="title">breathe</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Lion breathes&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l lion)</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Lion walk&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a animal</span><br><span class="line">    a = lion&#123;age: <span class="number">10</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Underlying Type: %T\n&quot;</span>, a)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Underlying Value: %v\n&quot;</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Concrete Type: main.lion</span><br><span class="line">Concrete Value: &#123;<span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure>
<p>An interface can be embedded in other interface as well as it can be embedded in a struct. Let’s look at each one by one</p>
<h2 id="Empty-Interface"><a href="#Empty-Interface" class="headerlink" title="Empty Interface"></a>Empty Interface</h2><p><strong>An interface that has zero methods is called an empty interface. It is represented as <code>interface&#123;&#125;</code>.</strong> Since the empty interface has zero methods, all types implement the empty interface.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;Type = %T, value = %v\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    s := <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">    describe(s)</span><br><span class="line">    i := <span class="number">55</span></span><br><span class="line">    describe(i)</span><br><span class="line">    strt := <span class="keyword">struct</span> &#123;</span><br><span class="line">        name <span class="keyword">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        name: <span class="string">&quot;Naveen R&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    describe(strt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://play.golang.org/p/Fm5KescoJb">Run in playground</a></p>
<p>In the program above, in line no.7, the <code>describe(i interface&#123;&#125;)</code> function takes an empty interface as an argument and hence any type can be passed.</p>
<p>We pass <code>string</code>, <code>int</code> and <code>struct</code> to the <code>describe</code> function in line nos. 13, 15 and 21 respectively. This program prints,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Type &#x3D; string, value &#x3D; Hello World  </span><br><span class="line">Type &#x3D; int, value &#x3D; 55  </span><br><span class="line">Type &#x3D; struct &#123; name string &#125;, value &#x3D; &#123;Naveen R&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="Type-assertion"><a href="#Type-assertion" class="headerlink" title="Type assertion"></a>Type assertion</h2><h3 id="Type-assertion-1"><a href="#Type-assertion-1" class="headerlink" title="Type assertion"></a>Type assertion</h3><p>Type assertion is used to extract the underlying value of the interface.</p>
<p><strong>i.(T)</strong> is the syntax which is used to get the underlying value of interface <code>i</code> whose concrete type is <code>T</code>.</p>
<p>A program is worth a thousand words 😀. Let’s write one for type assertion.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assert</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">    s := i.(<span class="keyword">int</span>) <span class="comment">//get the underlying int value from i</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">interface</span>&#123;&#125; = <span class="number">56</span></span><br><span class="line">    assert(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://play.golang.org/p/YstKXEeSBL">Run in playground</a></p>
<p>The concrete type of <code>s</code> in line no. 12 is <code>int</code>. We use the syntax <code>i.(int)</code> in line no. 8 to fetch the underlying int value of i. This program prints <code>56</code>.</p>
<p>What will happen if the concrete type in the above program is not int? Well, let’s find out.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assert</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">    s := i.(<span class="keyword">int</span>) </span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;Steven Paul&quot;</span></span><br><span class="line">    assert(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://play.golang.org/p/88KflSceHK">Run in playground</a></p>
<p>In the program above we pass <code>s</code> of concrete type <code>string</code> to the <code>assert</code> function which tries to extract a int value from it. This program will panic with the message <code>panic: interface conversion: interface &#123;&#125; is string, not int</code>.</p>
<p>To solve the above problem, we can use the syntax</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v, ok :&#x3D; i.(T)  </span><br></pre></td></tr></table></figure>
<p>If the concrete type of <code>i</code> is <code>T</code> then <code>v</code> will have the underlying value of <code>i</code> and <code>ok</code> will be true.</p>
<p>If the concrete type of <code>i</code> is not <code>T</code> then <code>ok</code> will be false and <code>v</code> will have the zero value of type <code>T</code> and <strong>the program will not panic</strong>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assert</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">    v, ok := i.(<span class="keyword">int</span>)</span><br><span class="line">    fmt.Println(v, ok)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">interface</span>&#123;&#125; = <span class="number">56</span></span><br><span class="line">    assert(s)</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;Steven Paul&quot;</span></span><br><span class="line">    assert(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://play.golang.org/p/0sB-KlVw8A">Run in playground</a></p>
<p>When <code>Steven Paul</code> is passed to the <code>assert</code> function, <code>ok</code> will be false since the concrete type of <code>i</code> is not <code>int</code> and <code>v</code> will have the value 0 which is the zero value of <code>int</code>. This program will print,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">56 true  </span><br><span class="line">0 false  </span><br></pre></td></tr></table></figure>
<h2 id="Type-switch"><a href="#Type-switch" class="headerlink" title="Type switch"></a>Type switch</h2><p><strong>A type switch is used to compare the concrete type of an interface against multiple types specified in various case statements. It is similar to <a href="https://golangbot.com/switch/">switch case</a>. The only difference being the cases specify types and not values as in normal switch.</strong></p>
<p>The syntax for type switch is similar to Type assertion. In the syntax <code>i.(T)</code> for Type assertion, the type <code>T</code> should be replaced by the keyword <code>type</code> for type switch. Let’s see how this works in the program below.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findType</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">switch</span> i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;I am a string and my value is %s\n&quot;</span>, i.(<span class="keyword">string</span>))</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;I am an int and my value is %d\n&quot;</span>, i.(<span class="keyword">int</span>))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Unknown type\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    findType(<span class="string">&quot;Naveen&quot;</span>)</span><br><span class="line">    findType(<span class="number">77</span>)</span><br><span class="line">    findType(<span class="number">89.98</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://play.golang.org/p/XYPDwOvoCh">Run in playground</a></p>
<p>In line no. 8 of the above program, <code>switch i.(type)</code> specifies a type switch. Each of the case statements compare the concrete type of <code>i</code> to a specific type. If any case matches, the corresponding statement is printed. This program outputs,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I am a string and my value is Naveen  </span><br><span class="line">I am an int and my value is 77  </span><br><span class="line">Unknown type  </span><br></pre></td></tr></table></figure>
<p><em>89.98</em> in line no. 20 is of type <code>float64</code> and does not match any of the cases and hence <code>Unknown type</code> is printed in the last line.</p>
<p><strong>It is also possible to compare a type to an interface. If we have a type and if that type implements an interface, it is possible to compare this type with the interface it implements.</strong></p>
<p>Let’s write a program for more clarity.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Describer <span class="keyword">interface</span> &#123;  </span><br><span class="line">    Describe()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Describe</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s is %d years old&quot;</span>, p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findType</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> Describer:</span><br><span class="line">        v.Describe()</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;unknown type\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    findType(<span class="string">&quot;Naveen&quot;</span>)</span><br><span class="line">    p := Person&#123;</span><br><span class="line">        name: <span class="string">&quot;Naveen R&quot;</span>,</span><br><span class="line">        age:  <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    findType(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://play.golang.org/p/o6aHzIz4wC">Run in playground</a></p>
<p>In the program above, the <code>Person</code> struct implements the <code>Describer</code> interface. In the case statement in line no. 19, <code>v</code> is compared to the <code>Describer</code> interface type. <code>p</code> implements <code>Describer</code> and hence this case is satisfied and <code>Describe()</code> method is called.</p>
<p>This program prints</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unknown type  </span><br><span class="line">Naveen R is 25 years old  </span><br></pre></td></tr></table></figure>
<p>This brings us to the end of Interfaces Part I. We will continue our discussion about interfaces in Part II. Please leave your valuable feedback in the comments.</p>
<h2 id="Compare-with-pointer-receiver-and-value-receiver"><a href="#Compare-with-pointer-receiver-and-value-receiver" class="headerlink" title="Compare with pointer receiver and value receiver"></a>Compare with pointer receiver and value receiver</h2><p>All the example interfaces we discussed in <a href="https://golangbot.com/interfaces-part-1/">part 1</a> were implemented using value receivers. It is also possible to implement interfaces using pointer receivers. There is a subtlety to be noted while implementing interfaces using pointer receivers. Lets understand that using the following program.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Describer <span class="keyword">interface</span> &#123;  </span><br><span class="line">    Describe()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Describe</span><span class="params">()</span></span> &#123; <span class="comment">//implemented using value receiver  </span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s is %d years old\n&quot;</span>, p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;  </span><br><span class="line">    state   <span class="keyword">string</span></span><br><span class="line">    country <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Address)</span> <span class="title">Describe</span><span class="params">()</span></span> &#123; <span class="comment">//implemented using pointer receiver  </span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;State %s Country %s&quot;</span>, a.state, a.country)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> d1 Describer</span><br><span class="line">    p1 := Person&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">25</span>&#125;</span><br><span class="line">    d1 = p1</span><br><span class="line">    d1.Describe()</span><br><span class="line">    p2 := Person&#123;<span class="string">&quot;James&quot;</span>, <span class="number">32</span>&#125;</span><br><span class="line">    d1 = &amp;p2</span><br><span class="line">    d1.Describe()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> d2 Describer</span><br><span class="line">    a := Address&#123;<span class="string">&quot;Washington&quot;</span>, <span class="string">&quot;USA&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* compilation error if the following line is</span></span><br><span class="line"><span class="comment">       uncommented</span></span><br><span class="line"><span class="comment">       cannot use a (type Address) as type Describer</span></span><br><span class="line"><span class="comment">       in assignment: Address does not implement</span></span><br><span class="line"><span class="comment">       Describer (Describe method has pointer</span></span><br><span class="line"><span class="comment">       receiver)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//d2 = a</span></span><br><span class="line"></span><br><span class="line">    d2 = &amp;a <span class="comment">//This works since Describer interface</span></span><br><span class="line">    <span class="comment">//is implemented by Address pointer in line 22</span></span><br><span class="line">    d2.Describe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://play.golang.org/p/IzspYiAQ82">Run in playground</a></p>
<p>In the program above, the <code>Person</code> struct implements the <code>Describer</code> interface using value receiver in line no. 13.</p>
<p>As we have already learnt during our discussion about <a href="https://golangbot.com/methods#valuereceiversinmethodsvsvalueargumentsinfunctions">methods</a>, methods with value receivers accept both pointer and value receivers. <em>It is legal to call a value method on anything which is a value or whose value can be dereferenced.</em></p>
<p><em>p1</em> is a value of type <code>Person</code> and it is assigned to <code>d1</code> in line no. 29. <code>Person</code> implements the <code>Describer</code> interface and hence line no. 30 will print <code>Sam is 25 years old</code>.</p>
<p>Similarly <code>d1</code> is assigned to <code>&amp;p2</code> in line no. 32 and hence line no. 33 will print <code>James is 32 years old</code>. Awesome :).</p>
<p>The <code>Address</code> struct implements the <code>Describer</code> interface using pointer receiver in line no. 22.</p>
<p>If line. no 45 of the program above is uncommented, we will get the compilation error <strong>main.go:42: cannot use a (type Address) as type Describer in assignment: Address does not implement Describer (Describe method has pointer receiver)</strong>. This is because, the <code>Describer</code> interface is implemented using a Address Pointer receiver in line 22 and we are trying to assign <code>a</code> which is a value type and it has not implemented the <code>Describer</code> interface. This will definitely surprise you since we learnt earlier that <a href="https://golangbot.com/methods/#pointerreceiversinmethodsvspointerargumentsinfunctions">methods</a> with pointer receivers will accept both pointer and value receivers. Then why isn’t the code in line no. 45 working.</p>
<p><strong>The reason is that it is legal to call a pointer-valued method on anything that is already a pointer or whose address can be taken. The concrete value stored in an interface is not addressable and hence it is not possible for the compiler to automatically take the address of <code>a</code> in line no. 45 and hence this code fails.</strong></p>
<p>Line no. 47 works because we are assigning the address of a <code>&amp;a</code> to <code>d2</code>.</p>
<p>The rest of the program is self explanatory. This program will print,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sam is 25 years old  </span><br><span class="line">James is 32 years old  </span><br><span class="line">State Washington Country USA  </span><br></pre></td></tr></table></figure>
<h2 id="Multiple-Interface"><a href="#Multiple-Interface" class="headerlink" title="Multiple Interface"></a>Multiple Interface</h2><p>A type can implement more than one interface. Lets see how this is done in the following program.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SalaryCalculator <span class="keyword">interface</span> &#123;  </span><br><span class="line">    DisplaySalary()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LeaveCalculator <span class="keyword">interface</span> &#123;  </span><br><span class="line">    CalculateLeavesLeft() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName <span class="keyword">string</span></span><br><span class="line">    lastName <span class="keyword">string</span></span><br><span class="line">    basicPay <span class="keyword">int</span></span><br><span class="line">    pf <span class="keyword">int</span></span><br><span class="line">    totalLeaves <span class="keyword">int</span></span><br><span class="line">    leavesTaken <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">DisplaySalary</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s %s has salary $%d&quot;</span>, e.firstName, e.lastName, (e.basicPay + e.pf))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">CalculateLeavesLeft</span><span class="params">()</span> <span class="title">int</span></span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> e.totalLeaves - e.leavesTaken</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    e := Employee &#123;</span><br><span class="line">        firstName: <span class="string">&quot;Naveen&quot;</span>,</span><br><span class="line">        lastName: <span class="string">&quot;Ramanathan&quot;</span>,</span><br><span class="line">        basicPay: <span class="number">5000</span>,</span><br><span class="line">        pf: <span class="number">200</span>,</span><br><span class="line">        totalLeaves: <span class="number">30</span>,</span><br><span class="line">        leavesTaken: <span class="number">5</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> s SalaryCalculator = e</span><br><span class="line">    s.DisplaySalary()</span><br><span class="line">    <span class="keyword">var</span> l LeaveCalculator = e</span><br><span class="line">    fmt.Println(<span class="string">&quot;\nLeaves left =&quot;</span>, l.CalculateLeavesLeft())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://play.golang.org/p/DJxS5zxBcV">Run in playground</a></p>
<p>The program above has two interfaces <code>SalaryCalculator</code> and <code>LeaveCalculator</code> declared in lines 7 and 11 respectively.</p>
<p>The <code>Employee</code> struct defined in line no. 15 provides implementations for the <code>DisplaySalary</code> method of <code>SalaryCalculator</code> interface in line no. 24 and the <code>CalculateLeavesLeft</code> method of <code>LeaveCalculator</code> interface interface in line no. 28. Now <code>Employee</code> implements both <code>SalaryCalculator</code> and <code>LeaveCalculator</code> interfaces.</p>
<p>In line no. 41 we assign <code>e</code> to a variable of type <code>SalaryCalculator</code> interface and in line no. 43 we assign the same variable <code>e</code> to a variable of type <code>LeaveCalculator</code>. This is possible since <code>e</code> which of type <code>Employee</code> implements both <code>SalaryCalculator</code> and <code>LeaveCalculator</code> interfaces.</p>
<p>This program outputs,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Naveen Ramanathan has salary $5200  </span><br><span class="line">Leaves left &#x3D; 25  </span><br></pre></td></tr></table></figure>
<h2 id="Embedding-Interfaces"><a href="#Embedding-Interfaces" class="headerlink" title="Embedding Interfaces"></a>Embedding Interfaces</h2><p>An interface can be embedded in other interface as well as it can be embedded in a struct. Let’s look at each one by one</p>
<h3 id="Embedding-interface-in-other-interface"><a href="#Embedding-interface-in-other-interface" class="headerlink" title="Embedding interface in other interface"></a>Embedding interface in other interface</h3><p>An interface can embed any number of interfaces in it as well as it can be embedded in any interface. All the methods of the embedded interface become part of the embedding interface. It is a way of creating a new interface by merging some small interfaces. Let’s understand it with an example</p>
<p>Assume we have an interface <strong>animal</strong> as below</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">    breathe()</span><br><span class="line">    walk()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s say there is another interface named <strong>human</strong> which embeds the <strong>animal</strong> interface</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> human <span class="keyword">interface</span> &#123;</span><br><span class="line">    animal</span><br><span class="line">    speak()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>So if any type needs to implement the <strong>human</strong> interface, then it has to define</p>
<ul>
<li><p><strong>breathe()</strong> and <strong>walk()</strong> method of animal interfaces animal is embedded in human</p>
</li>
<li><p><strong>speak()</strong> method of human interface</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">	breathe()</span><br><span class="line">	walk()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> human <span class="keyword">interface</span> &#123;</span><br><span class="line">	animal</span><br><span class="line">	speak()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e employee)</span> <span class="title">breathe</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Employee breathes&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e employee)</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Employee walk&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e employee)</span> <span class="title">speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Employee speaks&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> h human</span><br><span class="line"></span><br><span class="line">	h = employee&#123;name: <span class="string">&quot;John&quot;</span>&#125;</span><br><span class="line">	h.breathe()</span><br><span class="line">	h.walk()</span><br><span class="line">	h.speak()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Employee breathes</span><br><span class="line">Employee walk</span><br><span class="line">Employee speaks</span><br></pre></td></tr></table></figure>
<p>As an other example, the ReaderWriter interface of the <strong>io</strong> package of golang (<a href="https://golang.org/pkg/io/#ReadWriter">https://golang.org/pkg/io/#ReadWriter</a>) embeds two other interfaces</p>
<ul>
<li><p>The reader interface – <a href="https://golang.org/pkg/io/#Reader">https://golang.org/pkg/io/#Reader</a></p>
</li>
<li><p>The writer interface  – <a href="https://golang.org/pkg/io/#Writer">https://golang.org/pkg/io/#Writer</a></p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Embedding-interface-in-a-struct"><a href="#Embedding-interface-in-a-struct" class="headerlink" title="Embedding interface in a struct"></a>Embedding interface in a struct</h3><p>An interface can be embedded in a struct as well. All the methods of the embedded interface can be called via that struct. How these methods will be called will depend upon whether the embedded interface is a named field or an unnamed/anonymous field. </p>
<ul>
<li><p>If the embedded interface is a named field, then interface methods has to be called via the named interface name</p>
</li>
<li><p>If the embedded interface is unnamed/anonymous field then interface methods can be referred directly or via the interface name</p>
</li>
</ul>
<p>Let’s see a program illustrating above points</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">    breathe()</span><br><span class="line">    walk()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">breathe</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Dog breathes&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Dog walk&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> pet1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    a    animal</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> pet2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    animal</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d := dog&#123;age: <span class="number">5</span>&#125;</span><br><span class="line">    p1 := pet1&#123;name: <span class="string">&quot;Milo&quot;</span>, a: d&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(p1.name)</span><br><span class="line">    <span class="comment">// p1.breathe()</span></span><br><span class="line">    <span class="comment">// p1.walk()</span></span><br><span class="line">    p1.a.breathe()</span><br><span class="line">    p1.a.walk()</span><br><span class="line"></span><br><span class="line">    p2 := pet2&#123;name: <span class="string">&quot;Oscar&quot;</span>, animal: d&#125;</span><br><span class="line">    fmt.Println(p1.name)</span><br><span class="line">    p2.breathe()</span><br><span class="line">    p2.walk()</span><br><span class="line">    p1.a.breathe()</span><br><span class="line">    p1.a.walk()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Milo</span><br><span class="line">Dog breathes</span><br><span class="line">Dod walk</span><br><span class="line"></span><br><span class="line">Oscar</span><br><span class="line">Dog breathes</span><br><span class="line">Dog walk</span><br><span class="line">Dog breathes</span><br><span class="line">Dog walk</span><br></pre></td></tr></table></figure>
<p>We declared two struct <strong>pet1</strong> and <strong>pet2</strong>. <strong>pet1</strong> struct has named <strong>animal</strong> interface in it</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> pet1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    a    animal</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>pet2</strong> has unnamed/anonymous <strong>animal</strong> interface embedded</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> pet2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    animal</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For an instance of <strong>pet1</strong> struct we call the <strong>breathe()</strong> and <strong>walk()</strong> method like this</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p1.a.breathe()</span><br><span class="line">p1.a.walk()</span><br></pre></td></tr></table></figure>
<p>Directly calling these methods with raise compilation error</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p1.breathe()</span><br><span class="line">p1.walk()</span><br><span class="line">p1.breathe undefined (<span class="keyword">type</span> pet1 has no field or method breathe)</span><br><span class="line">p1.walk undefined (<span class="keyword">type</span> pet1 has no field or method walk)</span><br></pre></td></tr></table></figure>
<p>For an instance of <strong>pet2</strong> struct we can call the <strong>breathe()</strong> and <strong>walk()</strong> method like directly</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p2.breathe()</span><br><span class="line">p2.walk()</span><br></pre></td></tr></table></figure>
<p>We can directly access the methods of embedded interface if the embedded interface is anonymous or unnamed.</p>
<p>Below is also valid and another way fo called methods of unnamed/anonymous embedded interface</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p2.animal.breathe()</span><br><span class="line">p2.animal.walk()</span><br></pre></td></tr></table></figure>
<p>Also note that while creating the instance of either the <strong>pet1</strong> or <strong>pet2</strong> struct, the embedded interface i.e <strong>animal</strong> is initialised with a type implementing it i.e <strong>dog</strong> .</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p1 := pet1&#123;name: <span class="string">&quot;Milo&quot;</span>, a: d&#125;</span><br><span class="line">p2 := pet2&#123;name: <span class="string">&quot;Oscar&quot;</span>, animal: d&#125;</span><br></pre></td></tr></table></figure>
<p>If we don’t initialise the embedded interface <strong>animal</strong>, then it will be intialised with the zero value of the interface which is nil. Calling <strong>breathe()</strong> and <strong>walk()</strong> method on such an instance of <strong>pet1</strong> or <strong>pet2</strong> struct will create a panic.</p>
<h2 id="Access-Undelying-Variable-of-Interface"><a href="#Access-Undelying-Variable-of-Interface" class="headerlink" title="Access Undelying Variable of Interface"></a>Access Undelying Variable of Interface</h2><p>The underlying variable can be accessed in two ways</p>
<ul>
<li><p>Type Assertion</p>
</li>
<li><p>Type Switch</p>
</li>
</ul>
<h3 id="Type-assertion-2"><a href="#Type-assertion-2" class="headerlink" title="Type assertion"></a>Type assertion</h3><p>Type assertion provides a way to access the underlying variable inside the interface value of the interface by asserting the correct type of underlying value. Below is the syntax for that where <strong>i</strong> is an interface.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">val := i.(&#123;<span class="keyword">type</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>The above statement is asserting that the type of underlying value in the interface is of type {type}. If this is true then the underlying value is assigned to <strong>val.</strong> If not then the above statement panics.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">	breathe()</span><br><span class="line">	walk()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> lion <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l lion)</span> <span class="title">breathe</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Lion breathes&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l lion)</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Lion walk&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">breathe</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Dog breathes&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Dog walk&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a animal</span><br><span class="line"></span><br><span class="line">	a = lion&#123;age: <span class="number">10</span>&#125;</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(a animal)</span></span> &#123;</span><br><span class="line">	l := a.(lion)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Age: %d\n&quot;</span>, l.age)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//d := a.(dog)</span></span><br><span class="line">	<span class="comment">//fmt.Printf(&quot;Age: %d\n&quot;, d.age)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Age: <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>This is how we assert the variable <strong>a</strong> of type <strong>animal</strong> to have underlying type as <strong>lion</strong>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">l := a.(lion)</span><br></pre></td></tr></table></figure>
<p>Below line will create a panic as underlying type is <strong>lion</strong> and not <strong>dog</strong>. Uncomment the line to check it out</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//d := a.(dog)</span></span><br></pre></td></tr></table></figure>
<p>Type assertion provides another way to get the underlying value and which also prevents a panic. The syntax for that is</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">val, ok := i.()</span><br></pre></td></tr></table></figure>
<p>In this case type assertion returns two values, the first value is the same as discussed above, the other value is boolean indicating whether the type assertion was correct or not. This value is</p>
<ul>
<li><p>true if the type assertion is correct meaning the type asserted is same as the underlying type</p>
</li>
<li><p>false if the type assertion fails.</p>
</li>
</ul>
<p>So the second is a good way of doing type assertion since it prevents a panic. Let’s see an example</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">	breathe()</span><br><span class="line">	walk()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> lion <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l lion)</span> <span class="title">breathe</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Lion breathes&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l lion)</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Lion walk&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">breathe</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Dog breathes&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Dog walk&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a animal</span><br><span class="line"></span><br><span class="line">	a = lion&#123;age: <span class="number">10</span>&#125;</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(a animal)</span></span> &#123;</span><br><span class="line">	l, ok := a.(lion)</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(l)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;a is not of type lion&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	d, ok := a.(dog)</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(d)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;a is not of type lion&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">10</span>&#125;</span><br><span class="line">a is not of <span class="keyword">type</span> lion</span><br></pre></td></tr></table></figure>
<p>Let’s move on to type switch now.</p>
<h3 id="Type-switch-1"><a href="#Type-switch-1" class="headerlink" title="Type switch"></a>Type switch</h3><p>Type switch enables us to do above type assertion in series. See below code example for the same</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">	breathe()</span><br><span class="line">	walk()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> lion <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l lion)</span> <span class="title">breathe</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Lion breathes&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l lion)</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Lion walk&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">breathe</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Dog breathes&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Dog walk&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a animal</span><br><span class="line"></span><br><span class="line">	x = lion&#123;age: <span class="number">10</span>&#125;</span><br><span class="line">	<span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(a animal)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> v := a.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> lion:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Type: lion&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> dog:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Type: dog&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Unknown Type %T&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Type: lion</span><br></pre></td></tr></table></figure>
<p>In the code above, using the type switch we determine the type of value contained in interface variable x is <strong>lion</strong> or <strong>dog</strong> or some other type. It is also ok to add more different types in case statement</p>
<h2 id="Zero-Interface"><a href="#Zero-Interface" class="headerlink" title="Zero Interface"></a>Zero Interface</h2><p>The zero value of a interface is nil. A nil interface has both its underlying value and as well as concrete type as nil.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Describer <span class="keyword">interface</span> &#123;  </span><br><span class="line">    Describe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> d1 Describer</span><br><span class="line">    <span class="keyword">if</span> d1 == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;d1 is nil and has type %T value %v\n&quot;</span>, d1, d1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://play.golang.org/p/vwYHC6Y78H">Run in playground</a></p>
<p><em>d1</em> in the above program is <code>nil</code> and this program will output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d1 is nil and has type &lt;nil&gt; value &lt;nil&gt;  </span><br></pre></td></tr></table></figure>
<p>If we try to call a method on the <code>nil</code> interface, the program will panic since the <code>nil</code> interface neither has a underlying value nor a concrete type.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Describer <span class="keyword">interface</span> &#123;  </span><br><span class="line">    Describe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> d1 Describer</span><br><span class="line">    d1.Describe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://play.golang.org/p/rM-rY0uGTI">Run in playground</a></p>
<p>Since <code>d1</code> in the program above is <code>nil</code>, this program will panic with runtime error <strong>panic: runtime error: invalid memory address or nil pointer dereference<br>[signal SIGSEGV: segmentation violation code=0xffffffff addr=0x0 pc=0xc8527]</strong></p>
<h2 id="Interface-comparison"><a href="#Interface-comparison" class="headerlink" title="Interface comparison"></a>Interface comparison</h2><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_Learning_Fundamental_Json</title>
    <url>/2022/06/29/Go-Learning-Fundamental-Json/</url>
    <content><![CDATA[<p><strong>Reference</strong>: <a href="https://www.sohamkamani.com/golang/json/#unmarshaling-raw-json-data">blog_1</a>, <a href="https://pkg.go.dev/encoding/json">official docs</a></p>
<a id="more"></a>

<h2 id="JSON-Definition"><a href="#JSON-Definition" class="headerlink" title="JSON Definition"></a>JSON Definition</h2><p>JSON is the most popular standard data serialization format. This bllog is used to familar with the basic use of JSON Marshal and JSOM UnMarshal in Go. Any deep detail about json could find from above official docs.</p>
<h2 id="UnMarshal-JSON-Data-to-Struct"><a href="#UnMarshal-JSON-Data-to-Struct" class="headerlink" title="UnMarshal JSON Data to Struct"></a>UnMarshal JSON Data to Struct</h2><h3 id="To-Struct"><a href="#To-Struct" class="headerlink" title="To Struct"></a>To Struct</h3><p>The <code>Unmarshal</code> function provided by Go standard library is used to parse raw json data <code>[]byte format</code> to variables.</p>
<h4 id="To-Simple-Struct"><a href="#To-Simple-Struct" class="headerlink" title="To Simple Struct"></a>To Simple Struct</h4><p>Most simple way is parse to a simple struct. For example a person object:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rawJsonStr := <span class="string">`&#123;&quot;name&quot;: &quot;Qingzhi&quot;, &quot;Age&quot;: 15&#125;`</span></span><br><span class="line">	<span class="keyword">var</span> p Person</span><br><span class="line">	json.Unmarshal([]<span class="keyword">byte</span>(rawJsonStr), &amp;p)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;After unmarshall got person %#v \n&quot;</span>, p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// After unmarshall got person main.Person&#123;Name:&quot;Qingzhi&quot;, Age:15&#125; </span></span><br></pre></td></tr></table></figure>
<p>From above example, we find that the object <code>Person</code> is the mirror of <code>Raw Json DataFormat .</code>  Acturally the json umnmarshal function has a list of match standard, while that not the content today. </p>
<h4 id="To-Nested-Struct"><a href="#To-Nested-Struct" class="headerlink" title="To Nested Struct"></a>To Nested Struct</h4><p>Nested Struct is the same usage as simple struct.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Country  <span class="keyword">string</span></span><br><span class="line">	Province <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="keyword">string</span></span><br><span class="line">	Age     <span class="keyword">int</span></span><br><span class="line">	Address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rawJsonStr := <span class="string">`&#123;&quot;name&quot;: &quot;Qingzhi&quot;, &quot;Age&quot;: 15, &quot;Address&quot;: &#123;&quot;Country&quot;: &quot;China&quot;, &quot;Province&quot;: &quot;ShanDong&quot;&#125;&#125;`</span></span><br><span class="line">	<span class="keyword">var</span> p Person</span><br><span class="line">	json.Unmarshal([]<span class="keyword">byte</span>(rawJsonStr), &amp;p)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;After unmarshall got person %#v \n&quot;</span>, p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// After unmarshall got person main.Person&#123;Name:&quot;Qingzhi&quot;, Age:15, Address:main.Address&#123;Country:&quot;China&quot;, Province:&quot;ShanDong&quot;&#125;&#125; </span></span><br></pre></td></tr></table></figure>
<h4 id="To-Array"><a href="#To-Array" class="headerlink" title="To Array"></a>To Array</h4><p>We can decode any array objectss, like below:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Country  <span class="keyword">string</span></span><br><span class="line">	Province <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="keyword">string</span></span><br><span class="line">	Age     <span class="keyword">int</span></span><br><span class="line">	Address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rawJsonStr := <span class="string">`[</span></span><br><span class="line"><span class="string">		&#123;&quot;name&quot;: &quot;Qingzhi&quot;, &quot;Age&quot;: 15, &quot;Address&quot;: &#123;&quot;Country&quot;: &quot;China&quot;, &quot;Province&quot;: &quot;ShanDong&quot;&#125;&#125;,</span></span><br><span class="line"><span class="string">		&#123;&quot;name&quot;: &quot;WuKong&quot;, &quot;Age&quot;: 500, &quot;Address&quot;: &#123;&quot;Country&quot;: &quot;China&quot;, &quot;Province&quot;: &quot;ShanDong&quot;&#125;&#125;</span></span><br><span class="line"><span class="string">		]`</span></span><br><span class="line">	<span class="keyword">var</span> pSlice []Person</span><br><span class="line">	json.Unmarshal([]<span class="keyword">byte</span>(rawJsonStr), &amp;pSlice)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;After unmarshall got person %#v \n&quot;</span>, pSlice)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// After unmarshall got person []main.Person&#123;main.Person&#123;Name:&quot;Qingzhi&quot;, Age:15, Address:main.Address&#123;Country:&quot;China&quot;, Province:&quot;ShanDong&quot;&#125;&#125;, main.Person&#123;Name:&quot;WuKong&quot;, Age:500, Address:main.Address&#123;Country:&quot;China&quot;, Province:&quot;ShanDong&quot;&#125;&#125;&#125; </span></span><br></pre></td></tr></table></figure>
<h3 id="To-Map"><a href="#To-Map" class="headerlink" title="To Map"></a>To Map</h3><p>There is some scenatioies that we have no idea what kind of object would transfer to your application. In this context, use interfacr map is a good choice, after unmarshall unkown object, we can use type reflection to got the finial struct. For example :</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rawJsonStr := <span class="string">`&#123;&quot;name&quot;: &quot;Qingzhi&quot;, &quot;Age&quot;: 15, &quot;Address&quot;: &#123;&quot;Country&quot;: &quot;China&quot;, &quot;Province&quot;: &quot;ShanDong&quot;&#125;&#125;`</span></span><br><span class="line">	<span class="keyword">var</span> unkown <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	json.Unmarshal([]<span class="keyword">byte</span>(rawJsonStr), &amp;unkown)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;After unmarshall got person %#v \n&quot;</span>, unkown)</span><br><span class="line">	<span class="keyword">for</span> key, value := <span class="keyword">range</span> unkown &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;key is %v, value is %v, \n&quot;</span>, key, value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// After unmarshall got person map[string]interface &#123;&#125;&#123;&quot;Address&quot;:map[string]interface &#123;&#125;&#123;&quot;Country&quot;:&quot;China&quot;, &quot;Province&quot;:&quot;ShanDong&quot;&#125;, &quot;Age&quot;:15, &quot;name&quot;:&quot;Qingzhi&quot;&#125; </span></span><br><span class="line"><span class="comment">// key is Address, value is map[Country:China Province:ShanDong], </span></span><br><span class="line"><span class="comment">/// key is name, value is Qingzhi, </span></span><br><span class="line"><span class="comment">/// key is Age, value is 15, </span></span><br></pre></td></tr></table></figure>
<h3 id="To-Primitive-Type"><a href="#To-Primitive-Type" class="headerlink" title="To  Primitive Type"></a>To  Primitive Type</h3><p>We mostly deal with complex objects or arrays when working with JSON, but data like <code>3</code>, <code>3.1412</code> and <code>&quot;birds&quot;</code> are also valid JSON strings.</p>
<p>We can unmarshal these values to their corresponding data type in Go by using primitive types:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	numberJson := <span class="string">&quot;3&quot;</span></span><br><span class="line">	floatJson := <span class="string">&quot;3.1412&quot;</span></span><br><span class="line">	stringJson := <span class="string">`&quot;bird&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> pi <span class="keyword">float64</span></span><br><span class="line">	<span class="keyword">var</span> str <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	json.Unmarshal([]<span class="keyword">byte</span>(numberJson), &amp;n)</span><br><span class="line">	fmt.Println(n)</span><br><span class="line"></span><br><span class="line">	json.Unmarshal([]<span class="keyword">byte</span>(floatJson), &amp;pi)</span><br><span class="line">	fmt.Println(pi)</span><br><span class="line"></span><br><span class="line">	json.Unmarshal([]<span class="keyword">byte</span>(stringJson), &amp;str)</span><br><span class="line">	fmt.Println(str)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 3.1412</span></span><br><span class="line"><span class="comment">// bird</span></span><br></pre></td></tr></table></figure>
<h2 id="Marshal-Struct-to-JSON-Data"><a href="#Marshal-Struct-to-JSON-Data" class="headerlink" title="Marshal Struct to JSON Data"></a>Marshal Struct to JSON Data</h2><p>The same rule could used to encode struct to json data.</p>
<h3 id="From-Struct"><a href="#From-Struct" class="headerlink" title="From Struct"></a>From Struct</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := Person&#123;</span><br><span class="line">		Name: <span class="string">&quot;Qingzhi&quot;</span>,</span><br><span class="line">		Age:  <span class="number">15</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	bs, _ := json.Marshal(p)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Got marshall result %v \n&quot;</span>, <span class="keyword">string</span>(bs))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Got marshall result &#123;&quot;Name&quot;:&quot;Qingzhi&quot;,&quot;Age&quot;:15&#125; </span></span><br></pre></td></tr></table></figure>
<p>Other tips is omited.</p>
<h2 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h2><p>There is some useful api we used in our project.</p>
<h3 id="Transfer-object-to-object"><a href="#Transfer-object-to-object" class="headerlink" title="Transfer object to object"></a>Transfer object to object</h3><h3 id="Parse-Struct-to-String"><a href="#Parse-Struct-to-String" class="headerlink" title="Parse Struct to String"></a>Parse Struct to String</h3><h3 id="Parse-String-to-Struct"><a href="#Parse-String-to-Struct" class="headerlink" title="Parse String to Struct"></a>Parse String to Struct</h3><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>As a general rule of thumb, if you <em>can</em> use structs to represent your JSON data, you should use them. The only good reason to use maps would be if it were not possible to use structs due to the uncertain nature of the keys or values in the data.</p>
<p>If we use maps, we will either need each of the keys to have the same data type, or use a generic type and convert it later.</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_Learning_Fundamental_Label in Go Land</title>
    <url>/2022/06/29/Go-Learning-Fundamental-Label-in-Go-Land/</url>
    <content><![CDATA[<ul>
<li>Reference: <a href="https://go101.org/article/control-flows.html">Go 101</a></li>
</ul>
<p><code>Labels</code> in go is used in <code>break</code> and <code>continue</code> statement which is optional but it’s required in <code>goto</code> statement. The scope of <code>Labels</code> is the function where it’s declared.</p>
<a id="more"></a>

<h2 id="Declare-And-Definition"><a href="#Declare-And-Definition" class="headerlink" title="Declare And Definition"></a>Declare And Definition</h2><p>A label is declared with format <code>LabelName:</code>, where the <code>LabelName</code> is an identifier. A label which name is not a blank identifier must be used at least once time.</p>
<h3 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h3><ul>
<li><p>A <strong>label</strong> must be declared in a <strong>function body</strong>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Next: <span class="comment">// here, a label is declared.</span></span><br><span class="line">	fmt.Println(i)</span><br><span class="line">	i++</span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="number">5</span> &#123;</span><br><span class="line">		<span class="keyword">goto</span> Next <span class="comment">// execution jumps</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>A <strong>label</strong> is not visible/available outside the <strong>innermost block</strong> which the label is declared.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">goto</span> Label1 <span class="comment">// error</span></span><br><span class="line">	&#123;</span><br><span class="line">		Label1:</span><br><span class="line">		<span class="keyword">goto</span> Label2 <span class="comment">// error</span></span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		Label2:</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>If a <strong>label</strong> is declared with the scope of variable <code>a</code>, the use a <strong>label</strong> can’t appear before the declaration of variable <code>a</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">Next:</span><br><span class="line">	<span class="keyword">if</span> i &gt;= <span class="number">5</span> &#123;</span><br><span class="line">		<span class="comment">// error: jumps over declaration of k</span></span><br><span class="line">		<span class="keyword">goto</span> Exit</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	k := i + i</span><br><span class="line">	fmt.Println(k)</span><br><span class="line">	i++</span><br><span class="line">	<span class="keyword">goto</span> Next</span><br><span class="line"></span><br><span class="line"><span class="comment">// This label is declared in the scope of k,</span></span><br><span class="line"><span class="comment">// but its use is outside of the scope of k.</span></span><br><span class="line">Exit:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Fixed way one: <strong>shrink the variable scope</strong> </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">Next:</span><br><span class="line">	<span class="keyword">if</span> i &gt;= <span class="number">5</span> &#123;</span><br><span class="line">		<span class="keyword">goto</span> Exit</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Create an explicit code block to</span></span><br><span class="line">	<span class="comment">// shrink the scope of k.</span></span><br><span class="line">	&#123;</span><br><span class="line">		k := i + i</span><br><span class="line">		fmt.Println(k)</span><br><span class="line">	&#125;</span><br><span class="line">	i++</span><br><span class="line">	<span class="keyword">goto</span> Next</span><br><span class="line">Exit:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Fixed way two: <strong>enlarge the variable scope</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> k <span class="keyword">int</span> <span class="comment">// move the declaration of k here.</span></span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">Next:</span><br><span class="line">	<span class="keyword">if</span> i &gt;= <span class="number">5</span> &#123;</span><br><span class="line">		<span class="keyword">goto</span> Exit</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	k = i + i</span><br><span class="line">	fmt.Println(k)</span><br><span class="line">	i++</span><br><span class="line">	<span class="keyword">goto</span> Next</span><br><span class="line">Exit:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2></li>
</ul>
</li>
</ul>
<p>There are three control flow jump statements,<code>goto, break, continue</code> , could apply with <code>label</code>; The <code>goto</code> statement must follow with <code>label</code> while <code>break, continue</code> has option to choice.</p>
<h3 id="goto-Statement-with-label"><a href="#goto-Statement-with-label" class="headerlink" title="goto Statement with label"></a><code>goto</code> Statement with label</h3><p>The basic format of <code>goto</code> statement with <code>label</code> is :</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> label</span><br><span class="line"></span><br><span class="line">do something</span><br><span class="line"></span><br><span class="line">label: </span><br><span class="line">statement</span><br></pre></td></tr></table></figure>
<p>In the first part, the usage of <code>goto</code> has explained, in fact there is no much details could talk with <code>goto</code>. In practice <code>goto</code> is not recommend to use. It a easy way to deduct readability and product bug. </p>
<h3 id="break-Statement-with-label"><a href="#break-Statement-with-label" class="headerlink" title="break Statement with label"></a><code>break</code> Statement with label</h3><p>Generally, <code>break</code> containing  <code>label</code> is used in nested breakable control flow blocks.</p>
<p>If a <code>break</code> statement contains a label, the label must be declared just before a breakable control flow block which contains the <code>break</code> statement. We can view the label name as the name of the breakable control flow block. The <code>break</code> statement will make execution jump out of the breakable control flow block, even if the breakable control flow block is not the innermost breakable control flow block containing <code>break</code> statement.</p>
<h3 id="continue-Statement-with-label"><a href="#continue-Statement-with-label" class="headerlink" title="continue Statement with label"></a><code>continue</code> Statement with label</h3><p>Generally, <code>continue</code> containing  <code>label</code> is used in nested breakable control flow blocks.</p>
<p>If a <code>continue</code> statement contains a label, the label must be declared just before a loop control flow block which contains the <code>continue</code> statement. We can view the label name as the name of the loop control flow block. The <code>continue</code> statement will end the current loop step of the loop control flow block in advance, even if the loop control flow block is not the innermost loop control flow block containing the <code>continue</code> statement.</p>
<p>The following is an example of using <code>break</code> and <code>continue</code> statements with labels.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindSmallestPrimeLargerThan</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">Outer:</span><br><span class="line">	<span class="keyword">for</span> n++; ; n++&#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">2</span>; ; i++ &#123;</span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> i * i &gt; n:</span><br><span class="line">				<span class="keyword">break</span> Outer</span><br><span class="line">			<span class="keyword">case</span> n % i == <span class="number">0</span>:</span><br><span class="line">				<span class="keyword">continue</span> Outer</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">90</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		n := FindSmallestPrimeLargerThan(i)</span><br><span class="line">		fmt.Print(<span class="string">&quot;The smallest prime number larger than &quot;</span>)</span><br><span class="line">		fmt.Println(i, <span class="string">&quot;is&quot;</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_Learning_Fundamental_format</title>
    <url>/2022/06/29/Go-Learning-Fundamental-format/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://yourbasic.org/golang/fmt-printf-reference-cheat-sheet/">copy from blog</a>, <a href="https://zetcode.com/golang/string-format/">copy from blog</a></p>
</blockquote>
<a id="more"></a>

<h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><p>With the Go <a href="https://golang.org/pkg/fmt"><code>fmt</code></a> package you can format numbers and strings padded with spaces or zeroes, in different bases, and with optional quotes.</p>
<p>You submit a <strong>template string</strong> that contains the text you want to format plus some <strong>annotation verbs</strong> that tell the <code>fmt</code> functions how to format the trailing arguments.</p>
<h3 id="Printf"><a href="#Printf" class="headerlink" title="Printf"></a>Printf</h3><p>In this example, <a href="https://golang.org/pkg/fmt/#Printf"><code>fmt.Printf</code></a> formats and writes to standard output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fmt.Printf(&quot;Binary: %b\\%b&quot;, 4, 5) &#x2F;&#x2F; Prints &#96;Binary: 100\101&#96;</span><br></pre></td></tr></table></figure>
<ul>
<li>the <strong>template string</strong> is <code>&quot;Binary: %b\\%b&quot;</code>,</li>
<li>the <strong>annotation verb</strong> <code>%b</code> formats a number in binary, and</li>
<li>the <strong>special value</strong> <code>\\</code> is a backslash.</li>
</ul>
<p>As a special case, the verb <code>%%</code>, which consumes no argument, produces a percent sign:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fmt.Printf(&quot;%d %%&quot;, 50) &#x2F;&#x2F; Prints &#96;50 %&#96;</span><br></pre></td></tr></table></figure>
<h3 id="Sprintf-format-without-printing"><a href="#Sprintf-format-without-printing" class="headerlink" title="Sprintf (format without printing)"></a>Sprintf (format without printing)</h3><p>Use <a href="https://golang.org/pkg/fmt/#Sprintf"><code>fmt.Sprintf</code></a> to format a string without printing it:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s :&#x3D; fmt.Sprintf(&quot;Binary: %b\\%b&quot;, 4, 5) &#x2F;&#x2F; s &#x3D;&#x3D; &#96;Binary: 100\101&#96;</span><br></pre></td></tr></table></figure>
<h3 id="Find-fmt-errors-with-vet"><a href="#Find-fmt-errors-with-vet" class="headerlink" title="Find fmt errors with vet"></a>Find fmt errors with vet</h3><p>If you try to compile and run this incorrect line of code</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fmt.Printf(&quot;Binary: %b\\%b&quot;, 4) &#x2F;&#x2F; An argument to Printf is missing.</span><br></pre></td></tr></table></figure>
<p>you’ll find that the program will compile, and then print</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Binary: 100\%!b(MISSING)</span><br></pre></td></tr></table></figure>
<p>To catch this type of errors early, you can use the <a href="https://golang.org/cmd/vet/">vet command</a> – it can find calls whose arguments do not align with the format string.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go vet example.go</span><br><span class="line">example.go:8: missing argument for Printf(&quot;%b&quot;): format reads arg 2, have only 1 args</span><br></pre></td></tr></table></figure>
<h2 id="Basic-syntax"><a href="#Basic-syntax" class="headerlink" title="Basic syntax"></a>Basic syntax</h2><p>The functions take the format string and the list of arguments as parameters.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%[flags][width][.precision]verb</span><br></pre></td></tr></table></figure>
<p>The format string has this syntax. The options specified within [] characters are optional.</p>
<p>The **verb **at the end defines the type and the interpretation of its corresponding argument.</p>
<ul>
<li>d - decimal integer</li>
<li>o - octal integer</li>
<li>O - octal integer with 0 prefix</li>
<li>b - binary integer</li>
<li>x - hexadecimal integer lowercase</li>
<li>X - hexadecimal integer uppercase</li>
<li>f - decimal floating point, lowercase</li>
<li>F - decimal floating point, uppercase</li>
<li>e - scientific notation (mantissa/exponent), lowercase</li>
<li>E - scientific notation (mantissa/exponent), uppercase</li>
<li>g - the shortest representation of %e or %f</li>
<li>G - the shortest representation of %E or %F</li>
<li>c - a character represented by the corresponding Unicode code point</li>
<li>q - a quoted character</li>
<li>U - Unicode escape sequence</li>
<li>t - the word true or false</li>
<li>s - a string</li>
<li>v - default format</li>
<li>#v - Go-syntax representation of the value</li>
<li>T - a Go-syntax representation of the type of the value</li>
<li>p - pointer address</li>
<li>% - a double %% prints a single %</li>
</ul>
<p>The <strong>flags</strong> is a set of characters that modify the output format. The set of valid flags depends on the conversion character. </p>
<p>The <strong>width</strong> is a non-negative decimal integer indicating the minimum number of runes to be written to the output. If the value to be printed is shorter than the width, the result is padded with blank spaces. The value is not truncated even if the result is larger.</p>
<p>For integer conversion characters the <strong>precision</strong> specifies the minimum number of digits to be written. If the value to be written is shorter than this number, the result is padded with leading zeros. For strings it is the maximum number of runes to be printed. For e, E, f and F verbs, it is the number of digits to be printed after the decimal point. For g and G verbs it is the maximum number of significant digits to be printed.</p>
<h2 id="Cheat-sheet"><a href="#Cheat-sheet" class="headerlink" title="Cheat sheet"></a>Cheat sheet</h2><h3 id="Default-formats-and-type"><a href="#Default-formats-and-type" class="headerlink" title="Default formats and type"></a>Default formats and type</h3><ul>
<li><strong>Value:</strong> <code>[]int64&#123;0, 1&#125;</code></li>
</ul>
<table>
<thead>
<tr>
<th align="left">Format</th>
<th align="left">Verb</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[0 1]</td>
<td align="left"><code>%v</code></td>
<td align="left">Default format</td>
</tr>
<tr>
<td align="left">[]int64{0, 1}</td>
<td align="left"><code>%#v</code></td>
<td align="left">Go-syntax format</td>
</tr>
<tr>
<td align="left">[]int64</td>
<td align="left"><code>%T</code></td>
<td align="left">The type of the value</td>
</tr>
</tbody></table>
<h3 id="Integer-indent-base-sign"><a href="#Integer-indent-base-sign" class="headerlink" title="Integer (indent, base, sign)"></a>Integer (indent, base, sign)</h3><ul>
<li><strong>Value:</strong> <code>15</code></li>
</ul>
<table>
<thead>
<tr>
<th align="left">Format</th>
<th align="left">Verb</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">15</td>
<td align="left"><code>%d</code></td>
<td align="left">Base 10</td>
</tr>
<tr>
<td align="left">+15</td>
<td align="left"><code>%+d</code></td>
<td align="left">Always show sign</td>
</tr>
<tr>
<td align="left">␣␣15</td>
<td align="left"><code>%4d</code></td>
<td align="left">Pad with spaces (width 4, right justified)</td>
</tr>
<tr>
<td align="left">15␣␣</td>
<td align="left"><code>%-4d</code></td>
<td align="left">Pad with spaces (width 4, left justified)</td>
</tr>
<tr>
<td align="left">0015</td>
<td align="left"><code>%04d</code></td>
<td align="left">Pad with zeroes (width 4)</td>
</tr>
<tr>
<td align="left">1111</td>
<td align="left"><code>%b</code></td>
<td align="left">Base 2</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><code>%o</code></td>
<td align="left">Base 8</td>
</tr>
<tr>
<td align="left">f</td>
<td align="left"><code>%x</code></td>
<td align="left">Base 16, lowercase</td>
</tr>
<tr>
<td align="left">F</td>
<td align="left"><code>%X</code></td>
<td align="left">Base 16, uppercase</td>
</tr>
<tr>
<td align="left">0xf</td>
<td align="left"><code>%#x</code></td>
<td align="left">Base 16, with leading 0x</td>
</tr>
</tbody></table>
<h3 id="Character-quoted-Unicode"><a href="#Character-quoted-Unicode" class="headerlink" title="Character (quoted, Unicode)"></a>Character (quoted, Unicode)</h3><ul>
<li><strong>Value:</strong> <code>65</code>  (Unicode letter A)</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Format</th>
<th align="left">Verb</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">A</td>
<td align="left"><code>%c</code></td>
<td align="left">Character</td>
</tr>
<tr>
<td align="left">‘A’</td>
<td align="left"><code>%q</code></td>
<td align="left">Quoted character</td>
</tr>
<tr>
<td align="left">U+0041</td>
<td align="left"><code>%U</code></td>
<td align="left">Unicode</td>
</tr>
<tr>
<td align="left">U+0041 ‘A’</td>
<td align="left"><code>%#U</code></td>
<td align="left">Unicode with character</td>
</tr>
</tbody></table>
<h3 id="Boolean-true-false"><a href="#Boolean-true-false" class="headerlink" title="Boolean (true/false)"></a>Boolean (true/false)</h3><p>Use <code>%t</code> to format a boolean as <code>true</code> or <code>false</code>.</p>
<h3 id="Pointer-hex"><a href="#Pointer-hex" class="headerlink" title="Pointer (hex)"></a>Pointer (hex)</h3><p>Use <code>%p</code> to format a pointer in base 16 notation with leading <code>0x</code>.</p>
<h3 id="Float-indent-precision-scientific-notation"><a href="#Float-indent-precision-scientific-notation" class="headerlink" title="Float (indent, precision, scientific notation)"></a>Float (indent, precision, scientific notation)</h3><ul>
<li><strong>Value:</strong> <code>123.456</code></li>
</ul>
<table>
<thead>
<tr>
<th align="left">Format</th>
<th align="left">Verb</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1.234560e+02</td>
<td align="left"><code>%e</code></td>
<td align="left">Scientific notation</td>
</tr>
<tr>
<td align="left">123.456000</td>
<td align="left"><code>%f</code></td>
<td align="left">Decimal point, no exponent</td>
</tr>
<tr>
<td align="left">123.46</td>
<td align="left"><code>%.2f</code></td>
<td align="left">Default width, precision 2</td>
</tr>
<tr>
<td align="left">␣␣123.46</td>
<td align="left"><code>%8.2f</code></td>
<td align="left">Width 8, precision 2</td>
</tr>
<tr>
<td align="left">123.456</td>
<td align="left"><code>%g</code></td>
<td align="left">Exponent as needed, necessary digits only</td>
</tr>
</tbody></table>
<h3 id="String-or-byte-slice-quote-indent-hex"><a href="#String-or-byte-slice-quote-indent-hex" class="headerlink" title="String or byte slice (quote, indent, hex)"></a>String or byte slice (quote, indent, hex)</h3><ul>
<li><strong>Value:</strong> <code>&quot;café&quot;</code></li>
</ul>
<table>
<thead>
<tr>
<th align="left">Format</th>
<th align="left">Verb</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">café</td>
<td align="left"><code>%s</code></td>
<td align="left">Plain string</td>
</tr>
<tr>
<td align="left">␣␣café</td>
<td align="left"><code>%6s</code></td>
<td align="left">Width 6, right justify</td>
</tr>
<tr>
<td align="left">café␣␣</td>
<td align="left"><code>%-6s</code></td>
<td align="left">Width 6, left justify</td>
</tr>
<tr>
<td align="left">“café”</td>
<td align="left"><code>%q</code></td>
<td align="left">Quoted string</td>
</tr>
<tr>
<td align="left">636166c3a9</td>
<td align="left"><code>%x</code></td>
<td align="left">Hex dump of byte values</td>
</tr>
<tr>
<td align="left">63 61 66 c3 a9</td>
<td align="left"><code>% x</code></td>
<td align="left">Hex dump with spaces</td>
</tr>
</tbody></table>
<h3 id="Special-values"><a href="#Special-values" class="headerlink" title="Special values"></a>Special values</h3><table>
<thead>
<tr>
<th align="left">Value</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>\a</code></td>
<td align="left">U+0007 alert or bell</td>
</tr>
<tr>
<td align="left"><code>\b</code></td>
<td align="left">U+0008 backspace</td>
</tr>
<tr>
<td align="left"><code>\\</code></td>
<td align="left">U+005c backslash</td>
</tr>
<tr>
<td align="left"><code>\t</code></td>
<td align="left">U+0009 horizontal tab</td>
</tr>
<tr>
<td align="left"><code>\n</code></td>
<td align="left">U+000A line feed or newline</td>
</tr>
<tr>
<td align="left"><code>\f</code></td>
<td align="left">U+000C form feed</td>
</tr>
<tr>
<td align="left"><code>\r</code></td>
<td align="left">U+000D carriage return</td>
</tr>
<tr>
<td align="left"><code>\v</code></td>
<td align="left">U+000b vertical tab</td>
</tr>
</tbody></table>
<p>Arbitrary values can be encoded with backslash escapes and can be used in any <code>&quot;&quot;</code> string literal.</p>
<p>There are four different formats:</p>
<ul>
<li><code>\x</code> followed by exactly two hexadecimal digits,</li>
<li><code>\</code> followed by exactly three octal digits,</li>
<li><code>\u</code> followed by exactly four hexadecimal digits,</li>
<li><code>\U</code> followed by exactly eight hexadecimal digits.</li>
</ul>
<p>The escapes <code>\u</code> and <code>\U</code> represent Unicode code points.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fmt.Println(&quot;\\caf\u00e9&quot;) &#x2F;&#x2F; Prints \café</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_Learning_Fundamental_String</title>
    <url>/2022/06/29/Go-Learning-Fundamental-String/</url>
    <content><![CDATA[<p><strong>Reference</strong>: <a href="https://zetcode.com/golang/string/">blog1</a>, <a href="https://go101.org/article/string.html">blog2</a>, <a href="https://golangbot.com/strings/">blog_3</a>, <a href="https://www.sohamkamani.com/golang/json/#unmarshaling-raw-json-data">blog_4</a></p>
<a id="more"></a>

<h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>A string is <strong>a slice of bytes</strong> in Go. </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> is the set of all strings of <span class="number">8</span>-bit bytes, conventionally but not necessarily representing UTF<span class="number">-8</span>-encoded text. A <span class="keyword">string</span> may be empty, but not <span class="literal">nil</span>. Values of <span class="keyword">string</span> <span class="keyword">type</span> are immutable.</span><br><span class="line">																		--	from <span class="keyword">go</span> compilter</span><br></pre></td></tr></table></figure>
<h3 id="Base-Data-Structure-of-String-in-Go"><a href="#Base-Data-Structure-of-String-in-Go" class="headerlink" title="Base Data Structure of String in Go"></a>Base Data Structure of String in Go</h3><p>String in Go is C Struct, string is a wrapper of <code>byte</code> sequence. We can realyyy view string as immutable byte slice.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type _string <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	elements *byte <span class="comment">// underlying bytes</span></span><br><span class="line">	len      <span class="keyword">int</span>   <span class="comment">// number of bytes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="literal-String-Raw-String-Multi-Line-String"><a href="#literal-String-Raw-String-Multi-Line-String" class="headerlink" title="literal String| Raw String | Multi Line String"></a>literal String| Raw String | Multi Line String</h3><p>Go support two styles of string literals, the double-quote style and the back-quote style(raw string literalss).</p>
<p><strong>Literal String</strong>: created with double quotes, escape sequence is sensitive, such as <code>\n</code>, <code>\r</code>; </p>
<p><strong>Raw String:</strong> created with back-quote, escape sequence is insensitive.</p>
<p><strong>Multi Line String:</strong> create with bak-quote with multi line, escape sequence is insensitive.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	literalString := <span class="string">&quot;Literal string is create with double quote \nwhich own escape sequence sensitive feature;&quot;</span></span><br><span class="line">	rawString := <span class="string">`Raw string is create with back-quote \n which own escape sequence insensitive feature;`</span></span><br><span class="line">	multiLineString := <span class="string">`</span></span><br><span class="line"><span class="string">	MultiLine string is create with back-quote</span></span><br><span class="line"><span class="string">	which own multi line sentitive feature						</span></span><br><span class="line"><span class="string">	`</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(literalString)</span><br><span class="line">	fmt.Println(rawString)</span><br><span class="line">	fmt.Println(multiLineString)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Literal string is create with double quote </span></span><br><span class="line"><span class="comment">// which own escape sequence sensitive feature;</span></span><br><span class="line"><span class="comment">// Raw string is create with back-quote \n which own escape sequence insensitive feature;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        MultiLine string is create with back-quote</span></span><br><span class="line"><span class="comment">//        which own multi line sentitive feature</span></span><br></pre></td></tr></table></figure>
<h3 id="Some-Fact-with-String"><a href="#Some-Fact-with-String" class="headerlink" title="Some Fact with String"></a>Some Fact with String</h3><ul>
<li>String values can be used as constants (along with boolean and all kinds of numeric values).</li>
<li>Go supports <a href="https://go101.org/article/basic-types-and-value-literals.html#string-literals">two styles of string literals</a>, the double-quote style (or interpreted literals) and the back-quote style (or raw string literals).</li>
<li>The zero values of string types are blank strings, which can be represented with <code>&quot;&quot;</code> or ```` in literal.</li>
<li>Strings can be concatenated with <code>+</code> and <code>+=</code> operators.</li>
<li>String types are all comparable (by using the <code>==</code> and <code>!=</code> operators). And like integer and floating-point values, two values of the same string type can also be compared with <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code> and <code>&lt;=</code> operators. When comparing two strings, their underlying bytes will be compared, one byte by one byte. If one string is a prefix of the other one and the other one is longer, then the other one will be viewed as the larger one.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> hello = <span class="string">&quot;hello&quot;</span></span><br><span class="line">	<span class="keyword">var</span> world = <span class="string">`World!`</span></span><br><span class="line">	helloWorld := hello + <span class="string">&quot; &quot;</span> + world</span><br><span class="line">	fmt.Println(helloWorld)         <span class="comment">// helloworld</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;hello&quot;</span> == hello)   <span class="comment">// true</span></span><br><span class="line">	fmt.Println(hello &gt; helloWorld) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Like Java, the contents (underlying bytes) of string values are immutable. The lengths of string values also can’t be modified separately. An addressable string value can only be overwritten as a whole by assigning another string value to it.</li>
<li>The built-in <code>string</code>  type has no methods (just like most other built-in types in Go), but we can<ul>
<li>use functions provided in the <a href="https://golang.org/pkg/strings/"><code>strings</code> standard package</a> to do all kinds of string manipulations.</li>
<li>call the built-in <code>len</code> function to get the length of a string (number of bytes stored in the string).</li>
<li>use the element access syntax <code>aString[i]</code> introduced in <a href="https://go101.org/article/container.html#element-access">container element accesses</a> to get the *<em>i**</em>th* <code>byte</code> value stored in <code>aString</code>. The expression <code>aString[i]</code> is not addressable. In other words, value <code>aString[i]</code> can’t be modified.</li>
<li>use <a href="https://go101.org/article/container.html#subslice">the subslice syntax</a> <code>aString[start:end]</code> to get a substring of <code>aString</code>. Here, <code>start</code> and <code>end</code> are both indexes of bytes stored in <code>aString</code>.</li>
</ul>
</li>
<li>For the standard Go compiler, the destination string variable and source string value in a string assignment will share the same underlying byte sequence in memory. The result of a substring expression <code>aString[start:end]</code> also shares the same underlying byte sequence with the base string <code>aString</code> in memory.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> hello = <span class="string">&quot;hello&quot;</span></span><br><span class="line">	<span class="keyword">var</span> world = <span class="string">`World!`</span></span><br><span class="line">	helloWorld := hello + <span class="string">&quot; &quot;</span> + world</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(helloWorld))    <span class="comment">// 12</span></span><br><span class="line">	fmt.Println(helloWorld[<span class="number">0</span>])      <span class="comment">// 104 is byte value of &#x27;h&#x27;</span></span><br><span class="line">	<span class="comment">// helloWorld[0] = &#x27;H&#x27; Error string is immutable</span></span><br><span class="line">	<span class="comment">// fmt.Printf(&amp;helloWorld[0]) Error string is unaddressable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Operation-With-String"><a href="#Operation-With-String" class="headerlink" title="Operation With String"></a>Operation With String</h2><h3 id="Compare-String-in-Go"><a href="#Compare-String-in-Go" class="headerlink" title="Compare String in Go"></a>Compare String in Go</h3><p>As mentioned above, when comparing two strings, their <strong>underlying bytes</strong> will be compared, <strong>one byte by one byte</strong>, If one string is the prefix of another string, then the longer one viewed as the larger one. While Go compilers make the following optimizations for string comparisons.</p>
<ul>
<li>For <code>==</code> and <code>!=</code> comparison, if the length of the compared string is not equal, then the two strings must be not equal.</li>
<li>If their underlying bytes sequence pointers are equal, then the comparision result is the same as comparing the length of two strings.</li>
</ul>
<p>So for two equal strings, the time complexity of comparing them depend on whether or not their underlying byte sequence pointers are equal. If the two are equal, time complexity is <code>O(1)</code>, otherwise is <code>O(n)</code>.</p>
<p>As above mentioned, for the go standrad Go compiler, in a string value assignment, the destination string value and the source string will share the same underlying byte sequence in memory. So the cost of comparing the two strings becomes very small.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	bs := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1</span>&lt;&lt;<span class="number">26</span>)</span><br><span class="line">    <span class="comment">// s0, s1, s2 are three equal string</span></span><br><span class="line">    <span class="comment">// s0 is the deep copy of bs, s1 is also a deep copy of bs</span></span><br><span class="line">    <span class="comment">// so s0 s1 has different memory address</span></span><br><span class="line">    <span class="comment">// as mentiond, s2 and s1 share the same memory</span></span><br><span class="line">	s0 := <span class="keyword">string</span>(bs)</span><br><span class="line">	s1 := <span class="keyword">string</span>(bs)</span><br><span class="line">	s2 := s1</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	_ = s0 == s1</span><br><span class="line">	duration := time.Now().Sub(startTime)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Duration for (s0==s1):&quot;</span>, duration)</span><br><span class="line"></span><br><span class="line">	startTime = time.Now()</span><br><span class="line">	_ = s2 == s1</span><br><span class="line">	duration = time.Now().Sub(startTime)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Duration for (s1==s2):&quot;</span>, duration)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Duration for (s0==s1): 15.190255ms</span></span><br><span class="line"><span class="comment">// Duration for (s1==s2): 94ns</span></span><br></pre></td></tr></table></figure>
<p>1ms is 1000000ns! So please try to avoid comparing two long strings if they don’t share the same underlying byte sequence.</p>
<h3 id="Loop-Over-String"><a href="#Loop-Over-String" class="headerlink" title="Loop Over  String"></a>Loop Over  String</h3><ul>
<li>**Classic for : loop over bytes. **</li>
<li><strong>For range: loops over runes.</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	name := <span class="string">&quot;Sun清志&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i, char := <span class="keyword">range</span> name &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Index of char %c is %v \n&quot;</span>, char, i)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Print(<span class="string">&quot;--------------- \n&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(name); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;index %v  val of name is %c \n&quot;</span>, i, name[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Index of char S is 0 </span></span><br><span class="line"><span class="comment">// Index of char u is 1 </span></span><br><span class="line"><span class="comment">// Index of char n is 2 </span></span><br><span class="line"><span class="comment">// Index of char 清 is 3 </span></span><br><span class="line"><span class="comment">// Index of char 志 is 6 </span></span><br><span class="line"><span class="comment">/// --------------- </span></span><br><span class="line"><span class="comment">// index 0  val of name is S </span></span><br><span class="line"><span class="comment">// index 1  val of name is u </span></span><br><span class="line"><span class="comment">// index 2  val of name is n </span></span><br><span class="line"><span class="comment">// index 3  val of name is æ </span></span><br><span class="line"><span class="comment">// index 4  val of name is ¸ </span></span><br><span class="line"><span class="comment">// index 5  val of name is </span></span><br><span class="line"><span class="comment">// index 6  val of name is å </span></span><br><span class="line"><span class="comment">// index 7  val of name is ¿ </span></span><br><span class="line"><span class="comment">// index 8  val of name is  </span></span><br></pre></td></tr></table></figure>
<h3 id="String-Join-String-Split"><a href="#String-Join-String-Split" class="headerlink" title="String Join | String Split"></a>String Join | String Split</h3><p>Besides using the <code>+</code> operator to concatenate strings, we can also use following ways to concatenate strings.</p>
<ul>
<li>The <code>Sprintf</code>/<code>Sprint</code>/<code>Sprintln</code> functions in the <code>fmt</code> standard package can be used to concatenate values of any types, including string types.</li>
<li>Use the <code>Join</code> function in the <code>strings</code> standard package.</li>
<li>The <code>Buffer</code> type in the <code>bytes</code> standard package (or the built-in <code>copy</code> function) can be used to build byte slices, which afterwards can be converted to string values.</li>
<li>Since Go 1.10, the <code>Builder</code> type in the <code>strings</code> standard package can be used to build strings. Comparing with <code>bytes.Buffer</code> way, this way avoids making an unnecessary duplicated copy of underlying bytes for the result string.</li>
</ul>
<p>The standard Go compiler makes optimizations for string concatenations by using the <code>+</code> operator. So generally, using <code>+</code> operator to concatenate strings is convenient and efficient if the number of the concatenated strings is known at compile time.</p>
<h3 id="String-Related-Conversion"><a href="#String-Related-Conversion" class="headerlink" title="String Related Conversion"></a>String Related Conversion</h3><h4 id="String-Conversion-With-Byte-And-Rune"><a href="#String-Conversion-With-Byte-And-Rune" class="headerlink" title="String Conversion With Byte And Rune"></a>String Conversion With Byte And Rune</h4><ul>
<li>a string value can be explicitly converted to byte slice, and vice versa.</li>
<li>a string value can be explicitly converted to rune slice, and vice versa.</li>
</ul>
<p>In a conversion from a rune slice to string, each slice element (a rune value) will be UTF-8 encoded as from one to four bytes and stored in the result string. If a slice rune element value is outside the range of valid Unicode code points, then it will be viewed as <code>0xFFFD</code>, the code point for the Unicode replacement character. <code>0xFFFD</code> will be UTF-8 encoded as three bytes (<code>0xef 0xbf 0xbd</code>).</p>
<p>When a string is converted to a rune slice, the bytes stored in the string will be viewed as successive UTF-8 encoding byte sequence representations of many Unicode code points. Bad UTF-8 encoding representations will be converted to a rune value <code>0xFFFD</code>.</p>
<p>When a string is converted to a byte slice, the result byte slice is just a deep copy of the underlying byte sequence of the string. When a byte slice is converted to a string, the underlying byte sequence of the result string is also just a deep copy of the byte slice. A memory allocation is needed to store the deep copy in each of such conversions. The reason why a deep copy is essential is slice elements are mutable but the bytes stored in strings are immutable, so a byte slice and a string can’t share byte elements.</p>
<p>Please note, for conversions between strings and byte slices,</p>
<ul>
<li>illegal UTF-8 encoded bytes are allowed and will keep unchanged.</li>
<li>the standard Go compiler makes some optimizations for some special cases of such conversions, so that the deep copies are not made. </li>
</ul>
<h4 id="Conversion-Between-Byte-And-Rune"><a href="#Conversion-Between-Byte-And-Rune" class="headerlink" title="Conversion Between Byte And Rune"></a>Conversion Between Byte And Rune</h4><p>Conversions between byte slices and rune slices are not supported directly in Go, We can use the following ways to achieve this goal:</p>
<ul>
<li>use string values as a hop. This way is convenient but not very efficient, for two deep copies are needed in the process.</li>
<li>use the functions in <a href="https://golang.org/pkg/unicode/utf8/">unicode/utf8</a> standard package.</li>
<li>use <a href="https://golang.org/pkg/bytes/#Runes">the <code>Runes</code> function in the bytes standard package</a> to convert a <code>[]byte</code> value to a <code>[]rune</code> value. There is not a function in this package to convert a rune slice to byte slice.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;unicode/utf8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Runes2Bytes</span><span class="params">(rs []<span class="keyword">rune</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	n := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, r := <span class="keyword">range</span> rs &#123;</span><br><span class="line">		n += utf8.RuneLen(r)</span><br><span class="line">	&#125;</span><br><span class="line">	n, bs := <span class="number">0</span>, <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line">	<span class="keyword">for</span> _, r := <span class="keyword">range</span> rs &#123;</span><br><span class="line">		n += utf8.EncodeRune(bs[n:], r)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;Color Infection is a fun game.&quot;</span></span><br><span class="line">	bs := []<span class="keyword">byte</span>(s) <span class="comment">// string -&gt; []byte</span></span><br><span class="line">	s = <span class="keyword">string</span>(bs)  <span class="comment">// []byte -&gt; string</span></span><br><span class="line">	rs := []<span class="keyword">rune</span>(s) <span class="comment">// string -&gt; []rune</span></span><br><span class="line">	s = <span class="keyword">string</span>(rs)  <span class="comment">// []rune -&gt; string</span></span><br><span class="line">	rs = bytes.Runes(bs) <span class="comment">// []byte -&gt; []rune</span></span><br><span class="line">	bs = Runes2Bytes(rs) <span class="comment">// []rune -&gt; []byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Compiler-Optimizations-for-Conversions-Between-Strings-and-Byte-Slices"><a href="#Compiler-Optimizations-for-Conversions-Between-Strings-and-Byte-Slices" class="headerlink" title="Compiler Optimizations for Conversions Between Strings and Byte Slices"></a>Compiler Optimizations for Conversions Between Strings and Byte Slices</h4><p>Above has mentioned that the underlying bytes in the conversions between strings and byte slices will be copied. The standard Go compiler makes some optimizations, which are proven to still work in Go Toolchain 1.18, for some special scenarios to avoid the duplicate copies. These scenarios include:</p>
<ul>
<li>a conversion (from string to byte slice) which follows the <code>range</code> keyword in a <code>for-range</code> loop.</li>
<li>a conversion (from byte slice to string) which is used as a map key in map element retrieval indexing syntax.</li>
<li>a conversion (from byte slice to string) which is used in a comparison.</li>
<li>a conversion (from byte slice to string) which is used in a string concatenation, and at least one of concatenated string values is a non-blank string constant.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> str = <span class="string">&quot;world&quot;</span></span><br><span class="line">	<span class="comment">// Here, the []byte(str) conversion will</span></span><br><span class="line">	<span class="comment">// not copy the underlying bytes of str.</span></span><br><span class="line">	<span class="keyword">for</span> i, b := <span class="keyword">range</span> []<span class="keyword">byte</span>(str) &#123;</span><br><span class="line">		fmt.Println(i, <span class="string">&quot;:&quot;</span>, b)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	key := []<span class="keyword">byte</span>&#123;<span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;y&#x27;</span>&#125;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// The string(key) conversion copys the bytes in key.</span></span><br><span class="line">	m[<span class="keyword">string</span>(key)] = <span class="string">&quot;value&quot;</span></span><br><span class="line">	<span class="comment">// Here, this string(key) conversion doesn&#x27;t copy</span></span><br><span class="line">	<span class="comment">// the bytes in key. The optimization will be still</span></span><br><span class="line">	<span class="comment">// made, even if key is a package-level variable.</span></span><br><span class="line">	fmt.Println(m[<span class="keyword">string</span>(key)]) <span class="comment">// value (very possible)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note, the last line might not output <code>value</code> if there are data races in evaluating <code>string(key)</code>. However, such data races will never cause panics.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> x = []<span class="keyword">byte</span>&#123;<span class="number">1023</span>: <span class="string">&#x27;x&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> y = []<span class="keyword">byte</span>&#123;<span class="number">1023</span>: <span class="string">&#x27;y&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fc</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// None of the below 4 conversions will</span></span><br><span class="line">	<span class="comment">// copy the underlying bytes of x and y.</span></span><br><span class="line">	<span class="comment">// Surely, the underlying bytes of x and y will</span></span><br><span class="line">	<span class="comment">// be still copied in the string concatenation.</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">string</span>(x) != <span class="keyword">string</span>(y) &#123;</span><br><span class="line">		s = (<span class="string">&quot; &quot;</span> + <span class="keyword">string</span>(x) + <span class="keyword">string</span>(y))[<span class="number">1</span>:]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fd</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Only the two conversions in the comparison</span></span><br><span class="line">	<span class="comment">// will not copy the underlying bytes of x and y.</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">string</span>(x) != <span class="keyword">string</span>(y) &#123;</span><br><span class="line">		<span class="comment">// Please note the difference between the</span></span><br><span class="line">		<span class="comment">// following concatenation and the one in fc.</span></span><br><span class="line">		s = <span class="keyword">string</span>(x) + <span class="keyword">string</span>(y)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(testing.AllocsPerRun(<span class="number">1</span>, fc)) <span class="comment">// 1</span></span><br><span class="line">	fmt.Println(testing.AllocsPerRun(<span class="number">1</span>, fd)) <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title># Go_Learning_Fundamental_initialization</title>
    <url>/2022/06/29/Go-Learning-Fundamental-initialization/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 初识</title>
    <url>/2022/07/09/Docker-%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<ul>
<li><a href="https://zhuanlan.zhihu.com/p/187505981">知乎专栏</a></li>
</ul>
<p><code>Docker</code> 在前两年读研时经常会有实验室的师兄提起, 属于一直有所耳闻, 未曾深入了解的范畴. 目前在工作中, 发现<code>Docker</code> 是当前程序员必备技能之一, 公司微服务架构中,云计算的实现中,项目容器化的实践中 均使用<code>Docker</code> 作为实现工具. 所以需要对<code>Docker</code> 有一个基础而全面的认知才行. 这里以上述专栏为契机, 简单认识下<code>Docker</code>.</p>
<a id="more"></a>

<h2 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h2><p><strong>引子</strong>, 在开发过程中,项目代码的运行环境起码要经历三套环境,<code>开发环境</code>, <code>测试环境</code>, <code>生产环境</code>, 这三套环境一般会选择重新搭建; 搭建环境是费时又费力,并且随着操作系统的不同,或者操作流程的差异, 无法保证这一套环境的表现与开发环境保持一致. 那么对于解决当前环境迁移与依赖的问题目前的解决方案有哪些呢?</p>
<h2 id="VM-vs-Container"><a href="#VM-vs-Container" class="headerlink" title="VM vs Container"></a>VM vs Container</h2><p>目前存在两种技术解决方案, 1.虚拟机(VM)技术. 2.容器(Container)技术; </p>
<h3 id="VM"><a href="#VM" class="headerlink" title="VM"></a>VM</h3><p>虚拟机技术是通过<code>操作系统</code>级别的隔离,实现的应用间的隔离;下图展示的为虚拟机技术架构:</p>
<p><img src="https://s2.loli.net/2022/07/09/12mDh8qYU6eOwcQ.png" alt="VM Infrastructure"></p>
<p>上图的架构中可以看到,当要运行期望的项目<code>APP</code>时 需要 <code>环境依赖 + 系统依赖</code>, 而操作系统是缓慢而笨重的,并且占用大量的内存空间, 这不免有一种杀鸡用牛刀的感觉.那么如果去除掉<code>系统依赖</code> 仅存在环境依赖就可以提升内存有效利用率,更轻量,更便捷; 这种实现技术就是容器(Container);</p>
<h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p><code>Container</code> 在英文中有集装箱的含义, 这与容器技术是可以联想的;</p>
<p><img src="https://s2.loli.net/2022/07/09/XUOvkAPGSNTDFCi.png" alt="image-20220709160046656"></p>
<p>集装箱的好处:</p>
<ul>
<li>集装箱之间是隔离的;</li>
<li>可以反复使用;</li>
<li>快速的装载与卸载;</li>
<li>规格标准化,可以放置在船舶中也可以放在码头;</li>
</ul>
<p>与虚拟机通过操作系统实现隔离不同，容器技术<strong>只隔离应用程序的运行时环境但容器之间可以共享同一个操作系统</strong>，这里的运行时环境指的是程序运行依赖的各种库以及配置。下图是容器技术的架构图:</p>
<img src="https://s2.loli.net/2022/07/09/paZmv5NhVRfrMuK.png" alt="image-20220709155923948" style="zoom:50%;" />

<p>从架构图中,可以看到相比于虚拟机,容器更加轻量级,资源占用少; 对于同样规格的硬件资源,可部署的资源更多.那么容器技术的最佳实现工具是什么的? <strong>Docker</strong>!!!</p>
<h2 id="Docker-Definition"><a href="#Docker-Definition" class="headerlink" title="Docker Definition"></a>Docker Definition</h2><p><code>Docker</code> 是一个<code>Go</code> 实现的开源项目, 用于容器的创建与使用. 其通过将程序与相关依赖包打包到<code>docker container</code>方式,保证程序的平滑的运行在各种操作系统中,也就是屏蔽了系统环境的差异性, 实现了<code>BORE, build once run everywhere</code>.</p>
<p><code>Docker</code> 中存在三个关键概念:</p>
<ul>
<li><code>dockerfile</code></li>
<li><code>image</code></li>
<li><code>container</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实际上你可以简单的把image理解为可执行程序，container就是运行起来的进程。</span><br><span class="line"></span><br><span class="line">那么写程序需要源代码，那么“写”image就需要dockerfile，dockerfile就是image的源代码，docker就是&quot;编译器&quot;。</span><br><span class="line"></span><br><span class="line">因此我们只需要在dockerfile中指定需要哪些程序、依赖什么样的配置，之后把dockerfile交给“编译器”docker进行“编译”，也就是docker build命令，生成的可执行程序就是image，之后就可以运行这个image了，这就是docker run命令，image运行起来后就是docker container。</span><br></pre></td></tr></table></figure>
<h2 id="Docker-Usage"><a href="#Docker-Usage" class="headerlink" title="Docker Usage"></a>Docker Usage</h2><p><code>Docker</code> 使用<code>C/S</code> 架构, <code>docker client</code> 负责处理用户输入, <code>docker server</code> 实现对应功能;下面介绍三个常用命令的工作流程:</p>
<ul>
<li><p><code>docker build</code> : 当我们写完<code>dockerfile</code>交给docker“编译”时使用这个命令，那么client在接收到请求后转发给docker daemon，接着docker daemon根据<code>dockerfile</code>创建出“可执行程序”image。</p>
<p><img src="https://s2.loli.net/2022/07/09/JHLZ8zh432vgIOC.png" alt="image-20220709162307918"></p>
</li>
<li><p><code>docker run</code> : 有了“可执行程序”image后就可以运行程序了，接下来使用命令docker run，docker daemon接收到该命令后找到具体的image，然后加载到内存开始执行，image执行起来就是所谓的container。</p>
<p><img src="https://s2.loli.net/2022/07/09/mKEsovZXFeYh3z2.png" alt="image-20220709162337290"></p>
</li>
<li><p><code>docker pull</code> : 实现也很简单，那就是用户通过docker client发送命令，docker daemon接收到命令后向docker registry发送image下载请求，下载后存放在本地，这样我们就可以使用image了</p>
<p><img src="https://s2.loli.net/2022/07/09/4k6OQ5ediYr9qPJ.png" alt="image-20220709162543568"></p>
</li>
</ul>
<h2 id="Docker-Implementation-principle"><a href="#Docker-Implementation-principle" class="headerlink" title="Docker Implementation principle"></a>Docker Implementation principle</h2><p>docker基于Linux内核提供这样几项功能实现的：</p>
<ul>
<li><code>NameSpace</code><br>我们知道Linux中的PID、IPC、网络等资源是全局的，而<code>NameSpace</code>机制是一种资源隔离方案，在该机制下这些资源就不再是全局的了，而是属于某个特定的<code>NameSpace</code>，各个<code>NameSpace</code>下的资源互不干扰，这就使得每个<code>NameSpace</code>看上去就像一个独立的操作系统一样，但是只有<code>NameSpace</code>是不够。</li>
<li><code>Control groups</code><br>虽然有了<code>NameSpace</code>技术可以实现资源隔离，但进程还是可以不受控的访问系统资源，比如CPU、内存、磁盘、网络等，为了控制容器中进程对资源的访问，Docker采用control groups技术(也就是<code>cgroup</code>)，有了<code>cgroup</code>就可以控制容器中进程对系统资源的消耗了，比如你可以限制某个容器使用内存的上限、可以在哪些CPU上运行等等。</li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 基础概念</title>
    <url>/2022/11/19/Docker-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>参考: Docker实践, Docker Deep Dive;</p>
<a id="more"></a>

<p><code>Docker</code> 中存在若干基础概念, 理解基础概念,有助于理解<code>Docker</code> 的整个生命周期, 例如:</p>
<ul>
<li>镜像 (Image)</li>
<li>容器 (Container)</li>
<li>服务 (Registry)</li>
</ul>
<h2 id="Image-镜像"><a href="#Image-镜像" class="headerlink" title="Image 镜像"></a>Image 镜像</h2><ul>
<li><p>镜像是什么?</p>
<ul>
<li><p>感性上讲: 对于<code>VM</code> 管理员来说, 镜像是<code>VM</code>模板; 对于编码人员来说, 镜像是<code>Class</code>; 对于操作系统而言, 镜像相当于是一个<code>root</code> 文件系统; PS: 操作系统分为内核与用户空间. 对于Linux, 内核启动后, 会挂在<code>root</code>文件系统为其提供用户空间支持.</p>
</li>
<li><p>理性上讲: 镜像是一个特殊的文件系统,其不仅提供了容器运行需要的程序, 库, 资源, 配置等文件, 还提供了运行时准备的位置参数(比如匿名卷, 环境变量, 用户); </p>
</li>
</ul>
</li>
<li><p>镜像的组成:</p>
<p>镜像的构成设计采用了<code>Union FS</code>技术, 设计为分层存储的结构; 也就是说镜像并不是像<code>ISO</code> 那样的整个打包文件, 镜像是由一组文件系统联合组成的;</p>
<p>对于内部而言, 镜像是由一个精简的<code>OS</code>, 同时包括运行应用需要的文件和依赖包组成; 由底向上,分层构成;</p>
<p>对于外部而言, 镜像是一个独立的对象;</p>
</li>
<li><p>镜像的构建过程:</p>
<p>如镜像组成所示, 镜像的构建是一层层构建的, 前一层是后一层的基础, 每一层构建完后, 不会再发生变更, 后一层的变动, 仅影响当前层; 这也就需要在镜像构建时, 保证每一层,仅添加需要添加的文件, 额外的文件, 应当在当前层构建时清理掉;</p>
</li>
</ul>
<h2 id="Container-容器"><a href="#Container-容器" class="headerlink" title="Container  容器"></a>Container  容器</h2><ul>
<li><p>容器是什么?</p>
<p>容器是镜像的运行时实例, 这与<code>Class</code> 与 <code>Object</code> 的关系是一致的, 从这个角度来说镜像是静态的定义, 容器时动态的定义;</p>
</li>
<li><p>容器运行的操作?</p>
<p>既然是运行时的概念, 那么相关操作可以有: 容器创建, 启动, 停止, 删除, 暂定等;</p>
</li>
<li><p>容器的本质</p>
<p>容器的本质是进程, 但是其运行于自己独立的命名空间中, 因此容器具备自己的<code>root</code> 文件系统, 网路配置, 进程空间, 用户ID空间.</p>
</li>
<li><p>容器的运行时发生了什么?</p>
<p>由于镜像时分层存储的, 容器在运行时, 也是同理, 在以镜像层作为基础层, 在其上创建一个当前容器的存储层, 其为容器运行时读写而出现, 称为 <code>容器存储层</code>; <code>容器存储层</code>的生命后期与容器保持一致;</p>
</li>
</ul>
<h2 id="Registry-服务"><a href="#Registry-服务" class="headerlink" title="Registry 服务"></a>Registry 服务</h2><p><code>Docker Registry</code> 是什么?</p>
<p>镜像构建完成后, 想要在其他服务上使用该镜像, 则需要一个是镜像进行集中存储与分发的服务, 这就是 <code>Docker Registry</code>;</p>
<p><code>Docker Registry</code> 的组成?</p>
<p>一个<code>Docker Registry</code> 包含有多个仓库 <code>Repository</code>, 每个仓储包含有多个标签 <code>Tag</code>; 每个标签, 对应一个镜像;</p>
<p><code>Docker Registry</code> 公开服务有哪些?</p>
<p>默认的是官方的 <code>Docker Hub</code>, 还有 <code>Red Hat</code> 的<code>Quary.io</code>, <code>Google</code> 的 <code>Google Container Registry</code>, <code>GitHub</code>的<code>ghcr.io</code>等;</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 初次使用</title>
    <url>/2022/11/19/Docker-%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>本部分内容基于<code>CentOS 7</code> 进行整理, 仅为记录;</p>
<a id="more"></a>

<h2 id="运维视角的使用"><a href="#运维视角的使用" class="headerlink" title="运维视角的使用"></a>运维视角的使用</h2><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装<code>docker</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install docker</span><br></pre></td></tr></table></figure>
<p>出现<code>Complemte!</code> 表示则说明已安装成功;</p>
<h3 id="查看Docker-版本"><a href="#查看Docker-版本" class="headerlink" title="查看Docker 版本"></a>查看<code>Docker</code> 版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>
<p>发现<code>docker daemon</code> 并没有启动而<code>docker client</code>已启动, 那么需要启动<code>docker daemon</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Client:</span><br><span class="line"> Version:         1.13.1</span><br><span class="line"> API version:     1.26</span><br><span class="line"> Package version:</span><br><span class="line">Cannot connect to the Docker daemon at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?</span><br></pre></td></tr></table></figure>
<h3 id="启动docker-daemon-并置为系统启动"><a href="#启动docker-daemon-并置为系统启动" class="headerlink" title="启动docker daemon 并置为系统启动"></a>启动<code>docker daemon</code> 并置为系统启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start docker.service</span><br><span class="line">systemctl enable docker.service</span><br></pre></td></tr></table></figure>
<h3 id="再次查看Docker-版本"><a href="#再次查看Docker-版本" class="headerlink" title="再次查看Docker 版本"></a>再次查看<code>Docker</code> 版本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:         1.13.1</span><br><span class="line"> API version:     1.26</span><br><span class="line"> Package version: docker-1.13.1-209.git7d71120.el7.centos.x86_64</span><br><span class="line"> Go version:      go1.10.3</span><br><span class="line"> Git commit:      7d71120&#x2F;1.13.1</span><br><span class="line"> Built:           Wed Mar  2 15:25:43 2022</span><br><span class="line"> OS&#x2F;Arch:         linux&#x2F;amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:         1.13.1</span><br><span class="line"> API version:     1.26 (minimum version 1.12)</span><br><span class="line"> Package version: docker-1.13.1-209.git7d71120.el7.centos.x86_64</span><br><span class="line"> Go version:      go1.10.3</span><br><span class="line"> Git commit:      7d71120&#x2F;1.13.1</span><br><span class="line"> Built:           Wed Mar  2 15:25:43 2022</span><br><span class="line"> OS&#x2F;Arch:         linux&#x2F;amd64</span><br><span class="line"> Experimental:    false</span><br></pre></td></tr></table></figure>
<p>发现<code>docker daemon , docker client</code> 均已启动;</p>
<h3 id="拉取CentOS-镜像"><a href="#拉取CentOS-镜像" class="headerlink" title="拉取CentOS 镜像"></a>拉取<code>CentOS</code> 镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull centos</span><br><span class="line">或者 </span><br><span class="line">docker image pull centos</span><br></pre></td></tr></table></figure>
<h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io&#x2F;ubuntu    latest              27941809078c        4 weeks ago         77.8 MB</span><br><span class="line">docker.io&#x2F;centos    latest              5d0da3dc9764        9 months ago        231 MB</span><br><span class="line"></span><br><span class="line">[root@VM-0-13-centos ~]# docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io&#x2F;ubuntu    latest              27941809078c        4 weeks ago         77.8 MB</span><br><span class="line">docker.io&#x2F;centos    latest              5d0da3dc9764        9 months ago        231 MB</span><br></pre></td></tr></table></figure>
<p>两个命令均可以查看<code>docker</code> 镜像, 发现目前已经有两个镜像了, 均是刚拉取的镜像, 这里仅以<code>centos</code>作为示例;</p>
<h3 id="启动镜像获得容器"><a href="#启动镜像获得容器" class="headerlink" title="启动镜像获得容器"></a>启动镜像获得容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker run -it centos:latest &#x2F;bin&#x2F;bash</span><br><span class="line">[root@a99489e5262c &#x2F;]#</span><br><span class="line">----------------</span><br><span class="line">使用 docker container run -it centos:latest &#x2F;bin&#x2F;bash 是一样的;</span><br></pre></td></tr></table></figure>
<p>发现已经进入了容器的控制台;</p>
<h3 id="查看下容器内进程"><a href="#查看下容器内进程" class="headerlink" title="查看下容器内进程"></a>查看下容器内进程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@a99489e5262c &#x2F;]# ps -elf</span><br><span class="line">F S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD</span><br><span class="line">4 S root         1     0  0  80   0 -  3009 do_wai 09:58 ?        00:00:00 &#x2F;bin&#x2F;bash</span><br><span class="line">4 R root        14     1  0  80   0 - 11163 -      10:02 ?        00:00:00 ps -elf</span><br></pre></td></tr></table></figure>
<p>发现目前有两个进程在运行, 一个是启动容器<code>/bin/bash</code>的进程, 一个是用来查看进程的进程 <code>ps -elf</code></p>
<h3 id="回退到Host-主机"><a href="#回退到Host-主机" class="headerlink" title="回退到Host 主机"></a>回退到<code>Host</code> 主机</h3><p><code>Ctrl+PQ</code>, 这样返回并不会关闭进程;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@a99489e5262c &#x2F;]# [root@VM-0-13-centos ~]#</span><br></pre></td></tr></table></figure>
<h3 id="查看容器列表"><a href="#查看容器列表" class="headerlink" title="查看容器列表"></a>查看容器列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">a99489e5262c        centos:latest       &quot;&#x2F;bin&#x2F;bash&quot;         7 minutes ago       Up 7 minutes                            gracious_colden</span><br></pre></td></tr></table></figure>
<p>发现刚才启动的容器,确实在列表中;</p>
<h3 id="查看Host的进程"><a href="#查看Host的进程" class="headerlink" title="查看Host的进程"></a>查看<code>Host</code>的进程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l</span><br><span class="line">[root@VM-0-13-centos ~]# ps -elf</span><br><span class="line">F S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD</span><br><span class="line">4 S root         1     0  0  80   0 - 31438 ep_pol 17:16 ?        00:00:02 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;systemd --switched-root --system --deserialize 22</span><br><span class="line">1 S root         2     0  0  80   0 -     0 kthrea 17:16 ?        00:00:00 [kthreadd]</span><br><span class="line">1 S root         4     2  0  60 -20 -     0 worker 17:16 ?        00:00:00 [kworker&#x2F;0:0H]</span><br><span class="line">1 S root         6     2  0  80   0 -     0 smpboo 17:16 ?        00:00:00 [ksoftirqd&#x2F;0]</span><br><span class="line">1 S root         7     2  0 -40   - -     0 smpboo 17:16 ?        00:00:00 [migration&#x2F;0]</span><br><span class="line">1 S root         8     2  0  80   0 -     0 rcu_gp 17:16 ?        00:00:00 [rcu_bh]</span><br><span class="line">1 S root         9     2  0  80   0 -     0 rcu_gp 17:16 ?        00:00:00 [rcu_sched]</span><br><span class="line">1 S root        10     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [lru-add-drain]</span><br><span class="line">5 S root        11     2  0 -40   - -     0 smpboo 17:16 ?        00:00:00 [watchdog&#x2F;0]</span><br><span class="line">5 S root        12     2  0 -40   - -     0 smpboo 17:16 ?        00:00:00 [watchdog&#x2F;1]</span><br><span class="line">1 S root        13     2  0 -40   - -     0 smpboo 17:16 ?        00:00:00 [migration&#x2F;1]</span><br><span class="line">1 S root        14     2  0  80   0 -     0 smpboo 17:16 ?        00:00:00 [ksoftirqd&#x2F;1]</span><br><span class="line">1 S root        16     2  0  60 -20 -     0 worker 17:16 ?        00:00:00 [kworker&#x2F;1:0H]</span><br><span class="line">5 S root        18     2  0  80   0 -     0 devtmp 17:16 ?        00:00:00 [kdevtmpfs]</span><br><span class="line">1 S root        19     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [netns]</span><br><span class="line">1 S root        20     2  0  80   0 -     0 watchd 17:16 ?        00:00:00 [khungtaskd]</span><br><span class="line">1 S root        21     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [writeback]</span><br><span class="line">1 S root        22     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [kintegrityd]</span><br><span class="line">1 S root        23     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [bioset]</span><br><span class="line">1 S root        24     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [bioset]</span><br><span class="line">1 S root        25     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [bioset]</span><br><span class="line">1 S root        26     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [kblockd]</span><br><span class="line">1 S root        27     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [md]</span><br><span class="line">1 S root        28     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [edac-poller]</span><br><span class="line">1 S root        29     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [watchdogd]</span><br><span class="line">1 S root        36     2  0  80   0 -     0 kswapd 17:16 ?        00:00:00 [kswapd0]</span><br><span class="line">1 S root        37     2  0  85   5 -     0 ksm_sc 17:16 ?        00:00:00 [ksmd]</span><br><span class="line">1 S root        38     2  0  99  19 -     0 khugep 17:16 ?        00:00:00 [khugepaged]</span><br><span class="line">1 S root        39     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [crypto]</span><br><span class="line">1 S root        47     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [kthrotld]</span><br><span class="line">1 S root        48     2  0  80   0 -     0 worker 17:16 ?        00:00:00 [kworker&#x2F;u4:1]</span><br><span class="line">1 S root        49     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [kmpath_rdacd]</span><br><span class="line">1 S root        50     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [kaluad]</span><br><span class="line">1 S root        51     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [kpsmoused]</span><br><span class="line">1 S root        52     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [ipv6_addrconf]</span><br><span class="line">1 S root        65     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [deferwq]</span><br><span class="line">1 S root       108     2  0  80   0 -     0 kaudit 17:16 ?        00:00:00 [kauditd]</span><br><span class="line">1 S root       238     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [ata_sff]</span><br><span class="line">1 S root       241     2  0  80   0 -     0 scsi_e 17:16 ?        00:00:00 [scsi_eh_0]</span><br><span class="line">1 S root       242     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [scsi_tmf_0]</span><br><span class="line">1 S root       243     2  0  80   0 -     0 scsi_e 17:16 ?        00:00:00 [scsi_eh_1]</span><br><span class="line">1 S root       244     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [scsi_tmf_1]</span><br><span class="line">1 S root       248     2  0  60 -20 -     0 worker 17:16 ?        00:00:00 [kworker&#x2F;0:1H]</span><br><span class="line">1 S root       252     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [ttm_swap]</span><br><span class="line">1 S root       272     2  0  60 -20 -     0 worker 17:16 ?        00:00:00 [kworker&#x2F;1:1H]</span><br><span class="line">1 S root       273     2  0  80   0 -     0 kjourn 17:16 ?        00:00:00 [jbd2&#x2F;vda1-8]</span><br><span class="line">1 S root       274     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [ext4-rsv-conver]</span><br><span class="line">4 S root       363     1  0  80   0 - 26239 ep_pol 17:16 ?        00:00:00 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;systemd-journald</span><br><span class="line">4 S root       385     1  0  80   0 - 31210 poll_s 17:16 ?        00:00:00 &#x2F;usr&#x2F;sbin&#x2F;lvmetad -f</span><br><span class="line">4 S root       396     1  0  80   0 - 11424 ep_pol 17:16 ?        00:00:00 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;systemd-udevd</span><br><span class="line">1 S root       513     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [nfit]</span><br><span class="line">1 S root       633     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [rpciod]</span><br><span class="line">1 S root       634     2  0  60 -20 -     0 rescue 17:16 ?        00:00:00 [xprtiod]</span><br><span class="line">5 S root       636     1  0  76  -4 - 13883 ep_pol 17:16 ?        00:00:00 &#x2F;sbin&#x2F;auditd</span><br><span class="line">4 S root       638   636  0  72  -8 - 21139 futex_ 17:16 ?        00:00:00 &#x2F;sbin&#x2F;audispd</span><br><span class="line">4 S root       640   638  0  76  -4 - 13911 unix_s 17:16 ?        00:00:00 &#x2F;usr&#x2F;sbin&#x2F;sedispatch</span><br><span class="line">4 S polkitd    658     1  0  80   0 - 153610 poll_s 17:16 ?       00:00:00 &#x2F;usr&#x2F;lib&#x2F;polkit-1&#x2F;polkitd --no-debug</span><br><span class="line">4 S root       659     1  0  80   0 -  6654 ep_pol 17:16 ?        00:00:00 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;systemd-logind</span><br><span class="line">5 S rpc        668     1  0  80   0 - 17320 poll_s 17:16 ?        00:00:00 &#x2F;sbin&#x2F;rpcbind -w</span><br><span class="line">4 S dbus       672     1  0  80   0 - 15151 ep_pol 17:16 ?        00:00:00 &#x2F;usr&#x2F;bin&#x2F;dbus-daemon --system --address&#x3D;systemd: --nofork --nopidfile --syst</span><br><span class="line">1 S root       674     1  0  80   0 -  1097 poll_s 17:16 ?        00:00:00 &#x2F;usr&#x2F;sbin&#x2F;acpid</span><br><span class="line">5 S ntp        679     1  0  80   0 - 12345 poll_s 17:16 ?        00:00:00 &#x2F;usr&#x2F;sbin&#x2F;ntpd -u ntp:ntp -g</span><br><span class="line">4 S libstor+   685     1  0  80   0 -  2145 poll_s 17:16 ?        00:00:00 &#x2F;usr&#x2F;bin&#x2F;lsmd -d</span><br><span class="line">4 S avahi      686     1  0  80   0 - 15573 poll_s 17:16 ?        00:00:00 avahi-daemon: running [VM-0-13-centos.local]</span><br><span class="line">1 S avahi      690   686  0  80   0 - 15541 unix_s 17:16 ?        00:00:00 avahi-daemon: chroot helper</span><br><span class="line">1 S root       696     1  0  80   0 - 28853 do_wai 17:16 ?        00:00:00 &#x2F;bin&#x2F;bash &#x2F;usr&#x2F;sbin&#x2F;ksmtuned</span><br><span class="line">1 S root       697     1  0  80   0 - 50358 ep_pol 17:16 ?        00:00:00 &#x2F;usr&#x2F;sbin&#x2F;gssproxy -D</span><br><span class="line">1 S root       982     1  0  80   0 - 25726 poll_s 17:16 ?        00:00:00 &#x2F;sbin&#x2F;dhclient -H VM-0-13-centos -q -lf &#x2F;var&#x2F;lib&#x2F;dhclient&#x2F;dhclient--eth0.lea</span><br><span class="line">4 S root      1055     1  0  80   0 - 146513 poll_s 17:16 ?       00:00:00 &#x2F;usr&#x2F;bin&#x2F;python2 -Es &#x2F;usr&#x2F;sbin&#x2F;tuned -l -P</span><br><span class="line">4 S root      1076     1  0  80   0 - 185430 poll_s 17:16 ?       00:00:00 &#x2F;usr&#x2F;sbin&#x2F;rsyslogd -n</span><br><span class="line">4 S root      1090     1  0  80   0 - 251084 poll_s 17:16 ?       00:00:00 &#x2F;usr&#x2F;sbin&#x2F;libvirtd</span><br><span class="line">4 S root      1099     1  0  80   0 -  6477 hrtime 17:16 ?        00:00:00 &#x2F;usr&#x2F;sbin&#x2F;atd -f</span><br><span class="line">4 S root      1111     1  0  80   0 - 31598 hrtime 17:16 ?        00:00:00 &#x2F;usr&#x2F;sbin&#x2F;crond -n</span><br><span class="line">4 S root      1278     1  0  80   0 - 27552 n_tty_ 17:16 ttyS0    00:00:00 &#x2F;sbin&#x2F;agetty --keep-baud 115200,38400,9600 ttyS0 vt220</span><br><span class="line">4 S root      1279     1  0  80   0 - 27552 n_tty_ 17:16 tty1     00:00:00 &#x2F;sbin&#x2F;agetty --noclear tty1 linux</span><br><span class="line">1 S root      1314     1  0  80   0 -  7268 ep_pol 17:16 ?        00:00:00 &#x2F;usr&#x2F;local&#x2F;qcloud&#x2F;tat_agent&#x2F;tat_agent</span><br><span class="line">4 S root      1580     1  0  80   0 - 28231 poll_s 17:16 ?        00:00:00 &#x2F;usr&#x2F;sbin&#x2F;sshd -D</span><br><span class="line">5 S nobody    1592     1  0  80   0 - 13475 poll_s 17:16 ?        00:00:00 &#x2F;usr&#x2F;sbin&#x2F;dnsmasq --conf-file&#x3D;&#x2F;var&#x2F;lib&#x2F;libvirt&#x2F;dnsmasq&#x2F;default.conf --leasef</span><br><span class="line">1 S root      1593  1592  0  80   0 - 13468 pipe_w 17:16 ?        00:00:00 &#x2F;usr&#x2F;sbin&#x2F;dnsmasq --conf-file&#x3D;&#x2F;var&#x2F;lib&#x2F;libvirt&#x2F;dnsmasq&#x2F;default.conf --leasef</span><br><span class="line">4 S root      1598  1580  0  80   0 - 39852 poll_s 17:16 ?        00:00:00 sshd: root@pts&#x2F;0</span><br><span class="line">0 S root      1608     1  0  80   0 - 247139 do_wai 17:16 ?       00:00:00 &#x2F;usr&#x2F;local&#x2F;qcloud&#x2F;YunJing&#x2F;YDLive&#x2F;YDLive</span><br><span class="line">1 S root      1628     1  0  80   0 - 24351 hrtime 17:17 ?        00:00:00 &#x2F;usr&#x2F;local&#x2F;qcloud&#x2F;stargate&#x2F;bin&#x2F;sgagent -d</span><br><span class="line">1 S root      1644     1  0  80   0 - 38850 poll_s 17:17 ?        00:00:00 barad_agent</span><br><span class="line">1 S root      1650  1644  0  80   0 - 41227 poll_s 17:17 ?        00:00:01 barad_agent</span><br><span class="line">1 S root      1651  1644  0  80   0 - 134822 poll_s 17:17 ?       00:00:08 barad_agent</span><br><span class="line">4 S root      1661  1608  0  80   0 - 251552 ep_pol 17:17 ?       00:00:12 &#x2F;usr&#x2F;local&#x2F;qcloud&#x2F;YunJing&#x2F;YDEyes&#x2F;YDService</span><br><span class="line">0 S root      1801  1661  0  80   0 - 254192 futex_ 17:18 ?       00:00:00 &#x2F;bin&#x2F;sh -c sleep 100</span><br><span class="line">4 S root      1846  1580  0  80   0 - 39775 poll_s 17:18 ?        00:00:00 sshd: root@notty</span><br><span class="line">4 S root      1853  1846  0  80   0 - 18063 poll_s 17:18 ?        00:00:00 &#x2F;usr&#x2F;libexec&#x2F;openssh&#x2F;sftp-server</span><br><span class="line">4 S root      1867  1598  0  80   0 - 29333 n_tty_ 17:18 pts&#x2F;0    00:00:00 -bash</span><br><span class="line">4 S root      1939     1  0  80   0 - 102654 poll_s 17:18 ?       00:00:00 &#x2F;usr&#x2F;libexec&#x2F;packagekitd</span><br><span class="line">4 S root      2242  1580  0  80   0 - 38684 poll_s 17:20 ?        00:00:00 sshd: root@notty</span><br><span class="line">4 S root      2244  2242  0  80   0 - 28322 do_wai 17:20 ?        00:00:00 bash</span><br><span class="line">0 S root      2300  2244  0  80   0 - 28321 do_wai 17:20 ?        00:00:00 sh &#x2F;root&#x2F;.vscode-server&#x2F;bin&#x2F;4af164ea3a06f701fe3e89a2bcbb421d2026b68f&#x2F;bin&#x2F;cod</span><br><span class="line">0 S root      2312  2300  0  80   0 - 231839 ep_pol 17:20 ?       00:00:00 &#x2F;root&#x2F;.vscode-server&#x2F;bin&#x2F;4af164ea3a06f701fe3e89a2bcbb421d2026b68f&#x2F;node &#x2F;root</span><br><span class="line">0 S root      2367  2312  0  80   0 - 157627 ep_pol 17:20 ?       00:00:00 &#x2F;root&#x2F;.vscode-server&#x2F;bin&#x2F;4af164ea3a06f701fe3e89a2bcbb421d2026b68f&#x2F;node &#x2F;root</span><br><span class="line">4 S root      2885     1  0  80   0 - 204900 do_wai 17:22 ?       00:00:09 &#x2F;usr&#x2F;bin&#x2F;dockerd-current --add-runtime docker-runc&#x3D;&#x2F;usr&#x2F;libexec&#x2F;docker&#x2F;docke</span><br><span class="line">4 S root      2893  2885  0  80   0 - 80069 futex_ 17:22 ?        00:00:01 &#x2F;usr&#x2F;bin&#x2F;docker-containerd-current -l unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker&#x2F;libcontainerd&#x2F;d</span><br><span class="line">1 S root      5538     2  0  80   0 -     0 worker 17:37 ?        00:00:00 [kworker&#x2F;1:0]</span><br><span class="line">1 S root      5564     2  0  80   0 -     0 worker 17:37 ?        00:00:00 [kworker&#x2F;u4:0]</span><br><span class="line">4 S root      6971  1580  0  80   0 - 39850 poll_s 17:47 ?        00:00:00 sshd: root@pts&#x2F;1</span><br><span class="line">4 S root      6973  1580  0  80   0 - 39775 poll_s 17:47 ?        00:00:00 sshd: root@notty</span><br><span class="line">4 S root      6975  6971  0  80   0 - 29151 n_tty_ 17:47 pts&#x2F;1    00:00:00 -bash</span><br><span class="line">4 S root      7015  6973  0  80   0 - 18063 poll_s 17:47 ?        00:00:00 &#x2F;usr&#x2F;libexec&#x2F;openssh&#x2F;sftp-server</span><br><span class="line">1 S root      7421     2  0  80   0 -     0 worker 17:50 ?        00:00:00 [kworker&#x2F;0:2]</span><br><span class="line">4 R root      7859  1580  0  80   0 - 39850 -      17:53 ?        00:00:00 sshd: root@pts&#x2F;2</span><br><span class="line">4 S root      7861  1580  0  80   0 - 39775 poll_s 17:53 ?        00:00:00 sshd: root@notty</span><br><span class="line">4 S root      7863  7859  0  80   0 - 29151 do_wai 17:53 pts&#x2F;2    00:00:00 -bash</span><br><span class="line">4 S root      7905  7861  0  80   0 - 18063 poll_s 17:53 ?        00:00:00 &#x2F;usr&#x2F;libexec&#x2F;openssh&#x2F;sftp-server</span><br><span class="line">1 S root      8224     2  0  80   0 -     0 worker 17:55 ?        00:00:00 [kworker&#x2F;0:0]</span><br><span class="line">0 S root      8674  2893  0  80   0 - 68577 futex_ 17:58 ?        00:00:00 &#x2F;usr&#x2F;bin&#x2F;docker-containerd-shim-current a99489e5262c774cc07629fdd3fffc2a9732</span><br><span class="line">4 S root      8691  8674  0  80   0 -  3009 poll_s 17:58 pts&#x2F;3    00:00:00 &#x2F;bin&#x2F;bash</span><br><span class="line">1 S root      9005     2  0  80   0 -     0 worker 18:00 ?        00:00:00 [kworker&#x2F;1:2]</span><br><span class="line">1 S root      9742     2  0  80   0 -     0 worker 18:05 ?        00:00:00 [kworker&#x2F;0:1]</span><br><span class="line">0 S root      9785  2244  0  80   0 - 27014 hrtime 18:05 ?        00:00:00 sleep 180</span><br><span class="line">0 S root      9951   696  0  80   0 - 27014 hrtime 18:06 ?        00:00:00 sleep 60</span><br><span class="line">0 R root     10085  7863  0  80   0 - 38869 -      18:07 pts&#x2F;2    00:00:00 ps -elf</span><br></pre></td></tr></table></figure>
<p>发现<code>Host</code> 的进程比容器内多得多;</p>
<h3 id="连接到运行中的容器中"><a href="#连接到运行中的容器中" class="headerlink" title="连接到运行中的容器中"></a>连接到运行中的容器中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker container exec -it gracious_colden bash</span><br><span class="line">[root@a99489e5262c &#x2F;]#</span><br></pre></td></tr></table></figure>
<h3 id="回退到Host"><a href="#回退到Host" class="headerlink" title="回退到Host"></a>回退到<code>Host</code></h3><p>这里依旧没有直接退出, 用的<code>Ctrl+PQ</code></p>
<h3 id="再次查看容器状态"><a href="#再次查看容器状态" class="headerlink" title="再次查看容器状态"></a>再次查看容器状态</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@a99489e5262c &#x2F;]# [root@VM-0-13-centos ~]# docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">a99489e5262c        centos:latest       &quot;&#x2F;bin&#x2F;bash&quot;         14 minutes ago      Up 14 minutes                           gracious_colden</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="关闭容器"><a href="#关闭容器" class="headerlink" title="关闭容器"></a>关闭容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker container stop gracious_colden</span><br><span class="line">gracious_colden</span><br><span class="line">[root@VM-0-13-centos ~]# docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line"></span><br><span class="line">[root@VM-0-13-centos ~]#</span><br></pre></td></tr></table></figure>
<p>通过<code>docker container stop </code> 或 <code>docker container rm</code>, 命令是一样效果; 再次查看容器状态,发现已经没有了;</p>
<h2 id="开发视角的使用"><a href="#开发视角的使用" class="headerlink" title="开发视角的使用"></a>开发视角的使用</h2><p>本部分内容,会根据应用代码中的<code>Docerfile</code>将应用容器化,并使用容器的方式运行;代码来源于<code>Docker Deep Dive</code> 的配套资源;</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 学习路线</title>
    <url>/2022/11/19/Docker-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<p>目前打算系统的学习下Docker,现整理相关的学习资料如下:</p>
<a id="more"></a>

<ul>
<li>官方资料:<ul>
<li><a href="https://www.docker.com/">官方文档</a></li>
<li><a href="https://www.docker.com/blog/">官方博客</a></li>
<li><a href="https://www.docker.org.cn/">Docker中文社区</a></li>
</ul>
</li>
<li>书籍:<ul>
<li>Docker deep dive (深入浅出Docker)</li>
<li>第一本Docker书;</li>
</ul>
</li>
<li>知乎推荐:<ul>
<li><a href="https://zhuanlan.zhihu.com/p/23508637">学习资料整理</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/187505981">Docker简介</a></li>
</ul>
</li>
<li>线上学习:<ul>
<li><a href="https://vuepress.mirror.docker-practice.com/install/">Docker 从入门到实践</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 安全</title>
    <url>/2022/11/19/Docker-%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://vuepress.mirror.docker-practice.com/security/">安全 | Docker 从入门到实践 (docker-practice.com)</a></p>
<p>本部分主要介绍如何评估Docker内核安全性.</p>
</blockquote>
<a id="more"></a>

<p>一般从三个方面评估<code>Docker</code>安全性:</p>
<ul>
<li>内核的命名空间与控制组机制提供容器内在安全;</li>
<li><code>Docker</code>程序本身的抗攻击性;</li>
<li>内核能力机制</li>
</ul>
<p>简单罗列下:</p>
<h2 id="内核命名空间"><a href="#内核命名空间" class="headerlink" title="内核命名空间"></a>内核命名空间</h2><p>当用 <code>docker run</code> 启动一个容器时，在后台 Docker 为容器创建了一个独立的命名空间和控制组集合。</p>
<p>命名空间提供了最基础也是最直接的隔离，在容器中运行的进程不会被运行在主机上的进程和其它容器发现和作用。</p>
<p>每个容器都有自己独有的网络栈，意味着它们不能访问其他容器的 sockets 或接口。不过，如果主机系统上做了相应的设置，容器可以像跟主机交互一样的和其他容器交互。当指定公共端口或使用 links 来连接 2 个容器时，容器就可以相互通信了（可以根据配置来限制通信的策略）。</p>
<p>从网络架构的角度来看，所有的容器通过本地主机的网桥接口相互通信，就像物理机器通过物理交换机通信一样。</p>
<h2 id="控制组"><a href="#控制组" class="headerlink" title="控制组"></a>控制组</h2><p>控制组是 Linux 容器机制的另外一个关键组件，负责实现资源的审计和限制。</p>
<p>它提供了很多有用的特性；以及确保各个容器可以公平地分享主机的内存、CPU、磁盘 IO 等资源；当然，更重要的是，控制组确保了当容器内的资源使用产生压力时不会连累主机系统。</p>
<p>尽管控制组不负责隔离容器之间相互访问、处理数据和进程，它在防止拒绝服务（DDOS）攻击方面是必不可少的。</p>
<h2 id="Docker服务端的防护"><a href="#Docker服务端的防护" class="headerlink" title="Docker服务端的防护"></a><code>Docker</code>服务端的防护</h2><p>运行一个容器或应用程序的核心是通过 Docker 服务端。Docker 服务的运行目前需要 root 权限，因此其安全性十分关键。</p>
<p>首先，确保只有可信的用户才可以访问 Docker 服务。Docker 允许用户在主机和容器间共享文件夹，同时不需要限制容器的访问权限，这就容易让容器突破资源限制。例如，恶意用户启动容器的时候将主机的根目录<code>/</code>映射到容器的 <code>/host</code> 目录中，那么容器理论上就可以对主机的文件系统进行任意修改了。这听起来很疯狂？但是事实上几乎所有虚拟化系统都允许类似的资源共享，而没法禁止用户共享主机根文件系统到虚拟机系统。</p>
<p>这将会造成很严重的安全后果。因此，当提供容器创建服务时（例如通过一个 web 服务器），要更加注意进行参数的安全检查，防止恶意的用户用特定参数来创建一些破坏性的容器。</p>
<p>为了加强对服务端的保护，Docker 的 REST API（客户端用来跟服务端通信）在 0.5.2 之后使用本地的 Unix 套接字机制替代了原先绑定在 127.0.0.1 上的 TCP 套接字，因为后者容易遭受跨站脚本攻击。现在用户使用 Unix 权限检查来加强套接字的访问安全。</p>
<p>用户仍可以利用 HTTP 提供 REST API 访问。建议使用安全机制，确保只有可信的网络或 VPN，或证书保护机制（例如受保护的 stunnel 和 ssl 认证）下的访问可以进行。此外，还可以使用 <a href="https://docs.docker.com/engine/security/https/">HTTPS 和证书 (opens new window)</a>来加强保护。</p>
<p>最近改进的 Linux 命名空间机制将可以实现使用非 root 用户来运行全功能的容器。这将从根本上解决了容器和主机之间共享文件系统而引起的安全问题。</p>
<p>终极目标是改进 2 个重要的安全特性：</p>
<ul>
<li>将容器的 root 用户 <a href="https://docs.docker.com/engine/security/userns-remap/">映射到本地主机上的非 root 用户 (opens new window)</a>，减轻容器和主机之间因权限提升而引起的安全问题；</li>
<li>允许 Docker 服务端在 <a href="https://docs.docker.com/engine/security/rootless/">非 root 权限(rootless 模式) (opens new window)</a>下运行，利用安全可靠的子进程来代理执行需要特权权限的操作。这些子进程将只允许在限定范围内进行操作，例如仅仅负责虚拟网络设定或文件系统管理、配置操作等。</li>
</ul>
<p>最后，建议采用专用的服务器来运行 Docker 和相关的管理服务（例如管理服务比如 ssh 监控和进程监控、管理工具 nrpe、collectd 等）。其它的业务服务都放到容器中去运行。</p>
<h2 id="内核能力机制"><a href="#内核能力机制" class="headerlink" title="内核能力机制"></a>内核能力机制</h2><p><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html">能力机制（Capability） (opens new window)</a>是 Linux 内核一个强大的特性，可以提供细粒度的权限访问控制。 Linux 内核自 2.2 版本起就支持能力机制，它将权限划分为更加细粒度的操作能力，既可以作用在进程上，也可以作用在文件上。</p>
<p>例如，一个 Web 服务进程只需要绑定一个低于 1024 的端口的权限，并不需要 root 权限。那么它只需要被授权 <code>net_bind_service</code> 能力即可。此外，还有很多其他的类似能力来避免进程获取 root 权限。</p>
<p>默认情况下，Docker 启动的容器被严格限制只允许使用内核的一部分能力。</p>
<p>使用能力机制对加强 Docker 容器的安全有很多好处。通常，在服务器上会运行一堆需要特权权限的进程，包括有 ssh、cron、syslogd、硬件管理工具模块（例如负载模块）、网络配置工具等等。容器跟这些进程是不同的，因为几乎所有的特权进程都由容器以外的支持系统来进行管理。</p>
<ul>
<li>ssh 访问被主机上ssh服务来管理；</li>
<li>cron 通常应该作为用户进程执行，权限交给使用它服务的应用来处理；</li>
<li>日志系统可由 Docker 或第三方服务管理；</li>
<li>硬件管理无关紧要，容器中也就无需执行 udevd 以及类似服务；</li>
<li>网络管理也都在主机上设置，除非特殊需求，容器不需要对网络进行配置。</li>
</ul>
<p>从上面的例子可以看出，大部分情况下，容器并不需要“真正的” root 权限，容器只需要少数的能力即可。为了加强安全，容器可以禁用一些没必要的权限。</p>
<ul>
<li>完全禁止任何 mount 操作；</li>
<li>禁止直接访问本地主机的套接字；</li>
<li>禁止访问一些文件系统的操作，比如创建新的设备、修改文件属性等；</li>
<li>禁止模块加载。</li>
</ul>
<p>这样，就算攻击者在容器中取得了 root 权限，也不能获得本地主机的较高权限，能进行的破坏也有限。</p>
<p>默认情况下，Docker采用 <a href="https://github.com/moby/moby/blob/master/oci/caps/defaults.go">白名单 (opens new window)</a>机制，禁用必需功能之外的其它权限。 当然，用户也可以根据自身需求来为 Docker 容器启用额外的权限。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>除了能力机制之外，还可以利用一些现有的安全机制来增强使用 Docker 的安全性，例如 TOMOYO, AppArmor, Seccomp, SELinux, GRSEC 等。</p>
<p>Docker 当前默认只启用了能力机制。用户可以采用多种方案来加强 Docker 主机的安全，例如：</p>
<ul>
<li>在内核中启用 GRSEC 和 PAX，这将增加很多编译和运行时的安全检查；通过地址随机化避免恶意探测等。并且，启用该特性不需要 Docker 进行任何配置。</li>
<li>使用一些有增强安全特性的容器模板，比如带 AppArmor 的模板和 Redhat 带 SELinux 策略的模板。这些模板提供了额外的安全特性。</li>
<li>用户可以自定义访问控制机制来定制安全策略。</li>
</ul>
<p>跟其它添加到 Docker 容器的第三方工具一样（比如网络拓扑和文件系统共享），有很多类似的机制，在不改变 Docker 内核情况下就可以加固现有的容器。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 容器的使用</title>
    <url>/2022/11/19/Docker-%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Docker-命令集合"><a href="#Docker-命令集合" class="headerlink" title="Docker 命令集合"></a>Docker 命令集合</h2><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker container --help</span><br><span class="line">Usage:  docker container COMMAND</span><br><span class="line">Manage containers</span><br><span class="line">Options:</span><br><span class="line">      --help   Print usage</span><br><span class="line">Commands:</span><br><span class="line">  attach      Attach to a running container</span><br><span class="line">  commit      Create a new image from a container&#39;s changes</span><br><span class="line">  cp          Copy files&#x2F;folders between a container and the local filesystem</span><br><span class="line">  create      Create a new container</span><br><span class="line">  diff        Inspect changes on a container&#39;s filesystem</span><br><span class="line">  exec        Run a command in a running container</span><br><span class="line">  export      Export a container&#39;s filesystem as a tar archive</span><br><span class="line">  inspect     Display detailed information on one or more containers</span><br><span class="line">  kill        Kill one or more running containers</span><br><span class="line">  logs        Fetch the logs of a container</span><br><span class="line">  ls          List containers</span><br><span class="line">  pause       Pause all processes within one or more containers</span><br><span class="line">  port        List port mappings or a specific mapping for the container</span><br><span class="line">  prune       Remove all stopped containers</span><br><span class="line">  rename      Rename a container</span><br><span class="line">  restart     Restart one or more containers</span><br><span class="line">  rm          Remove one or more containers</span><br><span class="line">  run         Run a command in a new container</span><br><span class="line">  start       Start one or more stopped containers</span><br><span class="line">  stats       Display a live stream of container(s) resource usage statistics</span><br><span class="line">  stop        Stop one or more running containers</span><br><span class="line">  top         Display the running processes of a container</span><br><span class="line">  unpause     Unpause all processes within one or more containers</span><br><span class="line">  update      Update configuration of one or more containers</span><br><span class="line">  wait        Block until one or more containers stop, then print their exit codes</span><br><span class="line"></span><br><span class="line">Run &#39;docker container COMMAND --help&#39; for more information on a command.</span><br></pre></td></tr></table></figure>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="容器启动"><a href="#容器启动" class="headerlink" title="容器启动"></a>容器启动</h3><ul>
<li><p>新建容器并启动</p>
<ul>
<li><p>涉及命令: <code>docker run</code></p>
</li>
<li><p>示例:</p>
<ul>
<li><p>启动并操作后则终止容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               v2                  33a05755d7f3        3 weeks ago         142 MB</span><br><span class="line">docker.io/nginx     latest              51086ed63d8c        3 weeks ago         142 MB</span><br><span class="line">docker.io/ubuntu    18.04               71cb16d32be4        3 weeks ago         63.1 MB</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              618d482e06b4        3 months ago        52.6 MB</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              4c0257ee9d10        3 months ago        5.53 MB</span><br><span class="line">docker.io/ubuntu    latest              27941809078c        4 months ago        77.8 MB</span><br><span class="line">[root@VM-0-13-centos ~]# docker run docker.io/ubuntu:18.04 /bin/echo &#x27;Hello, World!&#x27;</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure></li>
<li><p>启动<code>bash</code>终端,并进行交互</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker run -it docker.io&#x2F;ubuntu:18.04 &#x2F;bin&#x2F;bash</span><br><span class="line">root@8c2f4c3d6f16:&#x2F;# pwd</span><br><span class="line">&#x2F;</span><br><span class="line">root@8c2f4c3d6f16:&#x2F;# exit</span><br><span class="line">exit</span><br><span class="line">[root@VM-0-13-centos ~]#</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>启动已中止容器</p>
<ul>
<li>涉及命令: <code>docker container start</code></li>
</ul>
</li>
</ul>
<h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p>很多场景下, 需要<code>Docker</code>后台运行而不是讲命令结果输出在宿主机上, 可通过 <code>-d</code> 参数实现;</p>
<ul>
<li><p>涉及命令: <code>docker run -d</code></p>
</li>
<li><p>示例:</p>
<ul>
<li><p>不用 <code>-d</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker run docker.io&#x2F;ubuntu:18.04 &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>可以看到容器的输出结果<code>STDOUT</code> , 打印在了宿主机上;</p>
</li>
<li><p>用<code>-d</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker run -d docker.io&#x2F;ubuntu:18.04 &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line">86ef2217c3d59179524323c4f957bb74cb7f47d8e173eb7f0f2c66d9a7eb9128</span><br></pre></td></tr></table></figure>
<p>此时容器选择后台运行;</p>
</li>
</ul>
</li>
</ul>
<h3 id="容器终止"><a href="#容器终止" class="headerlink" title="容器终止"></a>容器终止</h3><p>容器进入终止状态的方式是很多的, 例如:</p>
<ul>
<li><p><code>Docker</code> 容器指定的应用终结时, 自动终止容器;</p>
</li>
<li><p><code>Docker</code> 容器内通过, <code>exit</code>, <code>Ctrl+d</code> 退出终端后, 容器终止;</p>
</li>
<li><p><code>Docker container stop</code> 命令, 可以终止一个处于<code>运行</code>状态的容器;</p>
<ul>
<li><p>示例: 将上面启动的后台运行的<code>Docker</code>容器终止掉:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker container ls</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">86ef2217c3d5        docker.io&#x2F;ubuntu:18.04   &quot;&#x2F;bin&#x2F;sh -c &#39;while...&quot;   9 minutes ago       Up 9 minutes                             practical_montalcini</span><br><span class="line">[root@VM-0-13-centos ~]# docker container stop 86ef2217c3d5</span><br><span class="line">86ef2217c3d5</span><br><span class="line">[root@VM-0-13-centos ~]# docker container ls</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br></pre></td></tr></table></figure>
<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3></li>
</ul>
</li>
</ul>
<p>在某些场景内, 需要进入容器,进行操作, 可以使用 <code>docker attach</code> 或 <code>docker exec -it</code> 命令, 推荐使用 <code>docker exec -it</code>;</p>
<ul>
<li><p>使用 <code>docker attach</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker run -dit docker.io&#x2F;ubuntu:18.04</span><br><span class="line">5d5cbafd10fdb777c7063444db737130768dae3c4c36a048bf0c1f66cba5656d</span><br><span class="line">[root@VM-0-13-centos ~]# docker container ls</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">5d5cbafd10fd        docker.io&#x2F;ubuntu:18.04   &quot;bash&quot;                   12 seconds ago      Up 11 seconds                            brave_bohr</span><br><span class="line">[root@VM-0-13-centos ~]# docker attach 5d5cbafd10fd</span><br><span class="line">root@5d5cbafd10fd:&#x2F;# exit</span><br><span class="line">exit</span><br><span class="line">[root@VM-0-13-centos ~]# docker container ls</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br></pre></td></tr></table></figure>
<p>可以看到 使用<code>exit</code> 命令推出后, 容器变为终止状态;</p>
</li>
<li><p>使用 <code>docker exec</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker run -dit docker.io&#x2F;ubuntu:18.04</span><br><span class="line">f170bccfbdcff331f02bbdbc5dfd163fa929caf87ebc4555dd768236cd696d19</span><br><span class="line">[root@VM-0-13-centos ~]# docker exec -it f170 bash</span><br><span class="line">root@f170bccfbdcf:&#x2F;# exit</span><br><span class="line">exit</span><br><span class="line">[root@VM-0-13-centos ~]# docker container ls</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">f170bccfbdcf        docker.io&#x2F;ubuntu:18.04   &quot;bash&quot;                   37 seconds ago      Up 36 seconds                            mystifying_brattain</span><br></pre></td></tr></table></figure>
<p>可以看到即使使用了<code>exit</code> 命令, 也没有导致容器进入终止状态;</p>
</li>
</ul>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><ul>
<li><p>删除一个终止状态的容器, <code>docker container rm </code></p>
</li>
<li><p>删除所有终止状态的容器, <code>docker container prune</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker container prune</span><br><span class="line">WARNING! This will remove all stopped containers.</span><br><span class="line">Are you sure you want to continue? [y/N] y</span><br><span class="line">Deleted Containers:</span><br><span class="line">5d5cbafd10fdb777c7063444db737130768dae3c4c36a048bf0c1f66cba5656d</span><br><span class="line">86ef2217c3d59179524323c4f957bb74cb7f47d8e173eb7f0f2c66d9a7eb9128</span><br><span class="line">a3b8f09e5fe30f219e15a026ef52d070b204dbb12bad945fff16e4297c8c8d6e</span><br><span class="line">8c2f4c3d6f164d3e32dff74eeab1562828b3bda4fdf77b3e079d41a839e64a4b</span><br><span class="line">54a804e8935f520fa9915907bab8c21c5d09ea7fa064c46d01a0ed14f9f6cc6a</span><br><span class="line">857e62419b36ea769c2655d1eb13fe268a3a516a731e2c5cf7848582aa7d2233</span><br><span class="line">72b48ef7e44ba46b7746387c7041280bd5c065e5aa3e2672996d2affe675a005</span><br><span class="line">8194230a842c3469242b4c9dbc81cb4a83cf21e23a718b6cd0e0d456215c8c2c</span><br><span class="line">6be1289236e9321d86de1ca7aaded317b136b78c6174ed4192ead4a03cf44044</span><br><span class="line">0dc2228117db93521c7048248eb56c2be289401d0630965010eb93e903a6aa7b</span><br><span class="line">e0d023f15495e37eb3b78355cfda033eca7a1672f48c1574333157d09bab7976</span><br><span class="line">a93b2d91a8c3dd59713017e423e7ad34108b87904bbbcd4b9143f9854667877e</span><br><span class="line">7b44171dcfe7c63bb2aeab7df8a65e2a64afd1fe5182d07ef108b845143deb0b</span><br><span class="line"></span><br><span class="line">Total reclaimed space: 9.85 MB</span><br></pre></td></tr></table></figure></li>
<li><p>删除一个运行状态的容器, <code>docker container rm -f</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker container ls</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">f170bccfbdcf        docker.io&#x2F;ubuntu:18.04   &quot;bash&quot;                   5 minutes ago       Up 5 minutes                             mystifying_brattain</span><br><span class="line">3fa97808f299        docker.io&#x2F;ubuntu:18.04   &quot;&#x2F;bin&#x2F;bash&quot;              45 minutes ago      Up 45 minutes                            upbeat_swanson</span><br><span class="line">8bcaacf3fee6        nginx:v2                 &quot;&#x2F;docker-entrypoin...&quot;   3 weeks ago         Up 3 weeks          0.0.0.0:81-&gt;80&#x2F;tcp   web2</span><br><span class="line">c795eabb7c7d        nginx                    &quot;&#x2F;docker-entrypoin...&quot;   3 weeks ago         Up 3 weeks          0.0.0.0:80-&gt;80&#x2F;tcp   webserver</span><br><span class="line">[root@VM-0-13-centos ~]# docker rm -f upbeat_swanson</span><br><span class="line">upbeat_swanson</span><br></pre></td></tr></table></figure>


</li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 底层实现机制</title>
    <url>/2022/11/19/Docker-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://vuepress.mirror.docker-practice.com/underly/">底层实现 | Docker 从入门到实践 (docker-practice.com)</a></p>
</blockquote>
<a id="more"></a>

<p>Docker 底层的核心技术包括 Linux 上的命名空间（Namespaces）、控制组（Control groups）、Union 文件系统（Union file systems）和容器格式（Container format）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们知道，传统的虚拟机通过在宿主主机中运行 hypervisor 来模拟一整套完整的硬件环境提供给虚拟机的操作系统。虚拟机系统看到的环境是可限制的，也是彼此隔离的。 这种直接的做法实现了对资源最完整的封装，但很多时候往往意味着系统资源的浪费。 例如，以宿主机和虚拟机系统都为 Linux 系统为例，虚拟机中运行的应用其实可以利用宿主机系统中的运行环境。</span><br><span class="line"></span><br><span class="line">我们知道，在**操作系统中，包括内核、文件系统、网络、PID、UID、IPC、内存、硬盘、CPU **等等，所有的资源都是应用进程直接共享的。 要想实现虚拟化，除了要实现对内存、CPU、网络IO、硬盘IO、存储空间等的限制外，还要实现文件系统、网络、PID、UID、IPC等等的相互隔离。 前者相对容易实现一些，后者则需要宿主机系统的深入支持。</span><br><span class="line"></span><br><span class="line">随着 Linux 系统对于命名空间功能的完善实现，程序员已经可以实现上面的所有需求，让某些进程在彼此隔离的命名空间中运行。大家虽然都共用一个内核和某些运行时环境（例如一些系统命令和系统库），但是彼此却看不到，都以为系统中只有自己的存在。这种机制就是容器（Container），利用命名空间来做权限的隔离控制，利用 cgroups 来做资源分配。</span><br></pre></td></tr></table></figure>
<h2 id="Name-Spaces"><a href="#Name-Spaces" class="headerlink" title="Name Spaces"></a>Name Spaces</h2><h3 id="pid-命名空间"><a href="#pid-命名空间" class="headerlink" title="pid 命名空间"></a>pid 命名空间</h3><p>不同用户的进程就是通过 pid 命名空间隔离开的，且不同命名空间中可以有相同 pid。所有的 LXC 进程在 Docker 中的父进程为 Docker 进程，每个 LXC 进程具有不同的命名空间。同时由于允许嵌套，因此可以很方便的实现嵌套的 Docker 容器。</p>
<h3 id="net-命名空间"><a href="#net-命名空间" class="headerlink" title="#net 命名空间"></a><a href="https://vuepress.mirror.docker-practice.com/underly/namespace/#net-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">#</a>net 命名空间</h3><p>有了 pid 命名空间，每个命名空间中的 pid 能够相互隔离，但是网络端口还是共享 host 的端口。网络隔离是通过 net 命名空间实现的， 每个 net 命名空间有独立的 网络设备，IP 地址，路由表，/proc/net 目录。这样每个容器的网络就能隔离开来。Docker 默认采用 veth 的方式，将容器中的虚拟网卡同 host 上的一 个Docker 网桥 docker0 连接在一起。</p>
<h3 id="ipc-命名空间"><a href="#ipc-命名空间" class="headerlink" title="#ipc 命名空间"></a><a href="https://vuepress.mirror.docker-practice.com/underly/namespace/#ipc-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">#</a>ipc 命名空间</h3><p>容器中进程交互还是采用了 Linux 常见的进程间交互方法(interprocess communication - IPC)， 包括信号量、消息队列和共享内存等。然而同 VM 不同的是，容器的进程间交互实际上还是 host 上具有相同 pid 命名空间中的进程间交互，因此需要在 IPC 资源申请时加入命名空间信息，每个 IPC 资源有一个唯一的 32 位 id。</p>
<h3 id="mnt-命名空间"><a href="#mnt-命名空间" class="headerlink" title="#mnt 命名空间"></a><a href="https://vuepress.mirror.docker-practice.com/underly/namespace/#mnt-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">#</a>mnt 命名空间</h3><p>类似 chroot，将一个进程放到一个特定的目录执行。mnt 命名空间允许不同命名空间的进程看到的文件结构不同，这样每个命名空间 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个命名空间中的容器在 /proc/mounts 的信息只包含所在命名空间的 mount point。</p>
<h3 id="uts-命名空间"><a href="#uts-命名空间" class="headerlink" title="#uts 命名空间"></a><a href="https://vuepress.mirror.docker-practice.com/underly/namespace/#uts-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">#</a>uts 命名空间</h3><p>UTS(“UNIX Time-sharing System”) 命名空间允许每个容器拥有独立的 hostname 和 domain name， 使其在网络上可以被视作一个独立的节点而非 主机上的一个进程。</p>
<h3 id="user-命名空间"><a href="#user-命名空间" class="headerlink" title="#user 命名空间"></a><a href="https://vuepress.mirror.docker-practice.com/underly/namespace/#user-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">#</a>user 命名空间</h3><p>每个容器可以有不同的用户和组 id， 也就是说可以在容器内用容器内部的用户执行程序而非主机上的用户。</p>
<p>*注：更多关于 Linux 上命名空间的信息，请阅读 <a href="https://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/">这篇文章 (opens new window)</a>。</p>
<h2 id="Control-Groups"><a href="#Control-Groups" class="headerlink" title="Control Groups"></a>Control Groups</h2><p>控制组（cgroups (opens new window)）是 Linux 内核的一个特性，主要用来对共享资源进行隔离、限制、审计等。只有能控制分配到容器的资源，才能避免当多个容器同时运行时的对系统资源的竞争。</p>
<p>控制组可以提供对容器的内存、CPU、磁盘 IO 等资源的限制和审计管理。</p>
<h2 id="Union-File-Systems"><a href="#Union-File-Systems" class="headerlink" title="Union File Systems"></a>Union File Systems</h2><p>联合文件系统（UnionFS (opens new window)）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。</p>
<p>联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。</p>
<p>Docker 中使用的 AUFS（Advanced Multi-Layered Unification Filesystem）就是一种联合文件系统。 AUFS 支持为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）和写出（whiteout-able）权限, 同时 AUFS 里有一个类似分层的概念, 对只读权限的分支可以逻辑上进行增量地修改(不影响只读部分的)。</p>
<p>Docker 目前支持的联合文件系统包括 OverlayFS, AUFS, Btrfs, VFS, ZFS 和 Device Mapper。</p>
<p>各 Linux 发行版 Docker 推荐使用的存储驱动如下表。</p>
<table>
<thead>
<tr>
<th>Linux 发行版</th>
<th>Docker 推荐使用的存储驱动</th>
</tr>
</thead>
<tbody><tr>
<td>Docker on Ubuntu</td>
<td>overlay2 (16.04 +)</td>
</tr>
<tr>
<td>Docker on Debian</td>
<td>overlay2 (Debian Stretch), aufs, devicemapper</td>
</tr>
<tr>
<td>Docker on CentOS</td>
<td>overlay2</td>
</tr>
<tr>
<td>Docker on Fedora</td>
<td>overlay2</td>
</tr>
</tbody></table>
<p>在可能的情况下，推荐 (opens new window)使用 overlay2 存储驱动，overlay2 是目前 Docker 默认的存储驱动，以前则是 aufs。你可以通过配置来使用以上提到的其他类型的存储驱动。</p>
<h2 id="Container-Format"><a href="#Container-Format" class="headerlink" title="Container Format"></a>Container Format</h2><p>最初，Docker 采用了 <code>LXC</code> 中的容器格式。从 0.7 版本以后开始去除 LXC，转而使用自行开发的 <a href="https://github.com/docker/libcontainer">libcontainer (opens new window)</a>，从 1.11 开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc">runC (opens new window)</a>和 <a href="https://github.com/containerd/containerd">containerd (opens new window)</a>。</p>
<h2 id="Network-Implement"><a href="#Network-Implement" class="headerlink" title="Network Implement"></a>Network Implement</h2><p>Docker 的网络实现其实就是利用了 Linux 上的网络命名空间和虚拟网络设备（特别是 veth pair）。建议先熟悉了解这两部分的基本概念再阅读本章。</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="#基本原理"></a><a href="https://vuepress.mirror.docker-practice.com/underly/network/#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">#</a>基本原理</h3><p>首先，要实现网络通信，机器需要至少一个网络接口（物理接口或虚拟接口）来收发数据包；此外，如果不同子网之间要进行通信，需要路由机制。</p>
<p>Docker 中的网络接口默认都是虚拟的接口。虚拟接口的优势之一是转发效率较高。 Linux 通过在内核中进行数据复制来实现虚拟接口之间的数据转发，发送接口的发送缓存中的数据包被直接复制到接收接口的接收缓存中。对于本地系统和容器内系统看来就像是一个正常的以太网卡，只是它不需要真正同外部网络设备通信，速度要快很多。</p>
<p>Docker 容器网络就利用了这项技术。它在本地主机和容器内分别创建一个虚拟接口，并让它们彼此连通（这样的一对接口叫做 <code>veth pair</code>）。</p>
<h3 id="创建网络参数"><a href="#创建网络参数" class="headerlink" title="#创建网络参数"></a><a href="https://vuepress.mirror.docker-practice.com/underly/network/#%E5%88%9B%E5%BB%BA%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0">#</a>创建网络参数</h3><p>Docker 创建一个容器的时候，会执行如下操作：</p>
<ul>
<li>创建一对虚拟接口，分别放到本地主机和新容器中；</li>
<li>本地主机一端桥接到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 veth65f9；</li>
<li>容器一端放到新容器中，并修改名字作为 eth0，这个接口只在容器的命名空间可见；</li>
<li>从网桥可用地址段中获取一个空闲地址分配给容器的 eth0，并配置默认路由到桥接网卡 veth65f9。</li>
</ul>
<p>完成这些之后，容器就可以使用 eth0 虚拟网卡来连接其他容器和其他网络。</p>
<p>可以在 <code>docker run</code> 的时候通过 <code>--net</code> 参数来指定容器的网络配置，有4个可选值：</p>
<ul>
<li><code>--net=bridge</code> 这个是默认值，连接到默认的网桥。</li>
<li><code>--net=host</code> 告诉 Docker 不要将容器网络放到隔离的命名空间中，即不要容器化容器内的网络。此时容器使用本地主机的网络，它拥有完全的本地主机接口访问权限。容器进程可以跟主机其它 root 进程一样可以打开低范围的端口，可以访问本地网络服务比如 D-bus，还可以让容器做一些影响整个主机系统的事情，比如重启主机。因此使用这个选项的时候要非常小心。如果进一步的使用 <code>--privileged=true</code>，容器会被允许直接配置主机的网络堆栈。</li>
<li><code>--net=container:NAME_or_ID</code> 让 Docker 将新建容器的进程放到一个已存在容器的网络栈中，新容器进程有自己的文件系统、进程列表和资源限制，但会和已存在的容器共享 IP 地址和端口等网络资源，两者进程可以直接通过 <code>lo</code> 环回接口通信。</li>
<li><code>--net=none</code> 让 Docker 将新容器放到隔离的网络栈中，但是不进行网络配置。之后，用户可以自己进行配置。</li>
</ul>
<h3 id="网络配置细节"><a href="#网络配置细节" class="headerlink" title="#网络配置细节"></a><a href="https://vuepress.mirror.docker-practice.com/underly/network/#%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E7%BB%86%E8%8A%82">#</a>网络配置细节</h3><p>用户使用 <code>--net=none</code> 后，可以自行配置网络，让容器达到跟平常一样具有访问网络的权限。通过这个过程，可以了解 Docker 配置网络的细节。</p>
<p>首先，启动一个 <code>/bin/bash</code> 容器，指定 <code>--net=none</code> 参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -i -t --rm --net=none base /bin/bash</span><br><span class="line">root@63f36fc01b5f:/<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>在本地主机查找容器的进程 id，并为它创建网络命名空间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> 63f36fc01b5f</span><br><span class="line">2778</span><br><span class="line">$ pid=2778</span><br><span class="line">$ sudo mkdir -p /var/run/netns</span><br><span class="line">$ sudo ln -s /proc/<span class="variable">$pid</span>/ns/net /var/run/netns/<span class="variable">$pid</span></span><br></pre></td></tr></table></figure>
<p>检查桥接网卡的 IP 和子网掩码信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ip addr show docker0</span><br><span class="line">21: docker0: ...</span><br><span class="line">inet 172.17.42.1/16 scope global docker0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>创建一对 “veth pair” 接口 A 和 B，绑定 A 到网桥 <code>docker0</code>，并启用它</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ip link add A <span class="built_in">type</span> veth peer name B</span><br><span class="line">$ sudo brctl addif docker0 A</span><br><span class="line">$ sudo ip link <span class="built_in">set</span> A up</span><br></pre></td></tr></table></figure>
<p>将B放到容器的网络命名空间，命名为 eth0，启动它并配置一个可用 IP（桥接网段）和默认网关。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ip link <span class="built_in">set</span> B netns <span class="variable">$pid</span></span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip link <span class="built_in">set</span> dev B name eth0</span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip link <span class="built_in">set</span> eth0 up</span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip addr add 172.17.42.99/16 dev eth0</span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip route add default via 172.17.42.1</span><br></pre></td></tr></table></figure>
<p>以上，就是 Docker 配置网络的具体过程。</p>
<p>当容器结束后，Docker 会清空容器，容器内的 eth0 会随网络命名空间一起被清除，A 接口也被自动从 <code>docker0</code> 卸载。</p>
<p>此外，用户可以使用 <code>ip netns exec</code> 命令来在指定网络命名空间中进行配置，从而配置容器内的网络。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 数据管理</title>
    <url>/2022/11/19/Docker-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>容器中的数据在未设置时, 宿主机与其他容器是不感知, 其生命周期与容器生命周期保持一致; 然而数据的持久化是常见的需求, 例如记录关键日志; Docker 中支持两种方式的数据持久化: </p>
<a id="more"></a>

<ul>
<li>挂载数据卷(Volume)</li>
<li>挂载主机目录(Bind Mounts)</li>
</ul>
<p><img src="C:\Users\sun23\AppData\Roaming\Typora\typora-user-images\image-20221030174516931.png" alt="image-20221030174516931"></p>
<p>上图展示了Docker 数据管理的架构, 可供理解;</p>
<h2 id="挂载数据卷"><a href="#挂载数据卷" class="headerlink" title="挂载数据卷"></a>挂载数据卷</h2><h3 id="数据卷定义"><a href="#数据卷定义" class="headerlink" title="数据卷定义"></a>数据卷定义</h3><p><code>数据卷</code>是供一个或多个容器使用的目录, 存在诸多特性: 容器间共享, 修改即可生效, 生命周期独立于容器;</p>
<h3 id="数据卷命令"><a href="#数据卷命令" class="headerlink" title="数据卷命令"></a>数据卷命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume --help</span><br><span class="line">Usage:  docker volume COMMAND</span><br><span class="line">Manage volumes</span><br><span class="line">Options:</span><br><span class="line">      --help   Print usage</span><br><span class="line">Commands:</span><br><span class="line">  create      Create a volume</span><br><span class="line">  inspect     Display detailed information on one or more volumes</span><br><span class="line">  ls          List volumes</span><br><span class="line">  prune       Remove all unused volumes</span><br><span class="line">  rm          Remove one or more volumes</span><br></pre></td></tr></table></figure>
<h3 id="数据卷操作"><a href="#数据卷操作" class="headerlink" title="数据卷操作"></a>数据卷操作</h3><ul>
<li><p>创建一个数据卷: <code>docker volume create</code></p>
<ul>
<li><p>创建一个<code>my-vol</code>数据卷:<code>docker volume create</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker volume create my-vol</span><br><span class="line">my-vol</span><br></pre></td></tr></table></figure></li>
<li><p>查看所有数据卷信息: <code>docker volume ls</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               my-vol</span><br></pre></td></tr></table></figure>
<p>发现刚创建的数据卷已出现在列表中;</p>
</li>
<li><p>查看指定数据卷信息: <code>docker volume inspect</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker volume inspect my-vol</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>启动一个挂载数据卷的容器: <code>docker run --mount</code></p>
<p><code>docker run</code> 命令中可选参数 <code>-mount</code> 用于指定数据卷的挂载, 一次可以指定多个数据卷;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker run -d -P \ </span><br><span class="line">--name webs \ </span><br><span class="line">--mount source&#x3D;my-vol,target&#x3D;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \ </span><br><span class="line">nginx:v2</span><br><span class="line"></span><br><span class="line">c3f5eb699108de48074cb8050e9b811eb1d4a518ce35fe7fbe60040d8f82525c</span><br></pre></td></tr></table></figure></li>
<li><p>查看数据卷的具体信息: <code>docker inspect [CONTAINERNAME]</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker inspect webs</span><br><span class="line">[</span><br><span class="line">  ....</span><br><span class="line">        &quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;z&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">       ....</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>删除数据卷: <code>docker volume rm [VOLUMENAME]</code></p>
<p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p>
<p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p>
</li>
</ul>
<h2 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h2><p>挂载主机目录到指定<code>Docker</code>容器目录中, 是最直接的方式; </p>
<h3 id="挂载主机目录充当数据卷"><a href="#挂载主机目录充当数据卷" class="headerlink" title="挂载主机目录充当数据卷"></a>挂载主机目录充当数据卷</h3><p>使用<code>--mount</code>标记可以指定一个本地主机目录到容器中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -v -P --name web --mount source&#x3D;webapp,target&#x3D;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html nginx:v2</span><br></pre></td></tr></table></figure>
<p>查看容器详情:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect web</span><br><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;b7cf786fbd7bd5487677dcc9b3665e8bd22636a7fa1679e405184e6d7e661aa5&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;b7cf786fbd7bd5487677dcc9b3665e8bd22636a7fa1679e405184e6d7e661aa5&#x2F;_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;-P&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;webapp&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;webapp&#x2F;_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;z&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="挂载主机文件充当数据卷"><a href="#挂载主机文件充当数据卷" class="headerlink" title="挂载主机文件充当数据卷"></a>挂载主机文件充当数据卷</h3><p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker run --rm -it --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history    ubuntu:18.04    bash</span><br><span class="line">Unable to find image &#x27;ubuntu:18.04&#x27; locally</span><br><span class="line">18.04: Pulling from library/ubuntu</span><br><span class="line">a404e5416296: Pull complete</span><br><span class="line">Digest: sha256:ca70a834041dd1bf16cc38dfcd24f0888ec4fa431e09f3344f354cf8d1724499</span><br><span class="line">Status: Downloaded newer image for ubuntu:18.04</span><br><span class="line"></span><br><span class="line">root@729362a97898:/#</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 网络的使用</title>
    <url>/2022/11/19/Docker-%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><code>Docker</code> 网络能够实现容器间互联与外部访问容器;</p>
<a id="more"></a>

<h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p>
<p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口。</p>
<p>使用 <code>docker container ls</code> 可以看到，本地主机的 32768 被映射到了容器的 80 端口。此时访问本机的 32768 端口即可访问容器内 NGINX 默认页面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -P nginx:alpine</span><br><span class="line"></span><br><span class="line">$ docker container ls -l</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES</span><br><span class="line">fae320d08268        nginx:alpine        <span class="string">&quot;/docker-entrypoint.…&quot;</span>   24 seconds ago      Up 20 seconds       0.0.0.0:32768-&gt;80/tcp   bold_mcnulty</span><br></pre></td></tr></table></figure>
<p>同样的，可以通过 <code>docker logs</code> 命令来查看访问记录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker logs fa</span><br><span class="line">172.17.0.1 - - [25/Aug/2020:08:34:04 +0000] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 612 <span class="string">&quot;-&quot;</span> <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:80.0) Gecko/20100101 Firefox/80.0&quot;</span> <span class="string">&quot;-&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p>
<h3 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="#映射所有接口地址"></a><a href="https://vuepress.mirror.docker-practice.com/network/port_mapping/#%E6%98%A0%E5%B0%84%E6%89%80%E6%9C%89%E6%8E%A5%E5%8F%A3%E5%9C%B0%E5%9D%80">#</a>映射所有接口地址</h3><p>使用 <code>hostPort:containerPort</code> 格式本地的 80 端口映射到容器的 80 端口，可以执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -p 80:80 nginx:alpine</span><br></pre></td></tr></table></figure>
<p>此时默认会绑定本地所有接口上的所有地址。</p>
<h3 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="#映射到指定地址的指定端口"></a><a href="https://vuepress.mirror.docker-practice.com/network/port_mapping/#%E6%98%A0%E5%B0%84%E5%88%B0%E6%8C%87%E5%AE%9A%E5%9C%B0%E5%9D%80%E7%9A%84%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3">#</a>映射到指定地址的指定端口</h3><p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1:80:80 nginx:alpine</span><br></pre></td></tr></table></figure>
<p>1</p>
<h3 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" class="headerlink" title="#映射到指定地址的任意端口"></a><a href="https://vuepress.mirror.docker-practice.com/network/port_mapping/#%E6%98%A0%E5%B0%84%E5%88%B0%E6%8C%87%E5%AE%9A%E5%9C%B0%E5%9D%80%E7%9A%84%E4%BB%BB%E6%84%8F%E7%AB%AF%E5%8F%A3">#</a>映射到指定地址的任意端口</h3><p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1::80 nginx:alpine</span><br></pre></td></tr></table></figure>
<p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1:80:80/udp nginx:alpine</span><br></pre></td></tr></table></figure>
<p>1</p>
<h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="#查看映射端口配置"></a><a href="https://vuepress.mirror.docker-practice.com/network/port_mapping/#%E6%9F%A5%E7%9C%8B%E6%98%A0%E5%B0%84%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE">#</a>查看映射端口配置</h3><p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker port fa 80</span><br><span class="line">0.0.0.0:32768</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 查看，Docker 还可以有一个可变的网络配置。）</li>
<li><code>-p</code> 标记可以多次使用来绑定多个端口</li>
</ul>
<p>例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    -p 80:80 \</span><br><span class="line">    -p 443:443 \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>
<h2 id="容器间互联"><a href="#容器间互联" class="headerlink" title="容器间互联"></a>容器间互联</h2><p>可以自行创建网络, 并通过docker run 配置的方式实现; 但目前一般推荐使用<code>docker compose</code> , 或者 编排工具实现; <br>这里不选择细谈;</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 镜像的使用</title>
    <url>/2022/11/19/Docker-%E9%95%9C%E5%83%8F%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><a id="more"></a>

<p><code>docker pull </code> 命令用于从<code>Docker Registry</code> 中获取指定镜像到当前服务器中, 命令格式为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker pull --help</span><br><span class="line">Usage:  docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br><span class="line">Pull an image or a repository from a registry</span><br><span class="line">Options:</span><br><span class="line">  -a, --all-tags                Download all tagged images in the repository</span><br><span class="line">      --disable-content-trust   Skip image verification (default true)</span><br><span class="line">      --help                    Print usage</span><br></pre></td></tr></table></figure>
<p>上面的<code>NAME</code>就是<code>Docker Image</code> 的资源地址, 就像<code>URL</code>一样, 那么<code>docker pull</code> 命令可以表示为<code>docker pull dockerRegistry:port/repository:tag</code>. </p>
<ul>
<li>默认<code>dockerRegistry</code> 为官方库<code>Docker Hub</code>, 域名为<code>docker.io</code>;</li>
<li>默认<code>repository</code> 为官方镜像<code>library</code>;</li>
<li>默认 <code>tag</code> 为 <code>latest</code>;</li>
</ul>
<p>所以 <code>docker pull docker.io/library/nginx</code> == <code>docker pull nginx</code>;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker pull nginx</span><br><span class="line">Using default tag: latest</span><br><span class="line">Trying to pull repository docker.io&#x2F;library&#x2F;nginx ...</span><br><span class="line">latest: Pulling from docker.io&#x2F;library&#x2F;nginx</span><br><span class="line">bd159e379b3b: Pull complete</span><br><span class="line">8d634ce99fb9: Pull complete</span><br><span class="line">98b0bbcc0ec6: Pull complete</span><br><span class="line">6ab6a6301bde: Pull complete</span><br><span class="line">f5d8edcd47b1: Pull complete</span><br><span class="line">fe24ce36f968: Pull complete</span><br><span class="line">Digest: sha256:2f770d2fe27bc85f68fd7fe6a63900ef7076bc703022fe81b980377fe3d27b70</span><br><span class="line">Status: Downloaded newer image for docker.io&#x2F;nginx:latest</span><br></pre></td></tr></table></figure>
<p>从上面的<code>docker log</code> 可以发现, 首先使用了默认<code>tag latest</code>, 并随后表示从<code>docker.io/library/nginx</code> 库获得对应镜像;</p>
<h2 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h2><p><code>docker image ls</code> 命令, 用于查看当前服务器上存在的镜像;</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               v2                  33a05755d7f3        35 minutes ago      142 MB</span><br><span class="line">docker.io/nginx     latest              51086ed63d8c        21 hours ago        142 MB</span><br><span class="line">docker.io/ubuntu    18.04               71cb16d32be4        34 hours ago        63.1 MB</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              618d482e06b4        2 months ago        52.6 MB</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              4c0257ee9d10        2 months ago        5.53 MB</span><br><span class="line">docker.io/ubuntu    latest              27941809078c        4 months ago        77.8 MB</span><br><span class="line">docker.io/centos    latest              5d0da3dc9764        12 months ago       231 MB</span><br></pre></td></tr></table></figure>
<p>列表中包含项有: <code>仓库名</code>, <code>标签</code>, <code>镜像ID</code>, <code>创建时间</code>, <code>占用空间大小</code>; 镜像ID 是镜像的唯一标识, 需要注意的是一个镜像可以包含有多个标签;</p>
<ul>
<li><p>关于镜像体积:</p>
<ol>
<li><p><code>Docker Hub</code> 上的镜像体积, 通常小于本地所占空间, 这是由于<code>Docker Hub</code> 显示的为压缩体积, 在镜像下载与上传时使用, 本地空间为解压后的体积;</p>
</li>
<li><p><code>docker image ls</code> 显示的镜像体积之和, 并非一定是所有镜像的实际硬盘消耗; 这是由于<code>Docker Image</code> 采用多层存储接口, 允许相同层的复用与继承; 可以通过 <code>docker system df</code> 查看镜像, 容器, 存储卷所占用的空间;</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker system df</span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              7                   6                   566.5 MB            210.4 MB (37%)</span><br><span class="line">Containers          13                  2                   9.852 MB            9.85 MB (99%)</span><br><span class="line">Local Volumes       0                   0                   0 B                 0 B</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>关于虚悬镜像:</p>
<p>上面的镜像列表中, 存在两个仓库名与标签均为<code>&lt;none&gt;</code> 的镜像, 这就是虚悬镜像; 这些镜像,原本是存在仓库名与标签的, 两种情况下会导致为<code>&lt;none&gt;</code>;</p>
<ul>
<li><code>docker pull</code>: 例如官方镜像进行了维护, 发布了新版本, 重新拉取镜像<code>A</code> 后, <code>A</code> 的仓库名与标签迁移到新下载<code>A&#39;</code>的镜像上, 原镜像<code>A</code> 相关属性置为<code>&lt;none&gt;</code>;</li>
<li><code>docker build</code>: 构建一个同名,同标签的镜像 <code>A&#39;</code> 会导致原镜像<code>A</code>, 相关属性置为<code>&lt;none&gt;</code>;</li>
</ul>
<p>可以通过 <code>docker image ls -f dangling=true</code> 查看虚悬镜像:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker image ls -f dangling&#x3D;true</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              618d482e06b4        2 months ago        52.6 MB</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              4c0257ee9d10        2 months ago        5.53 MB</span><br></pre></td></tr></table></figure>
<p>通常来说, 虚悬镜像没有价值, 可以通过 <code>docker image prune</code> 命令删除:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker image prune</span><br><span class="line">WARNING! This will remove all dangling images.</span><br><span class="line">Are you sure you want to continue? [y/N] y</span><br><span class="line">Total reclaimed space: 0 B</span><br></pre></td></tr></table></figure></li>
<li><p>关于中间层镜像:</p>
<p>通过<code>docker image ls -a</code> 可以看到中间层镜像, <code>docker image ls</code> 默认显示顶层镜像;很多无标签的镜像是中间层镜像, 这些镜像并不是虚悬镜像, 也无法删除;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker image ls -a</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               v2                  33a05755d7f3        About an hour ago   142 MB</span><br><span class="line">docker.io&#x2F;nginx     latest              51086ed63d8c        21 hours ago        142 MB</span><br><span class="line">docker.io&#x2F;ubuntu    18.04               71cb16d32be4        34 hours ago        63.1 MB</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              618d482e06b4        2 months ago        52.6 MB</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              1eaace73d9c9        2 months ago        5.53 MB</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              4c0257ee9d10        2 months ago        5.53 MB</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              0dd3d5655279        2 months ago        5.53 MB</span><br><span class="line">docker.io&#x2F;ubuntu    latest              27941809078c        4 months ago        77.8 MB</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              e66264b98777        4 months ago        5.53 MB</span><br><span class="line">docker.io&#x2F;centos    latest              5d0da3dc9764        12 months ago       231 MB</span><br></pre></td></tr></table></figure>
<p>可以看到的镜像变多了;</p>
</li>
<li><p>查看部分镜像:</p>
<p>仅列举, 细节可看官方文档;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker image ls ubuntu</span><br><span class="line">&#x2F;&#x2F; 获得仓库名为 ubuntu 的镜像</span><br><span class="line">docker image ls ubuntu:18.04</span><br><span class="line">&#x2F;&#x2F; 获得仓库名为ubuntu 版本为 18.04 的镜像</span><br><span class="line">docker image ls -f since&#x3D;mongo:3.2</span><br><span class="line">&#x2F;&#x2F; 查看在 mongo:3.2 镜像之后下载的所有</span><br><span class="line">docker image ls -f before&#x3D;mongo:3.2</span><br><span class="line">&#x2F;&#x2F; 查看在 mongo:3.2 镜像之前下载的所有</span><br><span class="line">docker image ls -f label&#x3D;0.1</span><br><span class="line">&#x2F;&#x2F; 查看特定标签的镜像</span><br></pre></td></tr></table></figure></li>
<li><p>格式化镜像输出:</p>
<p>仅列举, 细节可看官方文档;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker image ls --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;&quot;</span><br><span class="line">IMAGE ID            REPOSITORY</span><br><span class="line">33a05755d7f3        nginx</span><br><span class="line">51086ed63d8c        docker.io&#x2F;nginx</span><br><span class="line">71cb16d32be4        docker.io&#x2F;ubuntu</span><br><span class="line">618d482e06b4        &lt;none&gt;</span><br><span class="line">4c0257ee9d10        &lt;none&gt;</span><br><span class="line">27941809078c        docker.io&#x2F;ubuntu</span><br><span class="line">5d0da3dc9764        docker.io&#x2F;centos</span><br></pre></td></tr></table></figure>
<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2></li>
</ul>
<p><code>docker image rm</code> 用于删除镜像:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker image rm --help</span><br><span class="line">Usage:  docker image rm [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line">Remove one or more images</span><br><span class="line">Aliases:</span><br><span class="line">  rm, rmi, remove</span><br><span class="line">Options:</span><br><span class="line">  -f, --force      Force removal of the image</span><br><span class="line">      --help       Print usage</span><br><span class="line">      --no-prune   Do not delete untagged parents</span><br></pre></td></tr></table></figure>
<p>命令中的<code>IMAGE</code> 可以是 <code>镜像短ID, 镜像长ID, 镜像名, 镜像摘要</code>, 例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM-0-13-centos ~]# docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               v2                  33a05755d7f3        About an hour ago   142 MB</span><br><span class="line">docker.io&#x2F;nginx     latest              51086ed63d8c        22 hours ago        142 MB</span><br><span class="line">docker.io&#x2F;ubuntu    18.04               71cb16d32be4        35 hours ago        63.1 MB</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              618d482e06b4        2 months ago        52.6 MB</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              4c0257ee9d10        2 months ago        5.53 MB</span><br><span class="line">docker.io&#x2F;ubuntu    latest              27941809078c        4 months ago        77.8 MB</span><br><span class="line">docker.io&#x2F;centos    latest              5d0da3dc9764        12 months ago       231 MB</span><br><span class="line">[root@VM-0-13-centos ~]# docker image rm 5d0da3dc9764</span><br><span class="line">Untagged: docker.io&#x2F;centos:latest</span><br><span class="line">Untagged: docker.io&#x2F;centos@sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177</span><br><span class="line">Deleted: sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6</span><br><span class="line">Deleted: sha256:74ddd0ec08fa43d09f32636ba91a0a3053b02cb4627c35051aff89f853606b59</span><br></pre></td></tr></table></figure>
<p>这里采用<code>ID</code> 方式删除对应Image;其余的方式, 不赘述, 可通过文档或博客方式快速应用;需要注意的是上面的删除<code>Log</code> 中存在两种行为: <code>Untagged</code> 和 <code>Deleted</code> ;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 Untagged，另一类是 Deleted。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</span><br><span class="line"></span><br><span class="line">因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 Untagged 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 Delete 行为就不会发生。所以并非所有的 docker image rm 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</span><br><span class="line"></span><br><span class="line">当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 docker pull 看到的层数不一样的原因。</span><br><span class="line"></span><br><span class="line">除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</span><br><span class="line">																-- Docker 入门与实战</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_Learning_Fundamental_String_2</title>
    <url>/2023/09/02/Go-Learning-Fundamental-String-2/</url>
    <content><![CDATA[<p>Refs: <a href="https://go.dev/blog/strings">Strings, bytes, runes and characters in Go - The Go Programming Language</a></p>
<h2 id="Prior-knowledge"><a href="#Prior-knowledge" class="headerlink" title="Prior knowledge"></a>Prior knowledge</h2><p>Before learning this part, we should know  some theoretical knowledge about <a href="https://guardingdog.github.io/2020/04/02/Pyhton-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/">utf-8 unicode</a> and some <a href="https://guardingdog.github.io/2022/06/29/Go-Learning-Fundamental-String/">basic usage</a> of string in Go.</p>
<a id="more"></a>

<h2 id="Key-Points"><a href="#Key-Points" class="headerlink" title="Key Points"></a>Key Points</h2><p>Here is the key points of this post.</p>
<ul>
<li>A string holds arbitrary bytes.</li>
<li>A string literal ,without byte-level escapes, always hold valid <code>UTF-8</code> sequence;</li>
<li>Go source code is always <code>UTF-8</code>.</li>
</ul>
<h2 id="A-string-holds-arbitrary-bytes"><a href="#A-string-holds-arbitrary-bytes" class="headerlink" title="A string holds arbitrary bytes."></a>A string holds arbitrary bytes.</h2><p>Strings is effect read-only slice of bytes in Go. Let’s start with <code>A string holds arbitrary bytes.</code> </p>
<p>Here is a example. I create a sting literal with byte-level escapes, like <code>\xbd\xb2\x3d\xbc\x20\xe2\xad\x90</code>. And the flag <code>\xNN</code> note a string with peculiar byte values. </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sample = <span class="string">&quot;\xbd\xb2\x3d\xbc\x20\xe2\xad\x90&quot;</span></span><br></pre></td></tr></table></figure>
<p>Print this <code>sample</code> with different format, like this:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> sample = <span class="string">&quot;\xbd\xb2\x3d\xbc\x20\xe2\xad\x90&quot;</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Print as string: %s \n&quot;</span>, sample)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Print(<span class="string">&quot;Print as Byte loop: &quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(sample); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%x &quot;</span>, sample[i])</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Printf with quota: %q\n\n&quot;</span>, sample)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Printf with plus quota: %+q\n&quot;</span>, sample)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>OutPut</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Print as string: ��=� ⭐ </span><br><span class="line"></span><br><span class="line">Print as Byte loop: bd b2 3d bc 20 e2 ad 90 </span><br><span class="line"></span><br><span class="line">Printf with quota: &quot;\xbd\xb2=\xbc ⭐&quot;</span><br><span class="line"></span><br><span class="line">Printf with plus quota: &quot;\xbd\xb2=\xbc \u2b50&quot;</span><br></pre></td></tr></table></figure>
<p><code>Explain:</code></p>
<ul>
<li><p>Because of the <code>sample</code> contain not valid <code>UTF-8</code> bytes, directly print <code>    fmt.Printf(&quot;Print as string: %s \n&quot;, sample)</code> is a mess <code>��=� ⭐</code> result. </p>
</li>
<li><p>To find out what string really hold on, i split it apart and examine each byte with <code>%x</code> flag. This byte to byte level output is <code>bd b2 3d bc 20 e2 ad 90</code>. This result is equal to the declaration statement <code>const sample = &quot;\xbd\xb2\x3d\xbc\x20\xe2\xad\x90&quot;</code> .</p>
</li>
<li><p>There’s more. The <code>%q</code> verb could escape any non-printable byte sequence in a string, So the output <code>&quot;\xbd\xb2=\xbc ⭐&quot;</code> is clear. If we check this output, we will find one <code>Equal ASCII</code> sign, one <code>Space ASCII</code> sign and one <code>Yello Star Unicode</code> sign.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">the yello star ⭐ has Unicode value U+2B50, encode with utf-8 bytes: e2 ad 90.</span><br></pre></td></tr></table></figure></li>
<li><p>The <code>%+q</code> verb could escape not only non-printable sequence, but also any non-ASCII bytes. It will exposes the Unicode values of properly formatted <code>UTF-8</code> format. <code>&quot;\xbd\xb2=\xbc \u2b50&quot;</code></p>
</li>
</ul>
<p>So  we got that: <strong>A string holds arbitrary bytes.</strong> is only a bunch of bytes. which means with ransom bytes mostly combine a invalid <code>utf-8</code> sequence like example above.</p>
<h2 id="String-literals-always-hold-valid-utf-8-sequence"><a href="#String-literals-always-hold-valid-utf-8-sequence" class="headerlink" title="String literals always hold valid utf-8 sequence"></a>String literals always hold valid <code>utf-8</code> sequence</h2><p>A string literal ,without byte-level escapes, always hold valid <code>UTF-8</code> sequence; We know that when we store a character in a string, it will store as byte to byte format. Let’s we what happened with a example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	const yelloStar &#x3D; &#96;⭐&#96;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(&quot;plain string: &quot;)</span><br><span class="line">	fmt.Printf(&quot;%s&quot;, yelloStar)</span><br><span class="line">	fmt.Printf(&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(&quot;quoted string: &quot;)</span><br><span class="line">	fmt.Printf(&quot;%+q&quot;, yelloStar)</span><br><span class="line">	fmt.Printf(&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(&quot;hex bytes: &quot;)</span><br><span class="line">	for i :&#x3D; 0; i &lt; len(yelloStar); i++ &#123;</span><br><span class="line">		fmt.Printf(&quot;%x &quot;, yelloStar[i])</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(&quot;\n&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>OutPut:</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plain string: ⭐</span><br><span class="line">quoted string: &quot;\u2b50&quot;</span><br><span class="line">hex bytes: e2 ad 90 </span><br></pre></td></tr></table></figure>
<p><code>Explain:</code></p>
<ul>
<li><p>The Unicode value of character <code>⭐</code> is <code>\u2b50</code>, present as bytes <code>e2 ad 90</code>(<code>Utf-8</code>). </p>
</li>
<li><p>Because of Go’s encoding format is <code>utf-8</code>, when the source code is written, the text editor (<code>VS Code, typora ...</code>) would place the <code>UTF-8</code> encoding of the symbol <code>⭐</code> into the source text.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In short, Go source code is UTF-8, so *the source code for the string literal is UTF-8 text*. If that string literal contains no escape sequences, which a raw string cannot, the constructed string will hold exactly the source text between the quotes. Thus by definition and by construction the raw string will always contain a valid UTF-8 representation of its contents. Similarly, unless it contains UTF-8-breaking escapes like those from the previous section, a regular string literal will also always contain valid UTF-8.</span><br></pre></td></tr></table></figure></li>
<li><p>To summarize, strings can contain arbitrary bytes, but when constructed from string literals, those bytes are (almost always) <code>UTF-8</code>.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_Learning_Fundamental_Text_Normalization</title>
    <url>/2023/09/03/Go-Learning-Fundamental-Text-Normalization/</url>
    <content><![CDATA[<p>Refs: <a href="https://go.dev/blog/normalization">Text normalization in Go - The Go Programming Language</a></p>
<h2 id="Prior-knowledge"><a href="#Prior-knowledge" class="headerlink" title="Prior knowledge"></a>Prior knowledge</h2><p>Before learning this part, we should know  some theoretical knowledge about <a href="https://en.wikipedia.org/wiki/Unicode_equivalence">Unicode equivalence - Wikipedia</a>.</p>
<a id="more"></a>

<ul>
<li><p><code>canoically equivalent</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canonically equivalent are assumed to have the same appearance and meaning when printed or displayed. For example, the code point U+006E (the Latin lowercase &quot;n&quot;) followed by U+0303 (the combining tilde &quot;◌̃&quot;) is defined by Unicode to be canonically equivalent to the single code point U+00F1 (the lowercase letter &quot;ñ&quot; of the Spanish alphabet). Therefore, those sequences should be displayed in the same manner, should be treated in the same way by applications such as alphabetizing names or searching, and may be substituted for each other.</span><br><span class="line">-- wiki</span><br></pre></td></tr></table></figure></li>
<li><p><code>compatible equivalent</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sequences that are defined as compatible are assumed to have possibly distinct appearances, but the same meaning in some contexts. Thus, for example, the code point U+FB00 (the typographic ligature &quot;ﬀ&quot;) is defined to be compatible—but not canonically equivalent—to the sequence U+0066 U+0066 (two Latin &quot;f&quot; letters). Compatible sequences may be treated the same way in some applications (such as sorting and indexing), but not in others; and may be substituted for each other in some situations, but not in others. Sequences that are canonically equivalent are also compatible, but the opposite is not necessarily true.</span><br><span class="line">-- wiki</span><br></pre></td></tr></table></figure></li>
<li><p><code>Composing, Decoposing</code>:</p>
<ul>
<li>The former replaces runes that can combine into a single rune with this single rune.</li>
<li>The latter breaks runes apart into their components.</li>
</ul>
</li>
</ul>
<h2 id="Key-Points"><a href="#Key-Points" class="headerlink" title="Key Points"></a>Key Points</h2><table>
<thead>
<tr>
<th></th>
<th>Composing</th>
<th>Decomposing</th>
</tr>
</thead>
<tbody><tr>
<td>Canonical</td>
<td><code>NFC</code></td>
<td><code>NFD</code></td>
</tr>
<tr>
<td>Compatibility</td>
<td><code>NFKC</code></td>
<td><code>NFKD</code></td>
</tr>
</tbody></table>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="Difference-With-NFC-NFD"><a href="#Difference-With-NFC-NFD" class="headerlink" title="Difference With NFC, NFD"></a>Difference With NFC, NFD</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;golang.org/x/text/unicode/norm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;é&quot;</span></span><br><span class="line">	nfc := norm.NFC.String(str) <span class="comment">// NFC 形式</span></span><br><span class="line">	nfd := norm.NFD.String(str) <span class="comment">// NFD 形式</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;NFC String RESULT IS: % s\n&quot;</span>, nfc) </span><br><span class="line">	fmt.Printf(<span class="string">&quot;NFD String RESULT IS: % s\n&quot;</span>, nfd) </span><br><span class="line">	fmt.Printf(<span class="string">&quot;NFC Bytes RESULT IS: % x\n&quot;</span>, nfc) </span><br><span class="line">	fmt.Printf(<span class="string">&quot;NFD Bytes RESULT IS: % x\n&quot;</span>, nfd)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;NFC Rune RESULT IS: % +q\n&quot;</span>, nfc) </span><br><span class="line">	fmt.Printf(<span class="string">&quot;NFD Rune RESULT IS: % +q\n&quot;</span>, nfd) </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查是否相等</span></span><br><span class="line">	fmt.Println(nfc == nfd) <span class="comment">// 输出：false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>OutPut:</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NFC String RESULT IS: é</span><br><span class="line">NFD String RESULT IS: é</span><br><span class="line">NFC Bytes RESULT IS: c3 a9</span><br><span class="line">NFD Bytes RESULT IS: 65 cc 81</span><br><span class="line">NFC Rune RESULT IS: &quot;\u00e9&quot;</span><br><span class="line">NFD Rune RESULT IS: &quot;e\u0301&quot;</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>From above we know that, both <code>NFC, NFD</code>, their string format is equal. While they hold difference byte sequence. <code>NFC: \xc3\xa9</code>, <code>NFD: \x65\xcc\x81</code>.</p>
<p>In this example, we used the letter “e” with an accent. By applying the normalization transformation to this string in the form of NFC and NFD, we can see the difference in the output. The NFC form combines the accent into a single character “e”, while the NFD form decomposes it into two characters “e”. At the same time, we can also compare the results of NFC and NFD forms to determine whether they are equal.</p>
<h3 id="Difference-With-NFC-NFKC"><a href="#Difference-With-NFC-NFKC" class="headerlink" title="Difference With NFC, NFKC"></a>Difference With NFC, NFKC</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;golang.org/x/text/unicode/norm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;㎡&quot;</span></span><br><span class="line">	nfc := norm.NFC.String(str)   <span class="comment">// NFC 形式</span></span><br><span class="line">	nfkc := norm.NFKC.String(str) <span class="comment">// NFKC 形式</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;NFC String RESULT IS: % s\n&quot;</span>, nfc)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;NFKC String RESULT IS: % s\n&quot;</span>, nfkc)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;NFC Bytes RESULT IS: % x\n&quot;</span>, nfc)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;NFKC Bytes RESULT IS: % x\n&quot;</span>, nfkc)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;NFC Rune RESULT IS: % +q\n&quot;</span>, nfc)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;NFKC Rune RESULT IS: % +q\n&quot;</span>, nfkc)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查是否相等</span></span><br><span class="line">	fmt.Println(nfc == nfkc) <span class="comment">// 输出：false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>OutPut:</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NFC String RESULT IS: ㎡</span><br><span class="line">NFKC String RESULT IS: m2</span><br><span class="line">NFC Bytes RESULT IS: e3 8e a1</span><br><span class="line">NFKC Bytes RESULT IS: 6d 32</span><br><span class="line">NFC Rune RESULT IS: &quot;\u33a1&quot;</span><br><span class="line">NFKC Rune RESULT IS: &quot;m2&quot;</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>In this example, we use the special character “㎡”, which is the unit for square meters. Through the string for NFC and NFKC forms of normalized transformation, we can see the change of the output. The NFC form leaves it as is, while the NFKC form converts it to “m²”, even though the superscript 2 is used to denote the square.</p>
<p>Thus, it can be seen that in some cases the strings of the form NFC and NFKC are not equal.</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go tool pprof</title>
    <url>/2023/12/30/Go-tool-pprof/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最近在项目中进行了大数据量下的性能测试, 在寻找性能瓶颈过程中,利用<code>go tool pprof</code>工具, 解决了内存大量申请释放, 业务逻辑等问题;</p>
<p>本文主要分为三部分:</p>
<ul>
<li><p><code>go tool pprof</code> 的介绍;</p>
</li>
<li><p><code>go tool pprof</code> 的使用方式的介绍;</p>
</li>
<li><p>项目实践检验</p>
</li>
</ul>
<a id="more"></a>

<h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p> 为何需要性能分析?</p>
<p>性能分析与优化是程序迭代过程中不可避免的步骤, 其好处不限于: 提高程序效率, 减少资源利用, 支持系统可扩展性, 提升用户体验等等. 在网络上, 对于性能优化的必要性讨论很多, 理解各有千秋, 例如<a href="https://zhuanlan.zhihu.com/p/373874739">知乎博主</a>认为是由于服务在扩展, 架构需重构, 服务需压测等原因; </p>
<p>总而言之, 有编码的地方, 就有BUG, 就有可优化空间; 就需要利用性能分析工具, 解决 业务逻辑问题, 内存申请过大问题, 内存泄露问题, 协程泄露问题…</p>
<p>性能分析工具五花八门, <a href="https://zhuanlan.zhihu.com/p/373874739">引用自</a>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vmstat、iostat、 mpstat、netstat、 sar 、top：查看系统、程序信息等</span><br><span class="line">gprof、perf、perf top：定位到具体函数、调用等</span><br><span class="line">strace、ltrace：系统调用、函数调用、库函数调用等</span><br><span class="line">pstack、ptree、pmap：堆栈信息</span><br><span class="line">dmesg：系统 log 信息</span><br></pre></td></tr></table></figure>
<p>对于<code>go</code>程序, 推荐使用<code>go</code>标准工具: <code>go tool pprof</code>, 进行性能分析, 问题定位; 这也是本文的主角:<code>go tool pprof</code>;</p>
<h2 id="定义-go-tool-pprof"><a href="#定义-go-tool-pprof" class="headerlink" title="定义: go tool pprof"></a>定义: go tool pprof</h2><h3 id="现状"><a href="#现状" class="headerlink" title="现状:"></a>现状:</h3><p><code>go</code>在2011年<a href="https://go.dev/blog/pprof">go blog pprof</a> 初次介绍了<code>go tool pprof</code>工具的基本使用方式, 提供了<code>CPU, Memory</code>性能分析指导. 经过了多次迭代优化: 内置了火焰图, 扩展了可分析范围, 例如: </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  cpu          </span></span><br><span class="line"><span class="comment">//	goroutine    - stack traces of all current goroutines</span></span><br><span class="line"><span class="comment">//	heap         - a sampling of memory allocations of live objects</span></span><br><span class="line"><span class="comment">//	allocs       - a sampling of all past memory allocations</span></span><br><span class="line"><span class="comment">//	threadcreate - stack traces that led to the creation of new OS threads</span></span><br><span class="line"><span class="comment">//	block        - stack traces that led to blocking on synchronization primitives</span></span><br><span class="line"><span class="comment">//	mutex        - stack traces of holders of contended mutexes</span></span><br><span class="line">截取自: runtime/pprof/pprof.<span class="keyword">go</span> 注释内容</span><br></pre></td></tr></table></figure>
<p>借助于<code>go tool pprof</code> , 编码人员可以有效分析性能瓶颈, 提升性能表现. </p>
<p>PS: 随着工具的成熟, 在<code>go 1.21</code> 版本, <a href="https://go.dev/blog/pgo">Go Official Intro About PGO</a>, <code>go</code>已经初步通过<code>FDO</code>流程的方式实现<code>Go</code>编译器自动优化代码性能表现;</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>其定义为:</p>
<blockquote>
<p><code>pprof is a tool for visualization and analysis of profiling data.</code></p>
<blockquote>
<p> <a href="https://github.com/google/pprof">https://github.com/google/pprof</a></p>
</blockquote>
</blockquote>
<p><code>pprof</code> 是用于分析<code>profiling data</code>并生成可视化报告的工具;</p>
<p>定义解释:</p>
<p><code>这一部分可以不看</code></p>
<p>什么是<code>profiling data</code>?</p>
<ul>
<li><p>主观的说<code>profiling data</code> 指的是程序的性能状态数据, 直译为<code>配置文件</code>, 为了防止误解, 本文选择使用<code>profiling data</code>原文标识;</p>
<p>PS: <code>profiling</code> 的理解各异, 其直译为<code>画像, 轮廓</code>, <a href="https://zhuanlan.zhihu.com/p/51559344">有人</a>称其为<code>当前应用状态的画像</code>, <a href="https://zhuanlan.zhihu.com/p/373874739">有人</a>称其为<code>prof文件</code>, <a href="https://zhuanlan.zhihu.com/p/141640004">有人</a>称其为<code>采样文件</code>. 在我看来, 上面的理解都对, <code>profiling data</code> 就是<code>runtime/pprof</code>经过采样后获得应用状态样本集合;</p>
</li>
<li><p>客观的说:</p>
<blockquote>
<p>profile.proto is a protocol buffer that describes a set of callstacks and symbolization information. A common usage is to represent a set of sampled callstacks from statistical profiling. The format is described on the proto/profile.proto file. For details on protocol buffers, see <a href="https://developers.google.com/protocol-buffers">https://developers.google.com/protocol-buffers</a></p>
<p>pprof operates on data in the profile.proto format. Each profile is a collection of samples, where each sample is associated to a point in a location hierarchy, one or more numeric values, and a set of labels. Often these profiles represents data collected through statistical sampling of a program, so each sample describes a program call stack and a number or value of samples collected at a location. pprof is agnostic to the profile semantics, so other uses are possible. The interpretation of the reports generated by pprof depends on the semantics defined by the source of the profile.</p>
<blockquote>
<p><a href="https://github.com/google/pprof/blob/main/doc/README.md">https://github.com/google/pprof/blob/main/doc/README.md</a></p>
</blockquote>
</blockquote>
<p><code>profiling data</code> 是程序调用栈的信息集合,也是样本的集合, 其符合<code>profile.proto</code>格式. 每一个样本都指向了一个<code>location hierarchy</code>, 其包含有一系列的标签及对应的值(数字/字符串). </p>
<ul>
<li>这里有一个疑问点: 什么是<code>location hierarchy</code>, 直译为<code>位置层次结构</code>.我个人理解为: 调用栈结构, 例如:<ul>
<li>在<code>CPU Profile</code>采样过程中, 其指代的通过<code>程序计数器 PC</code>获得的调用栈情况, 其衡量指标为: 每个函数的时间开销等;</li>
<li>在<code>Heap Profile</code> 采样过程中, 气质带通过<code>内存分配器</code>获得的调用情况, 其衡量指标为: 内存分配大小等;</li>
</ul>
</li>
</ul>
<p>细致的解释, 我这里暂时没有去梳理, 可以参考相关文章, <a href="https://github.com/google/pprof/blob/main/doc/README.md">Google About Pprof README</a>, <a href="https://developers.google.com/protocol-buffers">Google About Protocol-buffers</a>.</p>
</li>
</ul>
<h3 id="细节"><a href="#细节" class="headerlink" title="细节:"></a>细节:</h3><p>这一部分内容， 可看可不看， 不影响使用<code>pprof</code>的核心功能；</p>
<h4 id="profiling-data-文件内容"><a href="#profiling-data-文件内容" class="headerlink" title="profiling data 文件内容"></a><code>profiling data</code> 文件内容</h4><p>上一部分有讲到<code>profiling data</code>包含有<code>location hierarchy</code>, 其构成了<code>samples</code>. 每一个<code>location</code> 包含有两类值：</p>
<ul>
<li><code>flat</code>： <code>location</code>本身的值，例如对于<code>cpu time </code>就是函数本身的执行时间；</li>
<li><code>cum</code>: <code>location</code>本身及<code>child location</code>的值的合， 例如对于<code>cpu time</code>就是函数与其子函数的执行时间合；</li>
</ul>
<p>上面的提到的<code>flat</code>, <code>cum</code>可以说贯通了<code>pprof</code>命令中， 就像是砖块与水泥， 可以搭建出各种需求的建筑物；</p>
<h4 id="pprof-命令功能点梳理"><a href="#pprof-命令功能点梳理" class="headerlink" title="pprof 命令功能点梳理"></a><code>pprof</code> 命令功能点梳理</h4><p>通过<code>go tool pprof</code> 命令的<code>details</code>部分， 可以看到官方梳理的功能点；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@sangfor ~]# go tool pprof</span><br><span class="line">...</span><br><span class="line">Details:</span><br><span class="line">  Output formats (select at most one):</span><br><span class="line">    -callgrind       Outputs a graph in callgrind format</span><br><span class="line">    -comments        Output all profile comments</span><br><span class="line">    -disasm          Output assembly listings annotated with samples</span><br><span class="line">    -dot             Outputs a graph in DOT format  </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这里不做赘述，仅对功能项进行梳理，了解<code>go tool pprof</code> <code>CLI</code> 可以做什么即可；</p>
<table>
<thead>
<tr>
<th></th>
<th>功能</th>
<th>相关命令</th>
<th>示例</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>指定输出格式</td>
<td><code>-list -svg -top -web ... </code></td>
<td><code>go tool pprof -top ./cpu.prof</code> </br>指定交互模式中TOP命令， 按照<code>flat</code>逆序排序</td>
<td>部分格式需要依赖第三方包， 例如web;</td>
</tr>
<tr>
<td>2</td>
<td>Node过滤</td>
<td><code>-focus -hide -ignore ...</code></td>
<td><code>go tool pprof -focus=find ./cpu.prof</code> 指定过滤出匹配find正则表达式的samples</td>
<td>五花八门的过滤选项</td>
</tr>
<tr>
<td>3</td>
<td>聚合</td>
<td>`-functions -files -lines</td>
<td><code>go tool pprof -files ./cpu.prof</code>, 指定sample按照file维度聚合</td>
<td>默认按照function维度聚合</td>
</tr>
<tr>
<td>4</td>
<td>排序</td>
<td><code>-flat -cum</code></td>
<td><code>go tool pprof -files -cum ./cpu.prof</code>, 指定按照文件聚合， 并且通过cum维度逆序排序；</td>
<td>仅有两个排序选择</td>
</tr>
<tr>
<td>5</td>
<td>源.prof文件处理</td>
<td><code>-diff_base, -base ...</code></td>
<td><code>go tool pprof -diff_base ./v1/cpu.prof ./v2/cpu.prof</code> 展示两个<code>cpu.prof</code>文件之间的差异</td>
<td>没有实践过</td>
</tr>
<tr>
<td>6</td>
<td>选择交互模式</td>
<td><code>-http -tools -no_browser</code></td>
<td><code>go tool pprof -http=0.0.0.0:1234  ./cpu.prof</code>, 通过Web方式交互</td>
<td>最常用<code>-http</code></td>
</tr>
<tr>
<td>7</td>
<td>便捷选项</td>
<td><code>-alloc_space -inuse_objects ...</code></td>
<td><code>go tool pprof -alloc_space  ./v3/mem.prof</code> 通过 历史分配空间维度 查看<code>mem.prof</code>文件； 等于 <code>-sample_index=alloc_spac</code></td>
<td>不同类型文件的选择式不一样的，例如内存prof文件就可以指定 <code>space, objects</code>等</td>
</tr>
</tbody></table>
<p>在我自己的使用经历来看， 使用<code>go tool pprof -http=host:port source</code>的方式， 在<code>Web</code>页面上的选择已经基本上覆盖了所有的<code>Cli</code>使用方式。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>这一部分介绍<code>pprof</code>的使用方式, 参考:  <a href="https://github.com/google/pprof/blob/main/doc/README.md">Google About Pprof README</a>; <code>pprof</code> 工具的使用围绕于<code>profiling data</code>, 那么可以分为两部分:<code>profiling data</code> 的生成, 分析<code>profiling data</code>;</p>
<h3 id="1-profiling-data-生成"><a href="#1-profiling-data-生成" class="headerlink" title="1. profiling data 生成:"></a>1. <code>profiling data</code> 生成:</h3><h4 id="相关pkg"><a href="#相关pkg" class="headerlink" title="相关pkg:"></a>相关pkg:</h4><ul>
<li><p><code>runtime/pprof</code>: 官方推荐标准包: 通过<code>runtime</code>获得<code>profiling data</code>, 一般适用于可结束代码, 例如<code>Utils App</code>;</p>
</li>
<li><p><code>net/http/pprof</code>: 官方推荐标准包: 支持通过<code>HTTP Request</code> 获得<code>profiling data</code>, 一般适用于不可结束代码, 例如<code>Web App</code>;</p>
<p>其内部封装了<code>runtime/pprof</code>包, 在程序启动前自动注册<code>/debug/pprof/</code>路由, 方便触发式调用;</p>
</li>
</ul>
<p>理论上说: 任何封装了<code>runtime/pprof</code>的<code>pprof</code>工具包, 均可以用于<code>profiling data</code>生成;</p>
<h4 id="获得profiling-data的方式"><a href="#获得profiling-data的方式" class="headerlink" title="获得profiling data的方式:"></a>获得<code>profiling data</code>的方式:</h4><p>按照目标代码可以分为两种:</p>
<h5 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h5><p>通过测试代码<code>_test.go</code>获得<code>profiling data</code>: </p>
<p><code>go test</code> 基准测试<code>bench</code>内嵌了<code>runtime/pprof</code>, 可通过<code>options</code>获得: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go test -cpuprofile cpu.prof -memprofile mem.prof -bench .</span><br></pre></td></tr></table></figure>
<h5 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h5><p>通过程序代码<code>.go</code>获得,  这种方式需要嵌入代码,根据需要选择<code>runtime/pprof</code>, <code>net/http/pprof</code></p>
<ul>
<li><p>选择<code>runtime/pprof</code>:</p>
<p><a href="https://golang.google.cn/pkg/runtime/pprof/">参考代码</a>示例:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cpuprofile = flag.String(<span class="string">&quot;cpuprofile&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;write cpu profile to `file`&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> memprofile = flag.String(<span class="string">&quot;memprofile&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;write memory profile to `file`&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    <span class="keyword">if</span> *cpuprofile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        f, err := os.Create(*cpuprofile)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(<span class="string">&quot;could not create CPU profile: &quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> f.Close() <span class="comment">// error handling omitted for example</span></span><br><span class="line">        <span class="keyword">if</span> err := pprof.StartCPUProfile(f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(<span class="string">&quot;could not start CPU profile: &quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> pprof.StopCPUProfile()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... rest of the program ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> *memprofile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        f, err := os.Create(*memprofile)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(<span class="string">&quot;could not create memory profile: &quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> f.Close() <span class="comment">// error handling omitted for example</span></span><br><span class="line">        runtime.GC() <span class="comment">// get up-to-date statistics</span></span><br><span class="line">        <span class="keyword">if</span> err := pprof.WriteHeapProfile(f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(<span class="string">&quot;could not write memory profile: &quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中通过, 命令行<code>options</code>方式控制, <code>CPU Profile</code>, <code>Memory Profile</code>的生成;</p>
</li>
<li><p>选择<code>net/http/pprof</code>:</p>
<p>使用此方式的前提是:</p>
<p><code>import _ &quot;net/http/pprof&quot;</code></p>
<p>会默认注册/debug/pprof/. 路由到服务中, 通过<code>http request</code>获得<code>profiling data</code>, 并自动进入交互使用模式 具体为:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go tool pprof http://localhost:port/debug/pprof/profile   # 30-second CPU profile</span><br><span class="line">go tool pprof http://localhost:port/debug/pprof/heap      # heap profile</span><br><span class="line">go tool pprof http://localhost:port/debug/pprof/block     # goroutine blocking profile</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="2-profiling-data-分析"><a href="#2-profiling-data-分析" class="headerlink" title="2. profiling data 分析:"></a>2. <code>profiling data</code> 分析:</h3></li>
</ul>
<h4 id="live-profiling-data"><a href="#live-profiling-data" class="headerlink" title="live profiling data"></a><code>live profiling data</code></h4><p>查看实时<code>profiling data</code>, 如果使用了<code>net/http/pprof</code>包, 那么在浏览器上可以直接通过<code>URL: localhost:port/debug/pprof/</code>查看实时的<code>profiling data</code>. </p>
<p>这种模式的使用场景, 还是比较少的.</p>
<h4 id="file-profiling-data"><a href="#file-profiling-data" class="headerlink" title="file profiling data"></a><code>file profiling data</code></h4><p>查看序列化的<code>profiling data</code></p>
<p>使用格式为: <code>pprof &lt;format&gt; [options] [binary] &lt;source&gt; ...</code></p>
<p>其支持两种格式的分析:</p>
<h5 id="Interactive-Terminal-Use"><a href="#Interactive-Terminal-Use" class="headerlink" title="Interactive Terminal Use"></a>Interactive Terminal Use</h5><p>终端交互是默认的<code>format</code>, 格式为:</p>
<p><code>go tool pprof [options] source</code></p>
<ul>
<li><p><code>source</code>来源</p>
<p>可以是本地已保存的<code>profiling data</code>, 也可以是一个<code>http</code>的<code>debug/pprof</code>请求(也是profiling data), 例如:</p>
<ul>
<li><code>go tool pprof ./cpu.prof</code>: 分析当前路径下的<code>cpu.prof</code>文件</li>
<li><code>go tool pprof http://127.0.0.1:1234/debug/pprof/profile</code>: 分析30S内的本地<code>1234</code>服务产生的`CPU profiling data``</li>
</ul>
</li>
<li><p><code>source</code>格式可以是<code>.pb.gz</code>格式的压缩文件, 也可以是<code>.pb</code>的解压缩文件</p>
<ul>
<li><p>压缩示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[root]#</span><span class="bash"> ./pprof /root/pprof/pprof.cbspsvc-linux.samples.cpu.001.pb.gz</span></span><br><span class="line">File: cbspsvc-linux</span><br><span class="line">Type: cpu</span><br><span class="line">Time: Nov 22, 2023 at 2:42pm (CST)</span><br><span class="line">Duration: 30s, Total samples = 50ms ( 0.17%)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><p>解压缩示例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[root]#</span><span class="bash"> ./pprof /root/pprof/pprof.cbspsvc-linux.samples.cpu.002.pb</span></span><br><span class="line">File: cbspsvc-linux</span><br><span class="line">Type: cpu</span><br><span class="line">Time: Nov 22, 2023 at 2:46pm (CST)</span><br><span class="line">Duration: 30s, Total samples = 30ms (  0.1%)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h5 id="Interactive-Web-Use"><a href="#Interactive-Web-Use" class="headerlink" title="Interactive Web Use"></a>Interactive Web Use</h5></li>
</ul>
</li>
</ul>
<p>通过指定<code>format: http</code>, 格式为:<code>go tool pprof -http=[host]:[port] [options] source</code></p>
<p><code>pprof</code> 在指定端口,启动<code>http</code>请求, 通过浏览器, 以Web方式查看<code>source</code>, 例如: </p>
<p>以本地地址, 在1234端口, 查看<code>cpu profiling data</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@]# .&#x2F;pprof -http&#x3D;0.0.0.0:1234 &#x2F;root&#x2F;pprof&#x2F;pprof.cbspsvc-linux.samples.cpu.002.pb</span><br><span class="line">Serving web UI on http:&#x2F;&#x2F;0.0.0.0:1234</span><br><span class="line">http:&#x2F;&#x2F;0.0.0.0:1234</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>source</code> 文件的来源与格式, 与终端使用无差异;</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><p>这一部分将通过示例的方式展示性能优化分析过程。代码归档地址：<a href="https://github.com/GuardingDog/learnGo/tree/master">github</a>.</p>
<h3 id="示例项目"><a href="#示例项目" class="headerlink" title="示例项目"></a>示例项目</h3><p><code>Go</code>在11年首次提出<a href="https://go.dev/blog/pprof">Profiling Go Program</a>时,采用示例项目为<code>Robert Hundt paper&#39;s</code>提出的<code>Loop Recognition Algorithm Code</code>. 原文中提到的优化方式，具备一定的代表性. 本文采用的项目源码与其一致, 将采用了<code>Interactive Web</code>方式复现了原文中的优化措施, 并通过性能对比的方式进一步体现优化效果. </p>
<h4 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h4><ul>
<li><p>CPU:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[root]#</span><span class="bash"> lscpu</span></span><br><span class="line">Architecture:          x86_64</span><br><span class="line">CPU op-mode(s):        32-bit, 64-bit</span><br><span class="line">Byte Order:            Little Endian</span><br><span class="line">CPU(s):                4</span><br><span class="line">...</span><br><span class="line">Model name:            Intel(R) Core(TM)2 Duo CPU     T7700  @ 2.40GHz</span><br><span class="line">Stepping:              11</span><br><span class="line">CPU MHz:               2600.002</span><br><span class="line">BogoMIPS:              5200.00</span><br><span class="line">...</span><br><span class="line">L1d cache:             32K</span><br><span class="line">L1i cache:             32K</span><br><span class="line">L2 cache:              4096K</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><p>内存:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root]# free</span><br><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:       16265900     1089812    14215544       19504      960544    14829644</span><br><span class="line">Swap:       2097148           0     2097148</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>Go</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root]# go version</span><br><span class="line">go version go1.16.4 linux&#x2F;amd64</span><br></pre></td></tr></table></figure>
<h4 id="衡量标准"><a href="#衡量标准" class="headerlink" title="衡量标准"></a>衡量标准</h4></li>
</ul>
<p>本文采用的衡量指标与<a href="https://go.dev/blog/pprof">Profiling Go Program</a>一致:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root runtime]# cat xtime</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">/usr/bin/time -f &#x27;%Uu %Ss %er %MkB %C&#x27; &quot;$@&quot;</span><br></pre></td></tr></table></figure>
<p>通过<code>./xtime binaryFilePath</code> 可以获得<code>binaryFilePath</code>下的程序执行的:</p>
<ul>
<li><code>%Uu</code>用户CPU执行时间, 单位为秒;</li>
<li><code>%Ss</code>系统CPU执行时间, 单位为秒;</li>
<li><code>%er</code>命令开始到结束时间, 单位为秒;</li>
<li><code>%MKB</code>内存占用大小, 单位为KB;</li>
<li><code>%C</code> 传递的命令行参数.</li>
</ul>
<h3 id="优化前"><a href="#优化前" class="headerlink" title="优化前:"></a>优化前:</h3><p><a href="https://github.com/GuardingDog/learnGo/blob/master/pkg/tools/pprof/runtime/v1/havlak.go">具体代码地址</a></p>
<p>构建<code>go program</code>, 并通过<code>xtime</code>获得当前的程序执行情况:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root v1]# go build ./havlak.go</span><br><span class="line">[root v1]# ll</span><br><span class="line">total 2492</span><br><span class="line">-rwxr-xr-x. 1 root root 2530042 Dec 25 16:39 havlak</span><br><span class="line">-rw-r--r--. 1 root root   16551 Dec 25 10:23 havlak.go</span><br><span class="line">[root v1]# ../xtime ./havlak</span><br><span class="line"><span class="meta">#</span><span class="bash"> of loops: 76000 (including 1 artificial root node)</span></span><br><span class="line">42.51u 4.31s 38.48r 316284kB ./havlak</span><br></pre></td></tr></table></figure>
<p>在优化前的性能指标为:</p>
<table>
<thead>
<tr>
<th>Version</th>
<th>User Time</th>
<th>Sys Time</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>优化前</td>
<td>42.51 s</td>
<td>4.31 s</td>
<td>316284 kB</td>
</tr>
</tbody></table>
<h3 id="CPU分析"><a href="#CPU分析" class="headerlink" title="CPU分析"></a>CPU分析</h3><p>由于项目并非<code>Web</code>类, 属于可结束型代码, 所以采用了<code>runtime/pprof</code>包作为<code>profiling data</code>的生成包;</p>
<h4 id="profiling-data-生成"><a href="#profiling-data-生成" class="headerlink" title="profiling data 生成:"></a><code>profiling data</code> 生成:</h4><ul>
<li><p>嵌入<code>CPU Profile</code>生成代码, 开启<code>CPU Profiling</code>功能;</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cpuprofile = flag.String(<span class="string">&quot;cpuprofile&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;write cpu profile to this file&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="keyword">if</span> *cpuprofile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		f, err := os.Create(*cpuprofile)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">&quot;could not create CPU profile: &quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> f.Close() <span class="comment">// error handling omitted for example</span></span><br><span class="line">		<span class="keyword">if</span> err := pprof.StartCPUProfile(f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">&quot;could not start CPU profile: &quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> pprof.StopCPUProfile()</span><br><span class="line">	&#125;</span><br><span class="line">	....</span><br></pre></td></tr></table></figure>
<p>代码位置约为<code>660行</code>. 添加的代码部分, 其支持通过命令行参数<code>-cpuprofile</code>的方式,指定开启<code>CPU Profiling</code>功能的同时将<code>profiling data</code>输出在<code>cpuprofile</code>文件内;</p>
</li>
<li><p>编译代码, 开启<code>CPU Profiling</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root v1]# go build ./havlak.go</span><br><span class="line">[root v1]# ll</span><br><span class="line">total 2492</span><br><span class="line">-rwxr-xr-x. 1 root root 2530010 Dec 25 16:56 havlak</span><br><span class="line">-rw-r--r--. 1 root root   16720 Dec 25 16:44 havlak.go</span><br><span class="line">[root v1]# ./havlak -cpuprofile=cpu.prof</span><br><span class="line"><span class="meta">#</span><span class="bash"> of loops: 76000 (including 1 artificial root node)</span></span><br><span class="line">[root v1]# ll</span><br><span class="line">total 2528</span><br><span class="line">-rw-r--r--. 1 root root   34063 Dec 25 16:58 cpu.prof</span><br><span class="line">-rwxr-xr-x. 1 root root 2530010 Dec 25 16:56 havlak</span><br><span class="line">-rw-r--r--. 1 root root   16720 Dec 25 16:44 havlak.go</span><br></pre></td></tr></table></figure>
<p>在等待约30S后, 获得了<code>CPU Profiling data</code> : <code>cpu.prof</code>. </p>
</li>
</ul>
<h4 id="profilinf-data-分析"><a href="#profilinf-data-分析" class="headerlink" title="profilinf data 分析:"></a><code>profilinf data</code> 分析:</h4><ul>
<li><p>开启<code>Interactive Web</code>, 查看<code>CPU Profiling data</code></p>
<p>通过<code>go tool pprof -http=host:port source</code>命令, 可以在指定端口允许通过<code>Web</code>查看<code>CPU Profiling data</code>;</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root v1]# go tool pprof -http=0.0.0.0:1234 ./cpu.prof</span><br><span class="line">Serving web UI on http://0.0.0.0:1234</span><br><span class="line">http://0.0.0.0:1234</span><br></pre></td></tr></table></figure>
<p>上面指定监听<code>1234</code>端口, 由于本地机器<code>IP</code>为<code>10.131.197.202</code>. 所以可以通过浏览器访问<code>http://10.131.197.202:1234</code>查看交互页面;</p>
<p>页面默认展示<code>Graph VIEW</code>, 默认通过<code>cpu time</code>作为衡量指标, 如下图:</p>
<p><img src="../images/image-20231225172027695.png" alt="image-20231225172027695"></p>
<p>接下来将简单的解释下交互界面元素, 并对每一种<code>VIEW</code>模式进行简单解读.</p>
</li>
<li><p>界面解释:</p>
<ul>
<li><p>操作栏: </p>
<p><img src="../images/image-20231225173219408.png" alt="image-20231225173219408"></p>
<p>分为4列选项, <code>VIEW</code> 查看模式, <code>SAMPLE</code> 样本标签选择, <code>REFINE</code> 样本过滤,聚焦等, <code>CONFIG</code>记录配置项;1列正则表达式搜索框;</p>
<p>其中<code>VIEW</code>与<code>SAMPLE</code>就我而言,使用比较频繁, 下面会分别进行简单解释, 详细解释建议自行参考官方文档: <a href="https://github.com/google/pprof/blob/main/doc/README.md">Google About Pprof README</a>.</p>
</li>
<li><p><code>VIEW: Top</code></p>
<p><img src="../images/image-20231225174240035.png" alt="image-20231225174240035"></p>
<p><code>Top</code>模式下默认支持查看<code>Function</code>级别的<code>CPU</code>占用情况, 默认按照<code>Flat</code>时间逆序排序,方便用来分析性能瓶颈;</p>
<ul>
<li><code>Flat</code>: 当前函数占用的<code>cpu</code>时间,  支持页面排序;</li>
<li><code>Flat%</code>: 当前函数占用的<code>cpu</code>时间比例;</li>
<li><code>Sum%</code>: <code>Flat%</code>的汇总展示, 例如第三行的<code>Sum%</code>就是<code>1.Flat% + 2.Flat% + 3.Flat%</code>;</li>
<li><code>Cum</code>: 当前函数及子函数占用的<code>cpu</code>时间, 支持页面排序;</li>
<li><code>Cum%</code>: 当前函数及子函数占用的<code>cpu</code>时间比例;</li>
<li><code>Name</code>: 包名+函数名称</li>
<li><code>Inlined?</code>: 当前函数是否被编译器通过<code>inline</code>进行了优化.</li>
</ul>
<p>那么对于第一行来说可以解释为:</p>
<p><code>runtime.mapaccess1_fast64</code>函数本身执行时间最长约<code>3.88s</code>, 占比约<code>11.14%</code>, 与其子函数共占有<code>4.42s</code>, 占比约<code>12,69%</code>, 并未通过<code>inline</code>优化;</p>
</li>
<li><p><code>VIEW: Graph</code></p>
<p><img src="../images/image-20231225191747898.png" alt="image-20231225191747898"></p>
<p><code>Graph VIEW</code>模式是<code>Web</code>默认模式, 其展示了<code>Function</code>级别的调用关系, 如上图中<code>runtime.mallocgc -&gt; runtime(*mcache).nextFree</code>表示前者调用了后者, 边权重显示为<code>1.27s</code>, 表示<code>runtime(*mcache).nextFree</code>本身及其后续调用花销为<code>1.27s</code>, 具体解释如下, 每一个方框称为<code>Node</code>, 表示一个<code>Function</code></p>
<ul>
<li><code>Node Color/Size</code>: Size 代表了<code>cum</code>数字绝对值<ul>
<li><code>cum -&gt; +∞</code>, Size越大, 颜色越红;</li>
<li><code>cum -&gt; 0</code>, Size越小, 颜色越灰;</li>
<li><code>cum -&gt; -∞</code>, Size越大, 颜色越绿;</li>
</ul>
</li>
<li><code>Node Font Size</code>: 方框内字体Size代表<code>flat</code>, <code>flat -&gt; +∞</code>: 越大</li>
<li><code>Edge weight</code>: Node之间的边越粗, 代表占有的资源越多, 例如子函数占用的时间;</li>
<li><code>Edge color</code>: 与<code>Node color</code>形式一样</li>
<li><code>Dashed Edge</code>: 虚线边, 表示其中省略了<code>node</code>, 也就是说非直接调用;</li>
<li><code>Solid Edge</code>: 实线边, 表示直接调用;</li>
<li><code>Inline Marked Edge</code>: <code>inline</code>标记的边, 表示子函数被编译器<code>inline</code>优化了;</li>
</ul>
</li>
<li><p><code>VIEW: Flame Graph</code></p>
<p><img src="../images/image-20231225194552548.png" alt="image-20231225194552548"></p>
<p><code>Flame Graph</code> 因为其形状像是火焰, 俗称为火焰图; 其表示的是紧密型的函数调用(自上至下)关系;</p>
<p>图中的<code>Box</code>关系与<code>profiling data</code>中的堆栈表示是一致的.</p>
<p>每一个<code>Box</code>宽度表示<code>cum</code>时间. 其子函数位于下一层, 自左向右依次排列在一起, 如果有空余则表示<code>flat</code>时间;</p>
<p>点击<code>Box</code>后会聚焦在此函数, 如下图:</p>
<p><img src="../images/image-20231225195245151.png" alt="image-20231225195245151"></p>
<p>可以看到<code>FindLoops</code>函数, 其<code>cum</code>开销为<code>21.20s</code>, 调用了诸多子函数, 下一层最右侧空白位置为<code>FindLoops</code>本身的时间开销:<code>flat</code>;</p>
<p>PS: 我个人在使用时, 发现在1.21版本的<code>go tool pprof</code>下的火焰图有了新选项(<code>Flame Graph new</code>), 已经有了更多变化, 官方截图如下:</p>
<p><img src="../images/image-20231225195624242.png" alt="image-20231225195624242"></p>
<ul>
<li>加入了颜色标识: 方便识别包;</li>
<li>规范了子调用函数的图像展示, 自左至右开销时间依次降低;</li>
<li>…</li>
</ul>
</li>
<li><p><code>VIEW: Peek</code></p>
<p><img src="../images/image-20231225195826156.png" alt="image-20231225195826156"></p>
<p>以文本格式展示函数的调用关系, 可读性一般, 可以使用<code>Graph</code>, <code>Flame Graph</code>替代;</p>
</li>
<li><p><code>VIEW: Source</code></p>
<p><img src="../images/image-20231225200450042.png" alt="image-20231225200450042"></p>
<p>展示了已标注的源码, 左侧有三列, 分别表示 代码行, <code>flat</code>开销, <code>cum</code>开销; 右侧为源码本身;</p>
<p>那么图中表示, 存在<code>runtime/mgcmark.go</code>文件的1211行的<code>heapBitsForAddr</code>函数本身开销为<code>130ms</code>, 包括其子函数的开销为<code>160ms</code>;</p>
<p>本模式一般用于行级别的<code>BUG</code>排查, 一般已经基本明确瓶颈函数后, 通过上面的正则搜索框进行下一步定位;</p>
<p>点击源码可以看到对应的汇编码, 以方便进一步排查;</p>
<p><img src="../images/image-20231225201034874.png" alt="image-20231225201034874"></p>
</li>
<li><p><code>VIEW: Disassemble</code></p>
<p><img src="../images/image-20231225201103015.png" alt="image-20231225201103015"></p>
<p>汇编模式查看, 我自己没用过;</p>
</li>
</ul>
</li>
<li><p>分析</p>
<ol>
<li><p>首先通过<code>Top VIEW</code>确定下当前的瓶颈函数</p>
<p><img src="../images/image-20231225202113461.png" alt="image-20231225202113461"></p>
<p>发现<code>runtime.mapaccess1_fast64</code>函数其<code>flat</code>执行时间最长, 其功能为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runtime.mapaccess1_fast64 是 Go 语言中的一个内部函数，用于快速访问 map 结构中的元素。它是在编译器生成的代码中使用的，用于优化 map 的访问速度。这个函数的具体实现可以在 Go 语言的运行时源代码中找到。在一般的 Go 代码中，我们并不需要直接调用这个函数，而是通过 map[key] 的方式来访问 map 中的元素。</span><br></pre></td></tr></table></figure>
<p>由于其是<code>runtime</code>包内的函数, 不是业务代码, 而我们需要优化的是业务代码, 可以通过<code>Graph VIEW</code>查看其调用路径;</p>
</li>
<li><p>其次通过<code>Graph VIEW</code>查看, 借助于正字表达式过滤, 可以排除无效的分支干扰:</p>
<p><img src="../images/image-20231225202710714.png" alt="image-20231225202710714"></p>
<p>发现其调用来源主要有两个<code>main.DFS 2.54s, main.FindLoop 1.88s</code>. 那么目前已经可以定位到函数级别了, 需要进一步定位到行级别(<code>Source VIEW</code>)的分析. 我选择查看<code>main.DFS</code>函数的<code>Source VIEW</code>;</p>
</li>
<li><p>通过<code>Source VIEW</code>, 借助于正字表达式过滤, 准确定位到<code>main.DFS</code>函数的源码标注:</p>
<p><img src="../images/image-20231225203153527.png" alt="image-20231225203153527"></p>
<p>从上图可以看出:<code>cum</code>维度上看: 时间开销较多的有,  <code>237行, 4.89s </code>, <code>236行, 2.07s</code>, <code>235行, 1.18s</code> …</p>
<ul>
<li><p>其中<code>237</code>行是递归, 235行是循环. 这种时间开销不可避免;</p>
</li>
<li><p><code>236</code>行在进行<code>map</code>索引过程, 其与<code>Top VIEW</code>中定位的<code>runtime.mapaccess1_fast64</code>是匹配的.是需要处理的;</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>进一步分析, 发现<code>236行</code>操作的<code>number</code>变量, 在<code>232行 440ms, 240行 850ms</code>均在进行<code>map</code>索引操作. </p>
<pre><code>- 涉及`number`的map索引开销约`2.5s`, 可以进行优化;</code></pre>
</li>
<li><p>修改代码:</p>
<p>经过分析, 发现<code>number map</code>变量主要用于标识代码块是否访问过. 而<code>BasicBlock.Name int</code>属性是唯一且范围可控, 可以通过<code>[]int</code>切片的方式进行等价处理, 具体代码差异为:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root v2]# diff /home/learnGo-master/pkg/tools/pprof/runtime/v1/havlak.go /home/learnGo-master/pkg/tools/pprof/runtime/v2/havlak.go | sed &#x27;s/^/差异行： /&#x27;</span><br><span class="line">差异行： 230c230</span><br><span class="line">差异行： &lt; func DFS(currentNode *BasicBlock, nodes []*UnionFindNode, number map[*BasicBlock]int, last []int, current int) int &#123;</span><br><span class="line">差异行： ---</span><br><span class="line">差异行： &gt; func DFS(currentNode *BasicBlock, nodes []*UnionFindNode, number []int, last []int, current int) int &#123;</span><br><span class="line">差异行： 232c232</span><br><span class="line">差异行： &lt;      number[currentNode] = current</span><br><span class="line">差异行： ---</span><br><span class="line">差异行： &gt;      number[currentNode.Name] = current</span><br><span class="line">差异行： 236c236</span><br><span class="line">差异行： &lt;              if number[target] == unvisited &#123;</span><br><span class="line">差异行： ---</span><br><span class="line">差异行： &gt;              if number[target.Name] == unvisited &#123;</span><br><span class="line">差异行： 240c240</span><br><span class="line">差异行： &lt;      last[number[currentNode]] = lastid</span><br><span class="line">差异行： ---</span><br><span class="line">差异行： &gt;      last[number[currentNode.Name]] = lastid</span><br><span class="line">差异行： 260c260</span><br><span class="line">差异行： &lt;      number := make(map[*BasicBlock]int)</span><br><span class="line">差异行： ---</span><br><span class="line">差异行： &gt;      number := make([]int, size)</span><br><span class="line">差异行： 276c276</span><br><span class="line">差异行： &lt;              number[bb] = unvisited</span><br><span class="line">差异行： ---</span><br><span class="line">差异行： &gt;              number[bb.Name] = unvisited</span><br><span class="line">差异行： 304c304</span><br><span class="line">差异行： &lt;                              v := number[nodeV]</span><br><span class="line">差异行： ---</span><br><span class="line">差异行： &gt;                              v := number[nodeV.Name]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重新编译并执行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@sangfor v2]# go build .&#x2F;havlak.go</span><br><span class="line">[root@sangfor v2]# ..&#x2F;xtime .&#x2F;havlak</span><br><span class="line"># of loops: 76000 (including 1 artificial root node)</span><br><span class="line">26.71u 2.39s 20.65r 332400kB .&#x2F;havlak</span><br></pre></td></tr></table></figure>
<p>发现<code>CPU</code>时间开销已经下降了;</p>
<table>
<thead>
<tr>
<th>Version</th>
<th>User Time</th>
<th>Sys Time</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>优化前</td>
<td>42.51 s</td>
<td>4.31 s</td>
<td>316284 kB</td>
</tr>
<tr>
<td>优化CPU后</td>
<td>26.71 s</td>
<td>2.39 s</td>
<td>332400 kB</td>
</tr>
</tbody></table>
<p>再此获得<code>cpuprofile</code>文件查看:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@sangfor v2]# .&#x2F;havlak -cpuprofile&#x3D;cpu.prof</span><br><span class="line"># of loops: 76000 (including 1 artificial root node)</span><br><span class="line">[root@sangfor v2]# ll</span><br><span class="line">total 2516</span><br><span class="line">-rw-r--r--. 1 root root   27387 Dec 25 21:07 cpu.prof</span><br><span class="line">-rwxr-xr-x. 1 root root 2525690 Dec 25 20:53 havlak</span><br><span class="line">-rw-r--r--. 1 root root   16723 Dec 25 20:53 havlak.go</span><br><span class="line">[root@sangfor v2]# go tool pprof -http&#x3D;0.0.0.0:1234 .&#x2F;cpu.prof</span><br><span class="line">warning: GOPATH set to GOROOT (&#x2F;usr&#x2F;local&#x2F;go&#x2F;) has no effect</span><br><span class="line">Serving web UI on http:&#x2F;&#x2F;0.0.0.0:1234</span><br></pre></td></tr></table></figure>
<p>发现<code>runtime.mapaccess1_fast6</code>函数已经不再是瓶颈函数了;</p>
<p><img src="../images/image-20231225211042259.png" alt="image-20231225211042259"></p>
</li>
<li><p>当前瓶颈函数: <code>runtime.scanobject</code>, <code>runtime.mallocgc</code>… 均为<code>GoGC</code>机制使用, 需要进行内存分析;</p>
</li>
</ul>
<h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><h4 id="profiling-data-生成-1"><a href="#profiling-data-生成-1" class="headerlink" title="profiling data 生成:"></a><code>profiling data</code> 生成:</h4><ul>
<li><p>嵌入<code>Mem Profile</code>生成代码, 开启<code>Mem Profiling</code>功能;</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> memprofile = flag.String(<span class="string">&quot;memprofile&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;write memory profile to this file&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> *memprofile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		f, err := os.Create(*memprofile)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">&quot;could not create memory profile: &quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> f.Close() <span class="comment">// error handling omitted for example</span></span><br><span class="line">		runtime.GC()    <span class="comment">// get up-to-date statistics</span></span><br><span class="line">		<span class="keyword">if</span> err := pprof.WriteHeapProfile(f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">&quot;could not write memory profile: &quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">		FindHavlakLoops(cfgraph, NewLSG())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;# of loops: %d (including 1 artificial root node)\n&quot;</span>, lsgraph.NumLoops())</span><br><span class="line">	lsgraph.CalculateNestingLevel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码位置约为<code>709行</code>. 添加的代码部分, 其支持通过命令行参数<code>-memprofile</code>的方式,指定开启<code>Mem Profiling</code>功能的同时将<code>profiling data</code>输出在<code>memprofile</code>文件内;</li>
</ul>
</li>
<li><p>编译代码, 开启<code>Mem Profiling</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root v3]# go build ./havlak.go</span><br><span class="line">[root v3]# ./havlak -memprofile=mem.prof</span><br><span class="line"><span class="meta">#</span><span class="bash"> of loops: 76000 (including 1 artificial root node)</span></span><br><span class="line">[root@sangfor v3]# ll</span><br><span class="line">total 2556</span><br><span class="line">-rwxr-xr-x. 1 root root 2591320 Dec 25 21:18 havlak</span><br><span class="line">-rw-r--r--. 1 root root   17170 Dec 25 21:13 havlak.go</span><br><span class="line">-rw-r--r--. 1 root root    1891 Dec 25 21:18 mem.prof</span><br></pre></td></tr></table></figure>
<h4 id="profilinf-data-分析-1"><a href="#profilinf-data-分析-1" class="headerlink" title="profilinf data 分析:"></a><code>profilinf data</code> 分析:</h4></li>
<li><p>开启<code>Interactive Web</code>, 查看<code>Mem Profiling data</code></p>
<p>通过<code>go tool pprof -http=host:port source</code>命令, 可以在指定端口允许通过<code>Web</code>查看<code>Mem Profiling data</code>;</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root v3]# go tool pprof -http=0.0.0.0:1234 ./mem.prof</span><br><span class="line">Serving web UI on http://0.0.0.0:1234</span><br><span class="line">http://0.0.0.0:1234</span><br></pre></td></tr></table></figure>
<p>同样的默认展示<code>Graph VIEW</code>:</p>
<p><img src="../images/image-20231225214519100.png" alt="image-20231225214519100"></p>
</li>
<li><p>界面解释: 基本与<code>CPU</code>一致, 不解释;</p>
</li>
<li><p>分析:</p>
<ol>
<li><p>通过<code>Top VIEW</code> 查看瓶颈函数</p>
<p><img src="../images/image-20231225214348200.png" alt="image-20231225214348200"></p>
<p>前三列占据了8成的内存占用, 瓶颈函数分别为<code>main.NewBasicBlock, main.(*LSG).NewLoop, main.(*SimpleLoop).AddNode</code>;</p>
</li>
<li><p>通过<code>graph VIEW</code>模式查看其调用情况</p>
<p><img src="../images/image-20231225215136960.png" alt="image-20231225215136960"></p>
<p>发现上面的函数均进行了<code>inline</code>优化处理, 对于性能分析来说, <code>inline</code>优化会导致<code>Source VIEW</code>模式无法直接定位到<code>inline function</code>, 例如查看<code>main.(*LSG).NewLoop</code>, 显示找不到:</p>
<p><img src="../images/image-20231226095721989.png" alt="image-20231226095721989"></p>
<p>对于此, 我两种处理方案:</p>
<ol>
<li><p>继续使用当前<code>profiling data</code>方案: 可以通过<code>no-inline</code>的父调用函数进行<code>Source VIEW</code>查验, 例如其调用函数<code>main.FindLoops</code>函数未进行<code>inline</code>处理,如下图:</p>
<p><img src="../images/image-20231226100103507.png" alt="image-20231226100103507"></p>
<p>发现405行中, <code>lsgraph.NewLoop()</code>函数占用了<code>11.50MB</code>的内存, 其标注如下图:</p>
<p><img src="../images/image-20231226100531255.png" alt="image-20231226100531255"></p>
<p>个人再自行通过代码阅读的方式, 排查上述代码. 例如我们知道<code>566行, 567行的 make()</code>函数会进行内存分配操作, 也许这里是优化项.</p>
</li>
<li><p>使用<code>no-inline</code>版本的<code>profiling data</code>, 重新编译并指定不采用<code>inline</code>优化, 随后再次生成一份<code>profiling data</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root v3]# go build -o havlak-without-inline -gcflags=-l ./havlak.go</span><br><span class="line">[root v3]# ll</span><br><span class="line">total 5092</span><br><span class="line">-rwxr-xr-x. 1 root root 2591320 Dec 25 21:18 havlak</span><br><span class="line">-rw-r--r--. 1 root root   17170 Dec 25 21:13 havlak.go</span><br><span class="line">-rwxr-xr-x. 1 root root 2595129 Dec 26 09:44 havlak-without-inline</span><br><span class="line">-rw-r--r--. 1 root root    1891 Dec 25 21:18 mem.prof</span><br><span class="line">[root v3]# ./havlak-without-inline -memprofile=mem-without-inline.prof</span><br><span class="line"><span class="meta">#</span><span class="bash"> of loops: 76000 (including 1 artificial root node)</span></span><br><span class="line">[root v3]# ll</span><br><span class="line">total 5096</span><br><span class="line">-rwxr-xr-x. 1 root root 2591320 Dec 25 21:18 havlak</span><br><span class="line">-rw-r--r--. 1 root root   17170 Dec 25 21:13 havlak.go</span><br><span class="line">-rwxr-xr-x. 1 root root 2595129 Dec 26 09:44 havlak-without-inline</span><br><span class="line">-rw-r--r--. 1 root root    1891 Dec 25 21:18 mem.prof</span><br><span class="line">-rw-r--r--. 1 root root    2017 Dec 26 09:46 mem-without-inline.prof</span><br><span class="line">[root v3]# go tool pprof -http=0.0.0.0:1234 ./mem-without-inline.prof</span><br><span class="line">Serving web UI on http://0.0.0.0:1234</span><br><span class="line">http://0.0.0.0:1234</span><br></pre></td></tr></table></figure>
<p>可以在Web上看到均无<code>inline</code>标识, 可以直接利用<code>Source VIEW</code>定位:</p>
<p><img src="../images/image-20231226101357893.png" alt="image-20231226101357893"></p>
<p>个人在使用时, 采用了此种方案.</p>
</li>
</ol>
</li>
<li><p>通过<code>Source VIEW</code>, 借助于正字表达式过滤, 准确定位到<code>main.(*LSG).NewLoop</code>函数的源码标注, 如下图:</p>
<p><img src="../images/image-20231226101740684.png" alt="image-20231226101740684"></p>
<p>发现<code>566行, 567行 make()</code> 函数占用了约<code>7MB</code>的内存开销, 并且进一步分析发现<code>basicBlocks, Children</code>可以通过切片的方式替换Map, 这会减少内存开销;</p>
<p>在随后的分析中, 发现其他业务代码也有类似的问题, 并一并进行了优化处理, 这里就不一一赘述了, 具体文件差异如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root ~]# diff /home/learnGo-master/pkg/tools/pprof/runtime/v3/havlak.go /home/learnGo-master/pkg/tools/pprof/runtime/v4/havlak.go | sed &#x27;s/^/差异行： /&#x27;</span><br><span class="line">差异行： 244a245,253</span><br><span class="line">差异行： &gt; func appendUnique(a []int, x int) []int &#123;</span><br><span class="line">差异行： &gt;      for _, y := range a &#123;</span><br><span class="line">差异行： &gt;              if x == y &#123;</span><br><span class="line">差异行： &gt;                      return a</span><br><span class="line">差异行： &gt;              &#125;</span><br><span class="line">差异行： &gt;      &#125;</span><br><span class="line">差异行： &gt;      return append(a, x)</span><br><span class="line">差异行： &gt; &#125;</span><br><span class="line">差异行： &gt;</span><br><span class="line">差异行： 258c267</span><br><span class="line">差异行： &lt;      nonBackPreds := make([]map[int]bool, size)</span><br><span class="line">差异行： ---</span><br><span class="line">差异行： &gt;      nonBackPreds := make([][]int, size)</span><br><span class="line">差异行： 276c285</span><br><span class="line">差异行： &lt;      for i, bb := range cfgraph.Blocks &#123;</span><br><span class="line">差异行： ---</span><br><span class="line">差异行： &gt;      for _, bb := range cfgraph.Blocks &#123;</span><br><span class="line">差异行： 278d286</span><br><span class="line">差异行： &lt;              nonBackPreds[i] = make(map[int]bool)</span><br><span class="line">差异行： 313c321</span><br><span class="line">差异行： &lt;                                      nonBackPreds[w][v] = true</span><br><span class="line">差异行： ---</span><br><span class="line">差异行： &gt;                                      nonBackPreds[w] = appendUnique(nonBackPreds[w], v)</span><br><span class="line">差异行： 389c397</span><br><span class="line">差异行： &lt;                                      nonBackPreds[w][ydash.dfsNumber] = true</span><br><span class="line">差异行： ---</span><br><span class="line">差异行： &gt;                                      nonBackPreds[w] = appendUnique(nonBackPreds[w], ydash.dfsNumber)</span><br><span class="line">差异行： 464,465c472,473</span><br><span class="line">差异行： &lt;      basicBlocks map[*BasicBlock]bool</span><br><span class="line">差异行： &lt;      Children    map[*SimpleLoop]bool</span><br><span class="line">差异行： ---</span><br><span class="line">差异行： &gt;      basicBlocks []*BasicBlock</span><br><span class="line">差异行： &gt;      Children    []*SimpleLoop</span><br><span class="line">差异行： 477c485</span><br><span class="line">差异行： &lt;      loop.basicBlocks[bb] = true</span><br><span class="line">差异行： ---</span><br><span class="line">差异行： &gt;      loop.basicBlocks = append(loop.basicBlocks, bb)</span><br><span class="line">差异行： 481c489</span><br><span class="line">差异行： &lt;      loop.Children[child] = true</span><br><span class="line">差异行： ---</span><br><span class="line">差异行： &gt;      loop.Children = append(loop.Children, child)</span><br><span class="line">差异行： 499c507</span><br><span class="line">差异行： &lt;              for ll := range loop.Children &#123;</span><br><span class="line">差异行： ---</span><br><span class="line">差异行： &gt;              for _, ll := range loop.Children &#123;</span><br><span class="line">差异行： 505c513</span><br><span class="line">差异行： &lt;              for bb := range loop.basicBlocks &#123;</span><br><span class="line">差异行： ---</span><br><span class="line">差异行： &gt;              for _, bb := range loop.basicBlocks &#123;</span><br><span class="line">差异行： 566,567d573</span><br><span class="line">差异行： &lt;      loop.basicBlocks = make(map[*BasicBlock]bool)</span><br><span class="line">差异行： &lt;      loop.Children = make(map[*SimpleLoop]bool)</span><br><span class="line">差异行： 587c593</span><br><span class="line">差异行： &lt;      for ll := range loop.Children &#123;</span><br><span class="line">差异行： ---</span><br><span class="line">差异行： &gt;      for _, ll := range loop.Children &#123;</span><br><span class="line">差异行： 606c612</span><br><span class="line">差异行： &lt;      for ll := range loop.Children &#123;</span><br><span class="line">差异行： ---</span><br><span class="line">差异行： &gt;      for _, ll := range loop.Children &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>重新编译并执行:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@sangfor v4]# go build ./havlak.go</span><br><span class="line">[root@sangfor v4]# ll</span><br><span class="line">total 2556</span><br><span class="line">-rwxr-xr-x. 1 root root 2590786 Dec 26 10:33 havlak</span><br><span class="line">-rw-r--r--. 1 root root   17240 Dec 26 10:26 havlak.go</span><br><span class="line">[root@sangfor v4]# ../xtime ./havlak</span><br><span class="line"><span class="meta">#</span><span class="bash"> of loops: 76000 (including 1 artificial root node)</span></span><br><span class="line">11.64u 1.24s 8.49r 176892kB ./havlak</span><br></pre></td></tr></table></figure>
<p>发现<code>Mem</code>开销下降了, 并且<code>CPU</code>时间开销也随之下降, 性能有所提升;</p>
<table>
<thead>
<tr>
<th>Version</th>
<th align="right">User Time</th>
<th>Sys Time</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>优化前</td>
<td align="right">42.51 s</td>
<td>4.31 s</td>
<td>316284 kB</td>
</tr>
<tr>
<td>优化CPU后</td>
<td align="right">26.71 s</td>
<td>2.39 s</td>
<td>332400 kB</td>
</tr>
<tr>
<td>优化CPU+MEM后</td>
<td align="right">11.64 s</td>
<td>1.24 s</td>
<td>176892 kB</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ul>
<h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><table>
<thead>
<tr>
<th>Version</th>
<th align="right">User Time</th>
<th>Opt</th>
<th>Sys Time</th>
<th>Opt</th>
<th>Memory</th>
<th>Opt</th>
</tr>
</thead>
<tbody><tr>
<td>优化前</td>
<td align="right">42.51 s</td>
<td>0</td>
<td>4.31 s</td>
<td>0</td>
<td>316284 kB</td>
<td>0</td>
</tr>
<tr>
<td>优化CPU后</td>
<td align="right">26.71 s</td>
<td>37.17 %</td>
<td>2.39 s</td>
<td>44.55 %</td>
<td>332400 kB</td>
<td>-5%</td>
</tr>
<tr>
<td>优化CPU+MEM后</td>
<td align="right">11.64 s</td>
<td>72.62 %</td>
<td>1.24 s</td>
<td>71.23 %</td>
<td>176892 kB</td>
<td>44.07%</td>
</tr>
</tbody></table>
<p>优化率计算公式<code>(优化前-优化后)/优化前</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://github.com/google/pprof/blob/main/doc/README.md">https://github.com/google/pprof/blob/main/doc/README.md</a></li>
<li><a href="https://go.dev/blog/pprof">https://go.dev/blog/pprof</a></li>
<li><a href="https://protobuf.dev/">https://protobuf.dev/</a></li>
<li><a href="https://github.com/google/pprof">https://github.com/google/pprof</a></li>
<li><a href="https://golang.google.cn/pkg/runtime/pprof/">https://golang.google.cn/pkg/runtime/pprof/</a></li>
<li><a href="https://github.com/eddycjy/blog/blob/master/content/posts/go/tools/2018-09-15-go-tool-pprof.md">https://github.com/eddycjy/blog/blob/master/content/posts/go/tools/2018-09-15-go-tool-pprof.md</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/141640004">https://zhuanlan.zhihu.com/p/141640004</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/51559344">https://zhuanlan.zhihu.com/p/51559344</a></li>
<li><a href="https://juejin.cn/post/7193865759825592375">https://juejin.cn/post/7193865759825592375</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/373874739">https://zhuanlan.zhihu.com/p/373874739</a></li>
</ol>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Source: sync.RWMutex</title>
    <url>/2024/01/07/Go-Source-sync-RWMutex/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文是<code>Go Source Code</code>解读系列之<code>sync/RWMutex</code>读写锁. 本系列会以代码示例作为切入点, 解释源码.</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>为什么不允许对<code>sync.RWMutex</code>通过<code>recursive read</code>的方式使用.</p>
<a id="more"></a>

<p>最近项目中遇到了<code>random deadlock</code>问题, 经过排查发现是因为在使用读写锁<code>sync/RWMutex</code>时, 使用了<code>recursive read</code>方式读取资源的同时触发了并发读, 这有可能触发<code>deadlock</code>. </p>
<p>示例代码抽象如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mutex</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rw sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readData</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Try to get R lock: %v \n&quot;</span>, i)</span><br><span class="line">	rw.RLock()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Get R lock: %v \n&quot;</span>, i)</span><br><span class="line">	<span class="keyword">defer</span> rw.RUnlock()</span><br><span class="line">	innerRead(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// recursive read, oh no!!!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">innerRead</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Try to get Inner R lock: %v \n&quot;</span>, i)</span><br><span class="line">	rw.RLock()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Get inner R lock: %v \n&quot;</span>, i)</span><br><span class="line">	<span class="keyword">defer</span> rw.RUnlock()</span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Finish read something: %v \n&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeData</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Try to get W lock: %v \n&quot;</span>, i)</span><br><span class="line">	rw.Lock()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Get W lock: %v \n&quot;</span>, i)</span><br><span class="line">	<span class="keyword">defer</span> rw.Unlock()</span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Finish write something: %v \n&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RWCompetion</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rw.Lock()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Ready??!! \n&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> readData(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> writeData(<span class="number">2</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Go ... \n&quot;</span>)</span><br><span class="line">	rw.Unlock()</span><br><span class="line">	time.Sleep(<span class="number">20</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中通过<code>RWCompetion</code>函数模拟了读写锁的竞争场景. </p>
<p>其中<code>readData</code>函数中模拟了读取数据操作, 存在<code>recursive read</code>现象, 其尝试内外两层获取读锁, 读取相关资源后, 依次释放内外读锁. </p>
<p><code>writeData</code>函数模拟了写入数据操作, 其尝试获取写锁, 并在写入资源后, 释放写锁. </p>
<p>在<code>RWCompetion</code>最后通过<code>time.Sleep(20 * time.Second)</code>保证读取操作有充分的时间完成.</p>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>示例代码中一共发生了三次锁获取操作, 其中两次为读锁(<code>RLock, innerRLock</code>), 一次为写锁(<code>WLock</code>); 由于并发时机的不确定性, 其实际调用顺序也是不确定的, 可以分为:</p>
<ol>
<li><p><code>RLock -&gt; innerRLock -&gt; WLock</code> : 先读后写;</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-0-9-centos learnGo]# go run ./cmd/main.go </span><br><span class="line">Ready??!! </span><br><span class="line">Go ... </span><br><span class="line">Try to get R lock: 1 </span><br><span class="line">Get R lock: 1 </span><br><span class="line">Try to get Inner R lock: 1 </span><br><span class="line">Get inner R lock: 1 </span><br><span class="line">Try to get W lock: 2 </span><br><span class="line">Finish read something: 1 </span><br><span class="line">Get W lock: 2 </span><br><span class="line">Finish write something: 2 </span><br></pre></td></tr></table></figure></li>
<li><p><code>RLock -&gt; WLock -&gt; innerRLock</code>: 没读完就写;</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-0-9-centos learnGo]# go run ./cmd/main.go </span><br><span class="line">Ready??!! </span><br><span class="line">Go ... </span><br><span class="line">Try to get R lock: 1 </span><br><span class="line">Get R lock: 1 </span><br><span class="line">Try to get W lock: 2 </span><br><span class="line">Try to get Inner R lock: 1 </span><br></pre></td></tr></table></figure></li>
<li><p><code>WLock -&gt; RLock -&gt; innerRLock</code>: 先写后读;</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-0-9-centos learnGo]# go run ./cmd/main.go </span><br><span class="line">Ready??!! </span><br><span class="line">Go ... </span><br><span class="line">Try to get W lock: 2 </span><br><span class="line">Get W lock: 2 </span><br><span class="line">Try to get R lock: 1 </span><br><span class="line">Finish write something: 2 </span><br><span class="line">Get R lock: 1 </span><br><span class="line">Try to get Inner R lock: 1 </span><br><span class="line">Get inner R lock: 1 </span><br><span class="line">Finish read something: 1 </span><br></pre></td></tr></table></figure>
<p>通过控制台输出内容, 可以发现在第二种调用顺序 <code>RLock -&gt; WLock -&gt; innerRLock</code>时: 发生了<code>DeadLock</code>. 接下来会结合源码, 进行解释.</p>
</li>
</ol>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><code>RWMutex</code>读写锁的特点:</p>
<ul>
<li>允许任意数量的读锁</li>
<li>仅允许单独的写锁</li>
<li>默认零值锁为<code>unlock</code>状态</li>
</ul>
<p>核心代码结构包括 一个代码结构体 <code>RWMutex</code>, 4个方法<code>RLock, RUnlock, Lock, Unlock</code>;</p>
<ul>
<li><p>结构体: <code>RWMutex</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	w           Mutex        <span class="comment">// 互斥锁, 用于标识是否存在写锁</span></span><br><span class="line">	writerSem   <span class="keyword">uint32</span>       <span class="comment">// 信号量, 用于标识写锁, 在释放掉当前存在的读锁后, 消费掉此信号</span></span><br><span class="line">	readerSem   <span class="keyword">uint32</span>       <span class="comment">// 信号量, 用于标识读锁, 在释放掉当前存在的写锁后, 消费掉此信号</span></span><br><span class="line">	readerCount atomic.Int32 <span class="comment">// number of pending readers 所有读锁计数</span></span><br><span class="line">	readerWait  atomic.Int32 <span class="comment">// number of departing readers 被写锁排斥的读锁计数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法: <code>RLock, RUnlock, Lock, Unlock</code></p>
<ul>
<li><p><code>RLock</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">if</span> rw.readerCount.Add(<span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// A writer is pending, wait for it.</span></span><br><span class="line">		runtime_SemacquireRWMutexR(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码通过<code>rw.readerCount.Add(1)</code>对读者计数进行加1操作，并判断加1后的结果是否小于0。如果小于0，表示有一个写者正在等待，需要等待写者完成。</p>
</li>
<li><p><code>RUnlock</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">if</span> r := rw.readerCount.Add(<span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Outlined slow-path to allow the fast-path to be inlined</span></span><br><span class="line">		rw.rUnlockSlow(r)</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">rUnlockSlow</span><span class="params">(r <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// A writer is pending.</span></span><br><span class="line">	<span class="keyword">if</span> rw.readerWait.Add(<span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// The last reader unblocks the writer.</span></span><br><span class="line">		runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码通过<code>rw.readerCount.Add(-1)</code>对读者计数进行减1操作，并判断减1后的结果是否小于0。如果小于0，表示可能有其他的读者或写者在等待，需要进入慢路径处理。</p>
<p>然后，代码通过调用<code>rw.rUnlockSlow()</code>方法进入慢路径处理: 代码判断通过<code>rw.readerWait.Add(-1)</code>将等待的读者数量减1。如果减1后的结果为0，表示最后一个读者解锁了，需要唤醒等待的写者。</p>
</li>
<li><p><code>Lock</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">	<span class="comment">// First, resolve competition with other writers.</span></span><br><span class="line">	rw.w.Lock()</span><br><span class="line">	<span class="comment">// Announce to readers there is a pending writer.</span></span><br><span class="line">	r := rw.readerCount.Add(-rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">	<span class="comment">// Wait for active readers.</span></span><br><span class="line">	<span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; rw.readerWait.Add(r) != <span class="number">0</span> &#123;</span><br><span class="line">		runtime_SemacquireRWMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码通过<code>rw.w.Lock()</code>来解决与其他写者的竞争。这表示在获取写锁之前，需要先解决与其他写者的竞争。</p>
<p>接着，代码通过<code>rw.readerCount.Add(-rwmutexMaxReaders)</code>将读者计数减去最大读者数，并将结果加上最大读者数。这是为了向读者们宣告有一个等待的写者。</p>
<p>然后，代码通过<code>rw.readerWait.Add(r)</code>等待活动读者。如果等待的读者数量不为0，代码会通过<code>runtime_SemacquireRWMutex()</code>函数等待写者信号量。</p>
</li>
<li><p><code>Unlock</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">	<span class="comment">// Announce to readers there is no active writer.</span></span><br><span class="line">	r := rw.readerCount.Add(rwmutexMaxReaders)</span><br><span class="line">	<span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		fatal(<span class="string">&quot;sync: Unlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Unblock blocked readers, if any.</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(r); i++ &#123;</span><br><span class="line">		runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Allow other writers to proceed.</span></span><br><span class="line">	rw.w.Unlock()</span><br><span class="line">...			</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码通过<code>rw.readerCount.Add(rwmutexMaxReaders)</code>将读者计数加上最大读者数，并将结果赋值给变量<code>r</code>。这是为了向读者们宣告没有活动的写者。</p>
<p>接着，代码通过一个循环来释放读者信号量。循环的次数为<code>r</code>的值，即之前计算的读者计数加上最大读者数。在循环中，通过调用<code>runtime_Semrelease()</code>函数来释放读者信号量。</p>
<p>然后，代码通过<code>rw.w.Unlock()</code>来释放写锁。这表示写者已经完成了写操作，其他的写者可以继续执行。</p>
</li>
</ul>
</li>
</ul>
<h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>经过上面的源码解释, 可以分析出:  <code>RLock -&gt; WLock -&gt; innerRLock</code> 的流程为:</p>
<ul>
<li>顺利获得<code>RLock</code>, 此时<code>rw.readerCount == 1</code>, 标识正在使用的读者有一个;</li>
<li>试图去拿<code>WLock</code>, 发现存在读者在读, 进入了等待写信号量状态, 此时:<code>rw.w</code>处于锁定状态, <code>rw.readerCount == 1- 1&lt;&lt;30</code>;</li>
<li>试图去拿<code>innerRLock</code>, 发现前面存在一个写锁操作, 进入了等待读信号量状态.</li>
</ul>
<p>上面的三步操作, 其依赖关系为:</p>
<ul>
<li><code>innerRLock -&gt; WLock</code>: <code>innerRLock</code>在等待<code>WLock</code>释放;</li>
<li><code>RLock -&gt; innerRLock</code>: <code>RLock</code>在等待<code>innerRLock</code>释放;</li>
<li><code>WLock -&gt; RLock</code>: <code>WLock</code>在等待<code>RLock</code>释放;</li>
</ul>
<p>从而导致了死锁现象.</p>
<p>通过代码中添加<code>RWMutex</code>输出逻辑, 可以佐证上面的解释:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mutex</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rw sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readData</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Try to get R lock: %v \n&quot;</span>, i)</span><br><span class="line">	mutexInfo(<span class="string">&quot;TryRLock: &quot;</span>)</span><br><span class="line">	rw.RLock()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Get R lock: %v \n&quot;</span>, i)</span><br><span class="line">	mutexInfo(<span class="string">&quot;GetRLock: &quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> rw.RUnlock()</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	innerRead(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">innerRead</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	mutexInfo(<span class="string">&quot;TryInnerRLock: &quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Try to get Inner R lock: %v \n&quot;</span>, i)</span><br><span class="line">	rw.RLock()</span><br><span class="line">	mutexInfo(<span class="string">&quot;GetInnerRLock: &quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Get inner R lock: %v \n&quot;</span>, i)</span><br><span class="line">	<span class="keyword">defer</span> rw.RUnlock()</span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Finish read something: %v \n&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeData</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Try to get W lock: %v \n&quot;</span>, i)</span><br><span class="line">	mutexInfo(<span class="string">&quot;TryWLock: &quot;</span>)</span><br><span class="line">	rw.Lock()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Get W lock: %v \n&quot;</span>, i)</span><br><span class="line">	mutexInfo(<span class="string">&quot;GetWLock: &quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> rw.Unlock()</span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Finish write something: %v \n&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mutexInfo</span><span class="params">(pre <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s: RWMutext stats: %#v \n&quot;</span>, pre, rw)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RWCompetion</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rw.Lock()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Ready??!! \n&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> readData(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> writeData(<span class="number">2</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Go ... \n&quot;</span>)</span><br><span class="line">	rw.Unlock()</span><br><span class="line">	time.Sleep(<span class="number">20</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-0-9-centos learnGo]# go run ./cmd/main.go </span><br><span class="line">Ready??!! </span><br><span class="line">Go ... </span><br><span class="line">Try to get R lock: 1 </span><br><span class="line">TryRLock: : RWMutext stats: ... readerCount:atomic.Int32&#123;_:atomic.noCopy&#123;&#125;, v:0&#125;, readerWait:atomic.Int32&#123;_:atomic.noCopy&#123;&#125;, v:0&#125;&#125; </span><br><span class="line">Get R lock: 1 </span><br><span class="line">GetRLock: : RWMutext stats:... readerCount:atomic.Int32&#123;_:atomic.noCopy&#123;&#125;, v:1&#125;, readerWait:atomic.Int32&#123;_:atomic.noCopy&#123;&#125;, v:0&#125;&#125; </span><br><span class="line">Try to get W lock: 2 </span><br><span class="line">TryWLock: : RWMutext stats: ... readerCount:atomic.Int32&#123;_:atomic.noCopy&#123;&#125;, v:1&#125;, readerWait:atomic.Int32&#123;_:atomic.noCopy&#123;&#125;, v:0&#125;&#125; </span><br><span class="line">TryInnerRLock: : RWMutext stats: ... readerCount:atomic.Int32&#123;_:atomic.noCopy&#123;&#125;, v:-1073741823&#125;, readerWait:atomic.Int32&#123;_:atomic.noCopy&#123;&#125;, v:1&#125;&#125; </span><br><span class="line">Try to get Inner R lock: 1 </span><br></pre></td></tr></table></figure>
<p>PS: 由于并发的特性, 需要多试几次, 才可以复现上面的输出结果. 无关信息通过<code>...</code>忽略处理;</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>对于<code>sync/RWMutex</code>中的读锁操作允许重复读, 但是不允许<code>recursive</code>读. 这对导致内外层锁之间的依赖性, 破坏了原子性;</p>
<p>对于<code>sync/RWMutex</code>中的写锁操作仅允许单独写, 其会阻塞后续读锁操作(防止饥饿现象).</p>
<p>在使用过程中, 禁止<code>recursive</code>读操作即可;</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Protocol Buffer 简单使用</title>
    <url>/2024/01/16/Protocol-Buffer-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最近有接触到<code>.prof</code>文件, 发现其为<code>protocol buffer</code>格式文件. 第一次接触, 这里简单的做个梳理, 如要理解细节,可参考<a href="https://protobuf.dev/overview/">官网</a>.</p>
<a id="more"></a>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><code>Protocol Buffers</code> 是一种数据编码格式, 类似<code>JSON,XML</code>, 其不同点在于, <code>Protoco Buffers</code>并非完全可读的编码格式.</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>跨语言: 支持各种编程语言, <code>C++, C#, Go, Python, Java...</code></li>
<li>跨平台: <code>win, mac, linux ...</code></li>
<li>传输速度快, 数据体积小 …</li>
</ul>
<h3 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h3><p><code>gRPC, Google Cloud, Envoy Proxy ...</code></p>
<h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><p><img src="../images/image-20240115151319003.png" alt="image-20240115151319003"></p>
<ol>
<li>定义: 首先定义一个<code>.proto</code>文件, 其定义了消息的数据结构;</li>
<li>编译: 其次通过<code>protoc</code>编译器, 生成对应语言<code>例如:(Go)</code>的数据结构源码<code>(...pb.go)</code>;</li>
<li>处理: 最后通过项目, 操作<code>pb.go</code>实现业务功能: <code>序列化/反序列化...</code>;</li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>以<code>Go</code>语言为例</p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>定义<code>.proto</code>  数据格式; 具体的定义细节, 这里不做介绍, 有兴趣可参考: <a href="https://protobuf.dev/programming-guides/proto3/">Proto3版本介绍</a>.</p>
<p>例如: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; [START declaration]</span><br><span class="line">syntax &#x3D; &quot;proto3&quot;; &#x2F;&#x2F; 声明 .proto 文件版本</span><br><span class="line">package tutorial; &#x2F;&#x2F; 包定义, 防止跨项目间的命名冲突</span><br><span class="line">&#x2F;&#x2F; [END declaration]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [START go_declaration]</span><br><span class="line">option go_package &#x3D; &quot;&#x2F;protobuf&#x2F;go&#x2F;tutorialpb&quot;; &#x2F;&#x2F; 生成的Go代码包结构</span><br><span class="line">&#x2F;&#x2F; [END go_declaration]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [START messages]</span><br><span class="line">message Person &#123;</span><br><span class="line">  string name &#x3D; 1;</span><br><span class="line">  int32 id &#x3D; 2;  &#x2F;&#x2F; Unique ID number for this person.</span><br><span class="line">  string email &#x3D; 3; </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; [END messages]</span><br></pre></td></tr></table></figure>
<p>上面的<code>.proto</code>文件中定义了一个<code>Person</code>数据结构, 采用了<code>proto3</code>版本, 并指定代码生成在<code>/protobuf/go/tutorialpb</code>相对目录下.</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><h4 id="安装proto编译器"><a href="#安装proto编译器" class="headerlink" title="安装proto编译器"></a>安装<code>proto</code>编译器</h4><p><a href="https://protobuf.dev/downloads/">安装地址</a>, 选择对应的平台的压缩包, 例如在<code>Linux X86 64</code>架构下, 选择:<a href="https://github.com/protocolbuffers/protobuf/releases/download/v25.2/protoc-25.2-linux-x86_64.zip">protoc-25.2-linux-x86_64.zip</a>. </p>
<p>解压上述<code>zip</code>文件, 例如<code>/usr/local</code>下:<code>unzip -d protoc /usr/local/protoc-25.2-linux-x86_64.zip</code></p>
<h4 id="运行编译器"><a href="#运行编译器" class="headerlink" title="运行编译器"></a>运行编译器</h4><p>命令示例: <code>protoc -I=$SRC_DIR --go_out=$DST_DIR $SRC_DIR/addressbook.proto</code></p>
<p>生成:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;protoc&#x2F;bin&#x2F;</span><br><span class="line"></span><br><span class="line">.&#x2F;protoc -I&#x3D;&#x2F;home&#x2F;self&#x2F;pkg&#x2F;data&#x2F;tutorial --go_out&#x3D;&#x2F;home&#x2F;self&#x2F;pkg&#x2F;data&#x2F;tutorial &#x2F;home&#x2F;self&#x2F;pkg&#x2F;data&#x2F;tutorial&#x2F;person.proto</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<p><img src="../images/image-20240115160243873.png" alt="image-20240115160243873"></p>
<p>生成了<code>person.pb.go</code>数据文件;</p>
<h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><p>可以根据业务需求编写序列化与反序列化代码: 例如添加一个Person的需求:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">	pb <span class="string">&quot;self/pkg/data/tutorial/protobuf/go/pb&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/protobuf/proto&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">promptForAddress</span><span class="params">(r io.Reader)</span> <span class="params">(*pb.Person, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// A protocol buffer can be created like any struct.</span></span><br><span class="line">	p := &amp;pb.Person&#123;&#125;</span><br><span class="line"></span><br><span class="line">	rd := bufio.NewReader(r)</span><br><span class="line">	fmt.Print(<span class="string">&quot;Enter person ID number: &quot;</span>)</span><br><span class="line">	<span class="comment">// An int32 field in the .proto file is represented as an int32 field</span></span><br><span class="line">	<span class="comment">// in the generated Go struct.</span></span><br><span class="line">	<span class="keyword">if</span> _, err := fmt.Fscanf(rd, <span class="string">&quot;%d\n&quot;</span>, &amp;p.Id); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> p, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Print(<span class="string">&quot;Enter name: &quot;</span>)</span><br><span class="line">	name, err := rd.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> p, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// A string field in the .proto file results in a string field in Go.</span></span><br><span class="line">	<span class="comment">// We trim the whitespace because rd.ReadString includes the trailing</span></span><br><span class="line">	<span class="comment">// newline character in its output.</span></span><br><span class="line">	p.Name = strings.TrimSpace(name)</span><br><span class="line"></span><br><span class="line">	fmt.Print(<span class="string">&quot;Enter email address (blank for none): &quot;</span>)</span><br><span class="line">	email, err := rd.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> p, err</span><br><span class="line">	&#125;</span><br><span class="line">	p.Email = strings.TrimSpace(email)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main reads the entire person from a file, adds one person based on</span></span><br><span class="line"><span class="comment">// user input, then writes it back out to the same file.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;Usage:  %s PERSON_FILE\n&quot;</span>, os.Args[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	fname := os.Args[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Read the existing address book.</span></span><br><span class="line">	in, err := ioutil.ReadFile(fname)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s: File not found.  Creating new file.\n&quot;</span>, fname)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			log.Fatalln(<span class="string">&quot;Error reading file:&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// [START marshal_proto]</span></span><br><span class="line">	person := &amp;pb.Person&#123;&#125;</span><br><span class="line">	<span class="comment">// [START_EXCLUDE]</span></span><br><span class="line">	<span class="keyword">if</span> err := proto.Unmarshal(in, person); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;Failed to parse address book:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	bs, _ := json.Marshal(person)</span><br><span class="line">	log.Printf(<span class="string">&quot;Got PERSON : %v \n&quot;</span>, <span class="keyword">string</span>(bs))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add an address.</span></span><br><span class="line">	newPerson, err := promptForAddress(os.Stdin)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;Error with address:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// [END_EXCLUDE]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Write the new person back to disk.</span></span><br><span class="line">	out, err := proto.Marshal(newPerson)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;Failed to encode person:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := ioutil.WriteFile(fname, out, <span class="number">0644</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;Failed to write person:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// [END marshal_proto]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码: 添加一个Person数据并序列化到本地:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root addPerson]# go run add.go ./per</span><br><span class="line">./per: File not found.  Creating new file.</span><br><span class="line">2024/01/15 16:11:51 Got PERSON : &#123;&#125; </span><br><span class="line">Enter person ID number: 14930</span><br><span class="line">Enter name: HowardSUN</span><br><span class="line">Enter email address (blank for none): 14930@qq.com</span><br></pre></td></tr></table></figure>
<p>查看本地数据:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ addPerson]# cat per</span><br><span class="line"></span><br><span class="line">        HowardSUN⚌t</span><br><span class="line">14930@qq.com</span><br></pre></td></tr></table></figure>
<p>至于为何数据编码为上述样式, 本文不做解释.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Protocol Buffer</code>是跨语言, 跨平台的数据编码格式. 其中<code>.proto</code>数据定义格式, 决定了各平台,各语言可以识别相同的数据格式. <code>protocol buffer</code>编译器支持生成各语言下的数据源码, 统一化基础操作; 最后通过业务处理, 可以实现基于<code>序列化/反序列化</code>的个性化操作;</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>First Class Function In Go</title>
    <url>/2024/01/31/First-Class-Function-In-Go/</url>
    <content><![CDATA[<p>参考: <a href="https://golangbot.com/first-class-functions/">First Class Function Blog</a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><code>First Class Function</code> 是一种编程语言的术语, 指当一个函数可以赋值给变量, 可以当作参数传参, 可以作为返回值返回时, 称为<code>First Class Function</code>. 而<code>Go</code>语言拥有<code>First Class Function</code>特性;</p>
<a id="more"></a>

<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>这一部分将结合<code>Go</code>语言语法与各种使用场景阐述<code>First Class Function</code>;</p>
<h3 id="Scenario-1-Anonymous-function"><a href="#Scenario-1-Anonymous-function" class="headerlink" title="Scenario 1: Anonymous function"></a>Scenario 1: Anonymous function</h3><p><code>Anonymous function</code> (匿名函数)指的是没有函数名称的函数, 其在项目中往往充当简单的功能函数, 其使用方式很灵活, 例如:</p>
<ul>
<li><p>赋值<code>Anonymous function</code>给某变量;</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Hello First Class Function&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	a()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Type of variable a is %T&quot;</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hello First Class Function</span><br><span class="line">Type of variable a is func()</span><br></pre></td></tr></table></figure>
<p>上面定义了一个<code>Anonymous function</code>,其会输出<code>Hello First Class Function</code> ,并赋值给<code>a</code>;<br>随后调用<code>a</code>, 并打印出了<code>a</code>的类型, 发现其为<code>func()</code>;</p>
</li>
<li><p><code>Anonymous function</code> 创建的同时运行;</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Hello First Class Function&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hello First Class Function</span><br></pre></td></tr></table></figure>
<p>对于<code>Anonymous function</code>也可以不赋值, 例如上面定义了<code>Anonymous function</code>的同时立马运行, 输出了<code>Hello First Class Function</code>;</p>
</li>
<li><p><code>Anonymous function</code> 也支持传参;</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Hello&quot;</span>, n)</span><br><span class="line">	&#125;(<span class="string">&quot;Gophers&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>Anonymous function</code>, 自然也可以像普通函数一样通过传参的方式使用; 例如上面定义了一个接受<code>string</code>入参的<code>Anonymous function</code>.</p>
</li>
</ul>
<h3 id="Scenario-2-User-defined-function-types"><a href="#Scenario-2-User-defined-function-types" class="headerlink" title="Scenario 2: User defined function types"></a>Scenario 2: User defined function types</h3><p><code>Go</code> 语言支持用户自定义函数类型, 例如:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Min <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m Min = <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">			<span class="keyword">return</span> a</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">	res := m(<span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Min&quot;</span>, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Min 5</span><br></pre></td></tr></table></figure>
<p>上面定义了一个自定义函数类型<code>Min</code>, 随后通过<code>Anonymous function</code>的方式赋值给<code>Min</code>类型的变量<code>m</code>; 随后调用函数<code>m</code>获得两数中的小数;</p>
<h3 id="Scenario-3-Higher-order-functions"><a href="#Scenario-3-Higher-order-functions" class="headerlink" title="Scenario 3: Higher-order functions"></a>Scenario 3: Higher-order functions</h3><p><code>Higher-order functions</code> 高维函数指的是符合以下两者之一的函数:</p>
<ul>
<li>函数传参: 入参中至少包含一个函数入参</li>
<li>返回函数: 返回值中包含有函数</li>
</ul>
<p>函数传参:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">higher</span><span class="params">(f <span class="keyword">func</span>(a, b <span class="keyword">int</span>)</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Func result: %v&quot;</span>, f(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	min := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">			<span class="keyword">return</span> a</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">	higher(min)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Func result: 5</span><br></pre></td></tr></table></figure>
<p>上面的例子中, 我定义了一个<code>higher</code>高维函数, 其接受一个函数入参<code>f</code>, 并在内部逻辑中输出<code>f(5, 6)</code>的结果; 在<code>main</code>函数中, 定义了一个<code>Anonymous function</code> 并赋值给变量<code>min</code>; 最后将<code>min</code>传递给<code>higher</code>函数执行.</p>
<p>返回函数:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">higher</span><span class="params">()</span> <span class="title">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">			<span class="keyword">return</span> a</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := higher()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Result is: %v&quot;</span>, f(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Result is: 5</span><br></pre></td></tr></table></figure>
<p>在上面的例子中, 我定义了一个<code>higher</code>高维函数, 其会返回一个实现了<code>Min</code>逻辑的函数; 在<code>main</code>函数中, 我通过变量<code>f</code>接收了<code>higher</code>的返回值, 并在最后输出<code>f</code>的执行结果;</p>
<h3 id="Scenario-4-Closures"><a href="#Scenario-4-Closures" class="headerlink" title="Scenario 4: Closures"></a>Scenario 4: Closures</h3><p><code>Closures</code> 闭包是<code>anonymous functions</code>的特殊用例, 指的是在<code>Function Body</code> 内使用了外部的变量, 导致外部变量在函数使用期间无法被<code>GC</code>回收;例如:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendStr</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	t := <span class="string">&quot;Hello&quot;</span></span><br><span class="line">	c := <span class="function"><span class="keyword">func</span><span class="params">(b <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">		t = t + <span class="string">&quot; &quot;</span> + b</span><br><span class="line">		<span class="keyword">return</span> t</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := appendStr()</span><br><span class="line">	fmt.Println(a(<span class="string">&quot;World&quot;</span>))</span><br><span class="line">	fmt.Println(a(<span class="string">&quot;Gopher&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hello World</span><br><span class="line">Hello World Gopher</span><br></pre></td></tr></table></figure>
<p>在上面的例子中<code>appendStr</code>函数返回了一个<code>closure</code>, 其绑定了变量<code>t</code>; 在<code>main</code>函数中将<code>closure</code>赋值给变量<code>a</code>, 并在随后调用了两次; 可以发现, 第二次调用时的输出为<code>Hello World Gopher</code>而不是<code>Hello Gopher</code>. 这说明变量<code>t</code>在<code>closure</code>使用过程中一直被引用, 并且其值会随着多次调用,产生无法预期的变化. 在项目中, 一般避免使用<code>Closure</code>, 以免产生不必要的误解;</p>
<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p>这一部分将通过一个简单的用例, 说明<code>First Class Function</code>的用于<code>Dependency Injection</code>的用例场景;</p>
<ul>
<li><p>定义一个<code>student</code>结构体:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	firstName <span class="keyword">string</span></span><br><span class="line">	lastName  <span class="keyword">string</span></span><br><span class="line">	grade     <span class="keyword">string</span></span><br><span class="line">	country   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>student</code>结构体中包含有学生基础信息, <code>姓, 名, 分数, 国家</code>;</p>
</li>
<li><p>定义一个<code>filter</code>函数:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(s []student, f <span class="keyword">func</span>(student)</span> <span class="title">bool</span>) []<span class="title">student</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> r []student</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="keyword">if</span> f(v) == <span class="literal">true</span> &#123;</span><br><span class="line">			r = <span class="built_in">append</span>(r, v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了一个过滤函数<code>filter</code>, 其接受一个<code>student</code>列表与<code>filter logic: f</code>, 函数中会遍历<code>student</code>列表并返回符合<code>f</code>的学生列表;</p>
</li>
</ul>
<p>  定义了一个过滤函数<code>filter</code>, 其接受一个<code>student</code>列表与<code>filter logic: f</code>, 函数中会遍历<code>student</code>列表并返回符合<code>f</code>的学生列表;</p>
<ul>
<li><p>函数主逻辑如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	firstName <span class="keyword">string</span></span><br><span class="line">	lastName  <span class="keyword">string</span></span><br><span class="line">	grade     <span class="keyword">string</span></span><br><span class="line">	country   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(s []student, f <span class="keyword">func</span>(student)</span> <span class="title">bool</span>) []<span class="title">student</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> r []student</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="keyword">if</span> f(v) == <span class="literal">true</span> &#123;</span><br><span class="line">			r = <span class="built_in">append</span>(r, v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">studentList</span><span class="params">()</span> []<span class="title">student</span></span> &#123;</span><br><span class="line">	s1 := student&#123;</span><br><span class="line">		firstName: <span class="string">&quot;Naveen&quot;</span>,</span><br><span class="line">		lastName:  <span class="string">&quot;Ramanathan&quot;</span>,</span><br><span class="line">		grade:     <span class="string">&quot;A&quot;</span>,</span><br><span class="line">		country:   <span class="string">&quot;India&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	s2 := student&#123;</span><br><span class="line">		firstName: <span class="string">&quot;Samuel&quot;</span>,</span><br><span class="line">		lastName:  <span class="string">&quot;Johnson&quot;</span>,</span><br><span class="line">		grade:     <span class="string">&quot;B&quot;</span>,</span><br><span class="line">		country:   <span class="string">&quot;USA&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	s3 := student&#123;</span><br><span class="line">		firstName: <span class="string">&quot;Sun&quot;</span>,</span><br><span class="line">		lastName:  <span class="string">&quot;Qingzhi&quot;</span>,</span><br><span class="line">		grade:     <span class="string">&quot;C&quot;</span>,</span><br><span class="line">		country:   <span class="string">&quot;China&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> []student&#123;s1, s2, s3&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := studentList()</span><br><span class="line">	f := filter(s, <span class="function"><span class="keyword">func</span><span class="params">(s student)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> s.grade == <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在<code>main</code>函数逻辑中, 首先通过<code>studentList</code>函数获得了初始化学生列表, 随后通过调用<code>filter</code>函数, 并注入了一个匿名函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找到成绩为C的学生</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(s student)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">     <span class="keyword">if</span> s.grade == <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">	     <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后获得了符合匿名函数的学生列表;</p>
<p>输出为:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[&#123;Sun Qingzhi C China&#125;]</span><br></pre></td></tr></table></figure>
<p>这么做的好处在于将<code>filter logic</code>与<code>Caller</code>拆分开来, 是一种松耦合的编码方式;</p>
<p>如果发现目前有业务调整, 需要得到来自于<code>India</code>的学生列表, 那么只需要将<code>filter logic</code>逻辑更换为:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找到来自于印度的学生</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(s student)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> s.country == <span class="string">&quot;India&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[&#123;Naveen Ramanathan A India&#125;]</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li>
</ul>
<p>本文介绍的核心为<code>First Class Function</code>, 分别介绍了定义, <code>Go</code>中的使用场景与用例实战. 相信认真读到这里, 可以发现<code>First Class Function</code>是一个简单的术语, 在项目中或多或少的都有涉及. 期望这一篇文章可以对你有所帮助;</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
</search>
