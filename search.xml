<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Pyhton_字符编码</title>
    <url>/2020/04/02/Pyhton-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a></p>
</blockquote>
<h2 id="1-ASCII编码"><a href="#1-ASCII编码" class="headerlink" title="1.ASCII编码"></a>1.ASCII编码</h2><blockquote>
<p>我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有<code>0</code>和<code>1</code>两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从<code>00000000</code>到<code>11111111</code>。</p>
<p>上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。</p>
<p>ASCII 码一共规定了128个字符的编码，比如空格<code>SPACE</code>是32（二进制<code>00100000</code>），大写的字母<code>A</code>是65（二进制<code>01000001</code>）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为<code>0</code>。</p>
</blockquote>
<a id="more"></a>
<h2 id="2-非ASCII编码"><a href="#2-非ASCII编码" class="headerlink" title="2.非ASCII编码"></a>2.非ASCII编码</h2><blockquote>
<p>英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的<code>é</code>的编码为130（二进制<code>10000010</code>）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。</p>
<p>但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了<code>é</code>，在希伯来语编码中却代表了字母<code>Gimel</code> (<code>ג</code>)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0–127表示的符号是一样的，不一样的只是128–255的这一段。</p>
<p>至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。</p>
<p>中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。</p>
</blockquote>
<h2 id="3-Unicode"><a href="#3-Unicode" class="headerlink" title="3.Unicode"></a>3.Unicode</h2><blockquote>
<p>正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。</p>
<p>可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。</p>
<p>Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，<code>U+0639</code>表示阿拉伯字母<code>Ain</code>，<code>U+0041</code>表示英语的大写字母<code>A</code>，<code>U+4E25</code>表示汉字<code>严</code>。具体的符号对应表，可以查询<a href="http://www.unicode.org/">unicode.org</a>，或者专门的<a href="http://www.chi2ko.com/tool/CJK.htm">汉字对应表</a>。</p>
</blockquote>
<h2 id="4-Unicode-的问题"><a href="#4-Unicode-的问题" class="headerlink" title="4.Unicode 的问题"></a>4.<strong>Unicode 的问题</strong></h2><blockquote>
<p>需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</p>
<p>比如，汉字<code>严</code>的 Unicode 是十六进制数<code>4E25</code>，转换成二进制数足足有15位（<code>100111000100101</code>），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。</p>
<p>这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是<code>0</code>，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p>
<p>它们造成的结果是：1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。2）Unicode 在很长一段时间内无法推广，直到互联网的出现。</p>
</blockquote>
<h2 id="5-UTF-8"><a href="#5-UTF-8" class="headerlink" title="5.UTF-8"></a>5.<strong>UTF-8</strong></h2><blockquote>
<p>互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。<strong>重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。</strong></p>
<p>UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>
<p>UTF-8 的编码规则很简单，只有二条：</p>
<p>1）对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p>
<p>2）对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p>
<p>下表总结了编码规则，字母<code>x</code>表示可用编码的位。</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><figcaption><span>|        UTF-8编码方式</span></figcaption><table><tr><td class="code"><pre><span class="line">Unicode符号范围     |        UTF-8编码方式</span><br><span class="line">(十六进制)        |              （二进制）</span><br><span class="line">----------------------+---------------------------------------------</span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。</p>
<p>下面，还是以汉字<code>严</code>为例，演示如何实现 UTF-8 编码。</p>
<p><code>严</code>的 Unicode 是<code>4E25</code>（<code>100111000100101</code>），根据上表，可以发现<code>4E25</code>处在第三行的范围内（<code>0000 0800 - 0000 FFFF</code>），因此<code>严</code>的 UTF-8 编码需要三个字节，即格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从<code>严</code>的最后一个二进制位开始，依次从后向前填入格式中的<code>x</code>，多出的位补<code>0</code>。这样就得到了，<code>严</code>的 UTF-8 编码是<code>11100100 10111000 10100101</code>，转换成十六进制就是<code>E4B8A5</code>。</p>
</blockquote>
<h2 id="6-Little-endian-和-Big-endian"><a href="#6-Little-endian-和-Big-endian" class="headerlink" title="6.Little endian 和 Big endian"></a>6.<strong>Little endian 和 Big endian</strong></h2><blockquote>
<p>上一节已经提到，UCS-2 格式可以存储 Unicode 码（码点不超过<code>0xFFFF</code>）。以汉字<code>严</code>为例，Unicode 码是<code>4E25</code>，需要用两个字节存储，一个字节是<code>4E</code>，另一个字节是<code>25</code>。存储的时候，<code>4E</code>在前，<code>25</code>在后，这就是 Big endian 方式；<code>25</code>在前，<code>4E</code>在后，这是 Little endian 方式。</p>
<p>这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-endian)敲开还是从小头(Little-endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。</p>
<p>第一个字节在前，就是”大头方式”（Big endian），第二个字节在前就是”小头方式”（Little endian）。</p>
<p>那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？</p>
<p>Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用<code>FEFF</code>表示。这正好是两个字节，而且<code>FF</code>比<code>FE</code>大<code>1</code>。</p>
<p>如果一个文本文件的头两个字节是<code>FE FF</code>，就表示该文件采用大头方式；如果头两个字节是<code>FF FE</code>，就表示该文件采用小头方式。</p>
</blockquote>
<h2 id="7-延伸阅读"><a href="#7-延伸阅读" class="headerlink" title="7.延伸阅读"></a>7.延伸阅读</h2><blockquote>
<p><a href="http://www.joelonsoftware.com/articles/Unicode.html">http://www.joelonsoftware.com/articles/Unicode.html</a></p>
<p><a href="https://www.pconline.com.cn/pcedu/empolder/gj/other/0505/616631.html">https://www.pconline.com.cn/pcedu/empolder/gj/other/0505/616631.html</a></p>
<p><a href="https://www.ietf.org/rfc/rfc3629.txt">https://www.ietf.org/rfc/rfc3629.txt</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python2—_编码问题</title>
    <url>/2020/04/02/Python2-%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="python2编码问题"><a href="#python2编码问题" class="headerlink" title="python2编码问题"></a>python2编码问题</h2><blockquote>
<p>[Github相关解释][<a href="https://github.com/solomonxie/solomonxie.github.io/issues/24]">https://github.com/solomonxie/solomonxie.github.io/issues/24]</a></p>
<p>[知乎相关解释][<a href="https://zhuanlan.zhihu.com/p/39210353]">https://zhuanlan.zhihu.com/p/39210353]</a></p>
<p>[简书相关解释][<a href="https://www.jianshu.com/p/19c74e76ee0a]">https://www.jianshu.com/p/19c74e76ee0a]</a></p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>最近在调试python2过程中经常出现编码的问题，尤其是将python3程序重构为python2程序过程中出现的问题。</p>
<p>问题一：编码本身有什么不同</p>
<ul>
<li>这在字符编码.md文件中已经有了清晰的解释</li>
</ul>
<p>问题二：python2处理中文时为什么总是会出现乱码</p>
<ul>
<li>encode与decode两者需要明确区分</li>
<li>对应的字符与字节也需要区分</li>
</ul>
<p>带着以上两个问题看到了相关的解释，特记录如下：</p>
</blockquote>
<!-- more -->

<h2 id="1-字符与字节问题"><a href="#1-字符与字节问题" class="headerlink" title="1.字符与字节问题"></a>1.字符与字节问题</h2><blockquote>
<p>字符与字节之间并不是同等地位。</p>
<p><strong>字符串：</strong>由字符组成的序列</p>
<p><strong>字符：</strong>字符是<strong>人</strong>使用的符号，是一种人所认知的单位。例如：“中” ， “1” ，“￥”等等</p>
<blockquote>
<ul>
<li><p>在python3中，str对象中获取的元素是<strong>Unicode字符</strong> </p>
</li>
<li><p>在python2中，str对象中获取的原始<strong>字节序列</strong></p>
</li>
</ul>
<p>可以看到同样是str对象，python2中其实是字节，python3中是字符</p>
</blockquote>
<p><strong>字节：</strong>字节是<strong>计算机</strong>所使用的符号，是8位的二进制数字。例如 0x01,01010101,0b45</p>
</blockquote>
<p><strong>不同编码体制中，字符与字节拥有着不同的对应关系：</strong></p>
<ol>
<li><p><strong>ASCII码：</strong>  一个英文字母（不分大小写）占一个字节的空间，<strong>一个中文汉字占两个字节</strong>的空间。一个<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLPANWnW01uH6suhf3nWmk0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPjRYPjnvPH63nHmLnWRvPHcd">二进制数字</a>序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值0，最大值255。</p>
</li>
<li><p><strong>UTF-8：</strong>一个英文字符=一个字节，一个中文（含繁体）=三个字节。</p>
<blockquote>
<p>已知UTF-8编码是UNICODE编码的实现形式的一种，Unicode规定了世界上所有的符号与二进制的对应关系，但是其实现形式多种多样，比如UTF-8,UTF-16等等。</p>
<p><strong>Unicode才是真正的（人）字符串，而用ASCII、UTF-8、GBK等字符编码表示的是字节串。</strong></p>
<blockquote>
<p>从这个角度理解unicode就是CAMEO，utf-8就是VerbDic.</p>
</blockquote>
</blockquote>
</li>
</ol>
<h2 id="2-encode与decode"><a href="#2-encode与decode" class="headerlink" title="2.encode与decode"></a>2.encode与decode</h2><blockquote>
<p>encode与decode分别对应</p>
<p><strong>encode:</strong> 将人类可识别的字符转换为机器可识别的字节码，<strong>字符到字节的过程</strong>。</p>
<p><strong>decode:**就是将机器可识别的字节码转换成人类可识别的字符，</strong>字节到字符的过程**。</p>
</blockquote>
<h2 id="3-python中的默认编码"><a href="#3-python中的默认编码" class="headerlink" title="3.python中的默认编码"></a>3.python中的默认编码</h2><h3 id="3-1-Python源代码的执行过程"><a href="#3-1-Python源代码的执行过程" class="headerlink" title="3.1 Python源代码的执行过程"></a>3.1 Python源代码的执行过程</h3><blockquote>
<p>我们都知道，磁盘上的文件都是以二进制格式存放的，其中文本文件都是以某种特定编码的字节形式存放的。对于程序源代码文件的字符编码是由编辑器指定的，比如我们使用Pycharm来编写Python程序时会指定工程编码和文件编码为UTF-8，那么Python代码被<strong>保存到磁盘</strong>时就会被转换为UTF-8编码对应的字节（<strong>encode过程</strong>）后写入磁盘。</p>
<p>当执行Python代码文件中的代码时，Python解释器在读取Python代码文件中的字节串之后，需要将其转换为Unicode字符串（decode过程）之后才执行后续操作。</p>

</blockquote>
<h3 id="3-2默认编码"><a href="#3-2默认编码" class="headerlink" title="3.2默认编码"></a>3.2默认编码</h3><blockquote>
<p>如果我们没有在代码文件指定字符编码，Python解释器会使用哪种字符编码把从代码文件中读取到的字节转换为Unicode字符串呢？就像我们配置某些软件时，有很多默认选项一样，需要在Python解释器内部设置默认的字符编码来解决这个问题，这就是“默认编码”。</p>
<p>Python2和Python3的解释器使用的默认编码是不一样的，我们可以通过sys.getdefaultencoding()来获取默认编码：</p>
<ul>
<li><strong>Python2:ascii</strong></li>
<li><strong>Python3:utf-8</strong></li>
</ul>
</blockquote>
<h3 id="3-3-python2与python3处理文件"><a href="#3-3-python2与python3处理文件" class="headerlink" title="3.3 python2与python3处理文件"></a>3.3 python2与python3处理文件</h3><blockquote>
<p>对于Python2来讲，Python解释器在读取到中文字符的字节码时，会先查看当前代码文件头部是否指明字符编码是什么。如果没有指定，则使用默认字符编码”ASCII”进行解码，导致中文字符解码失败，出现如下错误</p>
<blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">SyntaxError:Non-ASCII character <span class="string">&#x27;\xc4&#x27;</span> <span class="keyword">in</span> file xxx.py <span class="keyword">on</span> line <span class="number">11</span>, but no encoding declared;</span><br><span class="line">see http:<span class="comment">//python.org/dev/peps/pep-0263/ for details</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>对于Python3来讲，执行过程是一样的，只是Python3的解释器以”UTF-8”作为默认编码，但是这并不表示可以完全兼容中文问题。比如我们在Windows上进行开发时，Python工程及代码文件都使用的是默认的GBK编码，也就是说Python代码文件是被转换成GBK格式的字节码保存到磁盘中的。Python3的解释器执行该代码文件时，试图用UTF-8进行解码操作时，同样会解码失败，出现如下错误：</p>
<blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">SyntaxError:Non-UTF<span class="number">-8</span> code starting <span class="keyword">with</span> <span class="string">&#x27;\xc4&#x27;</span> <span class="keyword">in</span> file xx.py <span class="keyword">on</span> line <span class="number">11</span>, but no encodingdeclared; </span><br><span class="line">see http:<span class="comment">//python.org/dev/peps/pep-0263/ for details</span></span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h2 id="4-Python2-Python3对字符串的支持"><a href="#4-Python2-Python3对字符串的支持" class="headerlink" title="4. Python2 Python3对字符串的支持"></a>4. Python2 Python3对字符串的支持</h2><h3 id="4-1-Python2"><a href="#4-1-Python2" class="headerlink" title="4.1 Python2"></a>4.1 Python2</h3><blockquote>
<p>Python2中对字符串的支持由以下三个类别提供：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">basestring</span></span>(<span class="keyword">object</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">str</span></span>(basestring)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unicode</span></span>(basestring)</span><br></pre></td></tr></table></figure>

<p>其中basestring类是str类与unicode类的父类。</p>
<ul>
<li><p><strong>str其实是字节串</strong>，它是unicode经过编码后的字节组成的序列。</p>
<blockquote>
<p>对UTF-8编码的str’汉’使用len()函数时，结果是3，因为UTF-8编码的’汉’==’\xE6\xB1\x89’。</p>
</blockquote>
</li>
<li><p><strong>unicode才是真正意义上的字符串</strong>，对字节串str使用正确的字符编码进行解码后获得，并且len(u’汉’)==1。</p>
</li>
</ul>
</blockquote>
<h3 id="4-2-Python3"><a href="#4-2-Python3" class="headerlink" title="4.2 Python3"></a>4.2 Python3</h3><blockquote>
<p>Python3中对字符串的支持进行了实现类层次的上简化，去掉了unicode类，添加了一个bytes类。从表面上来看，可认为Python3中的str和unicode合二为一了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bytes</span></span>(<span class="keyword">object</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">str</span></span>(<span class="keyword">object</span>)</span><br></pre></td></tr></table></figure>

<p>实际上，<strong>Python3中已经意识到之前的错误，开始明确区分字符串与字节</strong>。</p>
<p><strong>因此Python3中的str已经是真正的字符串，而字节是用单独的bytes类来表示。</strong></p>
<p>也就是说，Python3默认定义的就是字符串，实现了对Unicode的内置支持，减轻了程序员对字符串处理的负担。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*- </span></span><br><span class="line">a = <span class="string">&#x27;你好&#x27;</span></span><br><span class="line">b = <span class="string">u&#x27;你好&#x27;</span></span><br><span class="line">c = <span class="string">&#x27;你好&#x27;</span>.encode(<span class="string">&#x27;gbk&#x27;</span>) </span><br><span class="line">print(<span class="built_in">type</span>(a),<span class="built_in">len</span>(a))         <span class="comment"># output:&lt;class&#x27;str&#x27;&gt; 2</span></span><br><span class="line">print(<span class="built_in">type</span>(b),<span class="built_in">len</span>(b))         <span class="comment"># output:&lt;class&#x27;str&#x27;&gt; 2</span></span><br><span class="line">print(<span class="built_in">type</span>(c),<span class="built_in">len</span>(c))         <span class="comment"># output:&lt;class&#x27;bytes&#x27;&gt; 4</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="4-3-字符与字节转换"><a href="#4-3-字符与字节转换" class="headerlink" title="4.3 字符与字节转换"></a>4.3 字符与字节转换</h3><blockquote>
<p>4.3的名称我自己起的，合不合适的我们再看</p>
</blockquote>
<ul>
<li><p><strong>单个字符的encode：</strong></p>
<blockquote>
<p>Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="number">65</span></span><br><span class="line">&gt;&gt;&gt; ord(<span class="string">&#x27;中&#x27;</span>)</span><br><span class="line"><span class="number">20013</span></span><br><span class="line">&gt;&gt;&gt; chr(<span class="number">97</span>)</span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line">&gt;&gt;&gt; chr(<span class="number">20013</span>)</span><br><span class="line"><span class="string">&#x27;中&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果知道字符的整数编码，还可以用十六进制这么写字符：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="string">&#x27;\u4e2d\u6587&#x27;</span></span><br><span class="line"><span class="string">&#x27;中文&#x27;</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p><strong>字符.encode() = 字节</strong></p>
<blockquote>
<p>Python3的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。</p>
<p>Python对bytes类型的数据用带b前缀的单引号或双引号表示：x = b’ABC’。</p>
<p>要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。</p>
<p>以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="string">&#x27;ABC&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">b<span class="string">&#x27;ABC&#x27;</span></span><br><span class="line">&gt;&gt;&gt; <span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">b<span class="string">&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span></span><br><span class="line">&gt;&gt;&gt; <span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="symbol">UnicodeEncodeError:</span> <span class="string">&#x27;ascii&#x27;</span> codec can<span class="string">&#x27;t encode characters in position 0-1: ordinal not in range(128)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>常见的中文报错问题愿意：</p>
<p>纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。<strong>中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。</strong></p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>字节.decode() = 字符：</strong></p>
<blockquote>
<p>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b<span class="string">&#x27;ABC&#x27;</span>.decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;ABC&#x27;</span></span><br><span class="line">&gt;&gt;&gt; b<span class="string">&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;中文&#x27;</span></span><br></pre></td></tr></table></figure>

<p>要计算str包含多少个字符，可以用len()函数：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; len(<span class="string">&#x27;ABC&#x27;</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt; len(<span class="string">&#x27;中文&#x27;</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>en()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; len(b<span class="string">&#x27;ABC&#x27;</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt; len(b<span class="string">&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line">&gt;&gt;&gt; len(<span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="5-Python2-Python3字符编码的转换"><a href="#5-Python2-Python3字符编码的转换" class="headerlink" title="5.Python2 Python3字符编码的转换"></a>5.Python2 Python3字符编码的转换</h2><p>Unicode字符串可以与任意字符编码的字节串进行相互转换：</p>


</li>
</ul>
<blockquote>
<p>从上图可以看出不同字节编码之间是可以通过Unicode来实现相互转换的。</p>
<ul>
<li><p>Python2中的字符串进行字符编码转换过程是：</p>
<p><strong>字节串(Python2的str默认是字节串)–&gt;decode(‘原来的字符编码’)–&gt;Unicode字符串–&gt;encode(‘新的字符编码’)–&gt;字节串</strong></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python2</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*- </span></span><br><span class="line">utf_8_a = <span class="string">&#x27;我爱中国&#x27;</span></span><br><span class="line">gbk_a = utf_8_a.decode(<span class="string">&#x27;utf-8&#x27;</span>).encode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(gbk_a.decode(<span class="string">&#x27;gbk&#x27;</span>))</span><br><span class="line"><span class="comment"># 输出结果：我爱中国</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Python3中定义的字符串默认就是unicode，因此不需要先解码，可以直接编码成新的字符编码：</p>
<p><strong>字符串(str就是Unicode字符串)–&gt;encode(‘新的字符编码’)–&gt;字节串</strong></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*- </span></span><br><span class="line">utf_8_b = <span class="string">&#x27;我爱中国&#x27;</span></span><br><span class="line">gbk_b = utf_8_b.encode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(gbk_b.decode(<span class="string">&#x27;gbk&#x27;</span>))</span><br><span class="line"><span class="comment"># 输出结果：我爱中国</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="6-Python2-中乱码问题的解决方案"><a href="#6-Python2-中乱码问题的解决方案" class="headerlink" title="6.Python2 中乱码问题的解决方案"></a>6.Python2 中乱码问题的解决方案</h2><h3 id="6-1-不要相信Print-结果"><a href="#6-1-不要相信Print-结果" class="headerlink" title="6.1 不要相信Print()结果"></a>6.1 不要相信Print()结果</h3><blockquote>
<p>print()函数本身是加工后给<strong>人</strong>看的,不管给它什么样子的编码格式文件，都可以打印出来。</p>
<p><strong>这也就意味着print()，并没有展示变量的本质。</strong></p>
<p>可以选择 jupyter中</p>
<blockquote>
<p>这里是<strong>Python2</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>chinese = <span class="string">&#x27;中文&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chinese </span><br><span class="line"><span class="string">&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="6-2-Python2中“字符串”两大阵容"><a href="#6-2-Python2中“字符串”两大阵容" class="headerlink" title="6.2 Python2中“字符串”两大阵容"></a>6.2 Python2中“字符串”两大阵容</h3><blockquote>
<p>unicode和str</p>
<p>如果<code>type(字符串)</code>显示结果是<code>str</code>，其实指的是<code>bytes</code>字节码。</p>
<blockquote>
<p>由上面的内容我们已经理解当前python2中str对象与unicode对象分别代表：字节与字符</p>
</blockquote>
</blockquote>
<ul>
<li><p>encoding与decoding</p>
<p>从<code>unicode</code>转换到<code>str</code>，这个叫<code>encoding</code>，编码。<br>从<code>str</code>转换到<code>unicode</code>，这个叫<code>decoding</code>，解码。</p>



</li>
</ul>
<ul>
<li><p>案例</p>
<blockquote>
<p>Python2</p>
</blockquote>
  




</li>
</ul>
<h3 id="6-3-具体统一方案"><a href="#6-3-具体统一方案" class="headerlink" title="6.3 具体统一方案"></a>6.3 具体统一方案</h3><blockquote>
<p>见[剩余内容][<a href="https://segmentfault.com/a/1190000013202801]">https://segmentfault.com/a/1190000013202801]</a></p>
<p>这里的统一方案无非就是按照字符处理文件还是按照字节处理文件，何时进行decode何时encode的问题。</p>
<p>做个给出了一个方案，但我目前并没有采用，这里不详细写</p>
</blockquote>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python包管理之setup()函数详解</title>
    <url>/2020/04/02/Python%E5%8C%85%E7%AE%A1%E7%90%86-setup%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Python包管理-setup-详解"><a href="#Python包管理-setup-详解" class="headerlink" title="Python包管理.setup()详解"></a>Python包管理.setup()详解</h1><blockquote>
<p>[PythonPackageGuide][<a href="https://packaging.python.org/guides/distributing-packages-using-setuptools/]">https://packaging.python.org/guides/distributing-packages-using-setuptools/]</a></p>
<p>[Python包样例][<a href="https://github.com/pypa/sampleproject]">https://github.com/pypa/sampleproject]</a></p>
<p>[子包、数据文件与依赖包参数情况][[<a href="http://www.wbh-doc.com.s3.amazonaws.com/Python-OpenSource-Project-Developer-Guide/appendix%20-%20setup%20script.html]">http://www.wbh-doc.com.s3.amazonaws.com/Python-OpenSource-Project-Developer-Guide/appendix%20-%20setup%20script.html]</a></p>
</blockquote>
<h2 id="1-Setup-Args"><a href="#1-Setup-Args" class="headerlink" title="1. Setup() Args"></a>1. Setup() Args</h2><blockquote>
<p>参数详解</p>
</blockquote>
<h3 id="1-1-name"><a href="#1-1-name" class="headerlink" title="1.1 name"></a>1.1 name</h3><ul>
<li><p>项目名称</p>
<ul>
<li><p>命名规范：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Consist only of ASCII letters, digits, underscores (_), hyphens (-), and/or periods (.), and</span><br><span class="line"></span><br><span class="line">Start &amp; end with an ASCII letter or digit.</span><br></pre></td></tr></table></figure></li>
<li><p>PS：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Comparison of project names is case insensitive and treats arbitrarily-long runs of underscores, hyphens, and/or periods as equal.</span><br></pre></td></tr></table></figure>
<ol>
<li><p>大小写 不敏感</p>
</li>
<li><p>上述特殊符号（下划线、连字符、_、-、.）任意数量一致对待</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#以下名称等价</span><br><span class="line">Cool-Stuff</span><br><span class="line">cool.stuff</span><br><span class="line">COOL_STUFF</span><br><span class="line">CoOl__-.-__sTuFF</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-version"><a href="#1-2-version" class="headerlink" title="1.2 version"></a>1.2 version</h3></li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>版本号，version = “1.1.0”</p>
<p>[版本框架选择][<a href="https://packaging.python.org/guides/distributing-packages-using-setuptools/#choosing-a-versioning-scheme]">https://packaging.python.org/guides/distributing-packages-using-setuptools/#choosing-a-versioning-scheme]</a></p>
</blockquote>
<h3 id="1-3-description"><a href="#1-3-description" class="headerlink" title="1.3 description"></a>1.3 description</h3><blockquote>
<p>具体包含三个参数</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">description=&#x27;A sample Python project&#x27;,</span><br><span class="line">long_description=long_description,</span><br><span class="line">long_description_content_type=&#x27;text/x-rst&#x27;,</span><br></pre></td></tr></table></figure>
<ul>
<li>描述信息会在PyPI相关位置显示</li>
<li>long_description_content_type参数可选：<ol>
<li>text/plain    没有格式</li>
<li>text/x-rst    reST格式 </li>
<li>text/markdown     markdown格式</li>
</ol>
</li>
</ul>
<h3 id="1-4-url"><a href="#1-4-url" class="headerlink" title="1.4 url"></a>1.4 url</h3><blockquote>
<p>主页地址</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url&#x3D;&#39;https:&#x2F;&#x2F;github.com&#x2F;pypa&#x2F;sampleproject&#39;,</span><br></pre></td></tr></table></figure>
<h3 id="1-5-author"><a href="#1-5-author" class="headerlink" title="1.5 author"></a>1.5 author</h3><blockquote>
<p>提供作者信息</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">author=&#x27;The Python Packaging Authority&#x27;,</span><br><span class="line">author_email=&#x27;pypa-dev@googlegroups.com&#x27;,</span><br></pre></td></tr></table></figure>
<h3 id="1-6-license"><a href="#1-6-license" class="headerlink" title="1.6 license"></a>1.6 license</h3><blockquote>
<p>表明发布遵循的协议</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">license=&#x27;MIT&#x27;,</span><br></pre></td></tr></table></figure>
<ol>
<li>此字段不需要表明发布的协议</li>
<li>若采用标准协议则采用：classifiers字段</li>
<li>license字段通常用于指定与常用协议差异的部分，故此字段不常用</li>
</ol>
<h3 id="1-7-classifier"><a href="#1-7-classifier" class="headerlink" title="1.7 classifier"></a>1.7 classifier</h3><blockquote>
<p>按照内部成分对项目进行分类</p>
<p>[分类详细文档][<a href="https://pypi.org/classifiers/]">https://pypi.org/classifiers/]</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">classifiers=[</span><br><span class="line">    <span class="comment"># How mature is this project? Common values are</span></span><br><span class="line">    <span class="comment">#   3 - Alpha</span></span><br><span class="line">    <span class="comment">#   4 - Beta</span></span><br><span class="line">    <span class="comment">#   5 - Production/Stable</span></span><br><span class="line">    <span class="string">&#x27;Development Status :: 3 - Alpha&#x27;</span>,</span><br><span class="line">    <span class="comment"># Indicate who your project is intended for</span></span><br><span class="line">    <span class="string">&#x27;Intended Audience :: Developers&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Topic :: Software Development :: Build Tools&#x27;</span>,</span><br><span class="line">    <span class="comment"># Pick your license as you wish (should match &quot;license&quot; above)</span></span><br><span class="line">     <span class="string">&#x27;License :: OSI Approved :: MIT License&#x27;</span>,</span><br><span class="line">    <span class="comment"># Specify the Python versions you support here. In particular, ensure</span></span><br><span class="line">    <span class="comment"># that you indicate whether you support Python 2, Python 3 or both.</span></span><br><span class="line">    <span class="string">&#x27;Programming Language :: Python :: 2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Programming Language :: Python :: 2.6&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Programming Language :: Python :: 2.7&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Programming Language :: Python :: 3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Programming Language :: Python :: 3.2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Programming Language :: Python :: 3.3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Programming Language :: Python :: 3.4&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ol>
<li>上面内容可以看到，这里可以指定Python版本，但其并不能用于限制Python版本。只能用于在PyPI上面浏览时显示，版本限制需要用 python_requires 参数指定。</li>
</ol>
<h3 id="1-8-keywords"><a href="#1-8-keywords" class="headerlink" title="1.8 keywords"></a>1.8 keywords</h3><blockquote>
<p>列出项目关键字</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keywords=<span class="string">&#x27;sample setuptools development&#x27;</span>,</span><br></pre></td></tr></table></figure>
<h3 id="1-9-project-urls"><a href="#1-9-project-urls" class="headerlink" title="1.9 project_urls"></a>1.9 project_urls</h3><blockquote>
<p>列出相关url地址</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">project_urls=&#123;</span><br><span class="line">    <span class="string">&#x27;Documentation&#x27;</span>: <span class="string">&#x27;https://packaging.python.org/tutorials/distributing-packages/&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Funding&#x27;</span>: <span class="string">&#x27;https://donate.pypi.org&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Say Thanks!&#x27;</span>: <span class="string">&#x27;http://saythanks.io/to/example&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Source&#x27;</span>: <span class="string">&#x27;https://github.com/pypa/sampleproject/&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Tracker&#x27;</span>: <span class="string">&#x27;https://github.com/pypa/sampleproject/issues&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1-10-packages"><a href="#1-10-packages" class="headerlink" title="1.10 packages"></a>1.10 packages</h3><blockquote>
<p>设置项目中采用的所有包，包含其子包</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">packages=find_packages(include=[<span class="string">&#x27;sample&#x27;</span>, <span class="string">&#x27;sample.*&#x27;</span>]),</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>可手动指定</li>
<li>可利用setuptools.find_packages()自动寻找<ul>
<li>其方法可使用include字段找到指定的位置</li>
<li>其方法可使用exclude字段排除指定的位置</li>
</ul>
</li>
</ul>
<h3 id="1-11-py-modules"><a href="#1-11-py-modules" class="headerlink" title="1.11 py_modules"></a>1.11 py_modules</h3><blockquote>
<p>用于指定非包内的模块</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">py_modules=[<span class="string">&quot;six&quot;</span>],</span><br></pre></td></tr></table></figure>
<h3 id="1-12-install-requires"><a href="#1-12-install-requires" class="headerlink" title="1.12 install_requires"></a>1.12 install_requires</h3><blockquote>
<p>指定项目启动所需要的依赖</p>
<p>[install_requiresVSrequirements files][<a href="https://packaging.python.org/discussions/install-requires-vs-requirements/#install-requires-vs-requirements-files]">https://packaging.python.org/discussions/install-requires-vs-requirements/#install-requires-vs-requirements-files]</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">install_requires=[<span class="string">&#x27;peppercorn&#x27;</span>],</span><br></pre></td></tr></table></figure>
<h3 id="1-13-python-requires"><a href="#1-13-python-requires" class="headerlink" title="1.13 python_requires"></a>1.13 python_requires</h3><blockquote>
<p>指定可运行Python的版本</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#if your package is for Python 3+ only, write:</span></span><br><span class="line">python_requires=<span class="string">&#x27;&gt;=3&#x27;</span>,</span><br><span class="line"><span class="comment">#If your package is for Python 3.3 and up but you’re not willing to commit to Python 4 support yet, write:</span></span><br><span class="line">python_requires=<span class="string">&#x27;~=3.3&#x27;</span>,</span><br><span class="line"><span class="comment">#If your package is for Python 2.6, 2.7, and all versions of Python 3 starting with 3.3, write:</span></span><br><span class="line">python_requires=<span class="string">&#x27;&gt;=2.6, !=3.0.*, !=3.1.*, !=3.2.*, &lt;4&#x27;</span>,</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1-14-package-data"><a href="#1-14-package-data" class="headerlink" title="1.14 package_data"></a>1.14 package_data</h3><blockquote>
<p>指定包数据文件，包数据文件指不在包内的与项目相关的数据文件。比如字典。</p>
<p>[包文件详解][<a href="https://setuptools.readthedocs.io/en/latest/setuptools.html#including-data-files]">https://setuptools.readthedocs.io/en/latest/setuptools.html#including-data-files]</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">package_data=&#123;</span><br><span class="line">    <span class="string">&#x27;sample&#x27;</span>: [<span class="string">&#x27;package_data.dat&#x27;</span>],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="1-15-data-files"><a href="#1-15-data-files" class="headerlink" title="1.15 data_files"></a>1.15 data_files</h3><blockquote>
<p>data_files也用于指定文件，但是同package_data不同的是其用于指定<strong>不在包内</strong>的数据文件。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_files=[(<span class="string">&#x27;my_data&#x27;</span>, [<span class="string">&#x27;data/data_file&#x27;</span>])],</span><br></pre></td></tr></table></figure>
<ul>
<li>采用<code>(directory, files)</code>的形式指定文件。<ul>
<li>directory 采用相对地址[详解][<a href="https://docs.python.org/3/distutils/setupscript.html#installing-additional-files]">https://docs.python.org/3/distutils/setupscript.html#installing-additional-files]</a></li>
</ul>
</li>
</ul>
<h3 id="1-16-scripts"><a href="#1-16-scripts" class="headerlink" title="1.16 scripts"></a>1.16 scripts</h3><blockquote>
<p>用于指定安装的脚本，但目前并不推荐使用</p>
</blockquote>
<h3 id="1-17-entry-points"><a href="#1-17-entry-points" class="headerlink" title="1.17 entry_points"></a>1.17 entry_points</h3><blockquote>
<p>Use this keyword to specify any plugins that your project provides for any named entry points that may be defined by your project or others that you depend on..</p>
<p>没看懂</p>
<p>[文档详解][<a href="https://setuptools.readthedocs.io/en/latest/setuptools.html#dynamic-discovery-of-services-and-plugins]">https://setuptools.readthedocs.io/en/latest/setuptools.html#dynamic-discovery-of-services-and-plugins]</a></p>
<blockquote>
<p>官方文档没看懂，可以看[博客][<a href="http://blog.luoyuanhang.com/2016/03/25/Python-%E5%88%86%E5%8F%91%E5%B7%A5%E5%85%B7%E5%88%9D%E6%8E%A2%E4%B9%8B-setuptools-%E8%BF%9B%E9%98%B6/">http://blog.luoyuanhang.com/2016/03/25/Python-%E5%88%86%E5%8F%91%E5%B7%A5%E5%85%B7%E5%88%9D%E6%8E%A2%E4%B9%8B-setuptools-%E8%BF%9B%E9%98%B6/</a></p>
<p>entry_points 是一个字典，从entry point组名映射道一个表示entry point的字符串或字符串列表。Entry points是用来支持动态发现服务和插件的，也用来支持自动生成脚本。</p>
</blockquote>
</blockquote>
<h3 id="1-18-console-scripts"><a href="#1-18-console-scripts" class="headerlink" title="1.18 console_scripts"></a>1.18 console_scripts</h3><blockquote>
<p>entry_points内部参数，用于生成脚本文件<br>用于在系统路径下生成可执行脚本。</p>
<p>[官方文档详解][<a href="https://setuptools.readthedocs.io/en/latest/setuptools.html#automatic-script-creation]">https://setuptools.readthedocs.io/en/latest/setuptools.html#automatic-script-creation]</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">entry_points=&#123;</span><br><span class="line">    <span class="string">&#x27;console_scripts&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;sample=sample:main&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python包管理_实例操作</title>
    <url>/2020/04/02/Python%E5%8C%85%E7%AE%A1%E7%90%86-%E5%AE%9E%E4%BE%8B%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="Python包管理——简单案例"><a href="#Python包管理——简单案例" class="headerlink" title="Python包管理——简单案例"></a>Python包管理——简单案例</h1><blockquote>
<p>[Python packaging User Guide][<a href="https://packaging.python.org/tutorials/packaging-projects/]">https://packaging.python.org/tutorials/packaging-projects/]</a></p>
</blockquote>
<h2 id="1-创建简单项目"><a href="#1-创建简单项目" class="headerlink" title="1. 创建简单项目"></a>1. 创建简单项目</h2><ul>
<li><p>项目结构</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 可在D盘文件目录下查看</span><br><span class="line">packaging_tutorial/</span><br><span class="line">  example_pkg/</span><br><span class="line">    __init__.py</span><br></pre></td></tr></table></figure>
<ol>
<li>根目录：packaging_tutorial</li>
<li>包：example_pkg</li>
<li>包文件标识：__init__.py</li>
</ol>
</li>
</ul>
 <a id="more"></a> 

<h2 id="2-创建打包文件"><a href="#2-创建打包文件" class="headerlink" title="2. 创建打包文件"></a>2. 创建打包文件</h2><ul>
<li><p>结果项目结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">packaging_tutorial&#x2F;</span><br><span class="line">  example_pkg&#x2F;</span><br><span class="line">    __init__.py</span><br><span class="line">  setup.py</span><br><span class="line">  LICENSE</span><br><span class="line">  README.md</span><br></pre></td></tr></table></figure>
<ul>
<li><p>新增文件</p>
<blockquote>
<p>均位于主目录下</p>
</blockquote>
<ol>
<li><p>setup.py</p>
</li>
<li><p>LICENCE</p>
</li>
<li><p>README.MD</p>
<blockquote>
<p>非必须</p>
</blockquote>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="2-1-setup-py-文件简单编写"><a href="#2-1-setup-py-文件简单编写" class="headerlink" title="2.1 setup.py 文件简单编写"></a>2.1 setup.py 文件简单编写</h3><blockquote>
<p>此文件是打包的核心文件，用于告知setuptools包信息</p>
</blockquote>
<ul>
<li><p>此文档的编写示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> setuptools</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;README.md&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> fh:</span><br><span class="line">    long_description = fh.read()</span><br><span class="line"></span><br><span class="line">setuptools.setup(</span><br><span class="line">    name=<span class="string">&quot;example-pkg-HowardSun&quot;</span>, <span class="comment"># Replace with your own username</span></span><br><span class="line">    version=<span class="string">&quot;0.0.1&quot;</span>,</span><br><span class="line">    author=<span class="string">&quot;HowardSun&quot;</span>,</span><br><span class="line">    author_email=<span class="string">&quot;sun2387353@163.com&quot;</span>,</span><br><span class="line">    description=<span class="string">&quot;A small example package&quot;</span>,</span><br><span class="line">    long_description=long_description,</span><br><span class="line">    long_description_content_type=<span class="string">&quot;text/markdown&quot;</span>,</span><br><span class="line">    url=<span class="string">&quot;https://github.com/pypa/sampleproject&quot;</span>,</span><br><span class="line">    packages=setuptools.find_packages(),</span><br><span class="line">    classifiers=[</span><br><span class="line">        <span class="string">&quot;Programming Language :: Python :: 3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;License :: OSI Approved :: MIT License&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Operating System :: OS Independent&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    python_requires=<span class="string">&#x27;&gt;=3.6&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>name:发布的包名称，需要保证与他人发布包名无冲突。命名规则：字母、数字，-，_</p>
</li>
<li><p>version:版本号</p>
</li>
<li><p>author:作者</p>
</li>
<li><p>author_email：作者邮箱地址</p>
</li>
<li><p>long_description:发布包详细描述，可使用readme.md文件。</p>
</li>
<li><p>url:一般是github\gitlab地址</p>
</li>
<li><p>packages:项目所需要的包，可手动指定或使用find_packages()方式自动补充。</p>
<blockquote>
<p>此packages字段比较复杂，可以专门详解</p>
</blockquote>
</li>
<li><p>classifiers:添加包相关元信息</p>
<blockquote>
<p>[官方详解][<a href="https://pypi.org/classifiers/]%EF%BC%8C%E8%99%BD%E7%84%B6%E5%B9%B6%E6%9C%AA%E7%A0%94%E7%A9%B6%EF%BC%8C%E4%BD%86%E7%9C%8B%E6%9D%A5%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81">https://pypi.org/classifiers/]，虽然并未研究，但看来比较重要</a></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-README-md文件编写"><a href="#2-2-README-md文件编写" class="headerlink" title="2.2 README.md文件编写"></a>2.2 README.md文件编写</h3><blockquote>
<p>不解释</p>
</blockquote>
<h3 id="2-3-创建LICENSE文件"><a href="#2-3-创建LICENSE文件" class="headerlink" title="2.3 创建LICENSE文件"></a>2.3 创建LICENSE文件</h3><blockquote>
<p>用于告知用户相关的授权标准</p>
<p>[License官网][<a href="https://choosealicense.com/]">https://choosealicense.com/]</a></p>
</blockquote>
<h2 id="3-创建发布压缩文件"><a href="#3-创建发布压缩文件" class="headerlink" title="3. 创建发布压缩文件"></a>3. 创建发布压缩文件</h2><h3 id="3-1-安装工具包"><a href="#3-1-安装工具包" class="headerlink" title="3.1 安装工具包"></a>3.1 安装工具包</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python -m pip install --user --upgrade setuptools wheel</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-2-运行相关命令"><a href="#3-2-运行相关命令" class="headerlink" title="3.2 运行相关命令"></a>3.2 运行相关命令</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">python setup.py sdist bdist_wheel</span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果</p>
<ol>
<li><p>创建了build文件夹</p>
</li>
<li><p>创建了dist文件夹</p>
<ol>
<li><p>example_pkg_HowardSun-0.0.1-py3-none-any.whl</p>
<blockquote>
<p>发布文件</p>
</blockquote>
</li>
<li><p>example-pkg-HowardSun-0.0.1.tar.gz</p>
<blockquote>
<p>发布包的压缩文件</p>
</blockquote>
</li>
</ol>
</li>
<li><p>创建了example_pkg_HowardSun.egg-info文件夹</p>
</li>
</ol>
<h2 id="4-上传发布文件"><a href="#4-上传发布文件" class="headerlink" title="4.上传发布文件"></a>4.上传发布文件</h2></li>
</ul>
<h3 id="4-1-注册PyPI账号"><a href="#4-1-注册PyPI账号" class="headerlink" title="4.1 注册PyPI账号"></a>4.1 注册PyPI账号</h3><blockquote>
<p>测试中使用的[Test PyPI][ <a href="https://test.pypi.org/account/register/],%E4%B8%8E%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E4%B8%8D%E4%B8%80%E8%87%B4">https://test.pypi.org/account/register/],与正式发布不一致</a></p>
</blockquote>
<h3 id="4-2-安装发布工具包"><a href="#4-2-安装发布工具包" class="headerlink" title="4.2 安装发布工具包"></a>4.2 安装发布工具包</h3><blockquote>
<p>使用twine发布</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">python -m pip install --user --upgrade twine</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-3-运行相关命令"><a href="#4-3-运行相关命令" class="headerlink" title="4.3 运行相关命令"></a>4.3 运行相关命令</h3><blockquote>
<p>需要使用创建账户时创建的APITOKEN信息验证</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">python3 -m twine upload --repository-url https://test.pypi.org/legacy/ dist/*</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-安装新发布的包"><a href="#5-安装新发布的包" class="headerlink" title="5. 安装新发布的包"></a>5. 安装新发布的包</h2><blockquote>
<p>pip安装即可</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">python -m pip install --index-url https://test.pypi.org/simple/ --no-deps example-pkg-HowardSun</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>正常发布到PyPI上并不需要指定url</p>
</blockquote>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python2包管理工具对比</title>
    <url>/2020/04/02/Python%E5%8C%85%E7%AE%A1%E7%90%86-%E5%B7%A5%E5%85%B7%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h1 id="Python包管理"><a href="#Python包管理" class="headerlink" title="Python包管理"></a>Python包管理</h1><blockquote>
<p>参考地址：<a href="https://blog.zengrong.net/post/python_packaging/">Python 包管理工具解惑</a></p>
<blockquote>
<p>参考地址中作者详尽的调研并解释了相关问题，相对于其他博客内容，此篇内容系统性更强，这需要学习。</p>
</blockquote>
</blockquote>
<h2 id="1-疑惑问题"><a href="#1-疑惑问题" class="headerlink" title="1.  疑惑问题"></a>1.  疑惑问题</h2><blockquote>
<p>python 包管理我本身一直未曾仔细研究，处于混沌的状态。目前只知道pip,conda等包管理工具。</p>
</blockquote>
<p>目前存在的问题有：</p>
<ol>
<li><p>如何私有发布自己的模块</p>
</li>
<li><p>如何共有发布模块(发布到PyPI)</p>
</li>
<li><p>各种包管理工具的差异与用法</p>
<ul>
<li><p>distutils</p>
</li>
<li><p>setuptppls</p>
</li>
<li><p>distribute</p>
</li>
<li><p>disutils2</p>
</li>
<li><p>dislib</p>
</li>
<li><p>pip</p>
</li>
</ul>
</li>
<li><p>wheel与Egg的关系</p>
<a id="more"></a>

</li>
</ol>
<h2 id="2-Python包管理工具学习"><a href="#2-Python包管理工具学习" class="headerlink" title="2. Python包管理工具学习"></a>2. Python包管理工具学习</h2><blockquote>
<p>在上述参考文章中对各包管理工具已经有了基本的侧重，故此学习也存在侧重。</p>
</blockquote>
<h3 id="2-1-distutils"><a href="#2-1-distutils" class="headerlink" title="2.1 distutils"></a>2.1 distutils</h3><blockquote>
<p>setuptools是 distutils 的加强版，目前已经自动采用setuptools</p>
</blockquote>
<p><a href="https://docs.python.org/3/library/distutils.html">distutils</a>是python标准库的一部分，能够进行python模块的<a href="https://docs.python.org/3/install/index.html">安装</a>与<a href="https://docs.python.org/3/distutils/index.html">发布</a>。</p>
<ul>
<li><p>setup.py是利用distutils 的功能写成的，<a href="https://docs.python.org/3/distutils/introduction.html?highlight=distutils#a-simple-example">示例</a></p>
<ul>
<li>setup.py格式的详细描述：<a href="https://docs.python.org/3/distutils/setupscript.html">Writing the Setup Script</a></li>
</ul>
</li>
<li><p>常用功能</p>
<ol>
<li><p>安装模块：到当前Python环境中,可以使用此模块提供的setup.py 文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></li>
<li><p>发布模块：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#打包为tar.gz或者zip压缩包</span><br><span class="line">python setup.py sdist</span><br><span class="line">#打包为rpm</span><br><span class="line">python setip.py bdist_rpm</span><br><span class="line">#打包为exe</span><br><span class="line">python setup.py bdist_wininst</span><br></pre></td></tr></table></figure>
<h3 id="2-2-setuptools-和-distribute"><a href="#2-2-setuptools-和-distribute" class="headerlink" title="2.2  setuptools 和 distribute"></a>2.2  setuptools 和 distribute</h3></li>
</ol>
</li>
</ul>
<h4 id="2-2-1-setuptools"><a href="#2-2-1-setuptools" class="headerlink" title="2.2.1 setuptools"></a>2.2.1 setuptools</h4><blockquote>
<p><a href="https://docs.python.org/3/distutils/setupscript.html">setuptools</a>包含了easy_install 这个工具。</p>
</blockquote>
<p>ez_setup.py 是 setuptools的安装工具。ez是easy的简写。</p>
<blockquote>
<p>简单的说，setuptools 是一个项目的名称，是基础组件。而 <code>easy_install</code> 是这个项目中提供的工具，它依赖基础组件工作。</p>
</blockquote>
<p>使用setuptools可以自动下载、构建、安装和管理python模块。</p>
<h3 id="2-2-2-distribute"><a href="#2-2-2-distribute" class="headerlink" title="2.2.2 distribute"></a>2.2.2 distribute</h3><blockquote>
<p>distribute 是setuptools的一个分支版本。</p>
</blockquote>
<h3 id="2-3-distutil2和dislib"><a href="#2-3-distutil2和dislib" class="headerlink" title="2.3 distutil2和dislib"></a>2.3 distutil2和dislib</h3><blockquote>
<p>这两种工具目前并未进入python3的标准库中，不必了解</p>
</blockquote>
<h2 id="3-打包文件格式"><a href="#3-打包文件格式" class="headerlink" title="3.打包文件格式"></a>3.打包文件格式</h2><h3 id="3-1-Eggs"><a href="#3-1-Eggs" class="headerlink" title="3.1 Eggs"></a>3.1 Eggs</h3><blockquote>
<p><a href="http://peak.telecommunity.com/DevCenter/PythonEggs">The Quick Guide to Python Eggs</a></p>
<pre><code>    Eggs are to Pythons as Jars are to Java..</code></pre>
</blockquote>
<p>Eggs格式是setuptools引入的一种文件格式，使用.egg扩展名，用于python模块的安装。</p>
<p>setuptools可以识别、解析并安装它。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">easy_install /my_downloads/OtherPackage-3.2.1-py2.3.egg</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>缺点：</p>
<p><strong>但是</strong>pip目前是python 包管理标准，而且pip 目前已经替代了 easy_install ，即是其很多功能建立在setuptools 组件之上。pip 本身并不希望使用Egg 格式，更希望采用“源码发行版（python setup.py sdist ）”,这样可充分利用 <a href="https://pip.pypa.io/en/latest/reference/pip_install/#requirements-file-format">Requirements File Format</a>提供的功能。</p>
</li>
</ul>
<h3 id="3-2-Wheel"><a href="#3-2-Wheel" class="headerlink" title="3.2 Wheel"></a>3.2 Wheel</h3><p><a href="https://wheel.readthedocs.io/en/stable/">Wheel</a> 本质上是一个zip 包格式，其使用 .whl 扩展名，用于python 模块的安装，它的出现是为了替代 Egg.</p>
<ul>
<li><p>发布包</p>
<p>wheel 还提供一个 bdist_wheel 作为setuptools 的扩展命令， 这个命令可以用来生成 wheel 包。</p>
</li>
<li><p>安装包</p>
<p>pip 提供了一个wheel 子命令来安装wheel 包。</p>
</li>
<li><p>setup.cfg</p>
<p><a href="https://wheel.readthedocs.io/en/latest/#defining-the-python-version">setup.cfg</a>可以用来定义wheel 打包的相关信息</p>
</li>
<li><p>与Egg 的区别</p>
<p><a href="">wheel vs Egg</a></p>
</li>
</ul>
<h2 id="4-发布模块"><a href="#4-发布模块" class="headerlink" title="4.发布模块"></a>4.发布模块</h2><blockquote>
<p>这里纯抄</p>
</blockquote>
<p>对于 python3 程序员来说，当然应该先看这一篇：<a href="https://docs.python.org/3/distributing/index.html">Distributing Python Modules</a>。</p>
<p>另外，<a href="https://packaging.python.org/en/latest/distributing.html">Tutorial on Packaging and Distributing Projects</a> 也足够详细和官方。</p>
<p>而 Python2 程序员则应该看这篇 <a href="https://docs.python.org/2.7/distutils/index.html">Distributing Python Modules</a> 。</p>
<p>当然，setuptools 的官方文档也是不错的教程：<a href="http://pythonhosted.org/setuptools/setuptools.html">Building and Distributing Packages with Setuptools</a> 。</p>
<p>这篇教程可以用来入门：<a href="https://hynek.me/articles/sharing-your-labor-of-love-pypi-quick-and-dirty/">Sharing Your Labor of Love: PyPI Quick and Dirty</a></p>
<p>至于如何发布自己的模块到 PyPI 或者搭建自己的私有包管理服务器，上面的文章已经讲得非常清楚了。</p>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5.结论"></a>5.结论</h2><ul>
<li>发布包采用的工具：setuptools</li>
<li>发布包格式：wheel</li>
</ul>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络基础</title>
    <url>/2020/04/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="神经网络和深度学习"><a href="#神经网络和深度学习" class="headerlink" title="神经网络和深度学习"></a>神经网络和深度学习</h1><blockquote>
<p><a href="https://kyonhuang.top/Andrew-Ng-Deep-Learning-notes/#/Neural_Networks_and_Deep_Learning/">笔记来源</a></p>
</blockquote>
<a id="more"></a>
<h2 id="神经网络基础"><a href="#神经网络基础" class="headerlink" title="神经网络基础"></a>神经网络基础</h2><h3 id="训练集、验证集与测试集"><a href="#训练集、验证集与测试集" class="headerlink" title="训练集、验证集与测试集"></a>训练集、验证集与测试集</h3><blockquote>
<p><a href="https://www.cnblogs.com/HuZihu/p/10538295.html">解释博客</a></p>
</blockquote>
<p>三种集合的关系一直是容易混淆的概念：</p>
<p><strong>训练集（Training Set）</strong>：用于训练模型。</p>
<p><strong>验证集（Validation Set）</strong>：用于调整和选择模型。</p>
<p><strong>测试集（Test Set）</strong>：用于评估最终的模型。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>Logistic回归中损失函数建议采用</li>
</ol>
<p>$$<br>L(\hat{y},y) = -(y\log\hat{y})-(1-y)\log(1-\hat{y})<br>$$</p>
<p>不建议采用平方差函数，存在局部解。<strong>可以去了解</strong></p>
<ol start="2">
<li>样本实例在矩阵中多采用<strong>列向量</strong>表示，也就是说m个由n维特征表示的样本矩阵为[n,m]</li>
</ol>
<ul>
<li>实现一个神经网络时，如果需要遍历整个训练集，并不需要直接使用 for 循环。</li>
<li>神经网络的计算过程中，通常有一个正向过程（forward pass）或者叫<strong>正向传播步骤（forward propagation step）</strong>，接着会有一个反向过程（backward pass）或者叫<strong>反向传播步骤（backward propagation step）</strong>。</li>
</ul>
<h3 id="Logistic回归"><a href="#Logistic回归" class="headerlink" title="Logistic回归"></a>Logistic回归</h3><blockquote>
<p>逻辑回归最简总结：</p>
<ul>
<li>线性回归+sigmoid函数</li>
</ul>
<p>$$<br>z= (w^Tx+b)<br>$$</p>
<p>$$<br>\hat y = \frac{1}{1+e^{-z}}<br>$$</p>
</blockquote>
<p>Logistic 回归是一个用于二分分类的算法。</p>
<p>Logistic 回归中使用的参数如下：</p>
<ul>
<li><p>输入的特征向量：$ x \in R^{n_x}$ , 其中${n_x}$是特征数量；</p>
</li>
<li><p>用于训练的标签：$y \in 0,1$;</p>
</li>
<li><p>权重：$w \in R^{n_x}$</p>
</li>
<li><p>偏置：$b \in R$</p>
</li>
<li><p>输出：$\hat{y} = \sigma(w^Tx+b)$</p>
</li>
<li><p>Sigmoid 函数：</p>
</li>
</ul>
<p>$$<br>  s = \sigma(w^Tx+b) = \sigma(z) = \frac{1}{1+e^{-z}}<br>$$</p>
<p>为了将 $w^Tx+b$  约束在 [0, 1] 间，引入 Sigmoid 函数。从下图可看出，Sigmoid 函数的值域为 [0, 1]。</p>



<p>Logistic 回归可以看作是一个非常小的神经网络。下图是一个典型例子：</p>
<blockquote>
<p>也就是一个普通的神经元</p>
</blockquote>



<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p><strong>损失函数（loss function）</strong>用于衡量预测结果与真实值之间的误差。</p>
<p>最简单的损失函数定义方式为平方差损失：<br>$$<br>L(\hat{y},y) = \frac{1}{2}(\hat{y}-y)^2<br>$$<br>但 Logistic 回归中我们<strong>并不倾向</strong>于使用这样的损失函数，因为之后讨论的优化问题会变成非凸的，最后会得到很多个局部最优解，梯度下降法可能找不到全局最优值。</p>
<p>一般使用<br>$$<br>L(\hat{y},y) = -(y\log\hat{y})-(1-y)\log(1-\hat{y})<br>$$<br>损失函数是在单个训练样本中定义的，它衡量了在<strong>单个</strong>训练样本上的表现。而<strong>代价函数（cost function，或者称作成本函数）</strong>衡量的是在<strong>全体</strong>训练样本上的表现，即衡量参数 w 和 b 的效果。<br>$$<br>J(w,b) = \frac{1}{m}\sum_{i=1}^mL(\hat{y}^{(i)},y^{(i)})<br>$$</p>
<h3 id="梯度下降法（Gradient-Descent）"><a href="#梯度下降法（Gradient-Descent）" class="headerlink" title="梯度下降法（Gradient Descent）"></a>梯度下降法（Gradient Descent）</h3><blockquote>
<p>最简总结：<br>$$<br>w := w - \alpha\frac{dJ(w, b)}{dw}<br>$$</p>
</blockquote>
<p>函数的<strong>梯度（gradient）</strong>指出了函数的最陡增长方向。即是说，按梯度的方向走，函数增长得就越快。那么按梯度的负方向走，函数值自然就降低得最快了。</p>
<p>模型的训练目标即是寻找合适的 w 与 b 以最小化代价函数值。简单起见我们先假设 w 与 b 都是一维实数，那么可以得到如下的 J 关于 w 与 b 的图：</p>



<p>可以看到，成本函数 J 是一个<strong>凸函数</strong>，与非凸函数的区别在于其不含有多个局部最低点；选择这样的代价函数就保证了无论我们初始化模型参数如何，都能够寻找到合适的最优解。</p>
<p>参数 w 的更新公式为：<br>$$<br>w := w - \alpha\frac{dJ(w, b)}{dw}<br>$$<br>其中 α 表示学习速率，即每次更新的 w 的步伐长度。</p>
<p>当 w 大于最优解 w′ 时，导数大于 0，那么 w 就会向更小的方向更新。反之当 w 小于最优解 w′ 时，导数小于 0，那么 w 就会向更大的方向更新。迭代直到收敛。</p>
<p>在成本函数 J(w, b) 中还存在参数 b，因此也有：<br>$$<br>b := b - \alpha\frac{dJ(w, b)}{db}<br>$$</p>
<h3 id="计算图（Computation-Graph）"><a href="#计算图（Computation-Graph）" class="headerlink" title="计算图（Computation Graph）"></a>计算图（Computation Graph）</h3><p>神经网络中的计算即是由多个计算网络输出的前向传播与计算梯度的后向传播构成。所谓的<strong>反向传播（Back Propagation）</strong>即是当我们需要计算最终值相对于某个特征变量的导数时，我们需要利用计算图中上一步的结点定义。</p>
<h3 id="Logistic回归中的梯度下降法"><a href="#Logistic回归中的梯度下降法" class="headerlink" title="Logistic回归中的梯度下降法"></a>Logistic回归中的梯度下降法</h3><p>假设输入的特征向量维度为 2，即输入参数共有 x1, w1, x2, w2, b 这五个。可以推导出如下的计算图：</p>



<p>首先反向求出 L 对于 a 的导数：<br>$$<br>da=\frac{dL(a,y)}{da}=\frac{1-y}{1-a}-\frac{y}{a}<br>$$<br>然后继续反向求出 L 对于 z 的导数：<br>$$<br>dz=\frac{dL}{dz}=\frac{dL(a,y)}{dz}=\frac{dL}{da}\frac{da}{dz}=a-y<br>$$<br>依此类推求出最终的损失函数相较于原始参数的导数之后，根据如下公式进行参数更新：<br>$$<br>w _1:=w _1-\alpha dw _1<br>$$</p>
<p>$$<br>w _2:=w _2-\alpha dw _2<br>$$</p>
<p>$$<br>b:=b-\alpha db<br>$$</p>
<p>接下来我们需要将对于单个用例的损失函数扩展到整个训练集的代价函数：<br>$$<br>J(w,b)=\frac{1}{m}\sum^m_{i=1}L(a^{(i)},y^{(i)})<br>$$<br>其中:<br>$$<br>  a^{(i)}=\hat{y}^{(i)}=\sigma(z^{(i)})=\sigma(w^Tx^{(i)}+b)<br>$$<br>我们可以对于某个权重参数 $w_1$，其导数计算为：<br>$$<br>\frac{\partial J(w,b)}{\partial{w_1}}=\frac{1}{m}\sum^m_{i=1}\frac{\partial L(a^{(i)},y^{(i)})}{\partial{w_1}}<br>$$<br>完整的 Logistic 回归中某次训练的流程如下，这里仅假设特征向量的维度为 2：</p>



<p>然后对 w1、w2、b 进行迭代。</p>
<p>上述过程在计算时有一个缺点：你需要编写两个 for 循环。第一个 for 循环遍历 m 个样本，而第二个 for 循环遍历所有特征。如果有大量特征，在代码中显式使用 for 循环会使算法很低效。<strong>向量化</strong>可以用于解决显式使用 for 循环的问题。</p>
<h3 id="向量化（Vectorization）"><a href="#向量化（Vectorization）" class="headerlink" title="向量化（Vectorization）"></a>向量化（Vectorization）</h3><p>在 Logistic 回归中，需要计算<br>$$<br>z=w^Tx+b<br>$$<br>如果是非向量化的循环方式操作，代码可能如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_x):</span><br><span class="line">    z += w[i] * x[i]</span><br><span class="line">z += b</span><br></pre></td></tr></table></figure>
<p>而如果是向量化的操作，代码则会简洁很多，并带来近百倍的性能提升（并行指令）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = np.dot(w, x) + b</span><br></pre></td></tr></table></figure>
<p>不用显式 for 循环，实现 Logistic 回归的梯度下降一次迭代（对应之前蓝色代码的 for 循环部分。这里公式和 NumPy 的代码混杂，注意分辨）<br>$$<br>Z=w^TX+b=np.dot(w.T, x) + b<br>$$</p>
<p>$$<br> A=\sigma(Z)<br>$$</p>
<p>$$<br> dZ=A-Y<br>$$</p>
<p>$$<br>dw=\frac{1}{m}XdZ^T<br>$$</p>
<p>$$<br> db=\frac{1}{m}np.sum(dZ)<br>$$</p>
<p>$$<br> w:=w-\sigma dw<br>$$</p>
<p>$$<br> b:=b-\sigma db<br>$$</p>
<p>正向和反向传播尽管如此，多次迭代的梯度下降依然需要 for 循环。</p>
<h3 id="广播（broadcasting）"><a href="#广播（broadcasting）" class="headerlink" title="广播（broadcasting）"></a>广播（broadcasting）</h3><p>Numpy 的 Universal functions 中要求输入的数组 shape 是一致的。当数组的 shape 不相等的时候，则会使用广播机制，调整数组使得 shape 一样，满足规则，则可以运算，否则就出错。</p>
<p>四条规则：</p>
<ol>
<li>让所有输入数组都向其中 shape 最长的数组看齐，shape 中不足的部分都通过在前面加 1 补齐；</li>
<li>输出数组的 shape 是输入数组 shape 的各个轴上的最大值；</li>
<li>如果输入数组的某个轴和输出数组的对应轴的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错；</li>
<li>当输入数组的某个轴的长度为 1 时，沿着此轴运算时都用此轴上的第一组值。</li>
</ol>
<h3 id="Numpy-使用技巧"><a href="#Numpy-使用技巧" class="headerlink" title="Numpy 使用技巧"></a>Numpy 使用技巧</h3><p>转置对秩为 1 的数组无效。因此，应该避免使用秩为 1 的数组，用 n * 1 的矩阵代替。例如，用<code>np.random.randn(5,1)</code>代替<code>np.random.randn(5)</code>。</p>
<p>如果得到了一个秩为 1 的数组，可以使用<code>reshape</code>进行转换。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Neural Network</category>
      </categories>
  </entry>
  <entry>
    <title>语言是窗</title>
    <url>/2020/04/03/%E8%AF%AD%E8%A8%80%E6%98%AF%E7%AA%97/</url>
    <content><![CDATA[<p>难得看了一会儿书，这首诗写得很有代入感，故摘抄部分。</p>
<!-- more -- >


## 语言是窗

听了你的话，我仿佛受到审判，

无比委屈，又无从分辨，

那离开前，我想问，

那真的是你的意思吗？



在自我辩护前，

在带着痛苦或恐惧质问前，

在我用言语筑起心灵之墙前，

告诉我，我听明白了吗？

...

如果你以为我想羞辱你，

如果你认定我不在乎你，

请透过我的言语，

倾听我们共有的情感。

]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title>python-爬虫</title>
    <url>/2020/04/05/python-%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h1 id="Python-爬虫"><a href="#Python-爬虫" class="headerlink" title="Python_爬虫"></a>Python_爬虫</h1><p>爬虫对我来说一直是听说过没做过，今天一时兴起将爬虫的课程过了一遍，整理笔记如下。Python中是提供了爬虫库的，但学习中多采用requests库用于理解爬虫的过程。这里仅对老师讲解的部分进行了记录，还有很多未曾接触了，例如动态代理、header模拟浏览器等等针对反爬虫的策略。权当一份框架型笔记即可。</p>
<a id="more"></a>

<blockquote>
<p>[慕课课程][<a href="https://www.icourse163.org/course/BIT-1001870001]">https://www.icourse163.org/course/BIT-1001870001]</a></p>
</blockquote>
<h2 id="爬虫的主要流程"><a href="#爬虫的主要流程" class="headerlink" title="爬虫的主要流程"></a>爬虫的主要流程</h2><ol>
<li>请求获得对应网络信息</li>
<li>解析网络信息</li>
<li>存储需要的网络信息</li>
</ol>
<h2 id="Requests库介绍"><a href="#Requests库介绍" class="headerlink" title="Requests库介绍"></a>Requests库介绍</h2><p>用于爬虫第一步，发送HTTP请求获取对应网络信息。这里仅对Requests库做整体的介绍，具体方法的操作与技巧，可看[官方文档][<a href="https://requests.readthedocs.io/en/master/]%E6%88%96%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99%E3%80%82">https://requests.readthedocs.io/en/master/]或其他相关资料。</a></p>
<h4 id="requests主要方法"><a href="#requests主要方法" class="headerlink" title="requests主要方法"></a>requests主要方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>与HTTP对应</th>
<th>HTTP说明</th>
</tr>
</thead>
<tbody><tr>
<td>requests.request()</td>
<td>基础方法，构造一个请求</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>get()</td>
<td>获取HTML网页内容</td>
<td>GET</td>
<td>获得网页<strong>全内容</strong></td>
</tr>
<tr>
<td>head()</td>
<td>获取HTML网页头信息</td>
<td>HEAD</td>
<td>仅获得网页<strong>头信息</strong></td>
</tr>
<tr>
<td>post()</td>
<td>向HTML网页提交POST请求</td>
<td>POST</td>
<td>在已有资源后<strong>添加</strong>POST资源</td>
</tr>
<tr>
<td>put()</td>
<td>向HTML网页提交PUT请求</td>
<td>PUT</td>
<td>利用PUT资源<strong>替换</strong>原有资源</td>
</tr>
<tr>
<td>patch()</td>
<td>向HTML网页提交PATCH请求</td>
<td>PATCH</td>
<td><strong>局部更新</strong>PATCH指定资源</td>
</tr>
<tr>
<td>delete()</td>
<td>向HTML网页提交DELETE请求</td>
<td>DELETE</td>
<td><strong>删除</strong>资源</td>
</tr>
</tbody></table>
<p>我们可以看到其拥有七个主要方法，并且除基础方法外均一一对应与HTTP定义。除request() 方法外，六个方法均包装了request() 方法，所以上面七个方法本质上均为request() 方法，仅为方便用户使用。</p>
<p>在爬虫应用中，常使用get()或head()方法，其他对于资源修改的方法，反而不常用。</p>
<p>这里需要简单了解HTTP协议，以便更好的理解上述内容。</p>
<h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>HTTP：Hypertext Transfer Protocol , 超文本传输协议，是一种基于”<strong>请求与响应</strong>“,无状态的应用层协议。</p>
<p>理解此协议可以从定义出发：1.<strong>请求与响应</strong>：说明HTTP协议的工作方式为客户端向服务器发送请求，服务器向客户端响应。2.<strong>无状态</strong>：说明HTTP协议前后无关，没有记忆信息。3.<strong>应用层</strong>:高层协议，已经是面向用户的协议了。</p>
<p>HTTP协议通过URL定位资源，通过对应请求（GET\HEAD\PUT…）进行相关操作。对于URL的格式这里不解释。对于请求，HTTP规定了6种请求方式，如图：</p>

<p>各种方法解释，图上都有，这里不详细解释。我们发现与request的请求方法<strong>是一一对应</strong>的。前两种方法用于获取数据，后四种方法用于修改数据。</p>
<h4 id="Request对象与Response对象"><a href="#Request对象与Response对象" class="headerlink" title="Request对象与Response对象"></a>Request对象与Response对象</h4><p>requests库主要包含两个对象，分别是Request与Response,分别对应<strong>发送对象</strong>，<strong>返回对象</strong>。</p>


<h5 id="Response对象属性"><a href="#Response对象属性" class="headerlink" title="Response对象属性"></a>Response对象属性</h5><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r.status_code</td>
<td>HTTP请求的返回状态，<strong>200</strong>表示<strong>连接成功</strong>，<strong>404</strong>表示<strong>失败</strong></td>
</tr>
<tr>
<td>r.text</td>
<td>HTTP相应内容的字符串信息，即URL对应的网页内容</td>
</tr>
<tr>
<td>r.encoding</td>
<td>从HTTPheader中<strong>猜测</strong>的相应内容编码方式</td>
</tr>
<tr>
<td>r.apparent_encoding</td>
<td>从<strong>内容</strong>中<strong>分析</strong>出的响应内容编码方式</td>
</tr>
<tr>
<td>r.content</td>
<td>HTTP响应内容的<strong>二进制</strong>形式</td>
</tr>
</tbody></table>
<p>注意点：</p>
<ol>
<li><p>encoding属性与apparent_encoding的区别</p>
<p>encoding属性是根据HTTP头信息中是否存在charset字典来确定值，但并不是每一个网站设计都会包含此字段，默认为”ISO…”编码格式，其不一定准确。</p>
<p>apparent_encoding属性，是根据文本内容分析得到的，通常具有较高的准确性。</p>
</li>
</ol>
<h5 id="Request异常与通用代码框架"><a href="#Request异常与通用代码框架" class="headerlink" title="Request异常与通用代码框架"></a>Request异常与通用代码框架</h5><table>
<thead>
<tr>
<th>异常</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>requests.ConnectionError</td>
<td>连接错误异常，如DNS查询失败、拒绝连接</td>
</tr>
<tr>
<td>requests.HTTPError</td>
<td>HTTP错误异常</td>
</tr>
<tr>
<td>request.URLRequired</td>
<td>URL缺失异常</td>
</tr>
<tr>
<td>request.ConnectTimeout</td>
<td>连接远程服务器超时异常</td>
</tr>
<tr>
<td>request.Timeout</td>
<td>请求URL超时异常</td>
</tr>
</tbody></table>
<p>请求异常可以分为以上几种，但并不需要记录，知道即可。</p>
<table>
<thead>
<tr>
<th>检测异常方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r.raise_for_status()</td>
<td>若果不是200，产生异常request.HTTPError</td>
</tr>
</tbody></table>
<p>上述方法用于检测是否出现异常，常用。</p>
<p>一下通用代码框架可用于常见爬虫框架。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url ,timeout = <span class="number">30</span>)</span><br><span class="line">        r.raise_for_status() <span class="comment"># 状态不是200则引发一场</span></span><br><span class="line">        r.enconding = r.apparent_encoding <span class="comment"># 替换编码格式</span></span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;产生异常&quot;</span></span><br><span class="line">    </span><br><span class="line">url = <span class="string">&quot;http://www.baidu.com&quot;</span></span><br><span class="line">print(getHTMLText(url))</span><br></pre></td></tr></table></figure>
<h2 id="Robots协议"><a href="#Robots协议" class="headerlink" title="Robots协议"></a>Robots协议</h2><p>此协议是针对爬虫所指定的规范，哪些可以爬，哪些不能爬。通常直接放置在根目录下。例如百度”<a href="https://www.baidu.com/robots.txt&quot;.%E5%B9%B6%E6%88%AA%E5%8F%96%E5%A6%82%E4%B8%8B%E5%B1%95%E7%A4%BA%EF%BC%9A">https://www.baidu.com/robots.txt&quot;.并截取如下展示：</a></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">User-agent: Baiduspider</span><br><span class="line">Disallow: /baidu</span><br><span class="line">Disallow: /s?</span><br><span class="line">Disallow: /ulink?</span><br><span class="line">Disallow: /link?</span><br><span class="line">Disallow: /home/news/data/</span><br><span class="line">Disallow: /bh</span><br><span class="line"></span><br><span class="line">User-agent: Googlebot</span><br><span class="line">Disallow: /baidu</span><br><span class="line">Disallow: /s?</span><br><span class="line">Disallow: /shifen/</span><br><span class="line">Disallow: /homepage/</span><br><span class="line">Disallow: /cpro</span><br><span class="line">Disallow: /ulink?</span><br><span class="line">Disallow: /link?</span><br><span class="line">Disallow: /home/ne</span><br></pre></td></tr></table></figure>
<ul>
<li>user-agent:爬取框架/爬取人</li>
<li>Disallow:不允许爬取的内容通配符</li>
</ul>
<h2 id="BeautifulSoup库"><a href="#BeautifulSoup库" class="headerlink" title="BeautifulSoup库"></a>BeautifulSoup库</h2><p>BeautifulSoup可用于爬虫过程第二步，对HTML进行树结构解析，并提供了相对完备的遍历方法。</p>
<h3 id="BeautifulSoup的基本使用"><a href="#BeautifulSoup的基本使用" class="headerlink" title="BeautifulSoup的基本使用"></a>BeautifulSoup的基本使用</h3><p>使用很简单，指定HTML地址与解析方式即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将纯文本文件转换为树形结构，并进行解析便是BeautifulSoup的作用</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="keyword">as</span> bs</span><br><span class="line"><span class="comment">#第一个参数为通过requests获得的html文本</span></span><br><span class="line"><span class="comment">#第二个参数为指定用HTML格式解析此文本</span></span><br><span class="line"><span class="comment">#返回soup对象</span></span><br><span class="line">soup = bs(r.text,<span class="string">&quot;html.parser&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="soup对象的基本元素"><a href="#soup对象的基本元素" class="headerlink" title="soup对象的基本元素"></a>soup对象的基本元素</h3><table>
<thead>
<tr>
<th>基本元素</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Tag</td>
<td>标签，基本的信息组织单元，分别用&lt;&gt;和&lt;/&gt;表明开头与结尾</td>
</tr>
<tr>
<td>Name</td>
<td>标签名，p标签，a标签等，使用格式：Tag.name</td>
</tr>
<tr>
<td>Attributes</td>
<td>标签属性，字典形式组织，使用格式: Tag.attrs</td>
</tr>
<tr>
<td>NavigableString</td>
<td>标签内非属性字符串，使用格式：Tag.string</td>
</tr>
<tr>
<td>Comment</td>
<td>标签内字符串的注释部分，<!--....<--></td>
</tr>
</tbody></table>
<p>由上表可知，soup内对象基本元素的调用，以Tag元素为基础进行。</p>
<ul>
<li><p>Tag标签的调用</p>
<p>直接通过标签名称调用即可</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = bs(<span class="string">&quot;htmladress&quot;</span>,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"><span class="comment">#调用a标签，并获得标签对象</span></span><br><span class="line">soup.a</span><br><span class="line"><span class="comment">#调用body标签并获得标签对象</span></span><br><span class="line">soup.body</span><br></pre></td></tr></table></figure>
<ul>
<li>name,标签名的获得</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = bs(<span class="string">&quot;htmladress&quot;</span>,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"><span class="comment">#调用a标签，并获得标签对象</span></span><br><span class="line">tagA = soup.a</span><br><span class="line"><span class="comment">#获得a标签的标签名</span></span><br><span class="line">tagA.name</span><br></pre></td></tr></table></figure>
<ul>
<li>attrs,标签属性的获得</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = bs(<span class="string">&quot;htmladress&quot;</span>,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"><span class="comment">#调用a标签，并获得标签对象</span></span><br><span class="line">tagA = soup.a</span><br><span class="line"><span class="comment">#获得a标签的属性字典</span></span><br><span class="line">tagA.attrs</span><br></pre></td></tr></table></figure>
<ul>
<li>NavigableString,标签内非属性字符串的获得</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = bs(<span class="string">&quot;htmladress&quot;</span>,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"><span class="comment">#调用a标签，并获得标签对象</span></span><br><span class="line">tagA = soup.a</span><br><span class="line"><span class="comment">#获得普通字符串，可以跨层次</span></span><br><span class="line">tagA.string</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Comment,标签内部Comment获得，比较特殊</p>
<p>并没有一个为comment的属性直接进行提取Comment，但是可通过上述的.string方式获得Comment内容，不同处在于其列别可通过type()函数进行鉴别。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">newsoup = BeautifulSoup(<span class="string">&quot;&lt;b&gt;&lt;!-- this is comment --&gt;&lt;p&gt;This is not comment&lt;/p&gt;&lt;/b&gt;&quot;</span>)</span><br><span class="line">newsoup.b.string</span><br><span class="line"><span class="comment">#获得字符，但不知是否是comment还是NavigableString</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">type</span>(newsoup.b.string) <span class="keyword">is</span> bs4.elemnt.Comment :</span><br><span class="line">    print(<span class="string">&quot;发现Comment&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>下图为熟知的HTML格式，其与BeautifulSoup基本是一一对应的。</p>


<h3 id="BS的遍历"><a href="#BS的遍历" class="headerlink" title="BS的遍历"></a>BS的遍历</h3><p>BeautifulSoup对于树的遍历方式，并没有特殊的内容，这里仅做简单的介绍，知道即可。重点还是在应用中的情形。</p>
<p>三种遍历方式：上行、下行、平行</p>


<ul>
<li>下行遍历方法展示</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.content</td>
<td>子节点的列表，将所有子节点信息存入列表</td>
</tr>
<tr>
<td>.children</td>
<td>子节点的<strong>迭代</strong>类型，用于循环<strong>遍历</strong>子节点情形</td>
</tr>
<tr>
<td>.descendants</td>
<td>子孙节点的迭代类型，包含<strong>所有的子孙节点</strong>，用于<strong>遍历</strong></td>
</tr>
</tbody></table>
<ul>
<li>上行遍历方法展示</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.parent</td>
<td>节点的父节点标签</td>
</tr>
<tr>
<td>.parents</td>
<td>节点的祖先节点标签，用于<strong>循环遍历</strong></td>
</tr>
</tbody></table>
<ul>
<li>平行遍历方法展示</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.next_sibling</td>
<td>返回HTML文本顺序中下一个平行节点标签</td>
</tr>
<tr>
<td>.previous_sibling</td>
<td>返回HTML文本顺序中上一个平行节点标签</td>
</tr>
<tr>
<td>.next_siblings</td>
<td>迭代类型，返回HTML文本顺序中后序所有平行节点标签</td>
</tr>
<tr>
<td>.previous_siblings</td>
<td>迭代类型，返回HTML文本顺序中前序所有平行节点标签</td>
</tr>
</tbody></table>
<p>注意：平行遍历指的是在同一个父节点的前提下，而不是树中所有同一层次的情况。如图：</p>

<p>Bs4的遍历情况总结如图：</p>


<h2 id="信息标注方式与信息提取方法"><a href="#信息标注方式与信息提取方法" class="headerlink" title="信息标注方式与信息提取方法"></a>信息标注方式与信息提取方法</h2><h3 id="信息标注方式简介"><a href="#信息标注方式简介" class="headerlink" title="信息标注方式简介"></a>信息标注方式简介</h3><p>常见的信息标注方式有三种，分别是XML、JSON、YAML。HTML是XML的变种，也属于XML格式。下面简单的介绍比较三种信息标注方式。</p>
<ul>
<li>XML：eXtensible Markup Language , 其构成单位是Tag标签，且标签内包含有名称属性等信息如图：</li>
</ul>



<pre><code>其中空元素可通过一个&lt;&gt;表示 , 注释通过&lt;!-- --&gt; 表示</code></pre>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#XML空元素表示</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;china.jpg&quot;</span> <span class="attr">size</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">#XML注释格式</span><br><span class="line"><span class="comment">&lt;!-- This is a comment --&gt;</span></span><br></pre></td></tr></table></figure>
<p>总结：XML格式共包含三种样式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- --&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>JSON：JavaScript Object Notation , <strong>有类型</strong>的键值对表示方式</li>
</ul>



<p>总结：JSON格式包含三种样式</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#普通键值对表示</span><br><span class="line">&quot;key&quot; : &quot;Value&quot;</span><br><span class="line">#多值键值对表示</span><br><span class="line">&quot;key&quot; : [&quot;Value1&quot;,&quot;Value2&quot;]</span><br><span class="line">#键值对嵌套表示</span><br><span class="line">&quot;key&quot; : &#123;&quot;subkey&quot; : &quot;subvalue&quot;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>YAML：Ain’t Markup Language ， 无类型键值对</li>
</ul>


<p>  其表示各种关系情况：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#缩进表示所属关系，同Python</span></span><br><span class="line"><span class="attr">name:</span></span><br><span class="line">	<span class="attr">newName :</span> <span class="string">北京理工</span></span><br><span class="line">	<span class="attr">OldName :</span> <span class="string">延安自然科学院</span></span><br><span class="line"><span class="comment"># “-” 表达并列关系</span></span><br><span class="line"><span class="attr">name:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">北京理工大学</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">延安自然科学院</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># “|”表达整块数据</span></span><br><span class="line"><span class="attr">text:</span> <span class="string">|</span></span><br><span class="line"><span class="string">北京理工大学创立与......</span></span><br></pre></td></tr></table></figure>
<p>总结:三种表示形式如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">key :</span> <span class="string">value</span></span><br><span class="line"></span><br><span class="line"><span class="attr">key :</span> <span class="comment">#comment</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">value1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">value2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">key:</span></span><br><span class="line">	<span class="attr">subkey :</span> <span class="string">value</span> </span><br><span class="line">		</span><br></pre></td></tr></table></figure>
<h3 id="信息标注方式实例比较"><a href="#信息标注方式实例比较" class="headerlink" title="信息标注方式实例比较"></a>信息标注方式实例比较</h3><p>XML：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">firstName</span>&gt;</span>Tian<span class="tag">&lt;/<span class="name">firstName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lastName</span>&gt;</span>Song<span class="tag">&lt;/<span class="name">lastName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">streetAddr</span>&gt;</span>中关村南大街5号<span class="tag">&lt;/<span class="name">streetAddr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">city</span>&gt;</span>北京市<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">zipcode</span>&gt;</span>100081<span class="tag">&lt;/<span class="name">zipcode</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prof</span>&gt;</span>ComputerSystem<span class="tag">&lt;/<span class="name">prof</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prof</span>&gt;</span>Security<span class="tag">&lt;/<span class="name">prof</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--最早的通用标记语言，可扩展性好，但很繁琐 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用于INTERNET 信息交互与传递 --&gt;</span></span><br></pre></td></tr></table></figure>
<p>JSON:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    “firstName”: “Tian”,</span><br><span class="line">    “lastName”: “Song”,</span><br><span class="line">    “address”:&#123;“streetAddr”: “中关村南大街5号” ,</span><br><span class="line">               “city”: “北京市” ,</span><br><span class="line">               “zipcode”: “100081”&#125;,</span><br><span class="line">    “prof”:[“ComputerSystem”, “Security”]</span><br><span class="line">&#125;</span><br><span class="line">#信息有类型，适合程序处理，比XML简洁</span><br><span class="line">#用于移动英语云端与节点信息通信，无注释</span><br></pre></td></tr></table></figure>
<p>YAML:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">firstName:</span> <span class="string">Tian</span></span><br><span class="line"><span class="attr">lastName:</span> <span class="string">Song</span></span><br><span class="line"><span class="attr">address:</span></span><br><span class="line">	<span class="string">streetAddr:中关村南大街5号</span></span><br><span class="line">	<span class="string">city:北京市</span></span><br><span class="line">	<span class="attr">zipcode:</span> <span class="number">100081</span></span><br><span class="line"><span class="attr">prof:</span></span><br><span class="line"><span class="string">‐Computer</span> <span class="string">System</span></span><br><span class="line"><span class="string">‐Security</span></span><br><span class="line"><span class="comment"># 信息无类型，文本信息比例最高，可读性好</span></span><br><span class="line"><span class="comment"># 常用于各类系统配置文件，有注释易读</span></span><br></pre></td></tr></table></figure>


<h3 id="信息提取的三种方法"><a href="#信息提取的三种方法" class="headerlink" title="信息提取的三种方法"></a>信息提取的三种方法</h3><p>这里的信息提取指的是提取标注信息（xml、json、yaml）内容。</p>
<ol>
<li><p>完整解析信息标记，再提取关键信息，需要标记解析器，如BS4。虽然准确但是繁琐，速度慢。</p>
</li>
<li><p>无视标记形式，直接搜索关键信息。对信息文本直接查找。提取速度快，但准确性不确定。</p>
</li>
<li><p>融合方法，一般先通过第二种方式确定范围，再使用第一种方式精确处理。如图</p>


</li>
</ol>
<h3 id="基于Bs4库的HTML内容查找方法"><a href="#基于Bs4库的HTML内容查找方法" class="headerlink" title="基于Bs4库的HTML内容查找方法"></a>基于Bs4库的HTML内容查找方法</h3><p>由于本部分内容过于简单，更多的需要在实践中应用，故未详细说明。正则表达式也可以用于检索。</p>
<ol>
<li>首先利用find_all()方法，无视标记形式，直接搜索关键信息。</li>
</ol>


<ol start="2">
<li>其次解析其标签格式</li>
</ol>
<h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定向页面爬取</span></span><br><span class="line"><span class="comment">#获得中国“最好”大学排名情况</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"><span class="comment"># 1.通过requests等库获得网页内容</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 2.通过beautifulSoup等库解析网页内容，并获取关键信息 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillUnivList</span>(<span class="params">ulist, html</span>):</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">&#x27;tbody&#x27;</span>).children:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(tr, bs4.element.Tag):</span><br><span class="line">            tds = tr(<span class="string">&#x27;td&#x27;</span>)</span><br><span class="line">            ulist.append([tds[<span class="number">0</span>].string, tds[<span class="number">1</span>].string, tds[<span class="number">3</span>].string])</span><br><span class="line"><span class="comment"># 3.可视化输出</span></span><br><span class="line"><span class="comment">#chr(12288)用于中文符号填充，未研究</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printUnivList</span>(<span class="params">ulist, num</span>):</span></span><br><span class="line">    tplt = <span class="string">&quot;&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;&quot;</span></span><br><span class="line">    print(tplt.<span class="built_in">format</span>(<span class="string">&quot;排名&quot;</span>,<span class="string">&quot;学校名称&quot;</span>,<span class="string">&quot;总分&quot;</span>,<span class="built_in">chr</span>(<span class="number">12288</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        u=ulist[i]</span><br><span class="line">        print(tplt.<span class="built_in">format</span>(u[<span class="number">0</span>],u[<span class="number">1</span>],u[<span class="number">2</span>],<span class="built_in">chr</span>(<span class="number">12288</span>)))</span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">&#x27;http://www.zuihaodaxue.com/zuihaodaxuepaiming2018.html&#x27;</span></span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    fillUnivList(uinfo, html)</span><br><span class="line">    printUnivList(uinfo, <span class="number">20</span>) <span class="comment"># 20 univs</span></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-正则表达式</title>
    <url>/2020/04/06/python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Python-正则表达式"><a href="#Python-正则表达式" class="headerlink" title="Python_正则表达式"></a>Python_正则表达式</h1><p>正则表达式是常用于字符串匹配。之前也曾系统的看过相关的内容，但是一段时间不用发现又很陌生，特将相关内容记录如下。</p>
<a id="more"></a>

<p>正则表达式本身适用于匹配含有<strong>某种特征</strong>的字符串，从而对字符串进行相关处理（分割、替换、匹配等）。Python语言通过re库支持正则表达式。</p>
<h2 id="正则表达式简介"><a href="#正则表达式简介" class="headerlink" title="正则表达式简介"></a>正则表达式简介</h2><blockquote>
<p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p>
</blockquote>
<p>一个正则表达式由运算符与操作符构成，而运算符与操作符又可以分为若干种类。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>表示待匹配字符本身的符号，[a-z] 表示由a到z的单个字符。</p>
<h4 id="普通运算符"><a href="#普通运算符" class="headerlink" title="普通运算符"></a>普通运算符</h4><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。这里的<a href="https://www.runoob.com/regexp/regexp-metachar.html">元字符</a>可以单纯的理解为具有特殊含义的字符，不需要记忆。</p>
<h4 id="特殊运算符"><a href="#特殊运算符" class="headerlink" title="特殊运算符"></a>特殊运算符</h4><p>特殊运算符指的是利用<strong>转义字符</strong>表示特定字符的表示。可理解为对常见的运算符进行了约定表达，以达到简化的目的。</p>
<p>这里仅列举了常见的特殊运算符。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\w</td>
<td>匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。</td>
</tr>
<tr>
<td>\W</td>
<td>匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字字符。等价于 [0-9]。</td>
</tr>
<tr>
<td>\D</td>
<td>匹配一个非数字字符。等价于 [^0-9]。</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody></table>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>用于表示对运算符的某种操作，通常是限定符号。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>$</td>
<td>匹配结尾位置</td>
</tr>
<tr>
<td>( )</td>
<td>标记一个子表达式的开始和结束位置</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。</td>
</tr>
<tr>
<td>[</td>
<td>标记一个中括号表达式的开始。要匹配 [，请使用 [。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的开始位置</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。匹配确定的 n 次。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是一个非负整数。至少匹配n 次。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>最少匹配 n 次且最多匹配 m 次</td>
</tr>
</tbody></table>
<p>  通过上述运算符+操作符可以表示任意符号，根据应用场景千变万化。</p>
<h2 id="Python-中正则表达式的应用"><a href="#Python-中正则表达式的应用" class="headerlink" title="Python 中正则表达式的应用"></a>Python 中正则表达式的应用</h2><p>Python中采用re库对正则表达式进行处理。其正则表达式的调用方式分为两种：1.库直接调用 2.利用正则表达式对象调用。这里的关系我认为与类同对象的关系一致。</p>
<h3 id="库调用"><a href="#库调用" class="headerlink" title="库调用"></a>库调用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#实例</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#匹配一个或多个字母</span></span><br><span class="line">match = re.search(<span class="string">r&quot;[a-zA-Z]+&quot;</span> ,<span class="string">&quot;We are the chamion&quot;</span> )</span><br><span class="line">print(match.group(<span class="number">0</span>))</span><br><span class="line"><span class="comment">#Result : We</span></span><br></pre></td></tr></table></figure>
<p>直接使用库函数调用方法即可。主要方法如下：</p>
<table>
<thead>
<tr>
<th>函数调用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>re.search()</td>
<td>搜索匹配的第一个，并返回<strong>match</strong>对象</td>
</tr>
<tr>
<td>re.match()</td>
<td>从<strong>开始位置</strong>匹配符合正则的字符串，并返回<strong>match</strong>对象</td>
</tr>
<tr>
<td>re.findall()</td>
<td>搜索字符串，以<strong>列表</strong>形式返回全部匹配的字符串</td>
</tr>
<tr>
<td>re.split()</td>
<td>按照正则表达式分割原始字符串，并返回<strong>列表</strong>类型</td>
</tr>
<tr>
<td>re.finditer()</td>
<td>搜索字符串，返回符合匹配结果的<strong>迭代</strong>类型，每个迭代元素均为<strong>match</strong>对象</td>
</tr>
<tr>
<td>re.sub()</td>
<td>替换符合正则表达的子串为特定字符串，返回替换后的<strong>字符串</strong></td>
</tr>
</tbody></table>
<p>简单实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#实例</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#匹配一个或多个字母</span></span><br><span class="line">match = re.search(<span class="string">r&quot;[a-zA-Z]+&quot;</span> ,<span class="string">&quot;We are the 45 chamion 123&quot;</span> )</span><br><span class="line">print(match.group(<span class="number">0</span>))</span><br><span class="line"><span class="comment"># We</span></span><br><span class="line"></span><br><span class="line">match = re.match(<span class="string">r&quot;[a-zA-Z]+&quot;</span> ,<span class="string">&quot;We are the 45 chamion 123&quot;</span> )</span><br><span class="line">print(match.group(<span class="number">0</span>))</span><br><span class="line"><span class="comment"># We</span></span><br><span class="line"></span><br><span class="line">matchList = re.findall(<span class="string">r&quot;[a-zA-Z]+&quot;</span> ,<span class="string">&quot;We are the 45 chamion 123&quot;</span> )</span><br><span class="line">print(matchList)</span><br><span class="line"><span class="comment"># [&#x27;We&#x27;, &#x27;are&#x27;, &#x27;the&#x27;, &#x27;chamion&#x27;]</span></span><br><span class="line"></span><br><span class="line">splitList = re.split(<span class="string">r&quot;[a-zA-Z]+&quot;</span> ,<span class="string">&quot;We are the 45 chamion 123&quot;</span>  )</span><br><span class="line">print(splitList)</span><br><span class="line"><span class="comment"># [&#x27;&#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; 45 &#x27;, &#x27; 123&#x27;]</span></span><br><span class="line"></span><br><span class="line">iterMatch = re.finditer(<span class="string">r&quot;[a-zA-Z]+&quot;</span> ,<span class="string">&quot;We are the 45 chamion 123&quot;</span>  )</span><br><span class="line"><span class="keyword">for</span> match <span class="keyword">in</span> iterMatch:</span><br><span class="line">    print(match.group(<span class="number">0</span>))</span><br><span class="line"><span class="comment"># We</span></span><br><span class="line"><span class="comment"># are</span></span><br><span class="line"><span class="comment"># the</span></span><br><span class="line"><span class="comment"># chamion</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">subResult = re.sub(<span class="string">r&quot;[a-zA-Z]+&quot;</span> ,<span class="string">&quot;zzz&quot;</span> ,<span class="string">&quot;We are the 45 chamion 123&quot;</span>   )</span><br><span class="line">print(subResult)</span><br><span class="line"><span class="comment"># zzz zzz zzz 45 zzz 123</span></span><br></pre></td></tr></table></figure>
<p>上面仅仅是简单的实例，具体每个方法可以设置的参数都为细讲，可在应用时再看。</p>
<p>通过观察方法表中对每种方法的描述，我们可以发现<strong>match对象</strong>多次提及，其相应的属性与方法可简单了解。</p>
<h3 id="regex对象调用"><a href="#regex对象调用" class="headerlink" title="regex对象调用"></a>regex对象调用</h3><p>选择用regex对象调用上述方法的好处为，对于同一个正则表达式多次使用时可以减少系统默认的多次编译正则表达式次数。调用形式与库调用一致，理解为类与对象的关系即可。</p>
<p>调用实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re </span><br><span class="line"><span class="comment">#先编译，返回一个regex对象</span></span><br><span class="line">regex = re.<span class="built_in">compile</span>(<span class="string">r&quot;[a-z]+&quot;</span>)</span><br><span class="line"><span class="comment">#在调用相关方法即可</span></span><br><span class="line">regex.search(<span class="string">&quot;String&quot;</span>)</span><br></pre></td></tr></table></figure>


<h3 id="Match对象"><a href="#Match对象" class="headerlink" title="Match对象"></a>Match对象</h3><p>在上述方法中，多个方法返回的为<strong>match对象</strong>，其有自己的属性与方法，需要简单的了解下。</p>
<p>Match对象的属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.string</td>
<td>待匹配的文本</td>
</tr>
<tr>
<td>.re</td>
<td>匹配时使用的pattern对象，即正则</td>
</tr>
<tr>
<td>.pos</td>
<td>正则搜索文本的开始位置</td>
</tr>
<tr>
<td>.endpos</td>
<td>正则搜索的结束位置</td>
</tr>
</tbody></table>
<p>Match对象的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.group(0)</td>
<td>获得匹配的字符串</td>
</tr>
<tr>
<td>.start()</td>
<td>匹配字符串在原始字符串中的起始位置</td>
</tr>
<tr>
<td>.end()</td>
<td>匹配字符串在原始字符串中的结束位置</td>
</tr>
<tr>
<td>.span()</td>
<td>返回（.start() , .end()）</td>
</tr>
</tbody></table>
<p>本文中包含由正则表达的含义，与基本的用法 + Pyhon库re对于正则表达式的用法。多是用于理解与了解必要的使用方法与框架，并没有涉及具体的代码演示。个人认为正则的使用，跟需要在应用过程中进行。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title>python内存管理</title>
    <url>/2021/01/11/python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>Python内存管理是理解Python运行机制的重要一环,也是面试的高频问题,特整理相关信息如下:</p>
<a id="more"></a>

<blockquote>
<p>参考地址：<a href="https://www.cnblogs.com/geaozhang/p/7111961.html">博客一</a> ， <a href="https://andrewpqc.github.io/2018/10/08/python-memory-management/">博客二</a> ，<a href="https://cloud.tencent.com/developer/article/1670455">博客三</a></p>
</blockquote>
<p>Python内存管理是理解Python运行机制的重要一环，故整理下相关内容如下：</p>
<h2 id="前置知识：Python变量与对象"><a href="#前置知识：Python变量与对象" class="headerlink" title="前置知识：Python变量与对象"></a>前置知识：Python变量与对象</h2><p>我们在编程过程中，不可避免的使用变量指代对象，其关系为变量通过指针指向了对象；对象有自己的类型，而变量的类型则跟随者对象的类型而变化。关系如图：</p>
<p><img src="https://i.loli.net/2021/01/11/pSmqUE57vVdYGcx.png"></p>
<p><strong>变量：</strong>通过变量指针引用对象。而变量指针指向具体对象的<strong>内存空间</strong>；变量类型是<strong>动态</strong>的，与对象类型一致</p>
<p><strong>对象：</strong>类型是<strong>已知</strong>的，每个对象都包含有头部信息，其中为<strong>类型标识</strong>符与<strong>引用计数</strong>器</p>
<h3 id="多变量指向同一对象情况"><a href="#多变量指向同一对象情况" class="headerlink" title="多变量指向同一对象情况"></a>多变量指向同一对象情况</h3><p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var_1 = <span class="number">123</span></span><br><span class="line">var_2 = var_1</span><br><span class="line">print(<span class="built_in">id</span>(var_1)) <span class="comment"># 140711337393728</span></span><br><span class="line">print(<span class="built_in">id</span>(var_2)) <span class="comment"># 140711337393728</span></span><br><span class="line">print(<span class="built_in">id</span>(<span class="number">123</span>)) <span class="comment"># 140711337393728</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">type</span>(var_1)) <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>(var_2)) <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>(<span class="number">123</span>)) <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过对象被引用的方式(var_2 = var_1)，两个变量指向了同一地址，并且变量的类别与被引用对象的类别一致。简单示意图：</p>
<p><img src="https://i.loli.net/2021/01/11/qsDZ8Kr2tPHFUkV.png"></p>
<h3 id="多变量引用所指的判断"><a href="#多变量引用所指的判断" class="headerlink" title="多变量引用所指的判断"></a>多变量引用所指的判断</h3><p>在Python中判断多个变量的引用地址是否一致采用了内置函数is。先看一段代码再去讲。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 小于等于256的整数</span></span><br><span class="line">intA = <span class="number">256</span></span><br><span class="line">intB = <span class="number">256</span></span><br><span class="line">print(<span class="built_in">id</span>(intA)) <span class="comment"># 140711337397984</span></span><br><span class="line">print(<span class="built_in">id</span>(intB)) <span class="comment"># 140711337397984</span></span><br><span class="line">intA <span class="keyword">is</span> intB <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 大于256的整数</span></span><br><span class="line">intA = <span class="number">257</span> <span class="comment"># 3037955041360</span></span><br><span class="line">intB = <span class="number">257</span> <span class="comment"># 3037955041424</span></span><br><span class="line">print(<span class="built_in">id</span>(intA))</span><br><span class="line">print(<span class="built_in">id</span>(intB))</span><br><span class="line">intA <span class="keyword">is</span> intB <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 短字符串</span></span><br><span class="line">charA = <span class="string">&quot;aaaaaaaaaaa&quot;</span></span><br><span class="line">charB = <span class="string">&quot;aaaaaaaaaaa&quot;</span></span><br><span class="line">charA <span class="keyword">is</span> charB <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 长字符串</span></span><br><span class="line">charA = <span class="string">&quot;very Good&quot;</span></span><br><span class="line">charB = <span class="string">&quot;very Good&quot;</span></span><br><span class="line">charA <span class="keyword">is</span> charB <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器——列表</span></span><br><span class="line">listA = []</span><br><span class="line">listB = []</span><br><span class="line">listA <span class="keyword">is</span> listB <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<p>我们发现不同的数据类型或者同一数据类型不同“长度”时，多次创建时，其内存地址情况并不一致。这是由于Python会选择缓存常用的对象，使得多次赋值对象时，不需要创建新的对象，例如1~256的数字，短字符串等。基本上都是不可修改的数据类型。</p>
<ol>
<li>Python缓存了整数（1~256，短字符串），每个变量进行为赋值操作时，不需要创建新的对象，大家引用对象一致。</li>
<li>Python对于未缓存的对象，在进行赋值操作时，会直接生成新的对象，占用新的内存地址。</li>
</ol>
<h2 id="Python的垃圾回收机制"><a href="#Python的垃圾回收机制" class="headerlink" title="Python的垃圾回收机制"></a>Python的垃圾回收机制</h2><p>一句话描述就是：<strong>引用计数为主，标记清除与分代回收为辅</strong>；</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>Python中主要使用引用计数(Reference Counting)进行垃圾回收。每一个对象的核心就是一个结构体PyObject,其内部存在一个引用计数器(ob_refcnt)。当某对象的引用计数值为0时，其内存就可以被释放掉；</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"> typedef struct_object &#123;</span><br><span class="line">    <span class="built_in">int</span> ob_refcnt;</span><br><span class="line">    struct_typeobject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>
<h4 id="引起引用计数变化的情况"><a href="#引起引用计数变化的情况" class="headerlink" title="引起引用计数变化的情况"></a>引起引用计数变化的情况</h4><p><strong>引用计数增加的情况：</strong></p>
<ul>
<li>对象被创建,a = 2</li>
<li>对象被引用,b=a</li>
<li>对象作为参数传递到函数中,fun(a)</li>
<li>对象作为元素存储在容器中,numList.append(a)</li>
</ul>
<p><strong>引用计数减少的情况：</strong></p>
<ul>
<li>对象别名被显示销毁,del a</li>
<li>对象别名赋予了新的对象,b = 3</li>
<li>包含对象的函数运行结束,</li>
<li>对象所在的容器被摧毁或者从容其中删除了对象,numList.remove(a)</li>
</ul>
<h4 id="获取引用数量的方式"><a href="#获取引用数量的方式" class="headerlink" title="获取引用数量的方式"></a>获取引用数量的方式</h4><p>通过sys包中的getrefcount()获取一个名称所引用的对象当前的引用计数，这个函数本身也会造成其引用+1.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys.getrefcount(a)</span><br></pre></td></tr></table></figure>
<h4 id="引用计数的优缺点"><a href="#引用计数的优缺点" class="headerlink" title="引用计数的优缺点"></a>引用计数的优缺点</h4><p><strong>优点：</strong></p>
<ul>
<li>逻辑简单而高效，具备实时性；</li>
<li>垃圾回收随机分配到运行阶段，处理回收时间分散有利于系统稳定；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>空间浪费：每个对象都存在用来统计的引用的空间，加大了空间负担；</li>
<li>大对象释放缓慢：当需要释放大的对象时，比如字典，需要对引用的所有对象循环嵌套调用；</li>
<li>循环引用问题：引用计数的致命问题。</li>
</ul>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>标记清除(Mark and Sweep)算法，是为了解决对象可能产生的循环引用问题。(注意，只有<strong>容器</strong>对象才会产生循环引用的情况，比如列表、字典、用户自定义类的对象、元组等。而像数字，字符串这类简单类型不会出现循环引用。作为一种优化策略，对于只包含简单类型的元组也不在标记清除算法的考虑之列)。</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ol>
<li>标记阶段，遍历所有对象，如果对象可达（表明存在对象引用它），则标记对象可达；</li>
<li>清除阶段，再次遍历所有对象，对于不可达的对象，进行回收；</li>
</ol>
<p>如下图所示，在标记清除算法中，为了追踪容器对象，需要每个容器对象维护两个额外的指针，用来将容器对象组成一个双端链表，指针分别指向前后两个容器对象，方便插入和删除操作。python解释器(Cpython)维护了两个这样的双端链表，一个链表存放着需要被扫描的容器对象，另一个链表存放着临时不可达对象。在图中，这两个链表分别被命名为”Object to Scan”和”Unreachable”。图中例子是这么一个情况：link1,link2,link3组成了一个引用环，同时link1还被一个变量A(其实这里称为名称A更好)引用。link4自引用，也构成了一个引用环。从图中我们还可以看到，每一个节点除了有一个记录当前引用计数的变量<code>ref_count</code>还有一个<code>gc_ref</code>变量，这个<code>gc_ref</code>是<code>ref_count</code>的一个副本，所以初始值为<code>ref_count</code>的大小。<br><a href="https://andrewpqc.github.io/images/marksweep1.png"><img src="https://andrewpqc.github.io/images/marksweep1.png" alt="img"></a></p>
<p>gc启动的时候，会逐个遍历”Object to Scan”链表中的容器对象，并且将当前对象所引用的所有对象的<code>gc_ref</code>减一。(扫描到link1的时候，由于link1引用了link2,所以会将link2的<code>gc_ref</code>减一，接着扫描link2,由于link2引用了link3,所以会将link3的<code>gc_ref</code>减一…..)像这样将”Objects to Scan”链表中的所有对象考察一遍之后，两个链表中的对象的<code>ref_count</code>和<code>gc_ref</code>的情况如下图所示。这一步操作就相当于解除了循环引用对引用计数的影响。<br><a href="https://andrewpqc.github.io/images/marksweep2.png"><img src="https://andrewpqc.github.io/images/marksweep2.png" alt="img"></a></p>
<p>接着，gc会再次扫描所有的容器对象，如果对象的<code>gc_ref</code>值为0，那么这个对象就被标记为<code>GC_TENTATIVELY_UNREACHABLE</code>，并且被移至”Unreachable”链表中。下图中的link3和link4就是这样一种情况。<br><a href="https://andrewpqc.github.io/images/marksweep3.png"><img src="https://andrewpqc.github.io/images/marksweep3.png" alt="img"></a></p>
<p>如果对象的<code>gc_ref</code>不为0，那么这个对象就会被标记为<code>GC_REACHABLE</code>。同时当gc发现有一个节点是可达的，那么他会递归式的将从该节点出发可以到达的所有节点标记为<code>GC_REACHABLE</code>,这就是下图中link2和link3所碰到的情形。<br><a href="https://andrewpqc.github.io/images/marksweep4.png"><img src="https://andrewpqc.github.io/images/marksweep4.png" alt="img"></a></p>
<p>除了将所有可达节点标记为<code>GC_REACHABLE</code>之外，如果该节点当前在”Unreachable”链表中的话，还需要将其移回到”Object to Scan”链表中，下图就是link3移回之后的情形。<br><a href="https://andrewpqc.github.io/images/marksweep5.png"><img src="https://andrewpqc.github.io/images/marksweep5.png" alt="img"></a><br>第二次遍历的所有对象都遍历完成之后，存在于”Unreachable”链表中的对象就是真正需要被释放的对象。如上图所示，此时link4存在于Unreachable链表中，gc随即释放之。</p>
<p><strong>上面描述的垃圾回收的阶段，会暂停整个应用程序，等待标记清除结束后才会恢复应用程序的运行。</strong></p>
<h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><p>Python通过“分代回收”（Generational Collection）以<strong>空间换时间</strong>的方法提高<strong>垃圾回收效率</strong>。</p>
<h4 id="分代回收的依据"><a href="#分代回收的依据" class="headerlink" title="分代回收的依据"></a>分代回收的依据</h4><p><strong>对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。</strong></p>
<p>python gc给对象定义了三种世代(0,1,2),每一个新生对象在generation zero中，如果它在一轮gc扫描中活了下来，那么它将被移至generation one,在那里他将较少的被扫描，如果它又活过了一轮gc,它又将被移至generation two，在那里它被扫描的次数将会更少。</p>
<p>gc的扫描在什么时候会被触发呢?答案是<strong>当某一世代中被分配的对象与被释放的对象之差达到某一阈值的时候，就会触发gc对某一世代的扫描。</strong>值得注意的是<strong>当某一世代的扫描被触发的时候，比该世代年轻的世代也会被扫描。</strong>也就是说如果世代2的gc扫描被触发了，那么世代0,世代1也将被扫描，如果世代1的gc扫描被触发，世代0也会被扫描。</p>
<p>该阈值可以通过下面两个函数查看和调整:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gc.get_threshold() <span class="comment"># (threshold0, threshold1, threshold2).</span></span><br><span class="line">gc.set_threshold(threshold0[, threshold1[, threshold2]])</span><br></pre></td></tr></table></figure>
<p>下面对set_threshold()中的三个参数threshold0, threshold1, threshold2进行介绍。gc会记录自从上次收集以来新分配的对象数量与释放的对象数量，当两者之差超过threshold0的值时，gc的扫描就会启动，初始的时候只有世代0被检查。如果自从世代1最近一次被检查以来，世代0被检查超过threshold1次，那么对世代1的检查将被触发。相同的，如果自从世代2最近一次被检查以来，世代1被检查超过threshold2次，那么对世代2的检查将被触发。get_threshold()是获取三者的值，默认值为(700,10,10).</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>总体来说，在Python中，主要通过引用计数进行垃圾回收；通过 “标记-清除” 解决容器对象可能产生的循环引用问题；通过 “分代回收” 以空间换时间的方法提高垃圾回收效率。</strong></p>
<h2 id="内存池机制"><a href="#内存池机制" class="headerlink" title="内存池机制"></a>内存池机制</h2><p>Python中对于大内存（&gt; 256 字节）与小内存（1 ~ 256字节）的分配机制是不同的。</p>
<h4 id="为什么引入内存池"><a href="#为什么引入内存池" class="headerlink" title="为什么引入内存池"></a>为什么引入内存池</h4><p>解决多次调用malloc导致大量内存碎片的问题。</p>
<p>内存池就是预先申请一定数量的，大小相同的内存块，当出现新的内存需求，可以选择从内存池分配内存；</p>
<h4 id="大内存的分配机制：malloc"><a href="#大内存的分配机制：malloc" class="headerlink" title="大内存的分配机制：malloc"></a>大内存的分配机制：malloc</h4><p>大内存—–若请求分配的内存大于256K，malloc函数分配内存，free函数释放内存。</p>
<h4 id="小内存的分配机制：内存池"><a href="#小内存的分配机制：内存池" class="headerlink" title="小内存的分配机制：内存池"></a>小内存的分配机制：内存池</h4><p>内存池，有Python的接口函数PyMem_Malloc实现—–若请求分配的内存在1~256字节之间就使用内存池管理系统进行分配，调用malloc函数分配内存，但是每次只会分配一块大小为256K的大块内存，不会调用free函数释放内存，将该内存块留在内存池中以便下次使用。</p>
<h4 id="Python解释器的解释"><a href="#Python解释器的解释" class="headerlink" title="Python解释器的解释"></a>Python解释器的解释</h4><p><img src="https://i.loli.net/2021/01/11/weVvjoAi7s2FENz.png"></p>
<ul>
<li>python的对象管理主要位于Level+1~Level+3层</li>
<li>Level+3层：对于python内置的对象（比如int,dict等）都有独立的私有内存池，对象之间的内存池不共享，即int释放的内存，不会被分配给float使用</li>
<li>Level+2层：当申请的内存大小小于256KB时，内存分配主要由 Python 对象分配器（Python’s object allocator）实施</li>
<li>Level+1层：当申请的内存大小大于256KB时，由Python原生的内存分配器进行分配，本质上是调用C标准库中的malloc/realloc等函数.</li>
</ul>
<blockquote>
<p>关于释放内存方面，当一个对象的引用计数变为0时，Python就会调用它的析构函数。调用析构函数并不意味着最终一定会调用free来释放内存空间，如果真是这样的话，那频繁地申请、释放内存空间会使Python的执行效率大打折扣。因此在析构时也采用了内存池机制，从内存池申请到的内存会被归还到内存池中，以避免频繁地申请和释放动作.</p>
</blockquote>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title>wordNet Introduction</title>
    <url>/2020/04/26/wordNet-Introduction/</url>
    <content><![CDATA[<h1 id="WordNet简介与原理"><a href="#WordNet简介与原理" class="headerlink" title="WordNet简介与原理"></a>WordNet简介与原理</h1><h2 id="什么是WordNet"><a href="#什么是WordNet" class="headerlink" title="什么是WordNet"></a>什么是WordNet</h2><blockquote>
<p><a href="http://wordnetweb.princeton.edu/perl/webwn">wordNet在线使用地址</a>  <a href="http://www.nltk.org/howto/wordnet.html">wordNet_API</a>  <a href="http://wordvis.com/">wordNet_可视化</a></p>
</blockquote>
<p>一句话概括WorNet即为：面向<strong>英文</strong>的<strong>词汇</strong>数据库，其按照单词的含义构造了单词的网络。WordNet的最大的特点为<strong>按照词义构建词集</strong>，</p>
<a id="more"></a>

<p>在WordNet中词性是分类的重要标准，按照词性划分为四类同义词集，分别是动词同义词集、名词同义词集、形容词同义词集与副词同义词集。上述的四种同义词集各自构成了同义词网络。每一个同义词的集合表示一个基本<strong>语义</strong>概念，并且集合之间存在各种关系。</p>
<p>集合之间的关系包括九类：上下位关系（动词、名词）、蕴含关系（动词）、相似关系（名词）、成员部分关系（名词）、物质部分关系（名词）、部件部分关系（名词）、致使关系（动词）、相关动词关系（动词）、属性关系（形容词）。</p>
<p>例如名词”Love”的上下位关系为：</p>
<blockquote>
<p>entity——&gt;abstract entity——&gt;abstraction——&gt;attribute——&gt;state——&gt;feeling——&gt; emotion——&gt;love;</p>
</blockquote>
<h2 id="WordNet的特点"><a href="#WordNet的特点" class="headerlink" title="WordNet的特点"></a>WordNet的特点</h2><h3 id="1-与一般词典的组织结构不同"><a href="#1-与一般词典的组织结构不同" class="headerlink" title="1.与一般词典的组织结构不同"></a>1.与一般词典的组织结构不同</h3><p>它利用<strong>同义词集合</strong>作为基本组织单位，用户可以在同义词集中找到合适的词表示某个已知的基本概念，同时也给出了定义与例句。</p>
<p>如果将WordNet视为数据库，则Synset就是一条数据的主键，代表了一个词义。Python中Synset展示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-2bb918806d6a3a21932dbed3514368a9_720w.jpg"></p>
<p>上图中是Synset基础用法，其通过单词”dog”，寻找包含”dog”的所有同义词集。</p>
<h3 id="2-同义词集间通过关系构成网络"><a href="#2-同义词集间通过关系构成网络" class="headerlink" title="2.同义词集间通过关系构成网络"></a>2.同义词集间通过关系构成网络</h3><p>WordNet中同义词集并非是独立的，其通过特定的关系类型构建同义词集网络架构。</p>


<p>上图是”China”词，在WordNet中涉及的同义词集关系展示。</p>
<h3 id="3-WordNet中同义词集的单义性"><a href="#3-WordNet中同义词集的单义性" class="headerlink" title="3.WordNet中同义词集的单义性"></a>3.WordNet中同义词集的单义性</h3><p>在WordNet中，大多数的同义词集都有说明性的注释，但一个Synset不等于词典中的一个词条，因为一个Synset只包含一个注释，而在传统词典中的词条是多义词，会有多个解释。</p>
<p>所以说，“一个Synset等于的是一个词义”这一点必须反复强调。以一条词义为一条数据，是<strong>跨语言</strong>想要成立所必须的条件。</p>
<h3 id="WordNet-非重要概念"><a href="#WordNet-非重要概念" class="headerlink" title="WordNet 非重要概念"></a>WordNet 非重要概念</h3><p>这一部分内容介绍了WordNet中不太重要的概念，不影响基本使用，但有利于理解。</p>
<ol>
<li><p>独立起始概念（Unique Beginner）</p>
<p>某些同义词集不存在上位词集，那么我们称之为独立起始概念。这个可以认为是语义领域内所有概念的<strong>原始语义元素</strong>。在WordNet中名词体系中存在25个独立起始概念，例如：时间、物质、目的、关系、属性等等。其下位词继承上位词的所有特点，这与编程思想中父子类的关系类似。</p>
</li>
<li><p>词典ID（Lexicographer ID）</p>
<p>每一个同义词集都包含一个唯一的编号。</p>
</li>
<li><p>概念链（Concept Chain）</p>
<p>这里的概念链指的是同义词集间<strong>上下位关系</strong>，构成的概念链条。与上面提到的关系可视化概念类似，但其仅包含<strong>上下位关系</strong>。</p>
<p><img src="https://images0.cnblogs.com/blog/577482/201411/271433099491914.png"></p>
<p>上图内容与可视化展示相似，这里不解释。</p>
</li>
</ol>
<h3 id="WordNet文件结构简介"><a href="#WordNet文件结构简介" class="headerlink" title="WordNet文件结构简介"></a>WordNet文件结构简介</h3><p>WordNet语料库中最常用的有两个：omw与wordnet</p>
<h3 id="omw文件夹"><a href="#omw文件夹" class="headerlink" title="omw文件夹"></a>omw文件夹</h3><p>此文件夹内包含有各国家地区的研究人员基于英文WordNet构建的本国语言的WordNet，目前包含有27个国家与地区，其中cmn(简体中文)和qcn（繁体中文）与中文相关。</p>
<p>文件夹中有三个文件，分别是<em>citation.bib</em>、<em>LICENSE</em>和<em>wn-data-语言名.tab</em>。</p>
<h4 id="wn-data-cmn-tab文件"><a href="#wn-data-cmn-tab文件" class="headerlink" title="wn-data-cmn.tab文件"></a>wn-data-cmn.tab文件</h4><p>词条保存在<em>wn-data-语言名.tab</em>文件中。打开后发现，简体中文下的词条一共有79808条，繁体为8069条</p>
<blockquote>
<p>数据为两年前，目前中文词条应高于上述数据。</p>
</blockquote>
<p>如图：<img src="https://pic3.zhimg.com/80/v2-41006ed2100aa2b4db229b225f1a232e_720w.jpg"></p>
<p>文件的内容分为三列，第一列为词义的八位十进制序号（offset）（对应于上述的词典ID）和词性（n：名词、v：动词、a：形容词、r：动词）；第二列内容为“语言名：lemma”；第三列是对应语言的词义。</p>
<p>“00001740-a”的词义共包含有3个具体的词汇，分别是可以+的，有能力+的、能。</p>
<p>中文简体通过去重之后的词义数量为42312条数据。</p>
<p>WordNet中原本的此役统计数据为：名词：82115条，动词：13767条，形容词：18156条，副词：3621条，共计：117659条。大约占三分之一。</p>
<h4 id="wordnet文件"><a href="#wordnet文件" class="headerlink" title="wordnet文件"></a>wordnet文件</h4><p>此文件内包含有wordnet的本体。</p>
<blockquote>
<p>wordnet文件夹中一共有18个文件，比较重要的文件有15个。其中四个是data文件，存放四种词性的词的根本内容；四个是index文件，即索引文件；四个是exc文件，对词汇的变形进行对应；还有一个是lexnames文件，存放所有词的45个意向集（即这117659条词义，可以被归为这45个类）。</p>
</blockquote>
<p><img src="https://pic4.zhimg.com/v2-c5dbed774c162f765bc463d8e304eaa7_r.jpg"></p>
<p><strong>data.pos文件</strong></p>
<p>此文件是一个数据文件，以data.adj中able词条为例子：</p>
<p><img src="https://pic4.zhimg.com/80/v2-1827c3322b2e806c0d7c39ac1aea170f_720w.jpg"></p>
<p>上图中表示了”1740”同义词集下的able词条，其内容依次包含：词典ID、词意向集序号、词性、同义词集内词个数、指针个数、指针列表、句型、注释与例句。</p>
<p><img src="https://pic3.zhimg.com/80/v2-ab25ae65a88e5b69cc1021d465ee0fa2_720w.jpg"></p>
<p>上图是指针符号列表，用于表示此同义词集与其他同义词集的关系。</p>
<p><strong>lexnames文件</strong></p>
<p>WordNet讲英文单词归类为45个意向集，其中名词26个，动词15个，形容词3个，副词1个。</p>
<p><img src="https://pic2.zhimg.com/80/v2-9344743c81376dce4224704602f02ef9_720w.jpg"></p>
<h2 id="WordNet-API"><a href="#WordNet-API" class="headerlink" title="WordNet_API"></a>WordNet_API</h2><p>官方提供了WordNet接口用于研究与应用。其提供了基于上述数据库文件的基本使用方式：包括同义词集的获取、同义词集对应关系的获取、意向词集的获取、语义相似度的判断。</p>
<p>wordNet提供了多种维度的语义相似度接口，一共包含有6种；</p>
<ol>
<li><p>基于上下位词的最短路径,输出空间0-1.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dog.path_similarity(cat)  <span class="comment"># doctest: +ELLIPSIS</span></span><br><span class="line"><span class="number">0.2</span>...</span><br></pre></td></tr></table></figure></li>
<li><p>基于上下位词的最短路径与最大深度，其计算公式$-\log(p/2d)$.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dog.lch_similarity(cat)  <span class="comment"># doctest: +ELLIPSIS</span></span><br><span class="line"><span class="number">2.028</span>...</span><br></pre></td></tr></table></figure></li>
<li><p>基于两同义词深度与最近公共父节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dog.wup_similarity(cat)  <span class="comment"># doctest: +ELLIPSIS</span></span><br><span class="line"><span class="number">0.857</span>...</span><br></pre></td></tr></table></figure></li>
<li><p>基于两同义词深度与最近公共父节点的含义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dog.res_similarity(cat, brown_ic)  <span class="comment"># doctest: +ELLIPSIS</span></span><br><span class="line"><span class="number">7.911</span>...</span><br></pre></td></tr></table></figure>
<p>第五种与第六种与上述类似，仅仅是公式不同，这里不再赘述。</p>
</li>
</ol>
<p>可以看到WordNet利用了同义词集、同义词集网络深度等信息实现语义相似度的计算。</p>
<p>参考地址：</p>
<blockquote>
<p><a href="https://wordnet.princeton.edu/">wordnet官网</a> <br><a href="https://blog.csdn.net/weixin_30600503/article/details/97794989">wordnet的一些入门性介绍</a><br><a href="https://blog.csdn.net/skiffloveblue/article/details/9359427">wordnet词网研究</a><br><a href="https://zhuanlan.zhihu.com/p/26527203">wordnet思路</a><br><a href="http://wordnetweb.princeton.edu/perl/webwn">wordNet在线使用地址</a>  <br><a href="http://www.nltk.org/howto/wordnet.html">wordNet_API</a><br> [wordNet_可视化](</p>
</blockquote>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Wordnet</category>
      </categories>
      <tags>
        <tag>wordnet</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_Counter</title>
    <url>/2021/01/17/Python-Counter/</url>
    <content><![CDATA[<p>Counter类是一个用来<strong>统计元素频率</strong>的容器类别:</p>
<a id="more"></a>

<blockquote>
<p><a href="https://www.itread01.com/articles/1475818990.html">教学地址</a></p>
</blockquote>
<h2 id="Counter是什么"><a href="#Counter是什么" class="headerlink" title="Counter是什么?"></a>Counter是什么?</h2><p>Counter类是一个用来<strong>统计元素频率</strong>的容器类别,其是一个<strong>无序的容器</strong>类型,利用的<strong>键值对</strong>的形式存储,元素作为键,频率作为值.需要注意的是这里的频率可以为<strong>负数</strong>.</p>
<h2 id="Counter的构建"><a href="#Counter的构建" class="headerlink" title="Counter的构建"></a>Counter的构建</h2><p>Counter 提供了多种构建方式,属于符合Python风格的类别.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter() <span class="comment"># 創建一個空的Counter類</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(<span class="string">&#x27;gallahad&#x27;</span>) <span class="comment"># 從一個可iterable對象（list、tuple、dict、字符串等）創建</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;) <span class="comment"># 從一個字典對象創建</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(a=<span class="number">4</span>, b=<span class="number">2</span>) <span class="comment"># 從一組鍵值對創建</span></span><br></pre></td></tr></table></figure>
<h2 id="Counter访问空缺值"><a href="#Counter访问空缺值" class="headerlink" title="Counter访问空缺值"></a>Counter访问空缺值</h2><p>Counter实现了__missing__方法,对于没有的键值,会返回0.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(<span class="string">&quot;abcdefgab&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">&quot;a&quot;</span>]</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">&quot;c&quot;</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">&quot;h&quot;</span>]</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="Counter的更新"><a href="#Counter的更新" class="headerlink" title="Counter的更新"></a>Counter的更新</h2><h3 id="增加-update"><a href="#增加-update" class="headerlink" title="增加,update()"></a>增加,update()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(<span class="string">&#x27;which&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.update(<span class="string">&#x27;witch&#x27;</span>) <span class="comment"># 使用另一個iterable對象更新</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">&#x27;h&#x27;</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Counter(<span class="string">&#x27;watch&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.update(d) <span class="comment"># 使用另一個Counter對象更新</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">&#x27;h&#x27;</span>]</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="减少-subtract"><a href="#减少-subtract" class="headerlink" title="减少,subtract()"></a>减少,subtract()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(<span class="string">&#x27;which&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.subtract(<span class="string">&#x27;witch&#x27;</span>) <span class="comment"># 使用另一個iterable對象更新</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">&#x27;h&#x27;</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Counter(<span class="string">&#x27;watch&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.subtract(d) <span class="comment"># 使用另一個Counter對象更新</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="Counter键的删除-del"><a href="#Counter键的删除-del" class="headerlink" title="Counter键的删除:del"></a>Counter键的删除:del</h2><p>Counter类键的删除需要 使用del方法,不是使用赋值0操作.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(<span class="string">&quot;abcdcba&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">&quot;b&quot;</span>] = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">0</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> c[<span class="string">&quot;a&quot;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">Counter(&#123;<span class="string">&#x27;c&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Counter返回迭代器-elements"><a href="#Counter返回迭代器-elements" class="headerlink" title="Counter返回迭代器:elements()"></a>Counter返回迭代器:elements()</h2><p>此方法返回一个迭代器,元素重复多少次,则迭代器中包含有多少个相同元素,并且按照字母序排序.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">elements()方法Python</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(a=<span class="number">4</span>, b=<span class="number">2</span>, c=<span class="number">0</span>, d=-<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(c.elements())</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h2 id="Counter返回-TopN-列表-most-common-n"><a href="#Counter返回-TopN-列表-most-common-n" class="headerlink" title="Counter返回 TopN 列表:most_common([n])"></a>Counter返回 TopN 列表:most_common([n])</h2><p>返回一个TopN列表,如果n并没有指定,则全部返回.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.most_common()</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;r&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.most_common(<span class="number">3</span>)</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;r&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>
<h2 id="Counter中的算术操作与集合操作-amp"><a href="#Counter中的算术操作与集合操作-amp" class="headerlink" title="Counter中的算术操作与集合操作: + - &amp; |"></a>Counter中的算术操作与集合操作: + - &amp; |</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">+、-、&amp;、|操作也可以用於Counter。其中&amp;和|操作分別返回兩個Counter對象各元素的最小值和最大值。需要註意的是，得到的Counter對象將刪除小於<span class="number">1</span>的元素。</span><br><span class="line"></span><br><span class="line">Counter對象的算術和集合操作Python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(a=<span class="number">3</span>, b=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Counter(a=<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c + d <span class="comment"># c[x] + d[x]</span></span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">3</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c - d <span class="comment"># subtract（只保留正數計數的元素）</span></span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c &amp; d <span class="comment"># 交集: min(c[x], d[x])</span></span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c | d <span class="comment"># 並集: max(c[x], d[x])</span></span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span>(c.values()) <span class="comment"># 所有計數的總數</span></span><br><span class="line">c.clear() <span class="comment"># 重置Counter對象，註意不是刪除</span></span><br><span class="line"><span class="built_in">list</span>(c) <span class="comment"># 將c中的鍵轉為列表</span></span><br><span class="line"><span class="built_in">set</span>(c) <span class="comment"># 將c中的鍵轉為set</span></span><br><span class="line"><span class="built_in">dict</span>(c) <span class="comment"># 將c中的鍵值對轉為字典</span></span><br><span class="line">c.items() <span class="comment"># 轉為(elem, cnt)格式的列表</span></span><br><span class="line">Counter(<span class="built_in">dict</span>(list_of_pairs)) <span class="comment"># 從(elem, cnt)格式的列表轉換為Counter類對象</span></span><br><span class="line">c.most_common()[:-n:-<span class="number">1</span>] <span class="comment"># 取出計數最少的n個元素</span></span><br><span class="line">c += Counter() <span class="comment"># 移除0和負值</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_Logging</title>
    <url>/2021/01/17/Python-Logging/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://docs.python.org/3.7/howto/logging.html#logging-basic-tutorial">官方文档</a> <a href="https://zhuanlan.zhihu.com/p/38781838">知乎专栏</a></p>
<p>python 3.7</p>
</blockquote>
<h2 id="Logging是什么"><a href="#Logging是什么" class="headerlink" title="Logging是什么"></a>Logging是什么</h2><p>Logging包是Python的<strong>标准包</strong>之一,可用于<strong>代码事件追踪</strong>.事件也是分<strong>等级</strong>的,一般而言不同类型的<strong>事件</strong>所采用的<strong>策略</strong>是不同的.</p>
<h3 id="Logging提供的常用接口"><a href="#Logging提供的常用接口" class="headerlink" title="Logging提供的常用接口"></a>Logging提供的常用接口</h3><p>Logging针对不同等级的事件,提供了以下默认接口:debug() , info() , warning() , error() , critical().以下的表格展示了代码中<strong>事件的级别</strong>以及相应的<strong>追踪</strong>方法:</p>
<table>
<thead>
<tr>
<th>追踪任务</th>
<th>推荐使用的工具</th>
</tr>
</thead>
<tbody><tr>
<td>日常使用中<strong>展示</strong>控制台的<strong>输出</strong></td>
<td>print()</td>
</tr>
<tr>
<td>日程程序操作中<strong>报告</strong>某事件的发生</td>
<td>logging.info()/logging.debug()</td>
</tr>
<tr>
<td>程序运行时提出<strong>警告</strong>信息</td>
<td>logging.warning()/warning.warn()</td>
</tr>
<tr>
<td>程序运行时<strong>出错</strong></td>
<td>Raise exception</td>
</tr>
<tr>
<td>程序运行时<strong>出错</strong>但<strong>不抛出异常</strong></td>
<td>logging.error()/logging.exception()/logging.critical()</td>
</tr>
</tbody></table>
<p>我们发现对于不同等级的事件,对应这不同的解决方式,其有不同的名称:比如:DEBUG,INFO等.这些名称的含义如下表展示:</p>
<table>
<thead>
<tr>
<th>Level</th>
<th>When it’s used</th>
</tr>
</thead>
<tbody><tr>
<td>DEBUG</td>
<td>Detailed information, typically of interest only when diagnosing problems.</td>
</tr>
<tr>
<td>INFO</td>
<td>Confirmation that things are working as expected.</td>
</tr>
<tr>
<td>WARNING</td>
<td>An indication that something unexpected happened, or indicative of some problem in the near future (e.g. ‘disk space low’). The software is still working as expected.</td>
</tr>
<tr>
<td>ERROR</td>
<td>Due to a more serious problem, the software has not been able to perform some function.</td>
</tr>
<tr>
<td>CRITICAL</td>
<td>A serious error, indicating that the program itself may be unable to continue running.</td>
</tr>
</tbody></table>
<p>看到这里应该对<strong>事件级别</strong>有了大概的认识,logging包中默认的追踪级别时DEBUG;</p>
<p>在日常使用时,我们最常用的事件追踪方式就两种:</p>
<ol>
<li>打印到控制台;</li>
<li>写到硬盘文件中;</li>
</ol>
<h2 id="Logging的基本使用方式"><a href="#Logging的基本使用方式" class="headerlink" title="Logging的基本使用方式"></a>Logging的基本使用方式</h2><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><p>直接调用logging.debug()等接口即可,在<strong>控制台</strong>输出对应格式;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.warning(<span class="string">&#x27;Watch out!&#x27;</span>)  <span class="comment"># will print a message to the console</span></span><br><span class="line">logging.info(<span class="string">&#x27;I told you so&#x27;</span>)  <span class="comment"># will not print anything</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># WARNING:root:Watch out!</span></span><br></pre></td></tr></table></figure>
<p>上面代码只输出了warning()方法的信息,这是由于logging默认只追踪DEBUG(包括)之上的日志信息.</p>
<p>默认输出格式:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LEVEL:INFORMATION</span><br></pre></td></tr></table></figure>
<p>我们发现相较于默认的输出格式,还有一个root被输出出来,这里的root指的时logger的层次.</p>
<h4 id="输出到文件示例"><a href="#输出到文件示例" class="headerlink" title="输出到文件示例"></a>输出到文件示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(filename=<span class="string">&#x27;example.log&#x27;</span>,level=logging.DEBUG)</span><br><span class="line">logging.debug(<span class="string">&#x27;This message should go to the log file&#x27;</span>)</span><br><span class="line">logging.info(<span class="string">&#x27;So should this&#x27;</span>)</span><br><span class="line">logging.warning(<span class="string">&#x27;And this, too&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出文件内容:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">DEBUG:root:This message should go to the log file</span><br><span class="line">INFO:root:So should this</span><br><span class="line">WARNING:root:And this, too</span><br></pre></td></tr></table></figure>
<p>通过设置basicConfig()进行相关设置,细节这里不写;</p>
<h4 id="更改文件的输出格式-format关键字"><a href="#更改文件的输出格式-format关键字" class="headerlink" title="更改文件的输出格式:format关键字"></a>更改文件的输出格式:format关键字</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(<span class="built_in">format</span>=<span class="string">&#x27;%(levelname)s:%(message)s&#x27;</span>, level=logging.DEBUG)</span><br><span class="line">logging.debug(<span class="string">&#x27;This message should appear on the console&#x27;</span>)</span><br><span class="line">logging.info(<span class="string">&#x27;So should this&#x27;</span>)</span><br><span class="line">logging.warning(<span class="string">&#x27;And this, too&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出内容:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">DEBUG:This message should appear on the console</span><br><span class="line">INFO:So should this</span><br><span class="line">WARNING:And this, too</span><br></pre></td></tr></table></figure>
<h4 id="添加时间到输出格式中-asctime-s"><a href="#添加时间到输出格式中-asctime-s" class="headerlink" title="添加时间到输出格式中:%(asctime)s"></a>添加时间到输出格式中:%(asctime)s</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(<span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s %(message)s&#x27;</span>)</span><br><span class="line">logging.warning(<span class="string">&#x27;is when this event was logged.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出内容;</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">2010-12-12 11:41:42,612 is when this event was logged.</span><br></pre></td></tr></table></figure>
<h4 id="定制时间格式-datafmt关键字"><a href="#定制时间格式-datafmt关键字" class="headerlink" title="定制时间格式:datafmt关键字"></a>定制时间格式:datafmt关键字</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(<span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s %(message)s&#x27;</span>, datefmt=<span class="string">&#x27;%m/%d/%Y %I:%M:%S %p&#x27;</span>)</span><br><span class="line">logging.warning(<span class="string">&#x27;is when this event was logged.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出内容:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">12/12/2010 11:46:36 AM is when this event was logged.</span><br></pre></td></tr></table></figure>
<h3 id="format参数"><a href="#format参数" class="headerlink" title="format参数"></a>format参数</h3><p>在logging.basicConfig()方法内,format起着调整输出格式的作用.岂可选参数如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">`%(asctime)s`    表示当前时间，格式为`<span class="number">2018</span>-07-01 <span class="number">19</span>:08:<span class="number">41</span>,050`，逗号后面是毫秒</span><br><span class="line">`%(levelname)s`  表示日志级别名称</span><br><span class="line">`%(message)s`    表示日志内容</span><br><span class="line">`%(name)s`       表示日志名称（未指定则为roots）</span><br><span class="line">`%(lineno)d`     表示输出日志的代码所在行数</span><br><span class="line">`%(levelno)s`    表示数字形式的日志级别</span><br><span class="line">`%(pathname)s`   表示程序执行路径，相当于`sys.argv[<span class="number">0</span>]`</span><br><span class="line">`%(filename)s`   表示所在文件名称</span><br><span class="line">`%(funcName)s`   表示所在函数名称</span><br><span class="line">`%(thread)d`     表示当前线程ID</span><br><span class="line">`%(threadName)s` 表示当前线程名称</span><br><span class="line">`%(process)d`    表示当前进程ID</span><br><span class="line">`%(processName)s`表示当前进程名称</span><br><span class="line">`%(module)s`     表示当前模块名称</span><br><span class="line">`%(created)f`    表示UNIX标准时间浮点数表示</span><br></pre></td></tr></table></figure>
<h4 id="datefmt对时间格式进行修改"><a href="#datefmt对时间格式进行修改" class="headerlink" title="datefmt对时间格式进行修改"></a><code>datefmt</code>对时间格式进行修改</h4><p>使用例子如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(level&#x3D;logging.INFO,</span><br><span class="line">                   format&#x3D;&#39;%(asctime)s  %(message)s&#39;,</span><br><span class="line">                   datefmt&#x3D;&#39;%a, %d %b %Y %H:%M:%S +0000&#39;)</span><br><span class="line">logging.info(&#39;this is a info&#39;)</span><br></pre></td></tr></table></figure>
<p>输出结果如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Sun, 01 Jul 2018 19:19:00 +0000  this is a info</span><br></pre></td></tr></table></figure>
<p><code>datefmt</code>的格式可以参考<a href="https://link.zhihu.com/?target=https://docs.python.org/3.6/library/time.html%23time.strftime">官网表格</a></p>
<h4 id="style"><a href="#style" class="headerlink" title="style"></a>style</h4><p>默认为<code>%</code>，可选<code>&#123;</code>和<code>$</code>，他们的使用方法分别如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># %</span><br><span class="line">import logging</span><br><span class="line">logging.basicConfig(level&#x3D;logging.INFO,</span><br><span class="line">                   format&#x3D;&#39;%(asctime)s  %(message)s&#39;,</span><br><span class="line">                   datefmt&#x3D;&#39;%a, %d %b %Y %H:%M:%S +0000&#39;,</span><br><span class="line">                   style&#x3D;&#39;%&#39;)</span><br><span class="line">logging.info(&#39;this is a info&#39;)</span><br><span class="line"></span><br><span class="line"># &#123;</span><br><span class="line">import logging</span><br><span class="line">logging.basicConfig(level&#x3D;logging.INFO,</span><br><span class="line">                   format&#x3D;&#39;&#123;asctime&#125;  &#123;message&#125;&#39;,</span><br><span class="line">                   datefmt&#x3D;&#39;%a, %d %b %Y %H:%M:%S +0000&#39;,</span><br><span class="line">                   style&#x3D;&#39;&#123;&#39;)</span><br><span class="line">logging.info(&#39;this is a info&#39;)</span><br><span class="line"></span><br><span class="line"># $</span><br><span class="line">import logging</span><br><span class="line">logging.basicConfig(level&#x3D;logging.INFO,</span><br><span class="line">                   format&#x3D;&#39;$asctime  $message&#39;,</span><br><span class="line">                   datefmt&#x3D;&#39;%a, %d %b %Y %H:%M:%S +0000&#39;,</span><br><span class="line">                   style&#x3D;&#39;$&#39;)</span><br><span class="line">logging.info(&#39;this is a info&#39;)</span><br></pre></td></tr></table></figure>


<h2 id="Logging的高级使用方式"><a href="#Logging的高级使用方式" class="headerlink" title="Logging的高级使用方式"></a>Logging的高级使用方式</h2><p>高级模块无非是可以定制化log的生成,存储,具体格式等内容.上面的简单示例已经或多或少的有所触及,比如通过format关键字指定输出格式,通过filename关键字指定log存储文件地址,等等.</p>
<p>在logging中,分布有四个模块,每个模块都包含有特定的功能,分别是:logger,handler,filter,formatter;</p>
<h3 id="模块解释"><a href="#模块解释" class="headerlink" title="模块解释"></a>模块解释</h3><ul>
<li>Loggers expose the interface that application code directly uses.</li>
<li>Handlers send the log records (created by loggers) to the appropriate destination.</li>
<li>Filters provide a finer grained facility for determining which log records to output.</li>
<li>Formatters specify the layout of log records in the final output.</li>
</ul>
<p>Log事件信息会在上述四个模块间传递,最终得到你想要的log日志信息;</p>
<h4 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h4><p>Logger对象是logging的核心对象,其任务可以简单的分为产生信息并传递给下一模块,具体有三:</p>
<ol>
<li>提供了多种接口,用于<strong>运行时</strong>记录相关信息.这里说的接口与logging类一致:<strong>debug(),info(),warning(),error(),etc</strong>;</li>
<li>Logger对象可以<strong>决定处理什么等级的信息</strong>,可以通过默认关键字(level)设置或者filter对象;</li>
<li>Logger对象可以将日志信息**传递给相关对象(handler)**进行接下来的处理.</li>
</ol>
<p><strong>特点:</strong></p>
<p>Logger对象<strong>通过名称标识层次</strong>,层次间用英文句号分割.例如有三个logger其名称分别为:foo , foo.bar , foo.bar.baz,其分别扮演祖先,父母,与儿子的角色.类似于继承的概念.</p>
<p>一般情况下以当前的模块名称作为logger名称,这也就对模块的规范进行要求.以下是示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logger = logging.getLogger(__name__)</span><br></pre></td></tr></table></figure>
<p><strong>常见方法:</strong></p>
<hr>
<ul>
<li>Logger.setLevel():指定logger需要处理的最低层次信息;</li>
<li>Logger.addHandler() and Logger.removeHandler():添加与移除Handler对象</li>
<li>Logger.addFilter() and Logger.removeFilter():添加与移除Filter对象</li>
</ul>
<p>上述三个方法均具有继承性;</p>
<hr>
<ul>
<li>Logger.debug(),Logger.info(),Logger.warning(),Logger.error(),Logger.critical():产生log信息的方法.其信息均为format string,可通过替代符号”%s,%d,%d”进行设置.</li>
<li><a href="https://docs.python.org/3.7/library/logging.html#logging.Logger.exception"><code>Logger.exception()</code></a> creates a log message similar to <a href="https://docs.python.org/3.7/library/logging.html#logging.Logger.error"><code>Logger.error()</code></a>. The difference is that <a href="https://docs.python.org/3.7/library/logging.html#logging.Logger.exception"><code>Logger.exception()</code></a> dumps a stack trace along with it. Call this method only from an exception handler.</li>
<li><a href="https://docs.python.org/3.7/library/logging.html#logging.Logger.log"><code>Logger.log()</code></a> takes a log level as an explicit argument. This is a little more verbose for logging messages than using the log level convenience methods listed above, but this is how to log at custom log levels.</li>
</ul>
<hr>
<ul>
<li>getLogger():获得logger对象的方法,默认名称为root,可指定.</li>
</ul>
<h4 id="Handlers"><a href="#Handlers" class="headerlink" title="Handlers"></a>Handlers</h4><p>Handlers用来对log进行特定的分派处理,例如将某类型log发送到邮箱或存储在特定文件内.一般情况一个logger对象可以添加多个Handlers对象.   </p>
<p><strong>常见方法:</strong></p>
<ul>
<li>setLevel():设定进行<strong>dispatch</strong>的最底层事件</li>
<li>setFormatter():为handler对象选定格式对象</li>
<li>addFilter()/removeFilter():配置过滤对象</li>
</ul>
<h4 id="Formatters"><a href="#Formatters" class="headerlink" title="Formatters"></a>Formatters</h4><blockquote>
<p>这里没看懂文档解释</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>配置它们的流程是</p>
<ul>
<li>配置好的format设置到handler中</li>
<li>配置好的handler添加到logger中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># create logger</span></span><br><span class="line">logger = logging.getLogger(<span class="string">&#x27;simple_example&#x27;</span>)</span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create console handler and set level to debug</span></span><br><span class="line">ch = logging.StreamHandler()</span><br><span class="line">ch.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create formatter</span></span><br><span class="line">formatter = logging.Formatter(<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add formatter to ch</span></span><br><span class="line">ch.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add ch to logger</span></span><br><span class="line">logger.addHandler(ch)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;application&#x27; code</span></span><br><span class="line">logger.debug(<span class="string">&#x27;debug message&#x27;</span>)</span><br><span class="line">logger.info(<span class="string">&#x27;info message&#x27;</span>)</span><br><span class="line">logger.warning(<span class="string">&#x27;warn message&#x27;</span>)</span><br><span class="line">logger.error(<span class="string">&#x27;error message&#x27;</span>)</span><br><span class="line">logger.critical(<span class="string">&#x27;critical message&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2005</span>-03-<span class="number">19</span> <span class="number">15</span>:<span class="number">10</span>:<span class="number">26</span>,<span class="number">618</span> - simple_example - DEBUG - debug message</span><br><span class="line"><span class="number">2005</span>-03-<span class="number">19</span> <span class="number">15</span>:<span class="number">10</span>:<span class="number">26</span>,<span class="number">620</span> - simple_example - INFO - info message</span><br><span class="line"><span class="number">2005</span>-03-<span class="number">19</span> <span class="number">15</span>:<span class="number">10</span>:<span class="number">26</span>,<span class="number">695</span> - simple_example - WARNING - warn message</span><br><span class="line"><span class="number">2005</span>-03-<span class="number">19</span> <span class="number">15</span>:<span class="number">10</span>:<span class="number">26</span>,<span class="number">697</span> - simple_example - ERROR - error message</span><br><span class="line"><span class="number">2005</span>-03-<span class="number">19</span> <span class="number">15</span>:<span class="number">10</span>:<span class="number">26</span>,<span class="number">773</span> - simple_example - CRITICAL - critical message</span><br></pre></td></tr></table></figure>
<h4 id="创建log流程的多种方式"><a href="#创建log流程的多种方式" class="headerlink" title="创建log流程的多种方式"></a>创建log流程的多种方式</h4><blockquote>
<p>这里不一一展示</p>
</blockquote>
<ol>
<li>Creating loggers, handlers, and formatters explicitly using Python code that calls the configuration methods listed above.</li>
<li>Creating a logging config file and reading it using the <a href="https://docs.python.org/3.7/library/logging.config.html#logging.config.fileConfig"><code>fileConfig()</code></a> function.</li>
<li>Creating a dictionary of configuration information and passing it to the <a href="https://docs.python.org/3.7/library/logging.config.html#logging.config.dictConfig"><code>dictConfig()</code></a> function.</li>
</ol>
<h2 id="样例探究Logging的特点"><a href="#样例探究Logging的特点" class="headerlink" title="样例探究Logging的特点"></a>样例探究Logging的特点</h2><blockquote>
<p><a href="https://docs.python.org/3.7/howto/logging-cookbook.html">样例地址</a> 上述地址上讲解了各种情况下Logger的使用方式,不需要意义查看,针对自己的场景常看相关样例即可,这里仅介绍第一个样例.</p>
</blockquote>
<h3 id="多模块使用Logging的方式"><a href="#多模块使用Logging的方式" class="headerlink" title="多模块使用Logging的方式"></a>多模块使用Logging的方式</h3><ol>
<li>模块<strong>名称标识</strong>Logger的方式,即使在不同模块我们使用相同的名称,也会获得相同的对象;</li>
<li>不同模块间建议使用<strong>层次化模块名称</strong>,名称层次使用<strong>句号</strong>分割,主模块采用作为父名称,副模块采用子名称.</li>
<li>子模块的调用会自动传给父模块;</li>
</ol>
<p>module.py模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> auxiliary_module</span><br><span class="line"></span><br><span class="line"><span class="comment"># create logger with &#x27;spam_application&#x27;</span></span><br><span class="line">logger = logging.getLogger(<span class="string">&#x27;spam_application&#x27;</span>)</span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"><span class="comment"># create file handler which logs even debug messages</span></span><br><span class="line">fh = logging.FileHandler(<span class="string">&#x27;spam.log&#x27;</span>)</span><br><span class="line">fh.setLevel(logging.DEBUG)</span><br><span class="line"><span class="comment"># create console handler with a higher log level</span></span><br><span class="line">ch = logging.StreamHandler()</span><br><span class="line">ch.setLevel(logging.ERROR)</span><br><span class="line"><span class="comment"># create formatter and add it to the handlers</span></span><br><span class="line">formatter = logging.Formatter(<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line">fh.setFormatter(formatter)</span><br><span class="line">ch.setFormatter(formatter)</span><br><span class="line"><span class="comment"># add the handlers to the logger</span></span><br><span class="line">logger.addHandler(fh)</span><br><span class="line">logger.addHandler(ch)</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">&#x27;creating an instance of auxiliary_module.Auxiliary&#x27;</span>)</span><br><span class="line">a = auxiliary_module.Auxiliary()</span><br><span class="line">logger.info(<span class="string">&#x27;created an instance of auxiliary_module.Auxiliary&#x27;</span>)</span><br><span class="line">logger.info(<span class="string">&#x27;calling auxiliary_module.Auxiliary.do_something&#x27;</span>)</span><br><span class="line">a.do_something()</span><br><span class="line">logger.info(<span class="string">&#x27;finished auxiliary_module.Auxiliary.do_something&#x27;</span>)</span><br><span class="line">logger.info(<span class="string">&#x27;calling auxiliary_module.some_function()&#x27;</span>)</span><br><span class="line">auxiliary_module.some_function()</span><br><span class="line">logger.info(<span class="string">&#x27;done with auxiliary_module.some_function()&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>auxiliary_module.py辅助模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># create logger</span></span><br><span class="line">module_logger = logging.getLogger(<span class="string">&#x27;spam_application.auxiliary&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Auxiliary</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.logger = logging.getLogger(<span class="string">&#x27;spam_application.auxiliary.Auxiliary&#x27;</span>)</span><br><span class="line">        self.logger.info(<span class="string">&#x27;creating an instance of Auxiliary&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_something</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.logger.info(<span class="string">&#x27;doing something&#x27;</span>)</span><br><span class="line">        a = <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">        self.logger.info(<span class="string">&#x27;done doing something&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_function</span>():</span></span><br><span class="line">    module_logger.info(<span class="string">&#x27;received a call to &quot;some_function&quot;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">2020-08-14 16:51:52,747 - spam_application - INFO - creating an instance of auxiliary_module.Auxiliary</span><br><span class="line">2020-08-14 16:51:52,747 - spam_application.auxiliary.Auxiliary - INFO - creating an instance of Auxiliary</span><br><span class="line">2020-08-14 16:51:52,747 - spam_application - INFO - created an instance of auxiliary_module.Auxiliary</span><br><span class="line">2020-08-14 16:51:52,747 - spam_application - INFO - calling auxiliary_module.Auxiliary.do_something</span><br><span class="line">2020-08-14 16:51:52,748 - spam_application.auxiliary.Auxiliary - INFO - doing something</span><br><span class="line">2020-08-14 16:51:52,748 - spam_application.auxiliary.Auxiliary - INFO - done doing something</span><br><span class="line">2020-08-14 16:51:52,748 - spam_application - INFO - finished auxiliary_module.Auxiliary.do_something</span><br><span class="line">2020-08-14 16:51:52,748 - spam_application - INFO - calling auxiliary_module.some_function()</span><br><span class="line">2020-08-14 16:51:52,748 - spam_application.auxiliary - INFO - received a call to &quot;some_function&quot;</span><br><span class="line">2020-08-14 16:51:52,748 - spam_application - INFO - done with auxiliary_module.some_function()</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_OrderDict</title>
    <url>/2021/01/17/Python-OrderDict/</url>
    <content><![CDATA[<blockquote>
<p>reference Adress:<a href="https://docs.python.org/zh-cn/3/library/collections.html#ordereddict-objects">official Doc</a> <a href="https://pymotw.com/2/collections/ordereddict.html">Learning Bolg</a></p>
</blockquote>
<a id="more"></a>

<h2 id="What"><a href="#What" class="headerlink" title="What?"></a>What?</h2><p>An OrderedDict is a dictionary subclass that remembers the order in which its contents are added.<br>Compare with regular dict class, the OrderedDict remember the add sequentence and offer some functions to revise inner order;Intuitively,it more like a dict with list;</p>
<h2 id="Feature"><a href="#Feature" class="headerlink" title="Feature?"></a>Feature?</h2><h3 id="1-Remember-the-order-in-which-its-contents-are-added"><a href="#1-Remember-the-order-in-which-its-contents-are-added" class="headerlink" title="1.Remember the order in which its contents are added"></a>1.Remember the order in which its contents are added</h3><p>However Python3.7 dict has the same feature;So this feature is not matter any more;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;Regular dictionary:&#x27;</span>)</span><br><span class="line">d = &#123;&#125;</span><br><span class="line">d[<span class="string">&#x27;a&#x27;</span>] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">d[<span class="string">&#x27;b&#x27;</span>] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">d[<span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;C&#x27;</span></span><br><span class="line">d[<span class="string">&#x27;d&#x27;</span>] = <span class="string">&#x27;D&#x27;</span></span><br><span class="line">d[<span class="string">&#x27;e&#x27;</span>] = <span class="string">&#x27;E&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span> (k, v)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;\nOrderedDict:&#x27;</span>)</span><br><span class="line">d = collections.OrderedDict()</span><br><span class="line">d[<span class="string">&#x27;a&#x27;</span>] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">d[<span class="string">&#x27;b&#x27;</span>] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">d[<span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;C&#x27;</span></span><br><span class="line">d[<span class="string">&#x27;d&#x27;</span>] = <span class="string">&#x27;D&#x27;</span></span><br><span class="line">d[<span class="string">&#x27;e&#x27;</span>] = <span class="string">&#x27;E&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span> (k, v)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Regular dictionary:</span><br><span class="line">a A</span><br><span class="line">b B</span><br><span class="line">c C</span><br><span class="line">d D</span><br><span class="line">e E</span><br><span class="line"></span><br><span class="line">OrderedDict:</span><br><span class="line">a A</span><br><span class="line">b B</span><br><span class="line">c C</span><br><span class="line">d D</span><br><span class="line">e E</span><br></pre></td></tr></table></figure>
<h3 id="2-Offer-functions-to-revise-inner-order"><a href="#2-Offer-functions-to-revise-inner-order" class="headerlink" title="2.Offer functions to revise inner order"></a>2.Offer functions to revise inner order</h3><h4 id="1-popitem-last-True"><a href="#1-popitem-last-True" class="headerlink" title="1.popitem(last=True)"></a>1.popitem(last=True)</h4><p>The popitem() method for ordered dictionaries returns and removes a (key, value) pair. The pairs are returned in LIFO order if last is true or FIFO order if false.</p>
<h4 id="2-move-to-end-key-last-True"><a href="#2-move-to-end-key-last-True" class="headerlink" title="2.move_to_end(key, last=True)"></a>2.move_to_end(key, last=True)</h4><p>Move an existing key to either end of an ordered dictionary. The item is moved to the right end if last is true (the default) or to the beginning if last is false. Raises KeyError if the key does not exist:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = collections.OrderedDict.fromkeys(<span class="string">&#x27;abcde&#x27;</span>)</span><br><span class="line">d.move_to_end(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;</span>.join(d.keys())</span><br><span class="line"><span class="comment"># &#x27;acdeb&#x27;</span></span><br><span class="line"></span><br><span class="line">d.move_to_end(<span class="string">&quot;b&quot;</span> , last = <span class="literal">False</span>)</span><br><span class="line"><span class="string">&quot;&quot;</span>.join(d.keys())</span><br><span class="line"><span class="comment"># &#x27;bacde&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-order-sensitive"><a href="#3-order-sensitive" class="headerlink" title="3.order-sensitive"></a>3.order-sensitive</h3><p>A regular dict looks at its contents when testing for equality. An OrderedDict also considers the order the items were added.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;dict       :&#x27;</span>),</span><br><span class="line">d1 = &#123;&#125;</span><br><span class="line">d1[<span class="string">&#x27;a&#x27;</span>] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">d1[<span class="string">&#x27;b&#x27;</span>] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">d1[<span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;C&#x27;</span></span><br><span class="line">d1[<span class="string">&#x27;d&#x27;</span>] = <span class="string">&#x27;D&#x27;</span></span><br><span class="line">d1[<span class="string">&#x27;e&#x27;</span>] = <span class="string">&#x27;E&#x27;</span></span><br><span class="line"></span><br><span class="line">d2 = &#123;&#125;</span><br><span class="line">d2[<span class="string">&#x27;e&#x27;</span>] = <span class="string">&#x27;E&#x27;</span></span><br><span class="line">d2[<span class="string">&#x27;d&#x27;</span>] = <span class="string">&#x27;D&#x27;</span></span><br><span class="line">d2[<span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;C&#x27;</span></span><br><span class="line">d2[<span class="string">&#x27;b&#x27;</span>] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">d2[<span class="string">&#x27;a&#x27;</span>] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (d1 == d2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;OrderedDict:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d1 = collections.OrderedDict()</span><br><span class="line">d1[<span class="string">&#x27;a&#x27;</span>] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">d1[<span class="string">&#x27;b&#x27;</span>] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">d1[<span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;C&#x27;</span></span><br><span class="line">d1[<span class="string">&#x27;d&#x27;</span>] = <span class="string">&#x27;D&#x27;</span></span><br><span class="line">d1[<span class="string">&#x27;e&#x27;</span>] = <span class="string">&#x27;E&#x27;</span></span><br><span class="line"></span><br><span class="line">d2 = collections.OrderedDict()</span><br><span class="line">d2[<span class="string">&#x27;e&#x27;</span>] = <span class="string">&#x27;E&#x27;</span></span><br><span class="line">d2[<span class="string">&#x27;d&#x27;</span>] = <span class="string">&#x27;D&#x27;</span></span><br><span class="line">d2[<span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;C&#x27;</span></span><br><span class="line">d2[<span class="string">&#x27;b&#x27;</span>] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">d2[<span class="string">&#x27;a&#x27;</span>] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (d1 == d2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dict       :</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># OrderedDict:</span></span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples?"></a>Examples?</h2><p>LRU function can be easility finished by OrderedDict.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>(<span class="params">OrderedDict</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity</span>):</span></span><br><span class="line">        </span><br><span class="line">        self.capacity = capacity</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">return</span> - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        self.move_to_end(key)</span><br><span class="line">        <span class="keyword">return</span> self[key]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self:</span><br><span class="line">            self.move_to_end(key)</span><br><span class="line">        self[key] = value</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self) &gt; self.capacity:</span><br><span class="line">            self.popitem(last = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_del与弱引用</title>
    <url>/2021/01/17/Python-del%E4%B8%8E%E5%BC%B1%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>相似概念</p>
<a id="more"></a>

<h2 id="del的用处"><a href="#del的用处" class="headerlink" title="del的用处"></a>del的用处</h2><p><strong>del 删除的是名称变量，而不是对象</strong>。del可能会导致垃圾回收，但是仅当删除的变量保存的是对象最后一个引用时，或者无法得到对象时。重新绑定也有可能导致对象的引用变量数量归零，导致对象被销毁。</p>
<h2 id="弱引用含义"><a href="#弱引用含义" class="headerlink" title="弱引用含义"></a>弱引用含义</h2><p>弱引用就是在引用的同时不增加引用的数量，通常用于<strong>缓存</strong>中，也就是说弱引用不妨碍垃圾回收。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_dict与set</title>
    <url>/2021/01/17/Python-dict%E4%B8%8Eset/</url>
    <content><![CDATA[<p>Python中的字典类与集合类其内部均采用<strong>散列表</strong>实现，查询速度不受规模影响。</p>
<a id="more"></a>

<h2 id="字典类"><a href="#字典类" class="headerlink" title="字典类"></a>字典类</h2><h3 id="丰富的字典构建方法"><a href="#丰富的字典构建方法" class="headerlink" title="丰富的字典构建方法"></a>丰富的字典构建方法</h3><p><strong>普通构建方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">dict</span>(one = <span class="number">1</span> , two = <span class="number">2</span> , three = <span class="number">3</span>)</span><br><span class="line">b = &#123;<span class="string">&quot;one&quot;</span> : <span class="number">1</span> , <span class="string">&quot;two&quot;</span> : <span class="number">2</span> , <span class="string">&quot;three&quot;</span> : <span class="number">3</span>&#125;</span><br><span class="line">c = <span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&quot;one&quot;</span> , <span class="string">&quot;two&quot;</span> , <span class="string">&quot;three&quot;</span>] , [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br><span class="line">d = <span class="built_in">dict</span>([(<span class="string">&quot;two&quot;</span> , <span class="number">2</span>) , (<span class="string">&quot;one&quot;</span> , <span class="number">1</span>) , (<span class="string">&quot;three&quot;</span> , <span class="number">3</span>)])</span><br><span class="line">e = <span class="built_in">dict</span>(&#123;<span class="string">&quot;three&quot;</span> : <span class="number">3</span> , <span class="string">&quot;one&quot;</span>:<span class="number">1</span> , <span class="string">&quot;two&quot;</span>:<span class="number">2</span>&#125;)</span><br><span class="line">print(a == b == c == d ==e)</span><br></pre></td></tr></table></figure>
<p>上面的构建方法虽然是多样的，但是其键的插入顺序存在不同，如果产生哈希冲突，那么键的顺序会产生偏差。后半节会进行展示。</p>
<p><strong>字典推导构建字典</strong></p>
<p>用法与列表推导很像，这里不解释。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DIAL_CODES = [</span><br><span class="line">        (<span class="number">86</span>, <span class="string">&#x27;China&#x27;</span>),</span><br><span class="line">        (<span class="number">91</span>, <span class="string">&#x27;India&#x27;</span>),</span><br><span class="line">        (<span class="number">1</span>, <span class="string">&#x27;United States&#x27;</span>),</span><br><span class="line">        (<span class="number">62</span>, <span class="string">&#x27;Indonesia&#x27;</span>),</span><br><span class="line">        (<span class="number">55</span>, <span class="string">&#x27;Brazil&#x27;</span>),</span><br><span class="line">        (<span class="number">92</span>, <span class="string">&#x27;Pakistan&#x27;</span>),</span><br><span class="line">        (<span class="number">880</span>, <span class="string">&#x27;Bangladesh&#x27;</span>),</span><br><span class="line">        (<span class="number">234</span>, <span class="string">&#x27;Nigeria&#x27;</span>),</span><br><span class="line">        (<span class="number">7</span>, <span class="string">&#x27;Russia&#x27;</span>),</span><br><span class="line">        (<span class="number">81</span>, <span class="string">&#x27;Japan&#x27;</span>),</span><br><span class="line">    ]</span><br><span class="line">country_code = &#123;code:country.upper() <span class="keyword">for</span> code ,country <span class="keyword">in</span> DIAL_CODES&#125;</span><br><span class="line">print(country_code)</span><br><span class="line"><span class="comment"># &#123;86: &#x27;CHINA&#x27;, 91: &#x27;INDIA&#x27;, 1: &#x27;UNITED STATES&#x27;, 62: &#x27;INDONESIA&#x27;, 55: &#x27;BRAZIL&#x27;, 92: &#x27;PAKISTAN&#x27;, 880: &#x27;BANGLADESH&#x27;, 234: &#x27;NIGERIA&#x27;, 7: &#x27;RUSSIA&#x27;, 81: &#x27;JAPAN&#x27;&#125;</span></span><br><span class="line">country_code = &#123;country:code <span class="keyword">for</span> code ,country <span class="keyword">in</span> DIAL_CODES&#125;</span><br><span class="line">print(country_code)</span><br><span class="line"><span class="comment"># &#123;&#x27;China&#x27;: 86, &#x27;India&#x27;: 91, &#x27;United States&#x27;: 1, &#x27;Indonesia&#x27;: 62, &#x27;Brazil&#x27;: 55, &#x27;Pakistan&#x27;: 92, &#x27;Bangladesh&#x27;: 880, &#x27;Nigeria&#x27;: 234, &#x27;Russia&#x27;: 7, &#x27;Japan&#x27;: 81&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="如何处理找不到的键"><a href="#如何处理找不到的键" class="headerlink" title="如何处理找不到的键"></a>如何处理找不到的键</h3><p>首先介绍几个字典类关键方法与解释，方便接下来的理解；</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>d.default_factory</td>
<td>在__missing__函数中被调用的函数，用于给未找到的元素设置值</td>
</tr>
<tr>
<td>d.get(k , [default])</td>
<td>返回键k对应的值，如果字典里没有键k，则返回None或者default</td>
</tr>
<tr>
<td>d.__getitem__(k)</td>
<td>让字典d能用d[k]的形式返回键k对应的值</td>
</tr>
<tr>
<td>d.__missing__(k)</td>
<td>当__getitem__找不到对应键的时候，则调用此方法</td>
</tr>
<tr>
<td>d.__setdefault(k,[default])</td>
<td>若字典中有键k，则直接返回k所对应的值；若无，则使d[k] = default，然后返回default</td>
</tr>
</tbody></table>
<h4 id="利用get-k-default"><a href="#利用get-k-default" class="headerlink" title="利用get(k , default)"></a>利用get(k , default)</h4><p>以下代码实现了利用字典记录词与词频的记录，在键缺失时，采用get()方法进行处理，但是一般来说get的效率很低。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">WORD_RE = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line">index = &#123;&#125;</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(sys.argv[<span class="number">0</span>], encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="keyword">for</span> line_no, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(fp, <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> match <span class="keyword">in</span> WORD_RE.finditer(line):</span><br><span class="line">            word = match.group()</span><br><span class="line">            column_no = match.start()+<span class="number">1</span></span><br><span class="line">            location = (line_no, column_no)</span><br><span class="line">            <span class="comment"># this is ugly; coded like this to make a point</span></span><br><span class="line">            occurrences = index.get(word, [])  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">            occurrences.append(location)       <span class="comment"># &lt;2&gt;</span></span><br><span class="line">            index[word] = occurrences          <span class="comment"># &lt;3&gt;</span></span><br><span class="line"><span class="comment"># print in alphabetical order</span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> <span class="built_in">sorted</span>(index, key=<span class="built_in">str</span>.upper):  <span class="comment"># &lt;4&gt;</span></span><br><span class="line">    print(word, index[word])</span><br><span class="line"><span class="comment"># END INDEX0</span></span><br></pre></td></tr></table></figure>
<ol>
<li>获得键word的值，没有则返回[ ]</li>
<li>添加新的位置信息到变量中</li>
<li>将此变量赋值给地点对应键</li>
<li>依次打印词与词位置信息</li>
</ol>
<h4 id="利用setdefault方法"><a href="#利用setdefault方法" class="headerlink" title="利用setdefault方法"></a>利用setdefault方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">WORD_RE = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line">index = &#123;&#125;</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(sys.argv[<span class="number">0</span>], encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="keyword">for</span> line_no, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(fp, <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> match <span class="keyword">in</span> WORD_RE.finditer(line):</span><br><span class="line">            word = match.group()</span><br><span class="line">            column_no = match.start()+<span class="number">1</span></span><br><span class="line">            location = (line_no, column_no)</span><br><span class="line">            index.setdefault(word, []).append(location)  <span class="comment"># &lt;1&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print in alphabetical order</span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> <span class="built_in">sorted</span>(index, key=<span class="built_in">str</span>.upper):</span><br><span class="line">    print(word, index[word])</span><br></pre></td></tr></table></figure>
<p>上面代码中仅使用了一条语句就实现的相关功能，这是所提倡的方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict.setdefault(key , []).append(new_value)</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> my_dict:</span><br><span class="line">	my_dict[key] = []</span><br><span class="line">my_dict[key].append(new_value)</span><br></pre></td></tr></table></figure>
<h4 id="利用defaultdict类实现"><a href="#利用defaultdict类实现" class="headerlink" title="利用defaultdict类实现"></a>利用defaultdict类实现</h4><p>collection.defaultdict类的特点在于，在用户创建对象的时候就可以给它<strong>配置一个找不到键值时创造默认值的方法</strong>。通俗将就是在初始化对象时，参数为一个可以调用的方法，此方法在找不到键值时调用。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dd = defaultdict(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<p>如果键值不存在时其会进行接下来的流程：</p>
<ol>
<li>调用list() 构建一个新的列表</li>
<li>新列表作为值，new_value作为键，加入字典中</li>
<li>返回新列表的索引</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">WORD_RE = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\w+&#x27;</span>)</span><br><span class="line"><span class="comment"># 构建一个默认形式的字典</span></span><br><span class="line">index = collections.defaultdict(<span class="built_in">list</span>)     <span class="comment"># &lt;1&gt;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(sys.argv[<span class="number">0</span>], encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="keyword">for</span> line_no, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(fp, <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> match <span class="keyword">in</span> WORD_RE.finditer(line):</span><br><span class="line">            word = match.group()</span><br><span class="line">            column_no = match.start()+<span class="number">1</span></span><br><span class="line">            location = (line_no, column_no)</span><br><span class="line">            <span class="comment"># 代码逻辑看不到差别，透明性</span></span><br><span class="line">            index[word].append(location)  <span class="comment"># &lt;2&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print in alphabetical order</span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> <span class="built_in">sorted</span>(index, key=<span class="built_in">str</span>.upper):</span><br><span class="line">    print(word, index[word])</span><br></pre></td></tr></table></figure>
<h4 id="实现字典子类并重写-missing-方法"><a href="#实现字典子类并重写-missing-方法" class="headerlink" title="实现字典子类并重写 __missing__方法"></a>实现字典子类并重写 __missing__方法</h4><p>当__getitem__找不到对应键的时候，则调用此方法，而__getitem__在dict[key]是进行调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrKeyDict0</span>(<span class="params"><span class="built_in">dict</span></span>):</span>  <span class="comment"># &lt;1&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(key, <span class="built_in">str</span>):  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">        <span class="keyword">return</span> self[<span class="built_in">str</span>(key)]  <span class="comment"># &lt;3&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key, default=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]  <span class="comment"># &lt;4&gt;</span></span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">return</span> default  <span class="comment"># &lt;5&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> self.keys() <span class="keyword">or</span> <span class="built_in">str</span>(key) <span class="keyword">in</span> self.keys()  <span class="comment"># &lt;6&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中实现了字典的子类及相关方法，这里不解释，可在具体应用时操作。</p>
<h3 id="字典的变种"><a href="#字典的变种" class="headerlink" title="字典的变种"></a>字典的变种</h3><p>字典的变种很多，或多或少也接触过。collection.OrderDict\collection.ChainMap\collection.Counter等，不一一解释，用时自然知道。</p>
<h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><p><strong>集合是唯一对象的聚集。</strong>在日常使用中较少，其内部实现结构也是散列表。在集合中包含有两个重要的类别：set与frozenset.其存在一个重要的差别就是：frozenset是可散列的，set是不可散列的。而集合的元素要求是需要散列的。也就是说set的元素可以是forzenset，反之不可以。</p>
<p>上面说的散列就是指的hash()方法，可以哈希则表明hash(key)是不可变的，而set会产生变化，自然不能hash().</p>
<h3 id="集合的构造"><a href="#集合的构造" class="headerlink" title="集合的构造"></a>集合的构造</h3><h4 id="普通构建"><a href="#普通构建" class="headerlink" title="普通构建"></a>普通构建</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 经典构建</span></span><br><span class="line">s = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment"># &#123;1, 2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 空集的构建</span></span><br><span class="line">s = <span class="built_in">set</span>()</span><br><span class="line"><span class="comment"># set()</span></span><br></pre></td></tr></table></figure>
<h4 id="利用字面量构建"><a href="#利用字面量构建" class="headerlink" title="利用字面量构建"></a>利用字面量构建</h4><p>这里的字面量就是数学表达式的方式，除了空集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字面量构建</span></span><br><span class="line">s = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<h4 id="集合推导"><a href="#集合推导" class="headerlink" title="集合推导"></a>集合推导</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> name</span><br><span class="line">print(&#123; <span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>,<span class="number">256</span>) <span class="keyword">if</span> <span class="string">&quot;SIGN&quot;</span> <span class="keyword">in</span> name(<span class="built_in">chr</span>(i) , <span class="string">&quot;&quot;</span>)&#125;)</span><br><span class="line"><span class="comment"># &#123;&#x27;&gt;&#x27;, &#x27;±&#x27;, &#x27;÷&#x27;, &#x27;+&#x27;, &#x27;¤&#x27;, &#x27;£&#x27;, &#x27;&lt;&#x27;, &#x27;©&#x27;, &#x27;$&#x27;, &#x27;¶&#x27;, &#x27;#&#x27;, &#x27;¥&#x27;, &#x27;×&#x27;, &#x27;µ&#x27;, &#x27;¬&#x27;, &#x27;=&#x27;, &#x27;°&#x27;, &#x27;%&#x27;, &#x27;¢&#x27;, &#x27;®&#x27;, &#x27;§&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="dict与set背后的机制"><a href="#dict与set背后的机制" class="headerlink" title="dict与set背后的机制"></a>dict与set背后的机制</h2><p>只介绍dict即可。我们知道字典的背后机制是散列表，而散列表是一种稀疏数组。理想的散列函数应当保证整体的均衡性，也就是说<strong>越相似的散列值，其结果偏差越大</strong>。散列的解决冲突算法采用了再散列法。</p>
<h3 id="键必须是可散列的"><a href="#键必须是可散列的" class="headerlink" title="键必须是可散列的"></a>键必须是可散列的</h3><ol>
<li>支持hash()函数，并且散列值不可变；</li>
<li>支持通过__eq__()方法检测相等性；</li>
<li>若a == b ,则 hash(a) == hash(b)</li>
</ol>
<h3 id="字典内存开销大"><a href="#字典内存开销大" class="headerlink" title="字典内存开销大"></a>字典内存开销大</h3><p>首先需要保证字典是一个稀疏的数组，那么其空间效率低下；</p>
<h3 id="键查询快"><a href="#键查询快" class="headerlink" title="键查询快"></a>键查询快</h3><p>不解释</p>
<h3 id="键的次序却决于添加顺序"><a href="#键的次序却决于添加顺序" class="headerlink" title="键的次序却决于添加顺序"></a>键的次序却决于添加顺序</h3><p>这是由于大量元素插入过程中，不可避免的会产生冲突。不同顺序会导致差别。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BEGIN DIALCODES</span></span><br><span class="line"><span class="comment"># dial codes of the top 10 most populous countries</span></span><br><span class="line">DIAL_CODES = [</span><br><span class="line">        (<span class="number">86</span>, <span class="string">&#x27;China&#x27;</span>),</span><br><span class="line">        (<span class="number">91</span>, <span class="string">&#x27;India&#x27;</span>),</span><br><span class="line">        (<span class="number">1</span>, <span class="string">&#x27;United States&#x27;</span>),</span><br><span class="line">        (<span class="number">62</span>, <span class="string">&#x27;Indonesia&#x27;</span>),</span><br><span class="line">        (<span class="number">55</span>, <span class="string">&#x27;Brazil&#x27;</span>),</span><br><span class="line">        (<span class="number">92</span>, <span class="string">&#x27;Pakistan&#x27;</span>),</span><br><span class="line">        (<span class="number">880</span>, <span class="string">&#x27;Bangladesh&#x27;</span>),</span><br><span class="line">        (<span class="number">234</span>, <span class="string">&#x27;Nigeria&#x27;</span>),</span><br><span class="line">        (<span class="number">7</span>, <span class="string">&#x27;Russia&#x27;</span>),</span><br><span class="line">        (<span class="number">81</span>, <span class="string">&#x27;Japan&#x27;</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">d1 = <span class="built_in">dict</span>(DIAL_CODES)  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">print(<span class="string">&#x27;d1:&#x27;</span>, d1.keys())</span><br><span class="line">d2 = <span class="built_in">dict</span>(<span class="built_in">sorted</span>(DIAL_CODES))  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">print(<span class="string">&#x27;d2:&#x27;</span>, d2.keys())</span><br><span class="line">d3 = <span class="built_in">dict</span>(<span class="built_in">sorted</span>(DIAL_CODES, key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>]))  <span class="comment"># &lt;3&gt;</span></span><br><span class="line">print(<span class="string">&#x27;d3:&#x27;</span>, d3.keys())</span><br><span class="line"><span class="keyword">assert</span> d1 == d2 <span class="keyword">and</span> d2 == d3  <span class="comment"># &lt;4&gt;</span></span><br><span class="line"><span class="comment"># END DIALCODES</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># BEGIN DIALCODES_OUTPUT</span></span><br><span class="line"><span class="string">d1: dict_keys([880, 1, 86, 55, 7, 234, 91, 92, 62, 81])</span></span><br><span class="line"><span class="string">d2: dict_keys([880, 1, 91, 86, 81, 55, 234, 7, 92, 62])</span></span><br><span class="line"><span class="string">d3: dict_keys([880, 81, 1, 86, 55, 7, 234, 91, 92, 62])</span></span><br><span class="line"><span class="string"># END DIALCODES_OUTPUT</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="新键的添加可能影响原键的顺序"><a href="#新键的添加可能影响原键的顺序" class="headerlink" title="新键的添加可能影响原键的顺序"></a>新键的添加可能影响原键的顺序</h3><p>这是一个之前的盲点，无论何时往字典里添加新的键，Python解释器都可能做出为字典扩容的决定。扩容则导致新建一个更大的散列表，并将字典里已有的元素添加到新表里。这个过程可能产生新的散列冲突，导致次序变化。</p>
<p>由此可知，<strong>不可以对字典同时进行迭代与修改</strong>。</p>
<p>如果对字典同时进行迭代与修改，如果想要扫描并修改一个字典，最好分成两步：先对字典迭代，得出需要添加的内容，放入新字典；迭代结束后，对原字典更新。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_else块</title>
    <url>/2021/01/17/Python-else%E5%9D%97/</url>
    <content><![CDATA[<p>else简单也不简单:</p>
<a id="more"></a>

<blockquote>
<p><a href="15%E7%AB%A0%E8%8A%82">流畅的Python</a></p>
</blockquote>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h2><ul>
<li>作为排他性质的关键字: if else情况</li>
<li>作为标识正常运行结束的关键字:for else , while else , try else<ul>
<li>:如果异常或者return\break或continue语句导致控制权跳到了复合语句主块之外,else语句也会被跳过.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_metaclasses</title>
    <url>/2021/01/17/Python-metaclasses/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python">BlogAddress</a></p>
</blockquote>
<p>元类概念在平时的使用中是很少涉及到的，其核心理解概括为一句话就是<strong>类的类</strong>。在Python中我们常见的就是构建一个类，并且实例化这个类，并继续相关的操作。而类本身其实也是一个对象，其是元类的示例。 上面给定的博客地址就是讲的很详细，如果需要的化再去做相关的文档好了。</p>
<a id="more"></a>

<p>记住三点：</p>
<ol>
<li>元类是类的类</li>
<li>type()是一个元类，我们可以利用其构建类实例</li>
<li>平时很少用，装饰器可以满足其大部分应用。</li>
</ol>
<h2 id="1-Background-Knowledge"><a href="#1-Background-Knowledge" class="headerlink" title="1. Background Knowledge"></a>1. Background Knowledge</h2><h2 id="2-What-is-metaclasses"><a href="#2-What-is-metaclasses" class="headerlink" title="2. What is metaclasses ?"></a>2. What is metaclasses ?</h2><h2 id="3-How-to-use-metaclasses"><a href="#3-How-to-use-metaclasses" class="headerlink" title="3. How to use metaclasses"></a>3. How to use metaclasses</h2><h2 id="4-Custom-your-metaclasses"><a href="#4-Custom-your-metaclasses" class="headerlink" title="4.Custom your metaclasses"></a>4.Custom your metaclasses</h2><h2 id="5-advice"><a href="#5-advice" class="headerlink" title="5.advice"></a>5.advice</h2>]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_heapq类</title>
    <url>/2021/01/17/Python-heapq%E7%B1%BB/</url>
    <content><![CDATA[<p>Python官方提供的最小堆类:</p>
<a id="more"></a>

<blockquote>
<p><a href="https://docs.python.org/3.8/library/heapq.html">官方文档</a></p>
<p><a href="https://www.cnblogs.com/xiaobingqianrui/p/8487840.html">博客</a></p>
</blockquote>
<h2 id="heapq类是什么"><a href="#heapq类是什么" class="headerlink" title="heapq类是什么"></a>heapq类是什么</h2><ol>
<li><p>heapq本身是heap queue algorithm的缩略简称。</p>
</li>
<li><p>是Python官方提供的最小堆类</p>
<ul>
<li>提供了常见的操作函数</li>
<li>易于实现堆排序，优先队列等应用</li>
</ul>
</li>
</ol>
<h2 id="初始化与相关函数介绍"><a href="#初始化与相关函数介绍" class="headerlink" title="初始化与相关函数介绍"></a>初始化与相关函数介绍</h2><h3 id="堆的初始化"><a href="#堆的初始化" class="headerlink" title="堆的初始化"></a>堆的初始化</h3><p>堆实质就是一种理论上为树，物理上为列表的一种数据结构。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建一个空堆就是一个空列表</span></span><br><span class="line">emptyHeap = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建一个非空堆利用 heap.heapify()</span></span><br><span class="line"></span><br><span class="line">originalList = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span> , <span class="number">0</span> , -<span class="number">8</span>)]</span><br><span class="line">print(<span class="string">&quot;Before heapify: &quot;</span>,originalList)</span><br><span class="line">heapq.heapify(originalList) <span class="comment"># 注意heap.heapify()方法原地修改了list对象，而没有返回一个新的列表</span></span><br><span class="line">print(<span class="string">&quot;After heapify: &quot;</span>,originalList)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Before heapify:  [100, 92, 84, 76, 68, 60, 52, 44, 36, 28, 20, 12, 4]</span></span><br><span class="line"><span class="comment"># After heapify:  [4, 20, 12, 36, 28, 60, 52, 44, 76, 92, 68, 84, 100]</span></span><br></pre></td></tr></table></figure>
<h3 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h3><table>
<thead>
<tr>
<th>函数名称</th>
<th>函数作用</th>
</tr>
</thead>
<tbody><tr>
<td>heapq.heappush(heap,item)</td>
<td>堆插入，并进行堆调整（保持了最小堆）</td>
</tr>
<tr>
<td>heapq.heappop(heap)</td>
<td>pop堆顶元素，并返回，进行堆调整（保持了最小堆）</td>
</tr>
<tr>
<td>heapq.heappushpop(heap,item)</td>
<td>先push然后pop堆顶元素，并返回此元素，进行堆调整</td>
</tr>
<tr>
<td>heapq.heapify(x)</td>
<td>将list列表转换为最小堆</td>
</tr>
<tr>
<td>heapq.heapreplace(heap,item)</td>
<td>先pop，返回了此元素 ， 然后push item元素，进行堆调整</td>
</tr>
<tr>
<td>heapq.merge(*iterables , key= None , reverse = False)</td>
<td>合并多个堆，并返回结果</td>
</tr>
<tr>
<td>heapq.nlargest(n ,iterable , key=None)</td>
<td>返回可迭代对象的前N个大的元素，从大到小排序</td>
</tr>
<tr>
<td>heapq.nsmallest(n , iterable , key=None)</td>
<td>返回可迭代对象的前N个小的元素，从小到大排序</td>
</tr>
</tbody></table>
<p><strong>函数功能简单展示：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">originalList = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span> , <span class="number">0</span> , -<span class="number">8</span>)]</span><br><span class="line">print(<span class="string">&quot;Before heapify: &quot;</span>,originalList)</span><br><span class="line">heapq.heapify(originalList)</span><br><span class="line">print(<span class="string">&quot;After heapify: &quot;</span>,originalList)</span><br><span class="line">heapq.heappush(originalList , <span class="number">1</span>)</span><br><span class="line">print(<span class="string">&quot;After heappush: &quot;</span> , originalList)</span><br><span class="line">smallest = heapq.heappop(originalList)</span><br><span class="line">print(<span class="string">&quot;smallest elements is: &quot;</span> , smallest)</span><br><span class="line">secondSmall = heapq.heappushpop(originalList , <span class="number">1000</span>)</span><br><span class="line">print(<span class="string">&quot;After heappushpop&quot;</span>, originalList)</span><br><span class="line">print(<span class="string">&quot;second small element is: &quot;</span> , secondSmall)</span><br><span class="line">secondSmall = heapq.heapreplace(originalList , <span class="number">45</span>)</span><br><span class="line">print(<span class="string">&quot;After heapreplace&quot;</span>, originalList)</span><br><span class="line">print(<span class="string">&quot;second small element is: &quot;</span> , secondSmall)</span><br><span class="line">print(<span class="string">&quot;top 3 big elements is: &quot;</span> , heapq.nlargest(<span class="number">3</span>,originalList))</span><br><span class="line">print(<span class="string">&quot;top 3 small elements is:&quot;</span>, heapq.nsmallest(<span class="number">3</span>,originalList))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Before heapify:  [<span class="number">100</span>, <span class="number">92</span>, <span class="number">84</span>, <span class="number">76</span>, <span class="number">68</span>, <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>]</span><br><span class="line">After heapify:  [<span class="number">4</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">76</span>, <span class="number">92</span>, <span class="number">68</span>, <span class="number">84</span>, <span class="number">100</span>]</span><br><span class="line">After heappush:  [<span class="number">1</span>, <span class="number">20</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">60</span>, <span class="number">12</span>, <span class="number">44</span>, <span class="number">76</span>, <span class="number">92</span>, <span class="number">68</span>, <span class="number">84</span>, <span class="number">100</span>, <span class="number">52</span>]</span><br><span class="line">smallest elements <span class="keyword">is</span>:  <span class="number">1</span></span><br><span class="line">After heappushpop [<span class="number">12</span>, <span class="number">20</span>, <span class="number">52</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">60</span>, <span class="number">1000</span>, <span class="number">44</span>, <span class="number">76</span>, <span class="number">92</span>, <span class="number">68</span>, <span class="number">84</span>, <span class="number">100</span>]</span><br><span class="line">second small element <span class="keyword">is</span>:  <span class="number">4</span></span><br><span class="line">After heapreplace [<span class="number">20</span>, <span class="number">28</span>, <span class="number">52</span>, <span class="number">36</span>, <span class="number">45</span>, <span class="number">60</span>, <span class="number">1000</span>, <span class="number">44</span>, <span class="number">76</span>, <span class="number">92</span>, <span class="number">68</span>, <span class="number">84</span>, <span class="number">100</span>]</span><br><span class="line">second small element <span class="keyword">is</span>:  <span class="number">12</span></span><br><span class="line">top <span class="number">3</span> big elements <span class="keyword">is</span>:  [<span class="number">1000</span>, <span class="number">100</span>, <span class="number">92</span>]</span><br><span class="line">top <span class="number">3</span> small elements <span class="keyword">is</span>: [<span class="number">20</span>, <span class="number">28</span>, <span class="number">36</span>]</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappop , heappush</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapsort</span>(<span class="params">iterable</span>):</span></span><br><span class="line">     h = []</span><br><span class="line">     <span class="keyword">for</span> value <span class="keyword">in</span> iterable:</span><br><span class="line">         heappush(h, value)</span><br><span class="line">     <span class="keyword">return</span> [heappop(h) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(h))]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">heapsort([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>])</span><br><span class="line"><span class="comment">#[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_new与init</title>
    <url>/2021/01/17/Python-new%E4%B8%8Einit/</url>
    <content><![CDATA[<p>乍看一下上面两个方法功能相似，但其是其存在区别。</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__new__方法：用来构造一个类实例；</span><br><span class="line">__init__方法：用于初始化一个实例；</span><br></pre></td></tr></table></figure>
<p>那么从上面的差别来看，很明显需要首先调用new方法，构造实例后，才能够调用init初始化该实例。</p>
<p><strong>两个方法的参数差异：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__new__：方法用于构造实例，调用方法时传入的是类(CLS)，而非实例(INSTANCE)；</span><br><span class="line">__init__:方法用于初始化实例，调用方法时传入的是实例（INSTANCE）</span><br></pre></td></tr></table></figure>


<h2 id="相关知识：旧类与新类"><a href="#相关知识：旧类与新类" class="headerlink" title="相关知识：旧类与新类"></a>相关知识：旧类与新类</h2><p>在Python2中存在旧类与新类的概念，其中旧类指的是继承自type元类的类，而新类是继承自object类的类。</p>
<p>旧类代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">oldStyleClass</span>:</span> <span class="comment"># inherits from &#x27;type&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>新类代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">newStyleClass</span>(<span class="params"><span class="built_in">object</span></span>):</span> <span class="comment"># explicitly inherits from &#x27;object&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>在Python3中所有类默认继承自object，并不需要object作为基类；</p>
<p>我们现在就了解Python2中存在旧类与新类，他们只是继承的父类不同，那么也就继承了父类的方法与属性；相应的对new与init方法存在差异。</p>
<h2 id="Python旧类中两方法的差异"><a href="#Python旧类中两方法的差异" class="headerlink" title="Python旧类中两方法的差异"></a>Python旧类中两方法的差异</h2><ul>
<li>旧类中没有new方法，其init方法起到了构造的作用；</li>
<li>旧类中init方法的返回值无法进行控制；</li>
</ul>
<p><strong>定义一个旧类</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">oldStyleClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__new__ is called&quot;</span>) <span class="comment"># this line will never get called during construction</span></span><br><span class="line"></span><br><span class="line">oldStyleClass()</span><br><span class="line"><span class="comment"># &lt;__main__.oldStyleClass instance at 0x0000000003C1A5C8&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到即使，我们构造了一个new方法，在旧类的初始化过程中仍然不会调用它；</p>
<p><strong>重载init方法时：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">oldStyleClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__new__ is called&quot;</span>) <span class="comment"># this line will never get called during construction</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self)</span><br><span class="line">        print(<span class="string">&quot;init is called&quot;</span>)</span><br><span class="line"></span><br><span class="line">oldStyleClass()</span><br><span class="line"><span class="comment"># &lt;__main__.oldStyleClass instance at 0x0000000003C2AE48&gt;</span></span><br><span class="line"><span class="comment"># init is called</span></span><br><span class="line"><span class="comment"># &lt;__main__.oldStyleClass instance at 0x0000000003C2AE48&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们发现在函数的一开始就已经构造好了实例，并且返回了实例；</p>
<p><strong>带返回值的init:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class oldStyleClass:</span><br><span class="line">    def __new__(cls):</span><br><span class="line">        print(&quot;__new__ is called&quot;) # this line will never get called during construction</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(self)</span><br><span class="line">        print(&quot;init is called&quot;)</span><br><span class="line">        return 12</span><br><span class="line"></span><br><span class="line">oldStyleClass()</span><br><span class="line"># &lt;__main__.oldStyleClass instance at 0x00000000053BD708&gt;</span><br><span class="line"># init is called</span><br><span class="line"># TypeError: __init__() should return None</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在旧类中无法控制，init的返回值。</p>
<h2 id="Python新类中两方法差异"><a href="#Python新类中两方法差异" class="headerlink" title="Python新类中两方法差异"></a>Python新类中两方法差异</h2><p>Python的新类允许用户重载<code>__new__</code>和<code>__init__</code>方法，且这两个方法具有不同的作用。<code>__new__</code>作为构造器，起创建一个类实例的作用。而<code>__init__</code>作为初始化器，起初始化一个已被创建的实例的作用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">newStyleClass</span>(<span class="params"><span class="built_in">object</span></span>):</span> </span><br><span class="line">    <span class="comment"># In Python2, we need to specify the object as the base.</span></span><br><span class="line">    <span class="comment"># In Python3 it&#x27;s default.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__new__ is called&quot;</span>)</span><br><span class="line">        print(cls)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(newStyleClass, cls).__new__(cls)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__init__ is called&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;self is: &quot;</span>, self)</span><br><span class="line"></span><br><span class="line">newStyleClass()</span><br><span class="line"><span class="comment"># __new__ is called</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;__main__.newStyleClass&#x27;&gt;</span></span><br><span class="line"><span class="comment"># __init__ is called</span></span><br><span class="line"><span class="comment"># (&#x27;self is: &#x27;, &lt;__main__.newStyleClass object at 0x0000000005440DD8&gt;)</span></span><br><span class="line"><span class="comment"># &lt;__main__.newStyleClass at 0x5440dd8&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建类实例并初始化的过程中<code>__new__</code>和<code>__init__</code>被调用的顺序也能从上面代码的输出结果中看出：<code>__new__</code>函数首先被调用，构造了一个<code>newStyleClass</code>的实例，接着<code>__init__</code>函数在<code>__new__</code>函数返回一个实例的时候被调用，并且这个实例作为<code>self</code>参数被传入了<code>__init__</code>函数。</p>
<p>这里需要注意的是，如果<code>__new__</code>函数返回一个已经存在的实例（不论是哪个类的），<code>__init__</code>不会被调用。如下面代码所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = <span class="number">12</span> </span><br><span class="line"><span class="comment"># obj can be an object from any class, even object.__new__(object)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">returnExistedObj</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__new__ is called&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__init__ is called&quot;</span>)</span><br><span class="line"></span><br><span class="line">returnExistedObj()</span><br><span class="line"><span class="comment"># __new__ is called</span></span><br><span class="line"><span class="comment"># 12</span></span><br></pre></td></tr></table></figure>
<p>同时另一个需要注意的点是：</p>
<p>如果我们在<code>__new__</code>函数中不返回任何对象，则<code>__init__</code>函数也不会被调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">notReturnObj</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__new__ is called&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__init__ is called&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(notReturnObj())</span><br><span class="line"><span class="comment"># __new__ is called</span></span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure>
<p>可见如果<code>__new__</code>函数不返回对象的话，不会有任何对象被创建，<code>__init__</code>函数也不会被调用来初始化对象。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><code>__init__</code>不能有返回值</li>
<li><code>__new__</code>函数直接上可以返回别的类的实例。如上面例子中的<code>returnExistedObj</code>类的<code>__new__</code>函数返回了一个<code>int</code>值。</li>
<li>只有在<code>__new__</code>返回一个新创建属于该类的实例时当前类的<code>__init__</code>才会被调用。</li>
</ol>
<blockquote>
<p><a href="https://blog.csdn.net/Yaokai_AssultMaster/article/details/73500184">参考博客</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_python Call Graph学习</title>
    <url>/2021/01/17/Python-python-Call-Graph%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>Python Call Graph是用于<strong>可视化</strong>Python内部函数调用的包，其生成的为<strong>动态程序调用图</strong>。</p>
<a id="more"></a>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p><a href="https://pycallgraph.readthedocs.io/en/master/guide/intro.html">参考地址</a></p>
</blockquote>
<p>Python Call Graph是用于<strong>可视化</strong>Python内部函数调用的包，其生成的为<strong>动态程序调用图</strong>。</p>
<ul>
<li><strong>原理</strong>：利用了Python自带的DEBUG函数（sys.set_trace()）来追踪；<ul>
<li><strong>可追踪项目</strong>：函数名，函数的使用时间，函数间的调用关系；</li>
</ul>
</li>
<li><strong>输出多样化：</strong><ul>
<li>输出DOT文件：符合GraphViz的接口</li>
<li>输出JSON或者GDF文件：符合Gephi的接口</li>
</ul>
</li>
<li><strong>输出定制化：</strong>可利用提供的接口，定制化输出文件</li>
<li><strong>调用方式多样：</strong><ul>
<li>可使用命令行模式；</li>
<li>可使用代码模式；</li>
</ul>
</li>
<li><strong>可以进行过滤：</strong><ul>
<li>指定排外的函数</li>
<li>指定包括的函数</li>
<li>指定最大的深度</li>
</ul>
</li>
</ul>
<p>总的来说Python Call Graph是一个简单的包。</p>
<h2 id="基本代码演示"><a href="#基本代码演示" class="headerlink" title="基本代码演示"></a>基本代码演示</h2><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a><strong>代码：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">This example demonstrates a simple use of pycallgraph.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> pycallgraph <span class="keyword">import</span> PyCallGraph</span><br><span class="line"><span class="keyword">from</span> pycallgraph.output <span class="keyword">import</span> GraphvizOutput</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.no_bananas()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">no_bananas</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.bananas = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_banana</span>(<span class="params">self, banana</span>):</span></span><br><span class="line">        self.bananas.append(banana)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat_bananas</span>(<span class="params">self</span>):</span></span><br><span class="line">        [banana.eat() <span class="keyword">for</span> banana <span class="keyword">in</span> self.bananas]</span><br><span class="line">        self.no_bananas()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    graphviz = GraphvizOutput()</span><br><span class="line">    graphviz.output_file = <span class="string">&#x27;basic.png&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> PyCallGraph(output=graphviz):</span><br><span class="line">        person = Person()</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            person.add_banana(Banana())</span><br><span class="line">        person.eat_bananas()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a><strong>结果：</strong></h3><p><img src="F:\myPythonProject\PythonCallGraph\Examples\Basic.png"></p>
<p>上图中展示了<strong>函数调用的树图</strong> ， <strong>函数调用的次数</strong> ， <strong>函数调用花费的时间</strong></p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_python2的编码问题</title>
    <url>/2021/01/17/Python-python2%E7%9A%84%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>python2编码问题详解</p>
<!-- more  -->

<blockquote>
<p>最近在调试python2过程中经常出现编码的问题，尤其是将python3程序重构为python2程序过程中出现的问题。</p>
<p>问题一：编码本身有什么不同</p>
<ul>
<li>这在字符编码.md文件中已经有了清晰的解释</li>
</ul>
<p>问题二：python2处理中文时为什么总是会出现乱码</p>
<ul>
<li>encode与decode两者需要明确区分</li>
<li>对应的字符与字节也需要区分</li>
</ul>
<p>带着以上两个问题看到了相关的解释，特记录如下：</p>
</blockquote>
<h2 id="字符与字节问题"><a href="#字符与字节问题" class="headerlink" title="字符与字节问题"></a>字符与字节问题</h2><blockquote>
<p>字符与字节之间并不是同等地位。</p>
<p><strong>字符串：</strong>由字符组成的序列</p>
<p><strong>字符：</strong>字符是<strong>人</strong>使用的符号，是一种人所认知的单位。例如：“中” ， “1” ，“￥”等等</p>
<blockquote>
<ul>
<li><p>在python3中，str对象中获取的元素是<strong>Unicode字符</strong> </p>
</li>
<li><p>在python2中，str对象中获取的原始<strong>字节序列</strong></p>
</li>
</ul>
<p>可以看到同样是str对象，python2中其实是字节，python3中是字符</p>
</blockquote>
<p><strong>字节：</strong>字节是<strong>计算机</strong>所使用的符号，是8位的二进制数字。例如 0x01,01010101,0b45</p>
</blockquote>
<p><strong>不同编码体制中，字符与字节拥有着不同的对应关系：</strong></p>
<ol>
<li><p><strong>ASCII码：</strong>  一个英文字母（不分大小写）占一个字节的空间，<strong>一个中文汉字占两个字节</strong>的空间。一个<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLPANWnW01uH6suhf3nWmk0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPjRYPjnvPH63nHmLnWRvPHcd">二进制数字</a>序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值0，最大值255。</p>
</li>
<li><p><strong>UTF-8：</strong>一个英文字符=一个字节，一个中文（含繁体）=三个字节。</p>
<blockquote>
<p>已知UTF-8编码是UNICODE编码的实现形式的一种，Unicode规定了世界上所有的符号与二进制的对应关系，但是其实现形式多种多样，比如UTF-8,UTF-16等等。</p>
<p><strong>Unicode才是真正的（人）字符串，而用ASCII、UTF-8、GBK等字符编码表示的是字节串。</strong></p>
<blockquote>
<p>从这个角度理解unicode就是CAMEO，utf-8就是VerbDic.</p>
</blockquote>
</blockquote>
</li>
</ol>
<h2 id="encode与decode"><a href="#encode与decode" class="headerlink" title="encode与decode"></a>encode与decode</h2><blockquote>
<p>encode与decode分别对应</p>
<p><strong>encode:</strong> 将人类可识别的字符转换为机器可识别的字节码，<strong>字符到字节的过程</strong>。</p>
<p><strong>decode:**就是将机器可识别的字节码转换成人类可识别的字符，</strong>字节到字符的过程**。</p>
</blockquote>
<h2 id="python中的默认编码"><a href="#python中的默认编码" class="headerlink" title="python中的默认编码"></a>python中的默认编码</h2><h3 id="Python源代码的执行过程"><a href="#Python源代码的执行过程" class="headerlink" title="Python源代码的执行过程"></a>Python源代码的执行过程</h3><blockquote>
<p>我们都知道，磁盘上的文件都是以二进制格式存放的，其中文本文件都是以某种特定编码的字节形式存放的。对于程序源代码文件的字符编码是由编辑器指定的，比如我们使用Pycharm来编写Python程序时会指定工程编码和文件编码为UTF-8，那么Python代码被<strong>保存到磁盘</strong>时就会被转换为UTF-8编码对应的字节（<strong>encode过程</strong>）后写入磁盘。</p>
<p>当执行Python代码文件中的代码时，Python解释器在读取Python代码文件中的字节串之后，需要将其转换为Unicode字符串（decode过程）之后才执行后续操作。</p>
<p><img src="https://i.loli.net/2021/01/11/fBTidJh2WmHNkyD.png"></p>
</blockquote>
<h3 id="默认编码"><a href="#默认编码" class="headerlink" title="默认编码"></a>默认编码</h3><blockquote>
<p>如果我们没有在代码文件指定字符编码，<strong>Python解释器</strong>会使用哪种字符编码把从代码文件中读取到的字节转换为Unicode字符串呢？就像我们配置某些软件时，有很多默认选项一样，需要在Python解释器内部设置默认的字符编码来解决这个问题，这就是“默认编码”。</p>
<p>Python2和Python3的解释器使用的默认编码是不一样的，我们可以通过sys.getdefaultencoding()来获取默认编码：</p>
<ul>
<li><strong>Python2:ascii</strong></li>
<li><strong>Python3:utf-8</strong></li>
</ul>
</blockquote>
<h3 id="python2与python3处理文件"><a href="#python2与python3处理文件" class="headerlink" title="python2与python3处理文件"></a>python2与python3处理文件</h3><blockquote>
<p>对于Python2来讲，Python解释器在读取到中文字符的字节码时，会先查看当前代码文件头部是否指明字符编码是什么。如果没有指定，则使用默认字符编码”ASCII”进行解码，导致中文字符解码失败，出现如下错误</p>
<blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">SyntaxError:Non-ASCII character <span class="string">&#x27;\xc4&#x27;</span> <span class="keyword">in</span> file xxx.py <span class="keyword">on</span> line <span class="number">11</span>, but no encoding declared;</span><br><span class="line">see http:<span class="comment">//python.org/dev/peps/pep-0263/ for details</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>对于Python3来讲，执行过程是一样的，只是Python3的解释器以”UTF-8”作为默认编码，但是这并不表示可以完全兼容中文问题。比如我们在Windows上进行开发时，Python工程及代码文件都使用的是默认的GBK编码，也就是说Python代码文件是被转换成GBK格式的字节码保存到磁盘中的。Python3的解释器执行该代码文件时，试图用UTF-8进行解码操作时，同样会解码失败，出现如下错误：</p>
<blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">SyntaxError:Non-UTF<span class="number">-8</span> code starting <span class="keyword">with</span> <span class="string">&#x27;\xc4&#x27;</span> <span class="keyword">in</span> file xx.py <span class="keyword">on</span> line <span class="number">11</span>, but no encodingdeclared; </span><br><span class="line">see http:<span class="comment">//python.org/dev/peps/pep-0263/ for details</span></span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h2 id="Python2-Python3对字符串的支持"><a href="#Python2-Python3对字符串的支持" class="headerlink" title="Python2 Python3对字符串的支持"></a>Python2 Python3对字符串的支持</h2><h3 id="Python2"><a href="#Python2" class="headerlink" title="Python2"></a>Python2</h3><blockquote>
<p>Python2中对字符串的支持由以下三个类别提供：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">basestring</span></span>(<span class="keyword">object</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">str</span></span>(basestring)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unicode</span></span>(basestring)</span><br></pre></td></tr></table></figure>

<p>其中basestring类是str类与unicode类的父类。</p>
<ul>
<li><p><strong>str其实是字节串</strong>，它是unicode经过编码后的字节组成的序列。</p>
<blockquote>
<p>对UTF-8编码的str’汉’使用len()函数时，结果是3，因为UTF-8编码的’汉’==’\xE6\xB1\x89’。</p>
</blockquote>
</li>
<li><p><strong>unicode才是真正意义上的字符串</strong>，对字节串str使用正确的字符编码进行解码后获得，并且len(u’汉’)==1。</p>
</li>
</ul>
</blockquote>
<h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h3><blockquote>
<p>Python3中对字符串的支持进行了实现类层次的上简化，去掉了unicode类，添加了一个bytes类。从表面上来看，可认为Python3中的str和unicode合二为一了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bytes</span></span>(<span class="keyword">object</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">str</span></span>(<span class="keyword">object</span>)</span><br></pre></td></tr></table></figure>

<p>实际上，<strong>Python3中已经意识到之前的错误，开始明确区分字符串与字节</strong>。</p>
<p><strong>因此Python3中的str已经是真正的字符串，而字节是用单独的bytes类来表示。</strong></p>
<p>也就是说，Python3默认定义的就是字符串，实现了对Unicode的内置支持，减轻了程序员对字符串处理的负担。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*- </span></span><br><span class="line">a = <span class="string">&#x27;你好&#x27;</span></span><br><span class="line">b = <span class="string">u&#x27;你好&#x27;</span></span><br><span class="line">c = <span class="string">&#x27;你好&#x27;</span>.encode(<span class="string">&#x27;gbk&#x27;</span>) </span><br><span class="line">print(<span class="built_in">type</span>(a),<span class="built_in">len</span>(a))         <span class="comment"># output:&lt;class&#x27;str&#x27;&gt; 2</span></span><br><span class="line">print(<span class="built_in">type</span>(b),<span class="built_in">len</span>(b))         <span class="comment"># output:&lt;class&#x27;str&#x27;&gt; 2</span></span><br><span class="line">print(<span class="built_in">type</span>(c),<span class="built_in">len</span>(c))         <span class="comment"># output:&lt;class&#x27;bytes&#x27;&gt; 4</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="字符与字节转换"><a href="#字符与字节转换" class="headerlink" title="字符与字节转换"></a>字符与字节转换</h3><blockquote>
<p>4.3的名称我自己起的，合不合适的我们再看</p>
</blockquote>
<ul>
<li><p><strong>单个字符的encode：</strong></p>
<blockquote>
<p>Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="number">65</span></span><br><span class="line">&gt;&gt;&gt; ord(<span class="string">&#x27;中&#x27;</span>)</span><br><span class="line"><span class="number">20013</span></span><br><span class="line">&gt;&gt;&gt; chr(<span class="number">97</span>)</span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line">&gt;&gt;&gt; chr(<span class="number">20013</span>)</span><br><span class="line"><span class="string">&#x27;中&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果知道字符的整数编码，还可以用十六进制这么写字符：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="string">&#x27;\u4e2d\u6587&#x27;</span></span><br><span class="line"><span class="string">&#x27;中文&#x27;</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p><strong>字符.encode() = 字节</strong></p>
<blockquote>
<p>Python3的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。</p>
<p>Python对bytes类型的数据用带b前缀的单引号或双引号表示：x = b’ABC’。</p>
<p>要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。</p>
<p>以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="string">&#x27;ABC&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">b<span class="string">&#x27;ABC&#x27;</span></span><br><span class="line">&gt;&gt;&gt; <span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">b<span class="string">&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span></span><br><span class="line">&gt;&gt;&gt; <span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="symbol">UnicodeEncodeError:</span> <span class="string">&#x27;ascii&#x27;</span> codec can<span class="string">&#x27;t encode characters in position 0-1: ordinal not in range(128)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>常见的中文报错问题愿意：</p>
<p>纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。<strong>中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。</strong></p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>字节.decode() = 字符：</strong></p>
<blockquote>
<p>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b<span class="string">&#x27;ABC&#x27;</span>.decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;ABC&#x27;</span></span><br><span class="line">&gt;&gt;&gt; b<span class="string">&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;中文&#x27;</span></span><br></pre></td></tr></table></figure>

<p>要计算str包含多少个字符，可以用len()函数：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; len(<span class="string">&#x27;ABC&#x27;</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt; len(<span class="string">&#x27;中文&#x27;</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; len(b<span class="string">&#x27;ABC&#x27;</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt; len(b<span class="string">&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line">&gt;&gt;&gt; len(<span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Python2-Python3字符编码的转换"><a href="#Python2-Python3字符编码的转换" class="headerlink" title="Python2 Python3字符编码的转换"></a>Python2 Python3字符编码的转换</h2><p>Unicode字符串可以与任意字符编码的字节串进行相互转换：</p>
<p><img src="https://i.loli.net/2021/01/11/nODNpsrMTiJozU2.png"></p>
</li>
</ul>
<blockquote>
<p>从上图可以看出不同字节编码之间是可以通过Unicode来实现相互转换的。</p>
<ul>
<li><p>Python2中的字符串进行字符编码转换过程是：</p>
<p><strong>字节串(Python2的str默认是字节串)–&gt;decode(‘原来的字符编码’)–&gt;Unicode字符串–&gt;encode(‘新的字符编码’)–&gt;字节串</strong></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python2</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*- </span></span><br><span class="line">utf_8_a = <span class="string">&#x27;我爱中国&#x27;</span></span><br><span class="line">gbk_a = utf_8_a.decode(<span class="string">&#x27;utf-8&#x27;</span>).encode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(gbk_a.decode(<span class="string">&#x27;gbk&#x27;</span>))</span><br><span class="line"><span class="comment"># 输出结果：我爱中国</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Python3中定义的字符串默认就是unicode，因此不需要先解码，可以直接编码成新的字符编码：</p>
<p><strong>字符串(str就是Unicode字符串)–&gt;encode(‘新的字符编码’)–&gt;字节串</strong></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*- </span></span><br><span class="line">utf_8_b = <span class="string">&#x27;我爱中国&#x27;</span></span><br><span class="line">gbk_b = utf_8_b.encode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(gbk_b.decode(<span class="string">&#x27;gbk&#x27;</span>))</span><br><span class="line"><span class="comment"># 输出结果：我爱中国</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Python2-中乱码问题的解决方案"><a href="#Python2-中乱码问题的解决方案" class="headerlink" title="Python2 中乱码问题的解决方案"></a>Python2 中乱码问题的解决方案</h2><h3 id="不要相信Print-结果"><a href="#不要相信Print-结果" class="headerlink" title="不要相信Print()结果"></a>不要相信Print()结果</h3><blockquote>
<p>print()函数本身是加工后给<strong>人</strong>看的,不管给它什么样子的编码格式文件，都可以打印出来。</p>
<p><strong>这也就意味着print()，并没有展示变量的本质。</strong></p>
<p>可以选择 jupyter中</p>
<blockquote>
<p>这里是<strong>Python2</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>chinese = <span class="string">&#x27;中文&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chinese </span><br><span class="line"><span class="string">&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Python2中“字符串”两大阵容"><a href="#Python2中“字符串”两大阵容" class="headerlink" title="Python2中“字符串”两大阵容"></a>Python2中“字符串”两大阵容</h3><blockquote>
<p>unicode和str</p>
<p>如果<code>type(字符串)</code>显示结果是<code>str</code>，其实指的是<code>bytes</code>字节码。</p>
<blockquote>
<p>由上面的内容我们已经理解当前python2中str对象与unicode对象分别代表：字节与字符</p>
</blockquote>
</blockquote>
<ul>
<li><p>encoding与decoding</p>
<p>从<code>unicode</code>转换到<code>str</code>，这个叫<code>encoding</code>，编码。<br>从<code>str</code>转换到<code>unicode</code>，这个叫<code>decoding</code>，解码。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/01/11/X4YE6dehLPIiWq7.png"></p>
<ul>
<li><p>案例</p>
<blockquote>
<p>Python2</p>
</blockquote>
<p><img src="https://i.loli.net/2021/01/11/swf96A7lgDz14Rv.png"></p>
</li>
</ul>
<h3 id="具体统一方案"><a href="#具体统一方案" class="headerlink" title="具体统一方案"></a>具体统一方案</h3><blockquote>
<p>见剩余内容<a href="https://segmentfault.com/a/1190000013202801">https://segmentfault.com/a/1190000013202801</a></p>
<p>这里的统一方案无非就是按照字符处理文件还是按照字节处理文件，何时进行decode何时encode的问题。</p>
<p>做个给出了一个方案，但我目前并没有采用，这里不详细写</p>
</blockquote>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_上下文管理器</title>
    <url>/2021/01/17/Python-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<p><strong>上下文处理器</strong>是用来管理<strong>with语句</strong>.与之对标的概念就是迭代器用来管理for语句.</p>
<a id="more"></a>

<p><strong>Q:</strong> 上面提到了with语句的作用是什么?</p>
<p><strong>A:</strong> with语句的目的是<strong>简化try/finally</strong>模式,这种模式用于保证一段代码执行完毕后执行某操作,即使这段代码由于异常,return或者sys.exit()调用而终止.</p>
<h2 id="上下文管理器的构成"><a href="#上下文管理器的构成" class="headerlink" title="上下文管理器的构成"></a>上下文管理器的构成</h2><p>上下文管理器协议包含有两个方法:__enter__方法,__exit__方法.</p>
<ul>
<li><p>with语句<strong>开始运行</strong>时,会在上下文管理器对象上调用__enter__方法.</p>
</li>
<li><p>with语句<strong>运行结束</strong>后,会在上下文管理器对象上调用__exit__方法,扮演finally子句的作用.</p>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;mirror.py&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    src = fp.read(<span class="number">60</span>)</span><br><span class="line">print(<span class="built_in">len</span>(src))</span><br><span class="line"><span class="comment"># 60</span></span><br><span class="line">print(fp)</span><br><span class="line"><span class="comment"># &lt;_io.TextIOWrapper name=&#x27;mirror.py&#x27; mode=&#x27;r&#x27; encoding=&#x27;cp936&#x27;&gt;</span></span><br><span class="line">print(fp.closed , fp.encoding)</span><br><span class="line"><span class="comment"># True cp936</span></span><br><span class="line">fp.read(<span class="number">60</span>)</span><br><span class="line"><span class="comment"># ValueError: I/O operation on closed file.</span></span><br></pre></td></tr></table></figure>
<p>**注意:**在第一行语句中分为两部分:</p>
<ul>
<li>执行with后面的表达式得到的结果时<strong>上下文管理器对象</strong>.</li>
<li>执行as语句,是此对象执行__enter__方法返回的结果.<ul>
<li>open()方法本身提供的__enter__方法返回的是本身,所以可以看到fp变量指向的依旧是io.TextIPWrapper</li>
</ul>
</li>
</ul>
<p>不管控制流程以何种方式退出,都会在<strong>上下文管理器</strong>对象上调用__exit__方法,而不是__enter__返回的方法.</p>
<h2 id="深入理解上下文管理器的执行过程"><a href="#深入理解上下文管理器的执行过程" class="headerlink" title="深入理解上下文管理器的执行过程"></a>深入理解上下文管理器的执行过程</h2><p>像生成器的学习方式一样,我们既可以使用with语句隐式的调用上下文管理器的相关方法,也可以直接调用上下文管理器的相关方法以达到相同的目的.</p>
<h3 id="定义一个上下文管理器"><a href="#定义一个上下文管理器" class="headerlink" title="定义一个上下文管理器"></a>定义一个上下文管理器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LookingGlass</span>:</span></span><br><span class="line">		<span class="comment"># __enter__的输入参数,只有self本身</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span>  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        self.original_write = sys.stdout.write  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">        sys.stdout.write = self.reverse_write  <span class="comment"># &lt;3&gt;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;JABBERWOCKY&#x27;</span>  <span class="comment"># &lt;4&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span>(<span class="params">self, text</span>):</span>  <span class="comment"># &lt;5&gt;</span></span><br><span class="line">        self.original_write(text[::-<span class="number">1</span>])</span><br><span class="line">		<span class="comment"># __exit__的输入参数,包括其他</span></span><br><span class="line">    <span class="comment"># exc_type 异常类 , exc_value异常实例 , traceback traceback对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>):</span>  <span class="comment"># &lt;6&gt;</span></span><br><span class="line">        <span class="keyword">import</span> sys  <span class="comment"># &lt;7&gt;</span></span><br><span class="line">        sys.stdout.write = self.original_write  <span class="comment"># &lt;8&gt;</span></span><br><span class="line">        <span class="keyword">if</span> exc_type <span class="keyword">is</span> ZeroDivisionError:  <span class="comment"># &lt;9&gt;</span></span><br><span class="line">            print(<span class="string">&#x27;Please DO NOT divide by zero!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># &lt;10&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过定义__enter__与__exit__方法定义了一个上下文管理器,并且再次方法中利用<strong>monkey  patch</strong> 对sys中的输出方法进行的反转输出的操作.</p>
<h3 id="with语句使用上述的上下文管理器"><a href="#with语句使用上述的上下文管理器" class="headerlink" title="with语句使用上述的上下文管理器"></a>with语句使用上述的上下文管理器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mirror <span class="keyword">import</span> LookingGlass</span><br><span class="line"><span class="comment"># __enter__返回结果绑定到了what变量上面</span></span><br><span class="line"><span class="keyword">with</span> LookingGlass() <span class="keyword">as</span> what:</span><br><span class="line">    print(<span class="string">&quot;SUN QING ZHI&quot;</span>)</span><br><span class="line">    print(what)</span><br><span class="line">print(what)</span><br><span class="line">print(<span class="string">&quot;Back to Normal&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># IHZ GNIQ NUS</span></span><br><span class="line"><span class="comment"># YKCOWREBBAJ</span></span><br><span class="line"><span class="comment"># JABBERWOCKY</span></span><br><span class="line"><span class="comment"># Back to Normal</span></span><br></pre></td></tr></table></figure>
<p>可以看到上面的输出,在位于with语句内部时,print函数调用了上下文管理器中给定的逆输出函数,而跳出之后通过__exit__方法还原的原来的输出函数.</p>
<h3 id="直接调用上下文管理器进行相同操作"><a href="#直接调用上下文管理器进行相同操作" class="headerlink" title="直接调用上下文管理器进行相同操作"></a>直接调用上下文管理器进行相同操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mirror <span class="keyword">import</span> LookingGlass</span><br><span class="line">manager = LookingGlass()</span><br><span class="line">what = manager.__enter__()</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;SUN QING ZHI&quot;</span>)</span><br><span class="line">print(what)</span><br><span class="line">manager.__exit__(<span class="literal">None</span> , <span class="literal">None</span> ,<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">print(what)</span><br><span class="line">print(<span class="string">&quot;Back to Normal&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># IHZ GNIQ NUS</span></span><br><span class="line"><span class="comment"># YKCOWREBBAJ</span></span><br><span class="line"><span class="comment"># JABBERWOCKY</span></span><br><span class="line"><span class="comment"># Back to Normal</span></span><br></pre></td></tr></table></figure>
<p>手动调用了__enter__,__exit__ 两个方法,实现了相同的功能,这也就是with语句内部的逻辑.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 其他操作</span></span><br><span class="line"><span class="keyword">from</span> mirror <span class="keyword">import</span> LookingGlass</span><br><span class="line"><span class="keyword">with</span> LookingGlass():</span><br><span class="line">    print(<span class="string">&quot;SUN QING ZHI&quot;</span>)</span><br><span class="line">    <span class="comment"># IHZ GNIQ NUS</span></span><br><span class="line">    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">    <span class="comment"># Please DO NOT divide by zero!</span></span><br><span class="line">print(<span class="string">&quot;SUN QING ZHI&quot;</span>)</span><br><span class="line"><span class="comment"># SUN QING ZHI</span></span><br><span class="line"><span class="comment"># 正常输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> LookingGlass():</span><br><span class="line">    print(<span class="string">&quot;SUN QING ZHI&quot;</span>)</span><br><span class="line">    <span class="comment"># IHZ GNIQ NUS</span></span><br><span class="line">    A = NO_SUCH_NAME</span><br><span class="line">    <span class="comment"># NameError: name &#x27;NO_SUCH_NAME&#x27; is not defined</span></span><br><span class="line">print(<span class="string">&quot;SUN QING ZHI&quot;</span>)</span><br><span class="line"><span class="comment"># 没输出,上面错误上下文管理器并没有正确捕捉</span></span><br></pre></td></tr></table></figure>
<p>上面两个例子就是为了更好地理解上下文管理器的执行过程.</p>
<h2 id="contextlib-模块中的提供的上下文管理器工具"><a href="#contextlib-模块中的提供的上下文管理器工具" class="headerlink" title="contextlib 模块中的提供的上下文管理器工具"></a>contextlib 模块中的提供的上下文管理器工具</h2><p>应用到上下文管理器的场景其实很多,每次都通过手写管理器难免产生遗漏,为此官方提供了一系列的管理器,应用于不同场景.这里不一一的介绍里面的</p>
<p><strong>@contextmanager</strong>: 上下文管理器装饰器,可以应用于生成器函数,将其装饰为一个上下文管理器.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">A &quot;mirroring&quot; ``stdout`` context manager.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">While active, the context manager reverses text output to</span></span><br><span class="line"><span class="string">``stdout``::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># BEGIN MIRROR_GEN_DEMO_1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; from mirror_gen import looking_glass</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; with looking_glass() as what:  # &lt;1&gt;</span></span><br><span class="line"><span class="string">    ...      print(&#x27;Alice, Kitty and Snowdrop&#x27;)</span></span><br><span class="line"><span class="string">    ...      print(what)</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">    pordwonS dna yttiK ,ecilA</span></span><br><span class="line"><span class="string">    YKCOWREBBAJ</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; what</span></span><br><span class="line"><span class="string">    &#x27;JABBERWOCKY&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># END MIRROR_GEN_DEMO_1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This exposes the context manager operation::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># BEGIN MIRROR_GEN_DEMO_2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; from mirror_gen import looking_glass</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; manager = looking_glass()  # &lt;1&gt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; manager  # doctest: +ELLIPSIS</span></span><br><span class="line"><span class="string">    &lt;contextlib._GeneratorContextManager object at 0x...&gt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; monster = manager.__enter__()  # &lt;2&gt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; monster == &#x27;JABBERWOCKY&#x27;  # &lt;3&gt;</span></span><br><span class="line"><span class="string">    eurT</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; monster</span></span><br><span class="line"><span class="string">    &#x27;YKCOWREBBAJ&#x27;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; manager  # doctest: +ELLIPSIS</span></span><br><span class="line"><span class="string">    &gt;...x0 ta tcejbo reganaMtxetnoCrotareneG_.biltxetnoc&lt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; manager.__exit__(None, None, None)  # &lt;4&gt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; monster</span></span><br><span class="line"><span class="string">    &#x27;JABBERWOCKY&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># END MIRROR_GEN_DEMO_2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># BEGIN MIRROR_GEN_EX</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager  </span><span class="comment"># &lt;1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">looking_glass</span>():</span></span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    original_write = sys.stdout.write  <span class="comment"># &lt;2&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span>(<span class="params">text</span>):</span>  <span class="comment"># &lt;3&gt;</span></span><br><span class="line">        original_write(text[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    sys.stdout.write = reverse_write  <span class="comment"># &lt;4&gt;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;JABBERWOCKY&#x27;</span>  <span class="comment"># &lt;5&gt;</span></span><br><span class="line">    sys.stdout.write = original_write  <span class="comment"># &lt;6&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># END MIRROR_GEN_EX</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我这里就不一一总结了,了解就行.</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_内存管理</title>
    <url>/2021/01/17/Python-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>参考地址：<a href="https://www.cnblogs.com/geaozhang/p/7111961.html">博客一</a> ， <a href="https://andrewpqc.github.io/2018/10/08/python-memory-management/">博客二</a> ，<a href="https://cloud.tencent.com/developer/article/1670455">博客三</a></p>
<p>Python内存管理是理解Python运行机制的重要一环，故整理下相关内容如下：</p>
<a id="more"></a>

<h2 id="前置知识：Python变量与对象"><a href="#前置知识：Python变量与对象" class="headerlink" title="前置知识：Python变量与对象"></a>前置知识：Python变量与对象</h2><p>我们在编程过程中，不可避免的使用变量指代对象，其关系为变量通过指针指向了对象；对象有自己的类型，而变量的类型则跟随者对象的类型而变化。关系如图：</p>
<p><img src="https://i.loli.net/2021/01/17/YENw3MevIFUBcOL.png"></p>
<p><strong>变量：</strong>通过变量指针引用对象。而变量指针指向具体对象的<strong>内存空间</strong>；变量类型是<strong>动态</strong>的，与对象类型一致</p>
<p><strong>对象：</strong>类型是<strong>已知</strong>的，每个对象都包含有头部信息，其中为<strong>类型标识</strong>符与<strong>引用计数</strong>器</p>
<h3 id="多变量指向同一对象情况"><a href="#多变量指向同一对象情况" class="headerlink" title="多变量指向同一对象情况"></a>多变量指向同一对象情况</h3><p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var_1 = <span class="number">123</span></span><br><span class="line">var_2 = var_1</span><br><span class="line">print(<span class="built_in">id</span>(var_1)) <span class="comment"># 140711337393728</span></span><br><span class="line">print(<span class="built_in">id</span>(var_2)) <span class="comment"># 140711337393728</span></span><br><span class="line">print(<span class="built_in">id</span>(<span class="number">123</span>)) <span class="comment"># 140711337393728</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">type</span>(var_1)) <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>(var_2)) <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>(<span class="number">123</span>)) <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过对象被引用的方式(var_2 = var_1)，两个变量指向了同一地址，并且变量的类别与被引用对象的类别一致。简单示意图：</p>
<p><img src="https://i.loli.net/2021/01/17/vJfUoY75K3LjEOV.png"></p>
<h3 id="多变量引用所指的判断"><a href="#多变量引用所指的判断" class="headerlink" title="多变量引用所指的判断"></a>多变量引用所指的判断</h3><p>在Python中判断多个变量的引用地址是否一致采用了内置函数is。先看一段代码再去讲。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 小于等于256的整数</span></span><br><span class="line">intA = <span class="number">256</span></span><br><span class="line">intB = <span class="number">256</span></span><br><span class="line">print(<span class="built_in">id</span>(intA)) <span class="comment"># 140711337397984</span></span><br><span class="line">print(<span class="built_in">id</span>(intB)) <span class="comment"># 140711337397984</span></span><br><span class="line">intA <span class="keyword">is</span> intB <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 大于256的整数</span></span><br><span class="line">intA = <span class="number">257</span> <span class="comment"># 3037955041360</span></span><br><span class="line">intB = <span class="number">257</span> <span class="comment"># 3037955041424</span></span><br><span class="line">print(<span class="built_in">id</span>(intA))</span><br><span class="line">print(<span class="built_in">id</span>(intB))</span><br><span class="line">intA <span class="keyword">is</span> intB <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 短字符串</span></span><br><span class="line">charA = <span class="string">&quot;aaaaaaaaaaa&quot;</span></span><br><span class="line">charB = <span class="string">&quot;aaaaaaaaaaa&quot;</span></span><br><span class="line">charA <span class="keyword">is</span> charB <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 长字符串</span></span><br><span class="line">charA = <span class="string">&quot;very Good&quot;</span></span><br><span class="line">charB = <span class="string">&quot;very Good&quot;</span></span><br><span class="line">charA <span class="keyword">is</span> charB <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器——列表</span></span><br><span class="line">listA = []</span><br><span class="line">listB = []</span><br><span class="line">listA <span class="keyword">is</span> listB <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<p>我们发现不同的数据类型或者同一数据类型不同“长度”时，多次创建时，其内存地址情况并不一致。这是由于Python会选择缓存常用的对象，使得多次赋值对象时，不需要创建新的对象，例如1~256的数字，短字符串等。基本上都是不可修改的数据类型。</p>
<ol>
<li>Python缓存了整数（1~256，短字符串），每个变量进行为赋值操作时，不需要创建新的对象，大家引用对象一致。</li>
<li>Python对于未缓存的对象，在进行赋值操作时，会直接生成新的对象，占用新的内存地址。</li>
</ol>
<h2 id="Python的垃圾回收机制"><a href="#Python的垃圾回收机制" class="headerlink" title="Python的垃圾回收机制"></a>Python的垃圾回收机制</h2><p>一句话描述就是：<strong>引用计数为主，标记清除与分代回收为辅</strong>；</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>Python中主要使用引用计数(Reference Counting)进行垃圾回收。每一个对象的核心就是一个结构体PyObject,其内部存在一个引用计数器(ob_refcnt)。当某对象的引用计数值为0时，其内存就可以被释放掉；</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"> typedef struct_object &#123;</span><br><span class="line">    <span class="built_in">int</span> ob_refcnt;</span><br><span class="line">    struct_typeobject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>
<h4 id="引起引用计数变化的情况"><a href="#引起引用计数变化的情况" class="headerlink" title="引起引用计数变化的情况"></a>引起引用计数变化的情况</h4><p><strong>引用计数增加的情况：</strong></p>
<ul>
<li>对象被创建,a = 2</li>
<li>对象被引用,b=a</li>
<li>对象作为参数传递到函数中,fun(a)</li>
<li>对象作为元素存储在容器中,numList.append(a)</li>
</ul>
<p><strong>引用计数减少的情况：</strong></p>
<ul>
<li>对象别名被显示销毁,del a</li>
<li>对象别名赋予了新的对象,b = 3</li>
<li>包含对象的函数运行结束,</li>
<li>对象所在的容器被摧毁或者从容其中删除了对象,numList.remove(a)</li>
</ul>
<h4 id="获取引用数量的方式"><a href="#获取引用数量的方式" class="headerlink" title="获取引用数量的方式"></a>获取引用数量的方式</h4><p>通过sys包中的getrefcount()获取一个名称所引用的对象当前的引用计数，这个函数本身也会造成其引用+1.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys.getrefcount(a)</span><br></pre></td></tr></table></figure>
<h4 id="引用计数的优缺点"><a href="#引用计数的优缺点" class="headerlink" title="引用计数的优缺点"></a>引用计数的优缺点</h4><p><strong>优点：</strong></p>
<ul>
<li>逻辑简单而高效，具备实时性；</li>
<li>垃圾回收随机分配到运行阶段，处理回收时间分散有利于系统稳定；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>空间浪费：每个对象都存在用来统计的引用的空间，加大了空间负担；</li>
<li>大对象释放缓慢：当需要释放大的对象时，比如字典，需要对引用的所有对象循环嵌套调用；</li>
<li>循环引用问题：引用计数的致命问题。</li>
</ul>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>标记清除(Mark and Sweep)算法，是为了解决对象可能产生的循环引用问题。(注意，只有<strong>容器</strong>对象才会产生循环引用的情况，比如列表、字典、用户自定义类的对象、元组等。而像数字，字符串这类简单类型不会出现循环引用。作为一种优化策略，对于只包含简单类型的元组也不在标记清除算法的考虑之列)。</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ol>
<li>标记阶段，遍历所有对象，如果对象可达（表明存在对象引用它），则标记对象可达；</li>
<li>清除阶段，再次遍历所有对象，对于不可达的对象，进行回收；</li>
</ol>
<p>如下图所示，在标记清除算法中，为了追踪容器对象，需要每个容器对象维护两个额外的指针，用来将容器对象组成一个双端链表，指针分别指向前后两个容器对象，方便插入和删除操作。python解释器(Cpython)维护了两个这样的双端链表，一个链表存放着需要被扫描的容器对象，另一个链表存放着临时不可达对象。在图中，这两个链表分别被命名为”Object to Scan”和”Unreachable”。图中例子是这么一个情况：link1,link2,link3组成了一个引用环，同时link1还被一个变量A(其实这里称为名称A更好)引用。link4自引用，也构成了一个引用环。从图中我们还可以看到，每一个节点除了有一个记录当前引用计数的变量<code>ref_count</code>还有一个<code>gc_ref</code>变量，这个<code>gc_ref</code>是<code>ref_count</code>的一个副本，所以初始值为<code>ref_count</code>的大小。<br><a href="https://andrewpqc.github.io/images/marksweep1.png"><img src="https://andrewpqc.github.io/images/marksweep1.png" alt="img"></a></p>
<p>gc启动的时候，会逐个遍历”Object to Scan”链表中的容器对象，并且将当前对象所引用的所有对象的<code>gc_ref</code>减一。(扫描到link1的时候，由于link1引用了link2,所以会将link2的<code>gc_ref</code>减一，接着扫描link2,由于link2引用了link3,所以会将link3的<code>gc_ref</code>减一…..)像这样将”Objects to Scan”链表中的所有对象考察一遍之后，两个链表中的对象的<code>ref_count</code>和<code>gc_ref</code>的情况如下图所示。这一步操作就相当于解除了循环引用对引用计数的影响。<br><a href="https://andrewpqc.github.io/images/marksweep2.png"><img src="https://andrewpqc.github.io/images/marksweep2.png" alt="img"></a></p>
<p>接着，gc会再次扫描所有的容器对象，如果对象的<code>gc_ref</code>值为0，那么这个对象就被标记为<code>GC_TENTATIVELY_UNREACHABLE</code>，并且被移至”Unreachable”链表中。下图中的link3和link4就是这样一种情况。<br><a href="https://andrewpqc.github.io/images/marksweep3.png"><img src="https://andrewpqc.github.io/images/marksweep3.png" alt="img"></a></p>
<p>如果对象的<code>gc_ref</code>不为0，那么这个对象就会被标记为<code>GC_REACHABLE</code>。同时当gc发现有一个节点是可达的，那么他会递归式的将从该节点出发可以到达的所有节点标记为<code>GC_REACHABLE</code>,这就是下图中link2和link3所碰到的情形。<br><a href="https://andrewpqc.github.io/images/marksweep4.png"><img src="https://andrewpqc.github.io/images/marksweep4.png" alt="img"></a></p>
<p>除了将所有可达节点标记为<code>GC_REACHABLE</code>之外，如果该节点当前在”Unreachable”链表中的话，还需要将其移回到”Object to Scan”链表中，下图就是link3移回之后的情形。<br><a href="https://andrewpqc.github.io/images/marksweep5.png"><img src="https://andrewpqc.github.io/images/marksweep5.png" alt="img"></a><br>第二次遍历的所有对象都遍历完成之后，存在于”Unreachable”链表中的对象就是真正需要被释放的对象。如上图所示，此时link4存在于Unreachable链表中，gc随即释放之。</p>
<p><strong>上面描述的垃圾回收的阶段，会暂停整个应用程序，等待标记清除结束后才会恢复应用程序的运行。</strong></p>
<h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><p>Python通过“分代回收”（Generational Collection）以<strong>空间换时间</strong>的方法提高<strong>垃圾回收效率</strong>。</p>
<h4 id="分代回收的依据"><a href="#分代回收的依据" class="headerlink" title="分代回收的依据"></a>分代回收的依据</h4><p><strong>对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。</strong></p>
<p>python gc给对象定义了三种世代(0,1,2),每一个新生对象在generation zero中，如果它在一轮gc扫描中活了下来，那么它将被移至generation one,在那里他将较少的被扫描，如果它又活过了一轮gc,它又将被移至generation two，在那里它被扫描的次数将会更少。</p>
<p>gc的扫描在什么时候会被触发呢?答案是<strong>当某一世代中被分配的对象与被释放的对象之差达到某一阈值的时候，就会触发gc对某一世代的扫描。</strong>值得注意的是<strong>当某一世代的扫描被触发的时候，比该世代年轻的世代也会被扫描。</strong>也就是说如果世代2的gc扫描被触发了，那么世代0,世代1也将被扫描，如果世代1的gc扫描被触发，世代0也会被扫描。</p>
<p>该阈值可以通过下面两个函数查看和调整:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gc.get_threshold() <span class="comment"># (threshold0, threshold1, threshold2).</span></span><br><span class="line">gc.set_threshold(threshold0[, threshold1[, threshold2]])</span><br></pre></td></tr></table></figure>
<p>下面对set_threshold()中的三个参数threshold0, threshold1, threshold2进行介绍。gc会记录自从上次收集以来新分配的对象数量与释放的对象数量，当两者之差超过threshold0的值时，gc的扫描就会启动，初始的时候只有世代0被检查。如果自从世代1最近一次被检查以来，世代0被检查超过threshold1次，那么对世代1的检查将被触发。相同的，如果自从世代2最近一次被检查以来，世代1被检查超过threshold2次，那么对世代2的检查将被触发。get_threshold()是获取三者的值，默认值为(700,10,10).</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>总体来说，在Python中，主要通过引用计数进行垃圾回收；通过 “标记-清除” 解决容器对象可能产生的循环引用问题；通过 “分代回收” 以空间换时间的方法提高垃圾回收效率。</strong></p>
<h2 id="内存池机制"><a href="#内存池机制" class="headerlink" title="内存池机制"></a>内存池机制</h2><p>Python中对于大内存（&gt; 256 字节）与小内存（1 ~ 256字节）的分配机制是不同的。</p>
<h4 id="为什么引入内存池"><a href="#为什么引入内存池" class="headerlink" title="为什么引入内存池"></a>为什么引入内存池</h4><p>解决多次调用malloc导致大量内存碎片的问题。</p>
<p>内存池就是预先申请一定数量的，大小相同的内存块，当出现新的内存需求，可以选择从内存池分配内存；</p>
<h4 id="大内存的分配机制：malloc"><a href="#大内存的分配机制：malloc" class="headerlink" title="大内存的分配机制：malloc"></a>大内存的分配机制：malloc</h4><p>大内存—–若请求分配的内存大于256K，malloc函数分配内存，free函数释放内存。</p>
<h4 id="小内存的分配机制：内存池"><a href="#小内存的分配机制：内存池" class="headerlink" title="小内存的分配机制：内存池"></a>小内存的分配机制：内存池</h4><p>内存池，有Python的接口函数PyMem_Malloc实现—–若请求分配的内存在1~256字节之间就使用内存池管理系统进行分配，调用malloc函数分配内存，但是每次只会分配一块大小为256K的大块内存，不会调用free函数释放内存，将该内存块留在内存池中以便下次使用。</p>
<h4 id="Python解释器的解释"><a href="#Python解释器的解释" class="headerlink" title="Python解释器的解释"></a>Python解释器的解释</h4><p><img src="https://i.loli.net/2021/01/17/qEk3TmCjSU1vAB8.png"></p>
<ul>
<li>python的对象管理主要位于Level+1~Level+3层</li>
<li>Level+3层：对于python内置的对象（比如int,dict等）都有独立的私有内存池，对象之间的内存池不共享，即int释放的内存，不会被分配给float使用</li>
<li>Level+2层：当申请的内存大小小于256KB时，内存分配主要由 Python 对象分配器（Python’s object allocator）实施</li>
<li>Level+1层：当申请的内存大小大于256KB时，由Python原生的内存分配器进行分配，本质上是调用C标准库中的malloc/realloc等函数.</li>
</ul>
<blockquote>
<p>关于释放内存方面，当一个对象的引用计数变为0时，Python就会调用它的析构函数。调用析构函数并不意味着最终一定会调用free来释放内存空间，如果真是这样的话，那频繁地申请、释放内存空间会使Python的执行效率大打折扣。因此在析构时也采用了内存池机制，从内存池申请到的内存会被归还到内存池中，以避免频繁地申请和释放动作.</p>
</blockquote>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_值传递与引用传递</title>
    <url>/2021/01/17/Python-%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<blockquote>
<p>参考地址：<a href="http://c.biancheng.net/view/4471.html">博客教程</a> <a href="http://c.biancheng.net/view/2258.html">博客详细教程</a> <a href="https://github.com/taizilongxu/interview_python#1-python%E7%9A%84%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">gitHub地址</a></p>
</blockquote>
<a id="more"></a>

<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h3><p> 在函数定义中常见的函数都会选择<strong>有参数</strong>的函数形式，函数的作用是传递数据给函数，并对此数据进行具体的操作；</p>
<p>在使用函数时，经常会用到形式参数（形参）与实际参数（实参），二者都称为参数，其差别在于：</p>
<ul>
<li>形式参数：在<strong>定义函数</strong>时，函数名后面的参数就是形参，例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义函数时采用就是形参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span>(<span class="params">formalParameters</span>):</span></span><br><span class="line">    print(formalParameters)</span><br></pre></td></tr></table></figure>
<ul>
<li>实际参数：在<strong>调用函数</strong>时，函数的调用者给函数的参数，例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用函数时就是实际参数</span></span><br><span class="line">actualParameters = <span class="string">&quot;形式参数还是实际参数这是个问题&quot;</span></span><br><span class="line">demo(actualParameters)</span><br><span class="line"><span class="comment"># 形式参数还是实际参数这是个问题</span></span><br></pre></td></tr></table></figure>
<p>那么将<strong>实际参数传递给形式参数</strong>的过程，就可以分为值传递与引用传递啦；</p>
<h3 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h3><ul>
<li>相同点：都是将实参传递给形参的过程</li>
<li>不同点:<ul>
<li>值传递：适用于<strong>不可变</strong>的参数 ，例如 字符串，元组，数字等 ， 传递的是一个<strong>副本</strong>；</li>
<li>引用传递：适用于<strong>可变</strong>的参数，例如 列表，字典等，传递的是指向可变参数对象的<strong>指针</strong>。</li>
</ul>
</li>
<li>结论：如何判定当前是值传递还是引用传递呢？<ul>
<li>就是看当前传递的参数本身是否可变，不可变就是值传递，可变就是引用传递。<ul>
<li>这里的可变就是能够进行修改，immutable. </li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>其实值传递与引用传递是一回事，看接下来的描述即可；</p>
</blockquote>
<h2 id="值传递与引用传递详解"><a href="#值传递与引用传递详解" class="headerlink" title="值传递与引用传递详解"></a>值传递与引用传递详解</h2><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>我们先从一个例子出发看一看值传递与引用传递的对实际编程的影响；示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span>(<span class="params">obj</span>) :</span></span><br><span class="line">    obj += obj</span><br><span class="line">    print(<span class="string">&quot;形参值为：&quot;</span>,obj)</span><br><span class="line">print(<span class="string">&quot;-------值传递-----&quot;</span>)</span><br><span class="line">a = <span class="string">&quot;C语言中文网&quot;</span></span><br><span class="line">print(<span class="string">&quot;a的值为：&quot;</span>,a)</span><br><span class="line">demo(a)</span><br><span class="line">print(<span class="string">&quot;实参值为：&quot;</span>,a)</span><br><span class="line">print(<span class="string">&quot;-----引用传递-----&quot;</span>)</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">print(<span class="string">&quot;a的值为：&quot;</span>,a)</span><br><span class="line">demo(a)</span><br><span class="line">print(<span class="string">&quot;实参值为：&quot;</span>,a)</span><br></pre></td></tr></table></figure>
<p>结果展示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-------值传递-----</span><br><span class="line">a的值为： 吃了嘛？</span><br><span class="line">形参值为： 吃了嘛？吃了嘛？</span><br><span class="line">实参值为： 吃了嘛？</span><br><span class="line">-----引用传递-----</span><br><span class="line">a的值为： [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">形参值为： [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">实参值为： [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>结论：</p>
<ul>
<li><p>在应用值传递时：<strong>函数内部对数据进行操作，并不影响函数外部的变量的值</strong>；</p>
</li>
<li><p>在应用引用传递时：<strong>函数内部对数据操作，影响了函数外部变量的值</strong>。</p>
<blockquote>
<p>分析运行结果不难看出，在执行值传递时，改变形式参数的值，实际参数并不会发生改变；而在进行引用传递时，改变形式参数的值，实际参数也会发生同样的改变。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>至于为什么会产生如此的差异也很简单，值传递传递的是值的<strong>副本</strong>，引用传递传递的是指向对象的<strong>指针</strong>（<strong>的副本</strong>）。</p>
<p>值传递与引用传递的应用，我个人在使用时，其实一直没有很关注相关的差异，平时总是在不经意的使用，比如操作列表经常不需要返回即可，这就是引用传递的好处；在日常DEBUG中，如果对值传递与引用传递有一个清晰的认识，我想也会顺畅很多；</p>
<h3 id="Python值传递机制"><a href="#Python值传递机制" class="headerlink" title="Python值传递机制"></a>Python值传递机制</h3><p>上面我们已经知道值传递传递的是参数的副本，对其进行操作是不会影响原参数的。接下来也是从一个简单的例子出发，简单的探讨下内存机制的情况，有利于更清晰的认识。</p>
<p>一个值传递的例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span>(<span class="params">a , b</span>) :</span></span><br><span class="line">    <span class="comment"># 下面代码实现a、b变量的值交换</span></span><br><span class="line">    a, b = b, a</span><br><span class="line">    print(<span class="string">&quot;swap函数里，变量a的值是&quot;</span>, \</span><br><span class="line">        a, <span class="string">&quot;；变量b的值是&quot;</span>, b)</span><br><span class="line">a = <span class="number">6</span></span><br><span class="line">b = <span class="number">9</span></span><br><span class="line">swap(a , b)</span><br><span class="line">print(<span class="string">&quot;交换结束后，变量a的值是&quot;</span>, \</span><br><span class="line">    a , <span class="string">&quot;；变量b的值是&quot;</span>, b)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">swap函数里，变量a的值是 <span class="number">9</span> ；变量b的值是 <span class="number">6</span></span><br><span class="line">交换结束后，变量a的值是 <span class="number">6</span> ；变量b的值是 <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>从上面的输出我们可以看出，外部的a,b变量，并不是函数内部的a,b变量；正如上面提到的，swap()函数内部的变量仅仅是主程序变量a,b的复制品罢了；下面通过示意图的方式，展示其栈分配情况：</p>
<ul>
<li><p>首先程序中，定义了a,b两个局部变量，两个变量在内存中存储示意图如下所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190213/2-1Z2131J304295.gif"></p>
</li>
<li><p>然后执行swap()函数时，系统进入swap()函数，并将主程序中的a,b变量作为参数值传递给swap()函数，传入的是副本，并非其本身。进入swap()函数后系统已产生了4个变量，这四个变量在内存的存储示意图如下所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190213/2-1Z2131J33SX.gif"></p>
<ul>
<li>可以看到，目前分别为主程序与swap()生成了两个栈区，每个栈区均分别存在a,b变量。</li>
</ul>
</li>
<li><p>执行swap()函数的内部交换操作，<strong>仅仅</strong>是swap()栈区的变量产生了变化；</p>
</li>
</ul>
<p><img src="http://c.biancheng.net/uploads/allimg/190213/2-1Z2131J4355M.gif"></p>
<blockquote>
<p>对比图 3 与图 1，可以看到两个示意图中主程序栈区中 a、b 的值并未有任何改变，程序改变的只是 swap() 函数栈区中 a、b 的值。这就是值传递的实质：当系统开始执行函数时，系统对形参执行初始化，就是把实参变量的值赋给函数的形参变量，在函数中操作的并不是实际的实参变量</p>
</blockquote>
<h3 id="Python中的引用传递"><a href="#Python中的引用传递" class="headerlink" title="Python中的引用传递"></a>Python中的引用传递</h3><p>引用传递传递的是指向对象的<strong>指针</strong>（<strong>的副本</strong>），其实质其实与值传递一致，区别仅仅是是否改变了主程序中数据情况，而这并不是传递的锅；还是一个相似的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span>(<span class="params">dw</span>):</span></span><br><span class="line">    <span class="comment"># 下面代码实现dw的a、b两个元素的值交换</span></span><br><span class="line">    dw[<span class="string">&#x27;a&#x27;</span>], dw[<span class="string">&#x27;b&#x27;</span>] = dw[<span class="string">&#x27;b&#x27;</span>], dw[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">    print(<span class="string">&quot;swap函数里，a元素的值是&quot;</span>,\</span><br><span class="line">        dw[<span class="string">&#x27;a&#x27;</span>], <span class="string">&quot;；b元素的值是&quot;</span>, dw[<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">dw = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">9</span>&#125;</span><br><span class="line">swap(dw)</span><br><span class="line">print(<span class="string">&quot;交换结束后，a元素的值是&quot;</span>,\</span><br><span class="line">    dw[<span class="string">&#x27;a&#x27;</span>], <span class="string">&quot;；b元素的值是&quot;</span>, dw[<span class="string">&#x27;b&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">swap函数里，a元素的值是 <span class="number">9</span> ；b元素的值是 <span class="number">6</span></span><br><span class="line">交换结束后，a元素的值是 <span class="number">9</span> ；b元素的值是 <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>从上面的结果来看，不仅仅swap函数内部字典元素交换成功，主程序中字典元素也进行了交换。这就造成了一个错觉，再调用swap()函数时，传入的就是dw字典本身，而不是其复制品，但这是错误的，可通过下面图示进行说明：</p>
<blockquote>
<p>我就存在这样的错觉；</p>
</blockquote>
<ul>
<li><p>首先主程序创建了一个字典对象，并通过dw变量指向了字典对象，此时内存中包括：对象本身，指向对象的引用变量，如图：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190213/2-1Z2131J551L5.gif"></p>
</li>
<li><p>其次开始调用swap()函数，在调用时，dw变量作为参数传递给swap()函数，这里与值传递是一模一样的：将主程序中的dw变量的值赋给了swap()函数的dw形参，从而完成了swap()函数的dw参数的初始化。</p>
<ul>
<li>主程序中的dw是一个引用变量，保存了指向字典对象的地址值，当把dw值赋给swap()函数的dw参数后，函数swap()的dw参数也保存了地址值，也会应用到同一字典对象。如图：</li>
</ul>
<p><img src="http://c.biancheng.net/uploads/allimg/190213/2-1Z2131J63I52.gif"></p>
<ul>
<li>从这里可以看到这就是不折不扣的值传递，系统仍然复制了一份dw副本传入swap()函数。但是由于dw只是一个引用变量，因此系统复制的是dw变量，并没有复制对象本身。</li>
</ul>
</li>
<li><p>由于dw只是一个引用变量，故实际操作还是字典对象，也就看到了主程序中的dw引用的对象也发生了变化；</p>
</li>
<li><p>为了更好的证明主程序中的dw和swap()函数中的dw是两个变量，在swap()最后一行添加如下代码：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#把dw 直接赋值为None，让它不再指向任何对象</span></span><br><span class="line">dw = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>其内存如下：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190213/2-1Z2131JK5157.gif"></p>
<blockquote>
<p>从图 6 来看，把 swap() 函数中的 dw 赋值为 None 后，在 swap() 函数中失去了对字典对象的引用，不可再访问该字典对象。但主程序中的 dw 变量不受任何影响，依然可以引用该字典对象，所以依然可以输出字典对象的 a、b 元素的值。</p>
</blockquote>
<p><strong>结论：</strong></p>
<p>如果需要让函数修改某些数据，则可以通过把这些数据包装成列表、字典等可变对象，然后把列表、字典等可变对象作为参数传入函数，在函数中通过列表、字典的方法修改它们，这样才能改变这些数据。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_切片原理</title>
    <url>/2021/01/17/Python-%E5%88%87%E7%89%87%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>切片是Python重要的特性之一.与切片密切相关的是索引.一般情况下索引的返回值是序列的元素,切片的返回值是序列:</p>
<a id="more"></a>

<p>如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = <span class="built_in">tuple</span>(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">print(t[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">print(t[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"><span class="comment"># (1, 2)</span></span><br></pre></td></tr></table></figure>
<p>而在序列调用[ ] 时,默认调用的是__getitem__方法.</p>
<p>为了能够构建符合Python风格的索引与切片操作,或者为了学习Python的切片原理,我们对其切片进行分析.</p>
<p><strong>定义一个索引返回类进行查看</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mySeq</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line">s = mySeq()</span><br><span class="line">print(s[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">print(s[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"><span class="comment"># slice(1, 4, None)</span></span><br><span class="line">print(s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>])</span><br><span class="line"><span class="comment"># slice(1, 4, 2)</span></span><br><span class="line">print(s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>,<span class="number">9</span>])</span><br><span class="line"><span class="comment"># (slice(1, 4, 2), 9)</span></span><br><span class="line">print(s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span> , -<span class="number">5</span> :])</span><br><span class="line"><span class="comment"># (slice(1, 4, 2), slice(-5, None, None))</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当仅仅进行索引操作时返回的是数字</li>
<li>当仅一个切片操作时返回的是slice对象</li>
<li>当不仅一个切片操作时返回的时slice元组</li>
</ul>
<p><strong>slice类情况分析</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">slice</span>)</span><br><span class="line">print(<span class="built_in">dir</span>(<span class="built_in">slice</span>))</span><br><span class="line"><span class="comment">#&lt;class &#x27;slice&#x27;&gt;</span></span><br><span class="line"><span class="comment">#[&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__le__&#x27;, &#x27;__lt__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;indices&#x27;, &#x27;start&#x27;, &#x27;step&#x27;, &#x27;stop&#x27;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 上面的slice对象包含有诸多属性,其中start,stop,step我们都很清楚了.indices属性很关键.我们可以看下其解释:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">help</span>(<span class="built_in">slice</span>.indices))</span><br><span class="line">indices(...)</span><br><span class="line">    S.indices(len) -&gt; (start, stop, stride)</span><br><span class="line">    </span><br><span class="line">    Assuming a sequence of length <span class="built_in">len</span>, calculate the start <span class="keyword">and</span> stop</span><br><span class="line">    indices, <span class="keyword">and</span> the stride length of the extended <span class="built_in">slice</span> described by</span><br><span class="line">    S. Out of bounds indices are clipped <span class="keyword">in</span> a manner consistent <span class="keyword">with</span> the</span><br><span class="line">    handling of normal slices.</span><br><span class="line"></span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>那么slice的作用就是把你输入的start,stop,step进行计算,获得正确的索引:例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">slice</span>(<span class="literal">None</span> , <span class="number">10</span> ,<span class="number">2</span>).indices(<span class="number">10</span>))</span><br><span class="line">print(<span class="built_in">slice</span>(-<span class="number">3</span>,<span class="literal">None</span> , <span class="literal">None</span>).indices(<span class="number">5</span>))</span><br><span class="line">(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>这里我们已经知道getitem中该如何操作啦:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">import</span> itertools  <span class="comment"># &lt;1&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    typecode = <span class="string">&#x27;d&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, components</span>):</span></span><br><span class="line">        self._components = array(self.typecode, components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        components = reprlib.<span class="built_in">repr</span>(self._components)</span><br><span class="line">        components = components[components.find(<span class="string">&#x27;[&#x27;</span>):-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Vector(&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(components)</span><br><span class="line"></span><br><span class="line"><span class="comment"># BEGIN VECTOR_V2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        cls = <span class="built_in">type</span>(self)  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(index, <span class="built_in">slice</span>):  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">            <span class="keyword">return</span> cls(self._components[index])  <span class="comment"># &lt;3&gt;</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(index, numbers.Integral):  <span class="comment"># &lt;4&gt;</span></span><br><span class="line">            <span class="keyword">return</span> self._components[index]  <span class="comment"># &lt;5&gt;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg = <span class="string">&#x27;&#123;cls.__name__&#125; indices must be integers&#x27;</span></span><br><span class="line">            <span class="keyword">raise</span> TypeError(msg.<span class="built_in">format</span>(cls=cls))  <span class="comment"># &lt;6&gt;</span></span><br><span class="line">vec = Vector(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">print(vec[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"><span class="comment"># Vector([1.0, 2.0])</span></span><br></pre></td></tr></table></figure>
<p><strong>总结:</strong></p>
<p>Python中在切片或者索引的时候都会走__getitem__方法,对于切片来说会自动将输入范围定义为slice对象,通过解析此slice对象,可以获得正确的索引.</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_变量理解</title>
    <url>/2021/01/17/Python-%E5%8F%98%E9%87%8F%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>精准变量理解</p>
<a id="more"></a>

<h2 id="变量是不是盒子？"><a href="#变量是不是盒子？" class="headerlink" title="变量是不是盒子？"></a>变量是不是盒子？</h2><p>很多人将变量理解为盒子，其内部包裹着对象，然而这是不准确的。请看下面代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = a      </span><br><span class="line">a.append(<span class="number">4</span>)</span><br><span class="line">print(b)   </span><br><span class="line"><span class="comment"># [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>代码中，a,b 是指向同一列表对象的变量，修改a指向的对象，b指向的对象也随之改变。如果按照盒子去理解，那么a,b应该是分割的，正确理解为<strong>变量就是便利贴</strong>。如图：</p>
<p><img src="https://i.loli.net/2021/01/11/TfNDFEU1AcvVYdb.png"></p>
<p><strong>赋值语句的执行顺序</strong><br>Python中的赋值语句，始终是先读右边，对象在右侧创建或者获取，然后才会绑定到左侧的变量上，就像为对象贴上了便利贴；</p>
<h2 id="标识、相等性与别名"><a href="#标识、相等性与别名" class="headerlink" title="标识、相等性与别名"></a>标识、相等性与别名</h2><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>别名就是<strong>引用对同一对象</strong>的变量名称；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span> ,<span class="number">2</span> ,<span class="number">3</span>]</span><br><span class="line">b = a </span><br><span class="line">c = [<span class="number">1</span> ,<span class="number">2</span> ,<span class="number">3</span>]</span><br><span class="line">print(<span class="built_in">id</span>(a))</span><br><span class="line">print(<span class="built_in">id</span>(b))</span><br><span class="line">print(<span class="built_in">id</span>(c))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">15021560</span></span><br><span class="line"><span class="string">15021560</span></span><br><span class="line"><span class="string">15022720</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>可以看到通过赋值操作，b与a指向同一对象，b就是a的别名；而c指向的对象虽然内部元素与a一致，但是指向不同的对象，所以c不是a的别名。</p>
<h3 id="相等性：is-与"><a href="#相等性：is-与" class="headerlink" title="相等性：is 与 =="></a>相等性：is 与 ==</h3><p>这里大家都比较清除，Python中提供了两种相等性判定操作符：其中is用来判断两变量的标识（地址）。而==用来判断两对象的内部结构是否一致。</p>
<p><strong>TIPS:</strong> ==是一个语法糖，其等价于a.__eq__(b);而基类object中equal方法也是比较的双方的标识，结果与is是一样，一般的子类一般会重写此方法。</p>
<h3 id="元组的相对不可变性"><a href="#元组的相对不可变性" class="headerlink" title="元组的相对不可变性"></a>元组的相对不可变性</h3><p>首先我们要明确元组与列表等是一样的，其存储的是对象的引用。如果元组中的元素是可变的，那么即使元组不变（仍然指向那个内存地址），其内部元素仍然可变。也就是说元组的不可变性指的是<strong>数据结构的物理内容不可变（保存的引用不可变），与引用的对象无关。</strong>感觉就像是把指针冻住了，而没有冻住指向的对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">10</span> ,<span class="number">20</span>])</span><br><span class="line">t2 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">10</span> ,<span class="number">20</span>])</span><br><span class="line">print(t1 == t2) <span class="comment"># True , 俩元组对象内部内容一致</span></span><br><span class="line">print(t1 <span class="keyword">is</span> t2) <span class="comment"># False,不是同一个对象</span></span><br><span class="line">print(<span class="built_in">id</span>(t1)) <span class="comment"># 查看t1对象改变前的内存地址</span></span><br><span class="line">t1[-<span class="number">1</span>].append(<span class="number">30</span>)</span><br><span class="line">print(<span class="built_in">id</span>(t1))  <span class="comment"># 查看t1对象改变后的内存地址，即使内部元素已经变化而地址没有变</span></span><br><span class="line">print(t1)	</span><br><span class="line">print(t1 == t2)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">46182928</span></span><br><span class="line"><span class="string">46182928</span></span><br><span class="line"><span class="string">(1, 2, [10, 20, 30])</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里主要总结了Python中该如何理解变量，结论就是理解为便利贴。指向同一对象的便利贴之间的关系为别名。顺便讨论了在Python中常用到的相等性判断方法，延展出元组的相对不可变性。</p>
<p>总的来说，这一部分内容相对简单，更多的是在实践中检验。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_可迭代对象,迭代器,生成器</title>
    <url>/2021/01/17/Python-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<p>在流畅的Python一书中,讲述的有些混乱,这里我自己也只是整理下.</p>
<a id="more"></a>

<blockquote>
<p>来自于<a href="%E6%B5%81%E7%95%85%E7%9A%84Python">流畅的Python</a>.</p>
</blockquote>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>可迭代对象:实现了<strong>iter或者getitem</strong>方法的类实例,使用iter()内置方法可以获取可迭代对象.</li>
<li>迭代器:一种<strong>惰性</strong>获取数据的方式,也就是一次按需要获得一个数据的方式;</li>
<li>生成器: <strong>生成器就是迭代器</strong>,所有的生成器都实现了迭代器的”接口”.而生成器能够”凭空”<strong>生成</strong>元素.</li>
</ul>
<h2 id="背景知识-序列可以迭代的原因-iter函数"><a href="#背景知识-序列可以迭代的原因-iter函数" class="headerlink" title="背景知识:序列可以迭代的原因:iter函数"></a>背景知识:序列可以迭代的原因:iter函数</h2><p>解释器需要迭代对象x时,会自动调用iter(x)函数.</p>
<h3 id="内置的iter函数作用"><a href="#内置的iter函数作用" class="headerlink" title="内置的iter函数作用:"></a><strong>内置的iter函数作用:</strong></h3><ol>
<li><p>检查是否实现了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__iter__方法,如果实现了就调用它,获取一个迭代器.</span><br></pre></td></tr></table></figure></li>
<li><p>如果没有实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__iter__方法,但是实现了__getitem__方法,Python会创建一个迭代器,尝试按顺序(从索引0开始)获取元素.</span><br></pre></td></tr></table></figure></li>
<li><p>如果尝试失败则抛出TyprError异常,”object is not iterable”.</p>
</li>
</ol>
<h3 id="最简单的例子-实现-iter-函数"><a href="#最简单的例子-实现-iter-函数" class="headerlink" title="最简单的例子:实现 iter 函数"></a><strong>最简单的例子</strong>:实现 iter 函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最简单的可迭代类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line">print(<span class="built_in">issubclass</span>(Foo , abc.Iterable))</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">f = Foo()</span><br><span class="line">print(<span class="built_in">isinstance</span>(f , abc.Iterable))</span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>上面的例子我们发现当你实现了 iter ,系统已经默认你是Iter对象或者类.</p>
<p><strong>当你仅实现了 getitem ,则系统并不人为你是可迭代对象或者类</strong>,但是我们已经知道即使只实现 getitem 也会返回一个迭代器.可以看下面的例子.</p>
<h3 id="实现-getitem-函数的实例"><a href="#实现-getitem-函数的实例" class="headerlink" title="实现 getitem 函数的实例"></a>实现 getitem 函数的实例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, text</span>):</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RE_WORD.findall(text)  <span class="comment"># &lt;1&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.words[index]  <span class="comment"># &lt;2&gt;</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">issubclass</span>(Sentence , abc.Iterable))</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">f = Sentence(<span class="string">&quot;as das d&quot;</span>)</span><br><span class="line">print(<span class="built_in">isinstance</span>(f , abc.Iterable))</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> f:</span><br><span class="line">    print(c)</span><br><span class="line"><span class="comment"># as das d</span></span><br></pre></td></tr></table></figure>
<p>可以看到上面的例子只实现了 getitem ,系统并没有认为其为可迭代对象,<strong>然而却能够进行迭代操作.</strong></p>
<p><strong>该如何检查对象可迭代?</strong></p>
<p>从上面的原理与例子看,不能够通过isinstance或者issubclass等内置方法判定是否为可迭代对象,直接通过iter(x)即可.</p>
<h2 id="可迭代对象与迭代器对比"><a href="#可迭代对象与迭代器对比" class="headerlink" title="可迭代对象与迭代器对比"></a>可迭代对象与迭代器对比</h2><h3 id="定义细节"><a href="#定义细节" class="headerlink" title="定义细节"></a>定义细节</h3><p><strong>两者关系</strong>:Python可以通过可迭代对象获得迭代器</p>
<p><strong>迭代器:</strong> 迭代器是这样一个对象,其实现了两个方法,</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__next__():返回序列中下一个元素,如果没有则为StopIteration异常</span><br><span class="line">__iter__():迭代器本身也可以迭代</span><br></pre></td></tr></table></figure>
<p>可迭代对象并不是迭代器.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可迭代对象有一个__iter__方法,其作用是每次均实例化一个新的迭代器.</span><br><span class="line">而迭代器需要实现上面说的两个方法.</span><br><span class="line">故迭代器可以迭代,但是可迭代对象并不是迭代器.</span><br></pre></td></tr></table></figure>
<h3 id="迭代器的使用方式"><a href="#迭代器的使用方式" class="headerlink" title="迭代器的使用方式"></a>迭代器的使用方式</h3><p><strong>最常见的for 调用迭代器:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">	print(c)</span><br><span class="line"><span class="comment"># a b c</span></span><br></pre></td></tr></table></figure>
<p>上面的for循环其实就是使用了迭代器实现的上面的操作.其等价于:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&quot;abc&quot;</span></span><br><span class="line">it = <span class="built_in">iter</span>(S)</span><br><span class="line">print(<span class="built_in">next</span>(it))</span><br><span class="line">print(<span class="built_in">next</span>(it))</span><br><span class="line">print(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="comment"># a b c</span></span><br><span class="line"><span class="comment"># 上面的迭代器是无法还原的</span></span><br></pre></td></tr></table></figure>
<h3 id="两种可迭代对象的定义方式比较"><a href="#两种可迭代对象的定义方式比较" class="headerlink" title="两种可迭代对象的定义方式比较"></a>两种可迭代对象的定义方式比较</h3><p>我们上面知道了迭代器就是实现了next与iter两个方法的类,那么我们是单独构建迭代器对象还是在可迭代对象内部同时实现相关的方法呢?可以看下面的例子:</p>
<p><strong>可迭代对象同时实现迭代器在内部:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, text</span>):</span></span><br><span class="line">        self.text = text</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Sentence(%s)&#x27;</span> % reprlib.<span class="built_in">repr</span>(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        match = <span class="built_in">next</span>(self.word_iter)  <span class="comment"># &lt;4&gt;</span></span><br><span class="line">        <span class="keyword">return</span> match.group()  <span class="comment"># &lt;5&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure>


<p><strong>单独定义迭代器类</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, text</span>):</span></span><br><span class="line">        self.text = text</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Sentence(%s)&#x27;</span> % reprlib.<span class="built_in">repr</span>(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        word_iter = RE_WORD.finditer(self.text)  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">        <span class="keyword">return</span> SentenceIter(word_iter)  <span class="comment"># &lt;2&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SentenceIter</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, word_iter</span>):</span></span><br><span class="line">        self.word_iter = word_iter  <span class="comment"># &lt;3&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        match = <span class="built_in">next</span>(self.word_iter)  <span class="comment"># &lt;4&gt;</span></span><br><span class="line">        <span class="keyword">return</span> match.group()  <span class="comment"># &lt;5&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>很明显单独构建一个迭代器类更加合理,理由之一:为了支持”多种遍历”,必须能从一个可迭代的实例中获取多个独立的迭代器,而且各个迭代器能维护自身的内部状态.</p>
<h2 id="生成器函数充当迭代器"><a href="#生成器函数充当迭代器" class="headerlink" title="生成器函数充当迭代器"></a>生成器函数充当迭代器</h2><p>上面提供的例子中单独定义了迭代器类,但是我们知道生成器也是迭代器,所以利用生成器也可以定义出可迭代对象.</p>
<h3 id="生成器函数-关键字-yield"><a href="#生成器函数-关键字-yield" class="headerlink" title="生成器函数:关键字 yield"></a>生成器函数:关键字 yield</h3><p><strong>包含有yield关键字,该函数就是生成器函数.</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_123</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">print(<span class="built_in">type</span>(gen_123))</span><br><span class="line"><span class="comment"># &lt;class &#x27;function&#x27;&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>(gen_123()))</span><br><span class="line"><span class="comment"># &lt;class &#x27;generator&#x27;&gt;</span></span><br><span class="line">g = gen_123()</span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<p>可以看到实例化后,为一个生成器,也就是迭代器.</p>
<h3 id="生成器函数充当迭代器的应用"><a href="#生成器函数充当迭代器的应用" class="headerlink" title="生成器函数充当迭代器的应用:"></a>生成器函数充当迭代器的应用:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, text</span>):</span></span><br><span class="line">        self.text = text  <span class="comment"># &lt;1&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Sentence(%s)&#x27;</span> % reprlib.<span class="built_in">repr</span>(self.text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text):  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">            <span class="keyword">yield</span> match.group()  <span class="comment"># &lt;3&gt;</span></span><br><span class="line">S = Sentence(<span class="string">&quot;A D F G H&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">    print(c)</span><br><span class="line"><span class="comment"># A</span></span><br><span class="line"><span class="comment"># D</span></span><br><span class="line"><span class="comment"># F</span></span><br><span class="line"><span class="comment"># G</span></span><br><span class="line"><span class="comment"># H</span></span><br></pre></td></tr></table></figure>
<p>生成器函数会创建一个生成器对象.并将生成器传给next()函数时,生成器会向前,执行下一个Yield语句,返回产出的值.知道迭代完成.</p>
<h2 id="惰性实现迭代器"><a href="#惰性实现迭代器" class="headerlink" title="惰性实现迭代器"></a>惰性实现迭代器</h2><p>惰性实现就是不急于实现,生成器就是一种惰性实现.先对于一次性获得所有的元素,惰性实现会减少内存的消耗.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, text</span>):</span></span><br><span class="line">        self.text = text</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Sentence(%s)&#x27;</span> % reprlib.<span class="built_in">repr</span>(self.text)</span><br><span class="line"><span class="comment"># re.finditer()返回的是一个迭代器,能够节省大量的内存</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text):</span><br><span class="line">           <span class="keyword">yield</span> match.group()</span><br><span class="line">S = Sentence(<span class="string">&quot;A B C D E&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">    print(c)</span><br><span class="line"><span class="comment"># A B C D E</span></span><br></pre></td></tr></table></figure>
<p>其实这里在书中的意义更像是在过度.</p>
<h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>与列表表达式一样,这里可以使用生成式表达式,构造生成器.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(match.group() <span class="keyword">for</span> match <span class="keyword">in</span> re.finditer(self.text))</span><br></pre></td></tr></table></figure>
<p>这里没有详细的写,也记不住.哟</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在书中作者还编写了其他的部分,例如标准库中的生成器函数,完整的实例应用以及其他的小细节.我这里仅仅对关于生成器的理论部分进行了论述,理解可迭代对象,迭代器,生成器的关系,以及基本的使用即可.</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_字符串格式化</title>
    <url>/2021/01/17/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    <content><![CDATA[<p>题目中提到的%与format都是Python支持的字符串<strong>格式化</strong>方法，两个都好用，format函数是出现的比较晚，其功能相对全面，一般推荐使用format函数进行格式化；</p>
<a id="more"></a>

<blockquote>
<p><a href="https://www.runoob.com/python/att-string-format.html">菜鸟教程format</a>，<a href="https://www.runoob.com/python3/python3-string.html">菜鸟教程%</a></p>
</blockquote>
<h2 id="两方法差异"><a href="#两方法差异" class="headerlink" title="两方法差异"></a>两方法差异</h2><p>这里直接摘抄网友的结论：</p>
<blockquote>
<p>format的优点</p>
<p>1.不需要理会数据类型的问题，在%方法中%s只能替代字符串类型</p>
<p>2.单个参数可以多次输出，参数顺序可以不相同</p>
<p>3.填充方式十分灵活，对齐方式十分强大</p>
<p>4.官方推荐用的方式，%方式将会在后面的版本被淘汰</p>
</blockquote>
<h2 id="的使用方法"><a href="#的使用方法" class="headerlink" title="%的使用方法"></a>%的使用方法</h2><h2 id="format的使用方法"><a href="#format的使用方法" class="headerlink" title="format的使用方法"></a>format的使用方法</h2>]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_序列</title>
    <url>/2021/01/17/Python-%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>Python中存在大量的序列类型，每种序列类型都具备自己的特点与使用场景，了解其机制有利于构造更加高效的代码与自制序列类。</p>
<a id="more"></a>

<blockquote>
<p><a href="%E4%BC%98%E9%9B%85%E7%9A%84Python">优雅的Python第二章</a></p>
</blockquote>
<h2 id="内置序列概况"><a href="#内置序列概况" class="headerlink" title="内置序列概况"></a>内置序列概况</h2><p>按照能否存储同一数据类型数据分为：</p>
<ul>
<li><strong>容器</strong>序列：list,tuple,collections.deque,存储的为任意类型的<strong>引用</strong>，内存空间<strong>不连续</strong>。</li>
<li><strong>扁平</strong>序列：str,bytes,bytearray,memoryview,array.array，存储的是同一类型的<strong>值</strong>，内存空间<strong>连续</strong>。</li>
</ul>
<blockquote>
<p>上段时间我总结了关于Python中值传递与引用传递问题时，有提到相关概念的区别。</p>
</blockquote>
<p>按照序列类型能否修改：</p>
<ul>
<li>可变序列：list,bytearray.array.array,collection.deque,memoryview</li>
<li>不可变序列：tuple,str,bytes</li>
</ul>
<h2 id="list序列"><a href="#list序列" class="headerlink" title="list序列"></a>list序列</h2><p>列表类型是Python中常见的序列类型，其使用已烂熟于心，不妨关于列表的创建方法：</p>
<h3 id="列表推导与列表生成"><a href="#列表推导与列表生成" class="headerlink" title="列表推导与列表生成"></a>列表推导与列表生成</h3><h4 id="列表推导的简单使用"><a href="#列表推导的简单使用" class="headerlink" title="列表推导的简单使用"></a>列表推导的简单使用</h4><p>列表推导就是用于<strong>生成列表</strong>的，其是一种易于<strong>阅读</strong>的列表生成方式。</p>
<ul>
<li><p>传统的列表构造方式：for + append</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将一个字符串转换为Unicode码位列表</span></span><br><span class="line">symbols = <span class="string">&quot;$#@%&amp;*&quot;</span></span><br><span class="line">codes = []</span><br><span class="line"><span class="keyword">for</span> symbol <span class="keyword">in</span> symbols:</span><br><span class="line">    codes.append(<span class="built_in">ord</span>(symbol))</span><br><span class="line">print(codes)</span><br><span class="line"><span class="comment"># [36, 35, 64, 37, 38, 42]</span></span><br></pre></td></tr></table></figure></li>
<li><p>列表生成式：[ func(s) for s in strs]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将一个字符串转换为Unicode码位列表</span></span><br><span class="line">symbols = <span class="string">&quot;$#@%&amp;*&quot;</span></span><br><span class="line">codes = [<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols ]</span><br><span class="line">print(codes)</span><br><span class="line"><span class="comment"># [36, 35, 64, 37, 38, 42]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>使用标准：</strong></p>
<p>上面两种方式实现了相同的功能，使用哪一种取决于逻辑的复杂程度，逻辑复杂需要编写多行才能表示的使用传统for循环的方式更清晰，逻辑简单的使用列表推导方式则更加易读。</p>
<p>**TIPS:**Python会忽略代码中[],(),{}中的换行符号，方便逻辑展示。</p>
<h4 id="列表推导与map，filter的关系"><a href="#列表推导与map，filter的关系" class="headerlink" title="列表推导与map，filter的关系"></a>列表推导与map，filter的关系</h4><p>关系就是：map，filter能做的，利用列表推导同样可以实现。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 得到所有ASCII大于36的结果,列表生成</span></span><br><span class="line">symbols = <span class="string">&quot;$#@%&amp;*&quot;</span></span><br><span class="line">beyond_ascii = [<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols <span class="keyword">if</span> <span class="built_in">ord</span>(symbol) &gt; <span class="number">36</span>]</span><br><span class="line">print(beyond_ascii)</span><br><span class="line"><span class="comment"># [64, 37, 38, 42]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 得到所有ASCII大于36的结果,map,filter,lambda</span></span><br><span class="line">symbols = <span class="string">&quot;$#@%&amp;*&quot;</span></span><br><span class="line">beyond_ascii = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> c:c &gt; <span class="number">36</span> , <span class="built_in">map</span>(<span class="built_in">ord</span> , symbols)))</span><br><span class="line">print(beyond_ascii)</span><br><span class="line"><span class="comment"># [64, 37, 38, 42]</span></span><br></pre></td></tr></table></figure>
<h4 id="列表推导与笛卡儿积"><a href="#列表推导与笛卡儿积" class="headerlink" title="列表推导与笛卡儿积"></a>列表推导与笛卡儿积</h4><p>在列表推导中也可以生成笛卡儿积，直接看代码即可；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sizes = [<span class="string">&quot;small&quot;</span> , <span class="string">&quot;medium&quot;</span> , <span class="string">&quot;large&quot;</span>]</span><br><span class="line">colors = [<span class="string">&quot;white&quot;</span> , <span class="string">&quot;black&quot;</span>]</span><br><span class="line">print([(size  , color) <span class="keyword">for</span> size <span class="keyword">in</span> sizes </span><br><span class="line">       							  <span class="keyword">for</span> color <span class="keyword">in</span> colors ])</span><br><span class="line"><span class="comment"># [(&#x27;small&#x27;, &#x27;white&#x27;), (&#x27;small&#x27;, &#x27;black&#x27;), (&#x27;medium&#x27;, &#x27;white&#x27;), (&#x27;medium&#x27;, &#x27;black&#x27;), (&#x27;large&#x27;, &#x27;white&#x27;), (&#x27;large&#x27;, &#x27;black&#x27;)]</span></span><br></pre></td></tr></table></figure>
<h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><p>列表生成式也是生成列表的方式，其遵循了<strong>迭代器</strong>协议，逐个的产出元素，而<strong>不是建立完整的列表</strong>，显然可以<strong>节省内存</strong>。其形式与列表推导式大同小异，仅仅将<strong>方括号替换为圆括号</strong>。</p>
<ul>
<li>生成式是唯一参数时，不需要添加圆括号。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">symbols = <span class="string">&quot;$#@%&amp;*&quot;</span></span><br><span class="line">codes = <span class="built_in">list</span>(<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols)</span><br><span class="line">print(codes)</span><br><span class="line"><span class="comment"># [36, 35, 64, 37, 38, 42]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>生成式不是唯一参数时，需要添加圆括号。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> array</span><br><span class="line">symbols = <span class="string">&quot;$#@%&amp;*&quot;</span></span><br><span class="line">codes = array.array(<span class="string">&quot;I&quot;</span>,(<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols))</span><br><span class="line">print(codes)</span><br><span class="line"><span class="comment"># array(&#x27;I&#x27;, [36, 35, 64, 37, 38, 42])</span></span><br></pre></td></tr></table></figure>
<ul>
<li>生成式计算笛卡儿积</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sizes = [<span class="string">&quot;small&quot;</span> , <span class="string">&quot;medium&quot;</span> , <span class="string">&quot;large&quot;</span>]</span><br><span class="line">colors = [<span class="string">&quot;white&quot;</span> , <span class="string">&quot;black&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> tshirts <span class="keyword">in</span> (<span class="string">&quot;%s %s&quot;</span>%(size  , color) <span class="keyword">for</span> size <span class="keyword">in</span> sizes <span class="keyword">for</span> color <span class="keyword">in</span> colors ):</span><br><span class="line">print(tshirts)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">small white</span></span><br><span class="line"><span class="string">small black</span></span><br><span class="line"><span class="string">medium white</span></span><br><span class="line"><span class="string">medium black</span></span><br><span class="line"><span class="string">large white</span></span><br><span class="line"><span class="string">large black</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="Tuple序列"><a href="#Tuple序列" class="headerlink" title="Tuple序列"></a>Tuple序列</h2><p>元组不仅仅是不可变的列表，如何使用也取决于如何看代元组，例如将元素视为用于<strong>记录的字段数据</strong>。那么其数量与位置信息则是非常重要的，</p>
<ul>
<li>元组用于记录：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">metro_areas = [</span><br><span class="line">    (<span class="string">&#x27;Tokyo&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>)),   <span class="comment"># &lt;1&gt;</span></span><br><span class="line">    (<span class="string">&#x27;Delhi NCR&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>)),</span><br><span class="line">    (<span class="string">&#x27;Mexico City&#x27;</span>, <span class="string">&#x27;MX&#x27;</span>, <span class="number">20.142</span>, (<span class="number">19.433333</span>, -<span class="number">99.133333</span>)),</span><br><span class="line">    (<span class="string">&#x27;New York-Newark&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="number">20.104</span>, (<span class="number">40.808611</span>, -<span class="number">74.020386</span>)),</span><br><span class="line">    (<span class="string">&#x27;Sao Paulo&#x27;</span>, <span class="string">&#x27;BR&#x27;</span>, <span class="number">19.649</span>, (-<span class="number">23.547778</span>, -<span class="number">46.635833</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;&#123;:15&#125; | &#123;:^9&#125; | &#123;:^9&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;lat.&#x27;</span>, <span class="string">&#x27;long.&#x27;</span>))</span><br><span class="line">fmt = <span class="string">&#x27;&#123;:15&#125; | &#123;:9.4f&#125; | &#123;:9.4f&#125;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> name, cc, pop, (latitude, longitude) <span class="keyword">in</span> metro_areas:  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">    <span class="keyword">if</span> longitude &lt;= <span class="number">0</span>:  <span class="comment"># &lt;3&gt;</span></span><br><span class="line">        print(fmt.<span class="built_in">format</span>(name, latitude, longitude))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                |   lat.    |   long.  </span></span><br><span class="line"><span class="string">Mexico City     |   19.4333 |  -99.1333</span></span><br><span class="line"><span class="string">New York-Newark |   40.8086 |  -74.0204</span></span><br><span class="line"><span class="string">Sao Paulo       |  -23.5478 |  -46.6358</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>元组内部可嵌套，其内部嵌套标准这里不讨论。</li>
<li>元组可以进行<strong>拆包</strong></li>
</ol>
<h3 id="元组拆包"><a href="#元组拆包" class="headerlink" title="元组拆包"></a>元组拆包</h3><p>拆包就是将元组中的各元素一次性提取到多变量中。平行赋值是元组拆包的形式之一，也是最好辨认的形式。</p>
<ul>
<li>平行赋值示例：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lax_coordinates = (<span class="number">33.9425</span> , -<span class="number">118.4080</span>)</span><br><span class="line">latitude , longitude = lax_coordinates</span><br><span class="line">print(latitude)</span><br><span class="line">print(longitude)</span><br><span class="line"><span class="comment">#33.9425</span></span><br><span class="line"><span class="comment">#-118.408</span></span><br></pre></td></tr></table></figure>
<ul>
<li>“*” 来表示剩余的元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a , b , *rest = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line">print(a , b , rest)</span><br><span class="line"><span class="comment"># 0 1 [2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>嵌套元组的拆包</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">metro_areas = [</span><br><span class="line">    (<span class="string">&#x27;Tokyo&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>)),   <span class="comment"># &lt;1&gt;</span></span><br><span class="line">    (<span class="string">&#x27;Delhi NCR&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>)),</span><br><span class="line">    (<span class="string">&#x27;Mexico City&#x27;</span>, <span class="string">&#x27;MX&#x27;</span>, <span class="number">20.142</span>, (<span class="number">19.433333</span>, -<span class="number">99.133333</span>)),</span><br><span class="line">    (<span class="string">&#x27;New York-Newark&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="number">20.104</span>, (<span class="number">40.808611</span>, -<span class="number">74.020386</span>)),</span><br><span class="line">    (<span class="string">&#x27;Sao Paulo&#x27;</span>, <span class="string">&#x27;BR&#x27;</span>, <span class="number">19.649</span>, (-<span class="number">23.547778</span>, -<span class="number">46.635833</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;&#123;:15&#125; | &#123;:^9&#125; | &#123;:^9&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;lat.&#x27;</span>, <span class="string">&#x27;long.&#x27;</span>))</span><br><span class="line">fmt = <span class="string">&#x27;&#123;:15&#125; | &#123;:9.4f&#125; | &#123;:9.4f&#125;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> name, cc, pop, (latitude, longitude) <span class="keyword">in</span> metro_areas:  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">    <span class="keyword">if</span> longitude &lt;= <span class="number">0</span>:  <span class="comment"># &lt;3&gt;</span></span><br><span class="line">        print(fmt.<span class="built_in">format</span>(name, latitude, longitude))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                |   lat.    |   long.  </span></span><br><span class="line"><span class="string">Mexico City     |   19.4333 |  -99.1333</span></span><br><span class="line"><span class="string">New York-Newark |   40.8086 |  -74.0204</span></span><br><span class="line"><span class="string">Sao Paulo       |  -23.5478 |  -46.6358</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="具名元组"><a href="#具名元组" class="headerlink" title="具名元组"></a>具名元组</h3><p>具名元组是collection类的一个工厂函数，可以用来构建<strong>一个带字段名的元组和一个有名字的类</strong>。具体使用方式这里不表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">City = namedtuple(<span class="string">&quot;City&quot;</span> , <span class="string">&quot;name country population coordinates&quot;</span>)</span><br><span class="line">tokyo = City(<span class="string">&quot;Tokyo&quot;</span> , <span class="string">&quot;JP&quot;</span> , <span class="number">36.933</span> , (<span class="number">35.68</span> , <span class="number">139.69</span>))</span><br><span class="line">print(tokyo)</span><br><span class="line">print(tokyo.name)</span><br><span class="line">print(tokyo.coordinates)</span><br><span class="line">print(tokyo[<span class="number">0</span>])</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">City(name=&#x27;Tokyo&#x27;, country=&#x27;JP&#x27;, population=36.933, coordinates=(35.68, 139.69))</span></span><br><span class="line"><span class="string">Tokyo</span></span><br><span class="line"><span class="string">(35.68, 139.69)</span></span><br><span class="line"><span class="string">Tokyo</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="序列中的-与"><a href="#序列中的-与" class="headerlink" title="序列中的 + 与 *"></a>序列中的 + 与 *</h2><p>Python中的序列是支持的+与* 操作的，用于序列的拼接。而用于拼接的序列是不会被更改的，而是创建一个包含有同样类型的序列并返回。</p>
<p>“+”用于拼接序列时，一般要求<strong>左右元素的类型一致</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment"># * 的应用</span></span><br><span class="line">print(l*<span class="number">5</span>)</span><br><span class="line">print(<span class="string">&quot;abcd&quot;</span> * <span class="number">5</span>)</span><br><span class="line"><span class="comment"># [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]</span></span><br><span class="line"><span class="comment"># abcdabcdabcdabcdabcd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># + 的应用</span></span><br><span class="line">print(l + [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6] </span></span><br><span class="line">print(l + <span class="number">4</span>)</span><br><span class="line"><span class="comment"># TypeError: can only concatenate list (not &quot;int&quot;) to list</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>在使用a * n语句时，序列中的<strong>a中的元素是对其他可变对象的引用</strong>时，得到的结果可能会与预期存在不一致。我自己在编写算法过程中也遇到类似的情形。比如：初始化列表中的列表时，得到的三个元素是三个引用，三个引用指向的地址一致，</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正确的使用姿势</span></span><br><span class="line">board = [[<span class="string">&quot;_&quot;</span>] * <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>) ]</span><br><span class="line">board[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">&quot;x&quot;</span></span><br><span class="line">print(board)</span><br><span class="line"><span class="comment"># [[&#x27;_&#x27;, &#x27;x&#x27;, &#x27;_&#x27;], [&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;], [&#x27;_&#x27;, &#x27;_&#x27;, &#x27;_&#x27;]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误的使用姿势</span></span><br><span class="line">board = [[<span class="string">&quot;_&quot;</span>] * <span class="number">3</span> ] * <span class="number">3</span></span><br><span class="line">board[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">&quot;x&quot;</span></span><br><span class="line">print(board)</span><br><span class="line"><span class="comment"># [[&#x27;_&#x27;, &#x27;x&#x27;, &#x27;_&#x27;], [&#x27;_&#x27;, &#x27;x&#x27;, &#x27;_&#x27;], [&#x27;_&#x27;, &#x27;x&#x27;, &#x27;_&#x27;]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的错误与接下来的写法一致</span></span><br><span class="line">row = [<span class="string">&quot;_&quot;</span>] * <span class="number">3</span></span><br><span class="line">board = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">  board.append(row)</span><br><span class="line">board[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">&quot;x&quot;</span></span><br><span class="line">print(board)</span><br><span class="line"><span class="comment"># [[&#x27;_&#x27;, &#x27;x&#x27;, &#x27;_&#x27;], [&#x27;_&#x27;, &#x27;x&#x27;, &#x27;_&#x27;], [&#x27;_&#x27;, &#x27;x&#x27;, &#x27;_&#x27;]]</span></span><br></pre></td></tr></table></figure>
<h2 id="序列中的-与-运算"><a href="#序列中的-与-运算" class="headerlink" title="序列中的 += 与 *= 运算"></a>序列中的 += 与 *= 运算</h2><p>序列中的增量赋值运算，大同小异，只介绍+= 即可。理解增量赋值运算，主要是其结果到底是<strong>就地加法</strong>还是<strong>构造新的对象</strong>并赋值。</p>
<p><strong>Python遇到+=时</strong></p>
<ul>
<li>首先会调用“__iadd__”(就地加法方法)，__</li>
<li>如果没有实现，则调用“__add__”,此时等价于a = a +b.</li>
</ul>
<p>而上面是否实现了<strong>就地加法</strong>，却决于a是否是可变对象，比如列表就实现了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可变类型遇到增量赋值，一般为原地修改</span></span><br><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">print(<span class="built_in">id</span>(l))</span><br><span class="line"><span class="comment"># 29050360</span></span><br><span class="line">l += [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">print(<span class="built_in">id</span>(l))</span><br><span class="line"><span class="comment"># 29050360</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不可变类型遇到增量复制，会重新构造对象</span></span><br><span class="line">a = <span class="string">&quot;abcd&quot;</span></span><br><span class="line">print(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="comment"># 29036000</span></span><br><span class="line">a += <span class="string">&quot;efgh&quot;</span></span><br><span class="line">print(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="comment"># 59961416</span></span><br></pre></td></tr></table></figure>
<h2 id="list-sort与内置的sorted方法"><a href="#list-sort与内置的sorted方法" class="headerlink" title="list.sort与内置的sorted方法"></a>list.sort与内置的sorted方法</h2><p>上面的两个方法作用一致，其差别就是list.sort方法会选择原地重建列表结构，地址不变。内置的sorted方法则是重构一个列表对象，并返回。</p>
<h3 id="奇妙的key参数"><a href="#奇妙的key参数" class="headerlink" title="奇妙的key参数"></a>奇妙的key参数</h3><p>在list.sort\sorted\min\max函数中均提供了key参数，用于进行比较大小的依据。在一般的语言中，甚至在python2中也采用了<strong>双参数</strong>函数用于返回“-1，0，1”，以表示大小。而Python3中的key参数支持<strong>单参数</strong>函数进行比较。单参数的优势在于其更加高效，<strong>每个key函数只会调用一次</strong>。在排序中，自然会进行两个键值的比较，但是其发生才C语言一层，这样保证了其高效性。</p>
<p><strong>示例：实现字符与数字的序列排序</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">24</span>,<span class="number">14</span>,<span class="string">&quot;28&quot;</span> , <span class="number">5</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span> , <span class="number">6</span>,<span class="string">&quot;23&quot;</span> , <span class="number">19</span>]</span><br><span class="line">print(<span class="built_in">sorted</span>(l , key= <span class="built_in">int</span>))</span><br><span class="line"><span class="comment"># [&#x27;0&#x27;, &#x27;1&#x27;, 5, 6, &#x27;9&#x27;, 14, 19, &#x27;23&#x27;, 24, &#x27;28&#x27;]</span></span><br><span class="line"></span><br><span class="line">l = [<span class="number">24</span>,<span class="number">14</span>,<span class="string">&quot;28&quot;</span> , <span class="number">5</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span> , <span class="number">6</span>,<span class="string">&quot;23&quot;</span> , <span class="number">19</span>]</span><br><span class="line">print(<span class="built_in">sorted</span>(l , key= <span class="built_in">str</span>))</span><br><span class="line"><span class="comment"># [&#x27;0&#x27;, &#x27;1&#x27;, 14, 19, &#x27;23&#x27;, 24, &#x27;28&#x27;, 5, 6, &#x27;9&#x27;]</span></span><br></pre></td></tr></table></figure>
<h2 id="bisect来管理已排序序列"><a href="#bisect来管理已排序序列" class="headerlink" title="bisect来管理已排序序列"></a>bisect来管理已排序序列</h2><p>看理解就是利用二分查找，用来快速定位元素。支持左右二分查找，支持插入元素等。这里不一一贴代码。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_当函数参数为引用时</title>
    <url>/2021/01/17/Python-%E5%BD%93%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%BA%E5%BC%95%E7%94%A8%E6%97%B6/</url>
    <content><![CDATA[<p>Python在函数传递中唯一支持<strong>共享传参</strong>。共享传参指函数的各个形参获得实参中各个引用的副本，也可以说形参就是实参的别名。</p>
<a id="more"></a>

<p>而上面的参数传递机制就导致了当传入的是可变对象时，可能导致外面对象也出现变化。这一部分已经在值传递与引用传递部分讨论过。本文针对的就是当你传递的就是可变类型时应当如何编写代码是比较好的习惯，</p>
<h2 id="不可以使用可变参数作为默认值"><a href="#不可以使用可变参数作为默认值" class="headerlink" title="不可以使用可变参数作为默认值"></a>不可以使用可变参数作为默认值</h2><p>在Python中允许参数存在默认值，然而应当避免使用<strong>可变参数作为默认值</strong>。例如以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus1 = HauntedBus([&#x27;Alice&#x27;, &#x27;Bill&#x27;])</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus1.passengers</span></span><br><span class="line"><span class="string">[&#x27;Alice&#x27;, &#x27;Bill&#x27;]</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus1.pick(&#x27;Charlie&#x27;)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus1.drop(&#x27;Alice&#x27;)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus1.passengers</span></span><br><span class="line"><span class="string">[&#x27;Bill&#x27;, &#x27;Charlie&#x27;]</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus2 = HauntedBus()</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus2.pick(&#x27;Carrie&#x27;)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers</span></span><br><span class="line"><span class="string">[&#x27;Carrie&#x27;]</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus3 = HauntedBus()</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus3.passengers</span></span><br><span class="line"><span class="string">[&#x27;Carrie&#x27;]</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus3.pick(&#x27;Dave&#x27;)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers</span></span><br><span class="line"><span class="string">[&#x27;Carrie&#x27;, &#x27;Dave&#x27;]</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers is bus3.passengers</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus1.passengers</span></span><br><span class="line"><span class="string">[&#x27;Bill&#x27;, &#x27;Charlie&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>dir(HauntedBus.__init__)  # doctest: +ELLIPSIS</span></span><br><span class="line"><span class="string">[&#x27;__annotations__&#x27;, &#x27;__call__&#x27;, ..., &#x27;__defaults__&#x27;, ...]</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>HauntedBus.__init__.__defaults__</span></span><br><span class="line"><span class="string">([&#x27;Carrie&#x27;, &#x27;Dave&#x27;],)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>HauntedBus.__init__.__defaults__[0] is bus2.passengers</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BEGIN HAUNTED_BUS_CLASS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HauntedBus</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;A bus model haunted by ghost passengers&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, passengers=[]</span>):</span>  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">        self.passengers = passengers  <span class="comment"># &lt;2&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.passengers.append(name)  <span class="comment"># &lt;3&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drop</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.passengers.remove(name)</span><br></pre></td></tr></table></figure>
<p>上面定义了一个Bus类，其初始化方法中采用了[ ](**可变参数**)作为乘客为空时的默认值，乍一看没有问题。而上面的代码展示中发现，bus2,bus3中初始化均为空，而bus3在初始化后，其内部的乘客与bus2一模一样。而且代码显示，两辆车的乘客地址一致。这就不符合想要的逻辑效果。</p>
<p>其<strong>根源在于</strong>默认值是在定义函数时（加载模块时）构建的，随后成为其函数对象的属性。因此，如果默认值为可变对象，并且修改了其值那么后续的函数会受到影响。</p>
<p><strong>解决思路：</strong>通常采用None作为接收可变值的参数的默认值。如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>basketball_team = [&#x27;Sue&#x27;, &#x27;Tina&#x27;, &#x27;Maya&#x27;, &#x27;Diana&#x27;, &#x27;Pat&#x27;]</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus = TwilightBus(basketball_team)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus.drop(&#x27;Tina&#x27;)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus.drop(&#x27;Pat&#x27;)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>basketball_team</span></span><br><span class="line"><span class="string">[&#x27;Sue&#x27;, &#x27;Maya&#x27;, &#x27;Diana&#x27;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BEGIN TWILIGHT_BUS_CLASS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwilightBus</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;A bus model that makes passengers vanish&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, passengers=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.passengers = []  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.passengers = passengers  <span class="comment">#&lt;2&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.passengers.append(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drop</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.passengers.remove(name)  <span class="comment"># &lt;3&gt;</span></span><br><span class="line"><span class="comment"># END TWILIGHT_BUS_CLASS</span></span><br></pre></td></tr></table></figure>
<h2 id="防御可变参数"><a href="#防御可变参数" class="headerlink" title="防御可变参数"></a>防御可变参数</h2><p>上面的代码解决了初始化不适用可变参数的问题，但是却发现，函数内部的使用干扰了外部的使用。原因很明确，也是相同引用的问题。可以改编成这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, passengers=<span class="literal">None</span></span>):</span></span><br><span class="line">       <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">           self.passengers = []  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           self.passengers = <span class="built_in">list</span>(passengers)  <span class="comment">#&lt;2&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_文本与字节序列</title>
    <url>/2021/01/17/Python-%E6%96%87%E6%9C%AC%E4%B8%8E%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>关于Python2与3的编码差异、unicode的概念、encode与Decode的问题都在<a href="python2%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98.md">Python2编码问题</a>已经讨论过。这里讨论的是</p>
<ol>
<li><p>如何解决与理解编码出现的问题？</p>
</li>
<li><p>BOM是什么</p>
</li>
<li><p>处理文本文件时的建议</p>
</li>
<li><p>规范化Unicode字符串</p>
<a id="more"></a>

</li>
</ol>
<h2 id="编码相关的问题"><a href="#编码相关的问题" class="headerlink" title="编码相关的问题"></a>编码相关的问题</h2><h3 id="问题是怎么产生的？"><a href="#问题是怎么产生的？" class="headerlink" title="问题是怎么产生的？"></a>问题是怎么产生的？</h3><p>日常应用中在解码与编码过程中经常会报错，而报错的原因多半是由于以当前给定的编码方式无法正确解码。这说明不同的编码机制只能对一部分字符进行编码，当你采用其他编码算法进行解码时，那么则无法适配。如图所示：</p>
<p><img src="https://i.loli.net/2021/01/11/dDGFmAPWMS9RXEz.png"></p>
<p>在上图中不同的字符，存在部分编码机制没法编码。而在使用中往往出现有三种编码机制：ascII,gbk,utf-8这三种。</p>
<h3 id="了解解码问题"><a href="#了解解码问题" class="headerlink" title="了解解码问题"></a>了解解码问题</h3><h4 id="UnicodeEncodeError"><a href="#UnicodeEncodeError" class="headerlink" title="UnicodeEncodeError"></a>UnicodeEncodeError</h4><p>多数非UTF编码器只能处理Unicode字符的小部分子集。将文本转换为字节序列时，如果目标编码中没有定义某个字符，就会抛出UnicdeEncodeError异常，除非把errors参数传递给编码方法或函数，对错误进行特殊处理。</p>
<p><img src="https://i.loli.net/2021/01/11/gYvAfI86uF4QB95.png"></p>
<p>上面的代码中展示了3中cp437编码算法无法处理此字符。可通过errors关键字对错误进行相关处理，而不抛出异常。</p>
<ul>
<li>ignore:跳过无法编码的字符，并不推荐使用</li>
<li>replace：将无法编码的字符替换为？；数据出现损坏，用户知道</li>
<li>xmlcharrefreplace：无法编码的字符替换为xml实体</li>
</ul>
<h4 id="UnicodeDecodeError"><a href="#UnicodeDecodeError" class="headerlink" title="UnicodeDecodeError"></a>UnicodeDecodeError</h4><p>将字节转换为字符过程中出错，会抛出此异常。</p>
<p><img src="https://i.loli.net/2021/01/11/xZXvn67BcqkmVlP.png"></p>
<h4 id="SyntaxError"><a href="#SyntaxError" class="headerlink" title="SyntaxError"></a>SyntaxError</h4><h4 id="如何确定当前的编码"><a href="#如何确定当前的编码" class="headerlink" title="如何确定当前的编码"></a>如何确定当前的编码</h4><p>不能，除非有人告诉你。但是每种编码有自己的特点，统一字符编码侦测包 Chardet（<a href="https://pypi.python.org/pypi/chardet%EF%BC%89%E5%B0%B1%E6%98%AF%E8%BF%99%E6%A0%B7%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%8C%E5%AE%83%E8%83%BD%E8%AF%86%E5%88%AB%E6%89%80%E6%94%AF%E6%8C%81%E7%9A%84">https://pypi.python.org/pypi/chardet）就是这样工作的，它能识别所支持的</a> 30 种编码。Chardet 是一个 Python 库，可以在程序中使用，不过它也提供了<br>命令行工具 chardetect。下面是它对本章书稿文件的检测报告：</p>
<p><img src="https://i.loli.net/2021/01/11/uZYglQELvPWwXr4.png"></p>
<h2 id="处理文本文件的建议"><a href="#处理文本文件的建议" class="headerlink" title="处理文本文件的建议"></a>处理文本文件的建议</h2><p>存在一个三明治逻辑，将中间的肉比喻为业务的核心逻辑，将上面包比喻为字节转换为字符的过程，将下面包比喻为将字符转换为字节的过程。建议就是将上面包尽可能的早，而下面包尽可能的晚。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_方法的种类</title>
    <url>/2021/01/17/Python-%E6%96%B9%E6%B3%95%E7%9A%84%E7%A7%8D%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="Python中方法"><a href="#Python中方法" class="headerlink" title="Python中方法"></a>Python中方法</h2><p>一共存在三种方法，分别是<strong>实例方法，类方法（classmethod），静态方法(staticmethod)</strong>;</p>
<a id="more"></a>

<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单独的函数定义，不需要绑定实例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x</span>):</span></span><br><span class="line">    print(<span class="string">&quot;executing foo(%s)&quot;</span>%(x))</span><br><span class="line">foo(<span class="string">&quot;function&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="comment">#实例方法，需要绑定实例self</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self , x</span>):</span></span><br><span class="line">        print(<span class="string">&quot;executing foo(%s,%s)&quot;</span>%(self,x))</span><br><span class="line">    <span class="comment">#类方法需要绑定类，cls</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span>(<span class="params">cls,x</span>):</span></span><br><span class="line">        print(<span class="string">&quot;executing foo(%s,%s)&quot;</span>%(cls,x))</span><br><span class="line">    <span class="comment">#静态方法不需要任何绑定</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_foo</span>(<span class="params">x</span>):</span></span><br><span class="line">        print(<span class="string">&quot;executing foo(%s)&quot;</span>%(x))</span><br></pre></td></tr></table></figure>
<p>代码运行与结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = A()</span><br><span class="line">a.foo(<span class="string">&quot;实例调用实例方法&quot;</span>)</span><br><span class="line">a.class_foo(<span class="string">&quot;实例调用类方法&quot;</span>)</span><br><span class="line">a.static_foo(<span class="string">&quot;实例调用静态方法&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#executing foo(&lt;__main__.A object at 0x0000028BA3754780&gt;,实例调用实例方法):实例方法传入的是实例</span></span><br><span class="line"><span class="comment">#executing foo(&lt;class &#x27;__main__.A&#x27;&gt;,实例调用类方法) ：类方法即使是实例调用传入的仍然是类</span></span><br><span class="line"><span class="comment">#executing foo(实例调用静态方法)</span></span><br><span class="line"></span><br><span class="line">A.class_foo(<span class="string">&quot;类调用类方法&quot;</span>)</span><br><span class="line">A.static_foo(<span class="string">&quot;类调用静态方法&quot;</span>)</span><br><span class="line"><span class="comment"># executing foo(&lt;class &#x27;__main__.A&#x27;&gt;,类调用类方法)</span></span><br><span class="line"><span class="comment"># executing foo(类调用静态方法)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里先理解下函数参数里面的self和cls.这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用<code>foo(x)</code>,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是<code>foo(self, x)</code>,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的<code>a.foo(x)</code>(其实是<code>foo(a, x)</code>).类方法一样,只不过它传递的是类而不是实例,<code>A.class_foo(x)</code>.注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好.</p>
<p>对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用<code>a.static_foo(x)</code>或者<code>A.static_foo(x)</code>来调用.</p>
</blockquote>
<h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>Python中存在方法与函数：方法就是定义在class类定义的函数，其往往需要与实例或者类进行绑定，函数就是独立于实例与类存在的方法，不需要绑定任何事物；我们可以简单的将Python中的方法定义为位于类内部定义的函数即可；</p>
<p>Python中的方法往往需要进行绑定，这种绑定能够起到定义不同的作用域的作用，知道存在三种方法及其写法及其调用方式即可；</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_构造Python风格类</title>
    <url>/2021/01/17/Python-%E6%9E%84%E9%80%A0Python%E9%A3%8E%E6%A0%BC%E7%B1%BB/</url>
    <content><![CDATA[<p>所谓Python风格的对象,就是能够适用于Python原生方法的对象.</p>
<a id="more"></a>

<p>其实现多以通过魔法方法的实现完成的.这就是造轮子的过程.下面给出一个向量类的示例代码:当作参考.具体实现细节没有必要深究,也记不住.用时再查看.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">A 2-dimensional vector class</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector2d(3, 4)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(v1.x, v1.y)</span></span><br><span class="line"><span class="string">    3.0 4.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y = v1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1</span></span><br><span class="line"><span class="string">    Vector2d(3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = eval(repr(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(v1)</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; octets = bytes(v1)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; octets</span></span><br><span class="line"><span class="string">    b&#x27;d\\x00\\x00\\x00\\x00\\x00\\x00\\x08@\\x00\\x00\\x00\\x00\\x00\\x00\\x10@&#x27;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(v1)</span></span><br><span class="line"><span class="string">    5.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; bool(v1), bool(Vector2d(0, 0))</span></span><br><span class="line"><span class="string">    (True, False)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Test of ``.frombytes()`` class method:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone = Vector2d.frombytes(bytes(v1))</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1_clone</span></span><br><span class="line"><span class="string">    Vector2d(3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 == v1_clone</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of ``format()`` with Cartesian coordinates:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1)</span></span><br><span class="line"><span class="string">    &#x27;(3.0, 4.0)&#x27;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1, &#x27;.2f&#x27;)</span></span><br><span class="line"><span class="string">    &#x27;(3.00, 4.00)&#x27;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(v1, &#x27;.3e&#x27;)</span></span><br><span class="line"><span class="string">    &#x27;(3.000e+00, 4.000e+00)&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of the ``angle`` method::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Vector2d(0, 0).angle()</span></span><br><span class="line"><span class="string">    0.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Vector2d(1, 0).angle()</span></span><br><span class="line"><span class="string">    0.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; epsilon = 10**-8</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(Vector2d(0, 1).angle() - math.pi/2) &lt; epsilon</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(Vector2d(1, 1).angle() - math.pi/4) &lt; epsilon</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of ``format()`` with polar coordinates:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector2d(1, 1), &#x27;p&#x27;)  # doctest:+ELLIPSIS</span></span><br><span class="line"><span class="string">    &#x27;&lt;1.414213..., 0.785398...&gt;&#x27;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector2d(1, 1), &#x27;.3ep&#x27;)</span></span><br><span class="line"><span class="string">    &#x27;&lt;1.414e+00, 7.854e-01&gt;&#x27;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; format(Vector2d(1, 1), &#x27;0.5fp&#x27;)</span></span><br><span class="line"><span class="string">    &#x27;&lt;1.41421, 0.78540&gt;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of `x` and `y` read-only properties:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1.x, v1.y</span></span><br><span class="line"><span class="string">    (3.0, 4.0)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1.x = 123</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">    AttributeError: can&#x27;t set attribute</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Tests of hashing:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v1 = Vector2d(3, 4)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; v2 = Vector2d(3.1, 4.2)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; hash(v1), hash(v2)</span></span><br><span class="line"><span class="string">    (7, 384307168202284039)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; len(set([v1, v2]))</span></span><br><span class="line"><span class="string">    2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># END VECTOR2D_V3_DEMO</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment"># BEGIN VECTOR2D_V3_SLOTS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">&#x27;__x&#x27;</span>, <span class="string">&#x27;__y&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    typecode = <span class="string">&#x27;d&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># methods follow (omitted in book listing)</span></span><br><span class="line"><span class="comment"># END VECTOR2D_V3_SLOTS</span></span><br><span class="line">		<span class="comment"># 双下划线开头的属性为私有属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.__x = <span class="built_in">float</span>(x)</span><br><span class="line">        self.__y = <span class="built_in">float</span>(y)</span><br><span class="line">		<span class="comment"># 通过property装饰器将属性设为只读,注意方法名称就是属性名,</span></span><br><span class="line">    <span class="comment"># 你看这里的措施与Java对于属性的getx其实是一样的</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__x</span><br><span class="line">	</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">y</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__y</span><br><span class="line">		<span class="comment"># 迭代返回公开属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br><span class="line">		<span class="comment"># 定义对象的字符表现形式:repr()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        class_name = <span class="built_in">type</span>(self).__name__</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)&#x27;</span>.<span class="built_in">format</span>(class_name, *self)</span><br><span class="line">		<span class="comment">#  定义对象的字符表现形式:str()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">tuple</span>(self))</span><br><span class="line">	<span class="comment"># 定义将对象转换为字节的方法:bytes()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">bytes</span>([<span class="built_in">ord</span>(self.typecode)]) +</span><br><span class="line">                <span class="built_in">bytes</span>(array(self.typecode, self)))</span><br><span class="line"><span class="comment"># 定义 == : ==</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">tuple</span>(self) == <span class="built_in">tuple</span>(other)</span><br><span class="line"><span class="comment"># 定义 散列 : hash()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(self.x) ^ <span class="built_in">hash</span>(self.y)</span><br><span class="line"><span class="comment"># 定义 向量的模: abs()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> math.hypot(self.x, self.y)</span><br><span class="line"><span class="comment"># 定义 向量的模</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(<span class="built_in">abs</span>(self))</span><br><span class="line"><span class="comment"># 定义极坐标计算</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">angle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> math.atan2(self.y, self.x)</span><br><span class="line"><span class="comment"># 格式化显示:format() 或者str.format()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span>(<span class="params">self, fmt_spec=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> fmt_spec.endswith(<span class="string">&#x27;p&#x27;</span>):</span><br><span class="line">            fmt_spec = fmt_spec[:-<span class="number">1</span>]</span><br><span class="line">            coords = (<span class="built_in">abs</span>(self), self.angle())</span><br><span class="line">            outer_fmt = <span class="string">&#x27;&lt;&#123;&#125;, &#123;&#125;&gt;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            coords = self</span><br><span class="line">            outer_fmt = <span class="string">&#x27;(&#123;&#125;, &#123;&#125;)&#x27;</span></span><br><span class="line">        components = (<span class="built_in">format</span>(c, fmt_spec) <span class="keyword">for</span> c <span class="keyword">in</span> coords)</span><br><span class="line">        <span class="keyword">return</span> outer_fmt.<span class="built_in">format</span>(*components)</span><br><span class="line"><span class="comment"># 定义字节转换为对象的方法</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frombytes</span>(<span class="params">cls, octets</span>):</span></span><br><span class="line">        typecode = <span class="built_in">chr</span>(octets[<span class="number">0</span>])</span><br><span class="line">        memv = <span class="built_in">memoryview</span>(octets[<span class="number">1</span>:]).cast(typecode)</span><br><span class="line">        <span class="keyword">return</span> cls(*memv)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_浅复制与深复制</title>
    <url>/2021/01/17/Python-%E6%B5%85%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B7%B1%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p><a href="%E6%B5%81%E7%95%85%E7%9A%84python.pdf">流畅的python</a>,<a href="https://www.pythontutor.com/">Python可视化网站</a></p>
</blockquote>
<p>深复制与浅复制早就有所耳闻，今天发现没有进行相关笔记。这里简单写下，不做深入探讨。</p>
<a id="more"></a>

<h2 id="默认为浅复制"><a href="#默认为浅复制" class="headerlink" title="默认为浅复制"></a>默认为浅复制</h2><p>浅复制就是仅复制了最外层的引用，而对内部引用不做复制操作；对于不可变元素，这是很好的，减少了内存消耗。然而当内部元素是可变的，就会产生非预期的事情。Python中默认使用浅复制，例如列表中可以采用[:] 与 list() 构造进行复制操作。以下是一段代码，及其内存情况展示，可方便理解，面对不同元素对象操作时的异同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">3</span>, [<span class="number">66</span>,<span class="number">55</span>,<span class="number">44</span>] </span><br><span class="line"><span class="comment"># 通过构造函数进行了浅复制操作</span></span><br><span class="line">l2 = <span class="built_in">list</span>(l1)   <span class="comment"># （1）      </span></span><br><span class="line">l1.append(<span class="number">100</span>)  <span class="comment">#	      </span></span><br><span class="line">l1[<span class="number">1</span>].remove(<span class="number">55</span>)   <span class="comment">#  （2）   </span></span><br><span class="line">print(<span class="string">&quot;l1 ,&quot;</span>, l1 )    </span><br><span class="line">print(<span class="string">&quot;l2 ,&quot;</span> ,l2)</span><br><span class="line"><span class="comment"># l1 , [3, [66, 44], (7, 8, 9), 100]</span></span><br><span class="line"><span class="comment"># l2 , [3, [66, 44], (7, 8, 9)]</span></span><br><span class="line">l2[<span class="number">1</span>] += [<span class="number">33</span>,<span class="number">22</span>]     <span class="comment">#（3） </span></span><br><span class="line">l2[<span class="number">2</span>] += (<span class="number">10</span> ,<span class="number">11</span>)     <span class="comment">#（4）</span></span><br><span class="line">print(<span class="string">&quot;l1 ,&quot;</span>, l1 )    </span><br><span class="line">print(<span class="string">&quot;l2 ,&quot;</span> ,l2)     </span><br><span class="line"><span class="comment"># l1 , [3, [66, 44, 33, 22], (7, 8, 9), 100]</span></span><br><span class="line"><span class="comment"># l2 , [3, [66, 44, 33, 22], (7, 8, 9, 10, 11)]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/11/dDTsIWoG1tNOSek.png"></p>
<p>(1)可以看到上图中通过浅复制，l1,l2指向了不同的对象，而对象内部元素的引用并没有变化。</p>
<p><img src="https://i.loli.net/2021/01/11/2iwVdC8yu4kXEYr.png"></p>
<p>(2)可以看到在对l1中的列表元素进行操作直接影响了l2中列表元素的情况，这当然是由于<strong>其内部列表元素指向对象一致，并且列表是可变元素。</strong> 可变元素就说明其支持原地修改。</p>
<p><img src="https://i.loli.net/2021/01/11/kwFWReO3fi6pyNt.png"></p>
<p>(3)同理，l2中对列表元素的修改，也会影响到l1的内部情况。</p>
<p><img src="https://i.loli.net/2021/01/11/xk6MzWqyXQsbJu8.png"></p>
<p>(4)需要注意，对l2的tuple元素进行修改操作时，l1,l2不再指向同一tuple，这是由于元组本身不支持就地修改操作，其构建了一个新的元组对象并返回给了l2[2]的位置。</p>
<h2 id="如何进行深浅拷贝"><a href="#如何进行深浅拷贝" class="headerlink" title="如何进行深浅拷贝"></a>如何进行深浅拷贝</h2><p>Python提供了copy库方便提供了copy()与deepcopy()方法，很方便。使用方式展示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>import copy</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus1 = Bus([&#x27;Alice&#x27;, &#x27;Bill&#x27;, &#x27;Claire&#x27;, &#x27;David&#x27;])</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus2 = copy.copy(bus1)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus3 = copy.deepcopy(bus1)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus1.drop(&#x27;Bill&#x27;)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers</span></span><br><span class="line"><span class="string">[&#x27;Alice&#x27;, &#x27;Claire&#x27;, &#x27;David&#x27;]</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>bus3.passengers</span></span><br><span class="line"><span class="string">[&#x27;Alice&#x27;, &#x27;Bill&#x27;, &#x27;Claire&#x27;, &#x27;David&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BEGIN BUS_CLASS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, passengers=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.passengers = []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.passengers = <span class="built_in">list</span>(passengers)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.passengers.append(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drop</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.passengers.remove(name)</span><br><span class="line"><span class="comment"># END BUS_CLASS</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h3><p>深拷贝并没有那么简单，例如遇到循环引用时，岂不是会无限copy。不过这不用担心，Python自带的copy库可以记住已经copy过的对象。大胆用。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_特殊方法</title>
    <url>/2021/01/17/Python-%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Python中存在大量的特殊方法，官方一般称之为魔法方法(magic method)，也叫双下方法(dunder method).其方法形式为以双下划线为起始，并且以双下划线为结束，</p>
<a id="more"></a>

<p>__funcName__ . 魔法方法是指Python内部已经包含的，被双下划线所包围的方法，这些方法在进行特定的操作时会自动被调用，它们是Python面向对象下智慧的结晶。</p>
<blockquote>
<p><a href="P1~P14">流畅的Python</a> , <a href="https://zhuanlan.zhihu.com/p/24567545">知乎专栏</a> , <a href="https://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html">方法指南</a> ，<a href="https://wiki.jikexueyuan.com/project/explore-python/Class/magic_method.html">某教程</a></p>
</blockquote>
<h2 id="日常使用例子"><a href="#日常使用例子" class="headerlink" title="日常使用例子"></a>日常使用例子</h2><ol>
<li>在日常使用中我们其实经常<strong>调用</strong>，最常见的便是 __init__  方法，在创建实例的过程中会自动调用，进行初始化。</li>
<li>len(),方法会自动调用我们的__len__ 方法等等。</li>
</ol>
<p>调用形式多样，没必要意义列举。魔法方法的出现使得Python展现了强大的自由度，简化了繁琐的重写轮子的步骤；</p>
<h2 id="调用方法列举"><a href="#调用方法列举" class="headerlink" title="调用方法列举"></a>调用方法列举</h2><p>Python中每个魔法函数都对应了一个Python内置函数或操作，比如__str__对应str函数，__lt__对应小于号&lt;等。Python中的魔法函数可以大概分为以下几类：</p>
<h3 id="类的构造与删除"><a href="#类的构造与删除" class="headerlink" title="类的构造与删除"></a><strong>类的构造与删除</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span>.__new__(self, ...)</span><br><span class="line"><span class="built_in">object</span>.__init__(self, ...)</span><br><span class="line"><span class="built_in">object</span>.__del__(self)</span><br></pre></td></tr></table></figure>
<h3 id="二元操作"><a href="#二元操作" class="headerlink" title="二元操作"></a><strong>二元操作</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">+	<span class="built_in">object</span>.__add__(self, other)</span><br><span class="line">-	<span class="built_in">object</span>.__sub__(self, other)</span><br><span class="line">*	<span class="built_in">object</span>.__mul__(self, other)</span><br><span class="line">//	<span class="built_in">object</span>.__floordiv__(self, other)</span><br><span class="line">/	<span class="built_in">object</span>.__div__(self, other)</span><br><span class="line">%	<span class="built_in">object</span>.__mod__(self, other)</span><br><span class="line">**	<span class="built_in">object</span>.__pow__(self, other[, modulo])</span><br><span class="line">&lt;&lt;	<span class="built_in">object</span>.__lshift__(self, other)</span><br><span class="line">&gt;&gt;	<span class="built_in">object</span>.__rshift__(self, other)</span><br><span class="line">&amp;	<span class="built_in">object</span>.__and__(self, other)</span><br><span class="line">^	<span class="built_in">object</span>.__xor__(self, other)</span><br><span class="line">|	<span class="built_in">object</span>.__or__(self, other)</span><br></pre></td></tr></table></figure>
<h3 id="扩展二元操作"><a href="#扩展二元操作" class="headerlink" title="扩展二元操作**"></a>扩展二元操作**</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">+=	<span class="built_in">object</span>.__iadd__(self, other)</span><br><span class="line">-=	<span class="built_in">object</span>.__isub__(self, other)</span><br><span class="line">*=	<span class="built_in">object</span>.__imul__(self, other)</span><br><span class="line">/=	<span class="built_in">object</span>.__idiv__(self, other)</span><br><span class="line">//=	<span class="built_in">object</span>.__ifloordiv__(self, other)</span><br><span class="line">%=	<span class="built_in">object</span>.__imod__(self, other)</span><br><span class="line">**=	<span class="built_in">object</span>.__ipow__(self, other[, modulo])</span><br><span class="line">&lt;&lt;=	<span class="built_in">object</span>.__ilshift__(self, other)</span><br><span class="line">&gt;&gt;=	<span class="built_in">object</span>.__irshift__(self, other)</span><br><span class="line">&amp;=	<span class="built_in">object</span>.__iand__(self, other)</span><br><span class="line">^=	<span class="built_in">object</span>.__ixor__(self, other)</span><br><span class="line">|=	<span class="built_in">object</span>.__ior__(self, other)</span><br></pre></td></tr></table></figure>
<h3 id="一元操作"><a href="#一元操作" class="headerlink" title="一元操作"></a><strong>一元操作</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-	<span class="built_in">object</span>.__neg__(self)</span><br><span class="line">+	<span class="built_in">object</span>.__pos__(self)</span><br><span class="line"><span class="built_in">abs</span>()	<span class="built_in">object</span>.__abs__(self)</span><br><span class="line">~	<span class="built_in">object</span>.__invert__(self)</span><br><span class="line"><span class="built_in">complex</span>()	<span class="built_in">object</span>.__complex__(self)</span><br><span class="line"><span class="built_in">int</span>()	<span class="built_in">object</span>.__int__(self)</span><br><span class="line">long()	<span class="built_in">object</span>.__long__(self)</span><br><span class="line"><span class="built_in">float</span>()	<span class="built_in">object</span>.__float__(self)</span><br><span class="line"><span class="built_in">oct</span>()	<span class="built_in">object</span>.__oct__(self)</span><br><span class="line"><span class="built_in">hex</span>()	<span class="built_in">object</span>.__hex__(self)</span><br><span class="line"><span class="built_in">round</span>()	<span class="built_in">object</span>.__round__(self, n)</span><br><span class="line">floor()	object__floor__(self)</span><br><span class="line">ceil()	<span class="built_in">object</span>.__ceil__(self)</span><br><span class="line">trunc()	<span class="built_in">object</span>.__trunc__(self)</span><br></pre></td></tr></table></figure>
<h3 id="比较函数"><a href="#比较函数" class="headerlink" title="比较函数"></a><strong>比较函数</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;	<span class="built_in">object</span>.__lt__(self, other)</span><br><span class="line">&lt;=	<span class="built_in">object</span>.__le__(self, other)</span><br><span class="line">==	<span class="built_in">object</span>.__eq__(self, other)</span><br><span class="line">!=	<span class="built_in">object</span>.__ne__(self, other)</span><br><span class="line">&gt;=	<span class="built_in">object</span>.__ge__(self, other)</span><br><span class="line">&gt;	<span class="built_in">object</span>.__gt__(self, other)</span><br></pre></td></tr></table></figure>
<h3 id="类的表示与输出"><a href="#类的表示与输出" class="headerlink" title="类的表示与输出"></a><strong>类的表示与输出</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>()	<span class="built_in">object</span>.__str__(self) </span><br><span class="line"><span class="built_in">repr</span>()	<span class="built_in">object</span>.__repr__(self)</span><br><span class="line"><span class="built_in">len</span>()	<span class="built_in">object</span>.__len__(self)</span><br><span class="line"><span class="built_in">hash</span>()	<span class="built_in">object</span>.__hash__(self) </span><br><span class="line"><span class="built_in">bool</span>()	<span class="built_in">object</span>.__nonzero__(self) </span><br><span class="line"><span class="built_in">dir</span>()	<span class="built_in">object</span>.__dir__(self)</span><br><span class="line">sys.getsizeof()	<span class="built_in">object</span>.__sizeof__(self)</span><br></pre></td></tr></table></figure>
<h3 id="类容器"><a href="#类容器" class="headerlink" title="类容器**"></a>类容器**</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>()	<span class="built_in">object</span>.__len__(self)</span><br><span class="line">self[key]	<span class="built_in">object</span>.__getitem__(self, key)</span><br><span class="line">self[key] = value	<span class="built_in">object</span>.__setitem__(self, key, value)</span><br><span class="line"><span class="keyword">del</span>[key] <span class="built_in">object</span>.__delitem__(self, key)</span><br><span class="line"><span class="built_in">iter</span>()	<span class="built_in">object</span>.__iter__(self)</span><br><span class="line"><span class="built_in">reversed</span>()	<span class="built_in">object</span>.__reversed__(self)</span><br><span class="line"><span class="keyword">in</span>操作	<span class="built_in">object</span>.__contains__(self, item)</span><br><span class="line">字典key不存在时	<span class="built_in">object</span>.__missing__(self, key)</span><br></pre></td></tr></table></figure>
<h2 id="相关应用"><a href="#相关应用" class="headerlink" title="相关应用"></a>相关应用</h2><p>通过上面的描述我们已经知道我们常见的一些操作，其实是调用了魔法方法的缘故，但是知道又有什么意义呢？</p>
<p>意义：<strong>通过重写上述魔法方法，可以构造符合Python风格的类</strong>。这里的Python风格就是自己构造的类也可以使用Python常见的特性，比如你构建了集合类，可以使用切片、索引、迭代等等特性，你构建了向量类，可以利用操作符” +,-,*,/ ” , 实现向量的加减乘除。</p>
<h3 id="向量类构造实例"><a href="#向量类构造实例" class="headerlink" title="向量类构造实例"></a>向量类构造实例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x=<span class="number">0</span>, y=<span class="number">0</span></span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Vector(%r, %r)&#x27;</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(<span class="built_in">abs</span>(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        x = self.x + other.x</span><br><span class="line">        y = self.y + other.y</span><br><span class="line">        <span class="keyword">return</span> Vector(x, y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span>(<span class="params">self, scalar</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.x * scalar, self.y * scalar)</span><br><span class="line">v1 = Vector(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">v2 = Vector(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">print(v1 + v2) <span class="comment"># Vector(5, 5)</span></span><br><span class="line">print(<span class="built_in">abs</span>(v2)) <span class="comment"># 5.0</span></span><br><span class="line">print(v1 * <span class="number">3</span>)  <span class="comment"># Vector(6, 3)</span></span><br></pre></td></tr></table></figure>
<p>通过实现类内部的魔法方法，使得自定义的类也能够使用Python运算符进行相关计算，符合Python风格。当然你也可以像其他方法那样，实现相关功能，只是没有了Python风格。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_私有属性与受保护的属性</title>
    <url>/2021/01/17/Python-%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>Python中除去常见的普通属性外还存在私有属性与受保护的属性.</p>
<a id="more"></a>

<p>这两种属性往往是设计者不希望他人看到的属性,在类设计过程中会采用下划线来标识.</p>
<h2 id="私有属性双下划线开头"><a href="#私有属性双下划线开头" class="headerlink" title="私有属性双下划线开头"></a>私有属性双下划线开头</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Python中对以__开头的私有属性会进行改名操作,并存入实例__dict__属性中,其改名的策略为在其前面加一个下划线外加类名.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span>:</span></span><br><span class="line">  <span class="comment"># 实例构建方法中定义了三个属性,其中两个为私有属性一个为普通属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self , x, y ,z</span>):</span></span><br><span class="line">        self.__x = x</span><br><span class="line">        self.__y = y</span><br><span class="line">        self.z = z</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        class_name = <span class="built_in">type</span>(self).__name__</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;&#125;(&#123;!r&#125;, &#123;!r&#125; , &#123;!r&#125;)&#x27;</span>.<span class="built_in">format</span>(class_name, *self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">tuple</span>(self))</span><br><span class="line">      <span class="comment"># 发现在类定义里面,既可以使用改名前的私有属性,也可以使用改名后的私有属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.__x, self._vector__y , self.z))</span><br><span class="line">vec = vector(<span class="number">3</span>,<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">print(vec)</span><br><span class="line"><span class="comment"># (3, 4, 5)</span></span><br><span class="line">print(vec.__dict__)</span><br><span class="line"><span class="comment"># &#123;&#x27;_vector__x&#x27;: 3, &#x27;_vector__y&#x27;: 4, &#x27;z&#x27;: 5&#125;</span></span><br><span class="line">print(vec._vector__x)</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 只能通过改名后的属性进行访问</span></span><br><span class="line">print(vec.__x)</span><br><span class="line"><span class="comment"># AttributeError: &#x27;vector&#x27; object has no attribute &#x27;__x&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>优点:Python会进行识别并进行改名操作,防止他人误操作</p>
</li>
<li><p>缺点:不对称的名称规范,无法避免恶意操作,比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 私有属性就是不想让他人进行访问,或者变更,结果你强行更改</span></span><br><span class="line">vec._vector__x = <span class="number">8</span></span><br><span class="line">print(vec._vector__x)</span><br><span class="line"><span class="comment"># 8</span></span><br></pre></td></tr></table></figure>
<h2 id="受保护的属性单下划线开头"><a href="#受保护的属性单下划线开头" class="headerlink" title="受保护的属性单下划线开头"></a>受保护的属性单下划线开头</h2></li>
</ul>
<p>大多数Python程序员反对使用双下划线进行命名操作,于是提出使用单下划线前缀编写受保护的属性,<strong>约定</strong>不对单下划线进行访问.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self , x, y ,z</span>):</span></span><br><span class="line">        self._x = x</span><br><span class="line">        self.__y = y</span><br><span class="line">        self.z = z</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        class_name = <span class="built_in">type</span>(self).__name__</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;&#125;(&#123;!r&#125;, &#123;!r&#125; , &#123;!r&#125;)&#x27;</span>.<span class="built_in">format</span>(class_name, *self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">tuple</span>(self))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self._x, self._vector__y , self.z))</span><br><span class="line">vec = vector(<span class="number">3</span>,<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">print(vec)</span><br><span class="line">print(vec.__dict__)</span><br><span class="line">print(vec._x)</span><br><span class="line"><span class="comment"># (3, 4, 5)</span></span><br><span class="line"><span class="comment"># &#123;&#x27;_x&#x27;: 3, &#x27;_vector__y&#x27;: 4, &#x27;z&#x27;: 5&#125;</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<p>上面的代码实例可以看到单下划线的属性,Python解释器并没有对其进行改名操作,就当作普通属性,这就是一种约定而已.</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_类变量与实例变量</title>
    <url>/2021/01/17/Python-%E7%B1%BB%E5%8F%98%E9%87%8F%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p><strong>类变量：</strong>可以在类的所有实例间共享的变量</p>
<p><strong>实例变量：</strong>实例化后每个实例单独拥有的变量</p>
<a id="more"></a>

<h3 id="示例：利用类变量查看以构建的实例个数"><a href="#示例：利用类变量查看以构建的实例个数" class="headerlink" title="示例：利用类变量查看以构建的实例个数"></a>示例：利用类变量查看以构建的实例个数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params"><span class="built_in">object</span></span>):</span>  </span><br><span class="line">    num_of_instance = <span class="number">0</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">        Test.num_of_instance += <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    print(Test.num_of_instance)   <span class="comment"># 0</span></span><br><span class="line">    t1 = Test(<span class="string">&#x27;jack&#x27;</span>)  </span><br><span class="line">    print(Test.num_of_instance)   <span class="comment"># 1</span></span><br><span class="line">    t2 = Test(<span class="string">&#x27;lucy&#x27;</span>)  </span><br><span class="line">    print(t1.name , t1.num_of_instance)  <span class="comment"># jack 2</span></span><br><span class="line">    print(t2.name , t2.num_of_instance)  <span class="comment"># lucy 2</span></span><br></pre></td></tr></table></figure>
<p>这里还涉及很多变量指向的问题例如以下代码：</p>
<p><strong>不可修改变量时：</strong>值传递时</p>
<p>类修改了变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=<span class="string">&quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">Person.name=<span class="string">&quot;bbb&quot;</span></span><br><span class="line">print(p1.name)  <span class="comment"># bbb</span></span><br><span class="line">print(p2.name)  <span class="comment"># bbb</span></span><br><span class="line">print(Person.name) <span class="comment">#bbb</span></span><br></pre></td></tr></table></figure>
<p>实例修改了变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=<span class="string">&quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name=<span class="string">&quot;bbb&quot;</span></span><br><span class="line">print(p1.name)  <span class="comment"># bbb</span></span><br><span class="line">print(p2.name)  <span class="comment"># aaa</span></span><br><span class="line">print(Person.name)  <span class="comment"># aaa</span></span><br></pre></td></tr></table></figure>
<p>值传递的情况下，类变量的变化同步到了实例变量，而实例变量的改变不会影响类</p>
<p><strong>变量可修改时：</strong> 引用传递时</p>
<p>类修改了变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=[]</span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">Person.name.append(<span class="number">1</span>)</span><br><span class="line">print(p1.name)  <span class="comment"># [1]</span></span><br><span class="line">print(p2.name)  <span class="comment"># [1]</span></span><br><span class="line">print(Person.name)  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure>
<p>实例修改了变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=[]</span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name.append(<span class="number">1</span>)</span><br><span class="line">print(p1.name)  <span class="comment"># [1]</span></span><br><span class="line">print(p2.name)  <span class="comment"># [1]</span></span><br><span class="line">print(Person.name)  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure>
<p>引用传递的情况下，类变量的变化同步到了实例变量，而实例变量的改变同步到了类</p>
<p>具体的分析需要查看内存分布情况，但是我没找到详细的解释，这里略过；</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_装饰器</title>
    <url>/2021/01/17/Python-%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<p><a href="https://www.runoob.com/w3cnote/python-func-decorators.html">W3C文档</a> ， 此文档与文档底下的第一个评论均很好的解释了装饰器的作用这里没有全部列出.</p>
<a id="more"></a>

<h2 id="前置知识：高阶函数与返回函数"><a href="#前置知识：高阶函数与返回函数" class="headerlink" title="前置知识：高阶函数与返回函数"></a>前置知识：高阶函数与返回函数</h2><p>Python中存在一个重要的特性，<strong>函数的参数也可以是函数</strong>，这种函数称为高阶函数。同样的Python中函数的<strong>返回值也可以是函数</strong>。</p>
<h3 id="Python内置的高阶函数："><a href="#Python内置的高阶函数：" class="headerlink" title="Python内置的高阶函数："></a>Python内置的高阶函数：</h3><p><strong>map函数：</strong>其接收一个函数与列表，并将此函数应用到列表中每一个元素上；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>(<span class="built_in">map</span>(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])))</span><br><span class="line"><span class="comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure>
<p><strong>reduce函数：</strong>接收一个函数与列表，此函数要求存在两个参数，reduce会反复调用此函数，并返回最终结果；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x , y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">reduce(add,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>])</span><br><span class="line"><span class="comment"># 25</span></span><br></pre></td></tr></table></figure>
<p><strong>filter函数：</strong>接收一个函数与列表，会根据函数，过滤掉不符合条件的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filter()过滤掉偶数：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">filter</span>(is_odd, [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">17</span>]))</span><br></pre></td></tr></table></figure>
<h3 id="Python的特性"><a href="#Python的特性" class="headerlink" title="Python的特性"></a>Python的特性</h3><h4 id="一切皆对象"><a href="#一切皆对象" class="headerlink" title="一切皆对象"></a>一切皆对象</h4><p>Python中创建函数时，既创建了一个<strong>函数对象</strong>，也创建了一个**指向函数的变量(函数名)**。</p>
<p>在Python中，函数名就是指向函数对象的变量，既然是变量那么也可以通过赋值的方式，将此函数赋值给其他变量；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hi</span>(<span class="params">name=<span class="string">&quot;yasoob&quot;</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hi &quot;</span> + name</span><br><span class="line"> </span><br><span class="line">print(hi())</span><br><span class="line"><span class="comment"># output: &#x27;hi yasoob&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 我们甚至可以将一个函数赋值给一个变量，比如</span></span><br><span class="line">greet = hi</span><br><span class="line"><span class="comment"># 我们这里没有在使用小括号，因为我们并不是在调用hi函数</span></span><br><span class="line"><span class="comment"># 而是在将它放在greet变量里头。我们尝试运行下这个</span></span><br><span class="line"> </span><br><span class="line">print(greet())</span><br><span class="line"><span class="comment"># output: &#x27;hi yasoob&#x27;</span></span><br><span class="line">print(<span class="built_in">id</span>(hi)) <span class="comment"># 2316264257600</span></span><br><span class="line">print(<span class="built_in">id</span>(greet)) <span class="comment"># 2316264257600</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> hi</span><br><span class="line">print(hi())</span><br><span class="line"></span><br><span class="line">print(greet())</span><br><span class="line"><span class="comment">#outputs: &#x27;hi yasoob&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="函数中可以构建函数"><a href="#函数中可以构建函数" class="headerlink" title="函数中可以构建函数"></a>函数中可以构建函数</h4><p>python中支持函数中构建函数，其他语言貌似也可以</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hi</span>(<span class="params">name=<span class="string">&quot;yasoob&quot;</span></span>):</span></span><br><span class="line">    print(<span class="string">&quot;now you are inside the hi() function&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span>():</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;now you are in the greet() function&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">welcome</span>():</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;now you are in the welcome() function&quot;</span></span><br><span class="line"> </span><br><span class="line">    print(greet())</span><br><span class="line">    print(welcome())</span><br><span class="line">    print(<span class="string">&quot;now you are back in the hi() function&quot;</span>)</span><br><span class="line">hi()</span><br><span class="line"><span class="comment">#output:now you are inside the hi() function</span></span><br><span class="line"><span class="comment">#       now you are in the greet() function</span></span><br><span class="line"><span class="comment">#       now you are in the welcome() function</span></span><br><span class="line"><span class="comment">#       now you are back in the hi() function</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 上面展示了无论何时你调用hi(), greet()和welcome()将会同时被调用。</span></span><br><span class="line"><span class="comment"># 然后greet()和welcome()函数在hi()函数之外是不能访问的，比如：</span></span><br><span class="line">greet()</span><br><span class="line"><span class="comment">#outputs: NameError: name &#x27;greet&#x27; is not defined</span></span><br></pre></td></tr></table></figure>
<h4 id="函数中返回函数"><a href="#函数中返回函数" class="headerlink" title="函数中返回函数"></a>函数中返回函数</h4><p>Python的特性之一，既然所有的一切均是对象，能返回数字类型就能返回函数；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hi</span>(<span class="params">name=<span class="string">&quot;yasoob&quot;</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span>():</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;now you are in the greet() function&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">welcome</span>():</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;now you are in the welcome() function&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&quot;yasoob&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> greet</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> welcome</span><br><span class="line"> </span><br><span class="line">a = hi()</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment">#outputs: &lt;function greet at 0x7f2143c01500&gt;</span></span><br><span class="line"><span class="comment">#上面清晰地展示了`a`现在指向到hi()函数中的greet()函数</span></span><br><span class="line"><span class="comment">#现在试试这个</span></span><br><span class="line"> </span><br><span class="line">print(a())</span><br><span class="line"><span class="comment">#outputs: now you are in the greet() function</span></span><br></pre></td></tr></table></figure>
<p><strong>Tips：</strong>返回函数名就是返回的函数对象的引用，加上小括号()，就是运行此函数。</p>
<h4 id="函数可以作为参数传递给另外一个函数"><a href="#函数可以作为参数传递给另外一个函数" class="headerlink" title="函数可以作为参数传递给另外一个函数"></a>函数可以作为参数传递给另外一个函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hi</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Say niHao&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doSomeingBeforeHi</span>(<span class="params">func</span>):</span></span><br><span class="line">    print(<span class="string">&quot;do Something i donot like......&quot;</span>)</span><br><span class="line">    func()</span><br><span class="line">doSomeingBeforeHi(hi)</span><br><span class="line"><span class="comment"># do Something i donot like......</span></span><br><span class="line"><span class="comment"># Say niHao</span></span><br></pre></td></tr></table></figure>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>在1.2.4中的例子就是一个简单的装饰器；</p>
<h3 id="装饰器是什么？"><a href="#装饰器是什么？" class="headerlink" title="装饰器是什么？"></a>装饰器是什么？</h3><p>装饰器本质上是一个 <strong>Python 函数或类</strong>，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的<strong>返回值也是一个函数/类对象</strong>。它经常用于有<strong>切面需求的场景</strong>，比如：<strong>插入日志、性能测试、事务处理、缓存、权限校验等场景</strong>，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</p>
<h3 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h3><h4 id="定义函数与新需求"><a href="#定义函数与新需求" class="headerlink" title="定义函数与新需求"></a>定义函数与新需求</h4><p>定义一个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;i am foo&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>现在有一个新的需求，希望可以记录下函数的执行日志，于是在代码中添加日志代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;i am foo&#x27;</span>)</span><br><span class="line">    logging.info(<span class="string">&quot;foo is running&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>如果函数 bar()、bar2() 也有类似的需求，怎么做？再写一个 logging 在 bar 函数里？这样就造成大量雷同的代码，为了减少重复写代码，我们可以这样做，重新定义一个新的函数：专门处理日志 ，日志处理完之后再执行真正的业务代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span>(<span class="params">func</span>):</span></span><br><span class="line">    logging.warn(<span class="string">&quot;%s is running&quot;</span> % func.__name__)</span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;i am foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">use_logging(foo)</span><br></pre></td></tr></table></figure>
<p>这样做逻辑上是没问题的，功能是实现了，但是我们调用的时候不再是调用真正的业务逻辑 foo 函数，而是换成了 use_logging 函数，这就破坏了原有的代码结构， 现在我们不得不每次都要把原来的那个 foo 函数作为参数传递给 use_logging 函数，那么有没有更好的方式的呢？当然有，答案就是装饰器。</p>
<h4 id="不使用-时"><a href="#不使用-时" class="headerlink" title="不使用@时"></a>不使用@时</h4><p><strong>简单装饰器</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span>(<span class="params">func</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">        logging.warn(<span class="string">&quot;%s is running&quot;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func()   <span class="comment"># 把 foo 当做参数传递进来时，执行func()就相当于执行foo()</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;i am foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">foo = use_logging(foo)  <span class="comment"># 因为装饰器 use_logging(foo) 返回的时函数对象 wrapper，这条语句相当于  foo = wrapper</span></span><br><span class="line">foo()                   <span class="comment"># 执行foo()就相当于执行 wrapper()</span></span><br></pre></td></tr></table></figure>
<p>use_logging 就是一个装饰器，它一个普通的函数，它把执行真正业务逻辑的函数 func 包裹在其中，看起来像 foo 被 use_logging 装饰了一样，use_logging 返回的也是一个函数，这个函数的名字叫 wrapper。在这个例子中，函数进入和退出时 ，被称为一个横切面，这种编程方式被称为<strong>面向切面的编程</strong></p>
<h4 id="使用-时"><a href="#使用-时" class="headerlink" title="使用@时"></a>使用@时</h4><p>@ 语法**</p>
<p>如果你接触 Python 有一段时间了的话，想必你对 @ 符号一定不陌生了，没错 @ 符号就是装饰器的语法糖，它放在函数开始定义的地方，这样就可以省略最后一步再次赋值的操作.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span>(<span class="params">func</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">        logging.warn(<span class="string">&quot;%s is running&quot;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&quot;i am foo&quot;</span>)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>如上所示，有了 @ ，我们就可以省去foo = use_logging(foo)这一句了，直接调用 foo() 即可得到想要的结果。你们看到了没有，foo() 函数不需要做任何修改，只需在定义的地方加上装饰器，调用的时候还是和以前一样，如果我们有其他的类似函数，我们可以继续调用装饰器来修饰函数，而不用重复修改函数或者增加新的封装。这样，我们就提高了程序的可重复利用性，并增加了程序的可读性。</p>
<p>装饰器在 Python 使用如此方便都要归因于 Python 的函数能像普通的对象一样能作为参数传递给其他函数，可以被赋值给其他变量，可以作为返回值，可以被定义在另外一个函数内。</p>
<h4 id="多参数时"><a href="#多参数时" class="headerlink" title="多参数时"></a>多参数时</h4><p><strong><em>args、*</em>kwargs</strong></p>
<p>可能有人问，如果我的业务逻辑函数 foo 需要参数怎么办？比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(<span class="string">&quot;i am %s&quot;</span> % name)</span><br></pre></td></tr></table></figure>
<p>我们可以在定义 wrapper 函数的时候指定参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">name</span>):</span></span><br><span class="line">        logging.warn(<span class="string">&quot;%s is running&quot;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(name)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p>这样 foo 函数定义的参数就可以定义在 wrapper 函数中。这时，又有人要问了，如果 foo 函数接收两个参数呢？三个参数呢？更有甚者，我可能传很多个。当装饰器不知道 foo 到底有多少个参数时，我们可以用 *args 来代替：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args</span>):</span></span><br><span class="line">        logging.warn(<span class="string">&quot;%s is running&quot;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p>如此一来，甭管 foo 定义了多少个参数，我都可以完整地传递到 func 中去。这样就不影响 foo 的业务逻辑了。这时还有读者会问，如果 foo 函数还定义了一些关键字参数呢？比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">name, age=<span class="literal">None</span>, height=<span class="literal">None</span></span>):</span></span><br><span class="line">    print(<span class="string">&quot;I am %s, age %s, height %s&quot;</span> % (name, age, height))</span><br></pre></td></tr></table></figure>
<p>这时，你就可以把 wrapper 函数指定关键字函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># args是一个数组，kwargs一个字典</span></span><br><span class="line">        logging.warn(<span class="string">&quot;%s is running&quot;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"><span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<h4 id="装饰器本身带参数的情况"><a href="#装饰器本身带参数的情况" class="headerlink" title="装饰器本身带参数的情况"></a>装饰器本身带参数的情况</h4><p><strong>带参数的装饰器</strong></p>
<p>装饰器还有更大的灵活性，例如带参数的装饰器，在上面的装饰器调用中，该装饰器接收唯一的参数就是执行业务的函数 foo 。装饰器的语法允许我们在调用时，提供其它参数，比如@decorator(a)。这样，就为装饰器的编写和使用提供了更大的灵活性。比如，我们可以在装饰器中指定日志的等级，因为不同业务函数可能需要的日志级别是不一样的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span>(<span class="params">level</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="keyword">if</span> level == <span class="string">&quot;warn&quot;</span>:</span><br><span class="line">                logging.warn(<span class="string">&quot;%s is running&quot;</span> % func.__name__)</span><br><span class="line">            <span class="keyword">elif</span> level == <span class="string">&quot;info&quot;</span>:</span><br><span class="line">                logging.info(<span class="string">&quot;%s is running&quot;</span> % func.__name__)</span><br><span class="line">            <span class="keyword">return</span> func(*args)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging(<span class="params">level=<span class="string">&quot;warn&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">name=<span class="string">&#x27;foo&#x27;</span></span>):</span></span><br><span class="line">    print(<span class="string">&quot;i am %s&quot;</span> % name)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>上面的 use_logging 是允许带参数的装饰器。它实际上是对原有装饰器的一个函数封装，并返回一个装饰器。我们可以将它理解为一个含有参数的闭包。当我 们使用@use_logging(level=”warn”)调用的时候，Python 能够发现这一层的封装，并把参数传递到装饰器的环境中。</p>
<p><strong>@use_logging(level=”warn”)</strong> 等价于 <strong>@decorator</strong></p>
<h4 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h4><p><strong>类装饰器</strong></p>
<p>没错，装饰器不仅可以是函数，还可以是类，相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。使用类装饰器主要依靠类的__call__方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func</span>):</span></span><br><span class="line">        self._func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;class decorator runing&#x27;</span>)</span><br><span class="line">        self._func()</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;class decorator ending&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Foo</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bar()</span><br><span class="line">functools.wraps</span><br></pre></td></tr></table></figure>
<p>使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了，比如函数的docstring、__name__、参数列表，先看例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logged</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_logging</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span> func.__name__      <span class="comment"># 输出 &#x27;with_logging&#x27;</span></span><br><span class="line">        <span class="built_in">print</span> func.__doc__       <span class="comment"># 输出 None</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> with_logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数</span></span><br><span class="line"><span class="meta">@logged</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">   <span class="string">&quot;&quot;&quot;does some math&quot;&quot;&quot;</span></span><br><span class="line">   <span class="keyword">return</span> x + x * x</span><br><span class="line"></span><br><span class="line">logged(f)</span><br></pre></td></tr></table></figure>
<p>不难发现，函数 f 被with_logging取代了，当然它的docstring，__name__就是变成了with_logging函数的信息了。好在我们有functools.wraps，wraps本身也是一个装饰器，它能把原函数的元信息拷贝到装饰器里面的 func 函数中，这使得装饰器里面的 func 函数也有和原函数 foo 一样的元信息了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logged</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_logging</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span> func.__name__      <span class="comment"># 输出 &#x27;f&#x27;</span></span><br><span class="line">        <span class="built_in">print</span> func.__doc__       <span class="comment"># 输出 &#x27;does some math&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> with_logging</span><br><span class="line"></span><br><span class="line"><span class="meta">@logged</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">   <span class="string">&quot;&quot;&quot;does some math&quot;&quot;&quot;</span></span><br><span class="line">   <span class="keyword">return</span> x + x * x</span><br></pre></td></tr></table></figure>
<h4 id="多装饰器的执行循序"><a href="#多装饰器的执行循序" class="headerlink" title="多装饰器的执行循序"></a>多装饰器的执行循序</h4><p><strong>装饰器顺序</strong></p>
<p>一个函数还可以同时定义多个装饰器，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@a</span></span><br><span class="line"><span class="meta">@b</span></span><br><span class="line"><span class="meta">@c</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span> ():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>它的执行顺序是从里到外，最先调用最里层的装饰器，最后调用最外层的装饰器，它等效于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = a(b(c(f)))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_鸭子类型</title>
    <url>/2021/01/17/Python-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>最近在学习流畅的Python一书时,经常看到这样的名词”鸭子类型”.而对它的解释是:<strong>一只鸟如果长得像鸭子,走路像鸭子,游泳也像鸭子,那么它可以认为就是一只鸭子</strong>.</p>
<a id="more"></a>

<p>这句话乍看起来有些无厘头.于是看了下大家对鸭子类型的解释,总结如下:</p>
<p>上面标粗的这句话表明一件事:只关注的该对象的行为,而不关注该对象的类型.这是Python的特点,是一门动态语言.</p>
<p><strong>Python默认鸭子类型的示例</strong></p>
<p>像JAVA,C这种静态语言,传入对象后需要检查对象的类型,类型不符合预期会报错.而Python中并不会对类型进行限制.在日常使用中其实已经或多或少的涉及到.例如各种魔法方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">listTemp = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">len</span>(listTemp)</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">tupleTemp = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">len</span>(tupleTemp)</span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<p>不管你传入的列表或者元组甚至是你自己定义的序列类别,都可以正确的输出其长度,只要你实现了__len__方法.</p>
<p><strong>自定义鸭子类型示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;BiuBiuBiu Running One!!!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Infor</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;BiuBiuBiu Running Two!!!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runT</span>(<span class="params">Student</span>):</span></span><br><span class="line">    Student.run()</span><br><span class="line"></span><br><span class="line">StuA=Student()</span><br><span class="line">runT(StuA)</span><br><span class="line"><span class="comment"># BiuBiuBiu Running One!!!</span></span><br><span class="line"></span><br><span class="line">infA=Infor()</span><br><span class="line">runT(infA)</span><br><span class="line"><span class="comment"># BiuBiuBiu Running Two!!!</span></span><br></pre></td></tr></table></figure>
<p>传入对象,只关注对象的行为能不能实现,不关注对象的类型.其实讲到这里鸭子类型就已经很明了啦.</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>B树</title>
    <url>/2021/01/24/B%E6%A0%91/</url>
    <content><![CDATA[<p>B树是一种多路查找树，相关的定义与解释解释如下。</p>
<a id="more"></a>

<blockquote>
<p><a href="https://www.nowcoder.com/test/question/done?tid=33839050&qid=14850#summary">原文地址</a></p>
</blockquote>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">是一种多路搜索树（并不是二叉的）：</span><br><span class="line"></span><br><span class="line">       1. 定义任意非叶子结点最多只有 M 个儿子；且 M&gt;2 ；</span><br><span class="line"></span><br><span class="line">       2. 根结点的儿子数为 [2, M] ；</span><br><span class="line"></span><br><span class="line">       3. 除根结点以外的非叶子结点的儿子数为 [M&#x2F;2, M] ；</span><br><span class="line"></span><br><span class="line">       4. 每个结点存放至少 M&#x2F;2-1 （取上整）和至多 M-1 个关键字；（至少 2 个关键字）</span><br><span class="line"></span><br><span class="line">       5. 非叶子结点的关键字个数 &#x3D; 指向儿子的指针个数 -1 ；</span><br><span class="line"></span><br><span class="line">       6. 非叶子结点的关键字： K[1], K[2], …, K[M-1] ；且 K[i] &lt; K[i+1] ；</span><br><span class="line"></span><br><span class="line">       7. 非叶子结点的指针： P[1], P[2], …, P[M] ；其中 P[1] 指向关键字小于 K[1] 的子树， P[M] 指向关键字大于 K[M-1] 的子树，其它 P[i] 指向关键字属于 (K[i-1], K[i]) 的子树；</span><br><span class="line"></span><br><span class="line">       8. 所有叶子结点位于同一层；</span><br><span class="line"></span><br><span class="line">        如：（ M&#x3D;3 ）</span><br></pre></td></tr></table></figure>
<p><img src="http://images.cnblogs.com/cnblogs_com/syxchina/201110/201110012318587145.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> B- 树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；</span><br><span class="line"></span><br><span class="line">B- 树的特性：</span><br><span class="line"></span><br><span class="line">       1. 关键字集合分布在整颗树中；</span><br><span class="line"></span><br><span class="line">       2. 任何一个关键字出现且只出现在一个结点中；</span><br><span class="line"></span><br><span class="line">       3. 搜索有可能在非叶子结点结束；</span><br><span class="line"></span><br><span class="line">       4. 其搜索性能等价于在关键字全集内做一次二分查找；</span><br><span class="line"></span><br><span class="line">       5. 自动层次控制；</span><br><span class="line"></span><br><span class="line">        由于限制了除根结点以外的非叶子结点，至少含有 M&#x2F;2 个儿子，确保了结点的至少利用率，其最底搜索性能为：</span><br></pre></td></tr></table></figure>
<p><img src="http://images.cnblogs.com/cnblogs_com/syxchina/201110/201110012318589936.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其中， M 为设定的非叶子结点最多子树个数， N 为关键字总数；</span><br><span class="line"></span><br><span class="line">      所以 B- 树的性能总是等价于二分查找（与 M 值无关），也就没有 B 树平衡的问题；</span><br><span class="line"></span><br><span class="line">      由于 M&#x2F;2 的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占 M&#x2F;2 的结点；删除结点时，需将两个不足 M&#x2F;2 的兄弟结点合并；</span><br></pre></td></tr></table></figure>
<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B+ 树是 B- 树的变体，也是一种多路搜索树：</span><br><span class="line"></span><br><span class="line">      1. 其定义基本与 B- 树同，除了：</span><br><span class="line"></span><br><span class="line">      2. 非叶子结点的子树指针与关键字个数相同；</span><br><span class="line"></span><br><span class="line">      3. 非叶子结点的子树指针 P[i] ，指向关键字值属于 [K[i], K[i+1]) 的子树（ B- 树是开区间）；</span><br><span class="line"></span><br><span class="line">      5. 为所有叶子结点增加一个链指针；</span><br><span class="line"></span><br><span class="line">      6. 所有关键字都在叶子结点出现；</span><br><span class="line"></span><br><span class="line">       如：（ M&#x3D;3 ）</span><br></pre></td></tr></table></figure>
<p><img src="http://images.cnblogs.com/cnblogs_com/syxchina/201110/20111001231859983.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B+ 的搜索与 B- 树也基本相同，区别是 B+ 树只有达到叶子结点才命中（ B- 树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</span><br><span class="line"></span><br><span class="line">      B+ 的特性：</span><br><span class="line"></span><br><span class="line">      1. 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</span><br><span class="line"></span><br><span class="line">      2. 不可能在非叶子结点命中；</span><br><span class="line"></span><br><span class="line">      3. 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</span><br><span class="line"></span><br><span class="line">      4. 更适合文件索引系统；</span><br></pre></td></tr></table></figure>


<h2 id="B-树-2"><a href="#B-树-2" class="headerlink" title="B*树"></a>B*树</h2><p>是 B+ 树的变体，在 B+ 树的非根和非叶子结点再增加指向兄弟的指针；</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/syxchina/201110/201110012319014688.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B* 树定义了非叶子结点关键字个数至少为 (2&#x2F;3)*M ，即块的最低使用率为 2&#x2F;3 （代替 B+ 树的 1&#x2F;2 ）；</span><br><span class="line"></span><br><span class="line">      B+ 树的分裂：当一个结点满时，分配一个新的结点，并将原结点中 1&#x2F;2 的数据复制到新结点，最后在父结点中增加新结点的指针； B+ 树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</span><br><span class="line"></span><br><span class="line">      B* 树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制 1&#x2F;3 的数据到新结点，最后在父结点增加新结点的指针；</span><br><span class="line"></span><br><span class="line">       所以， B* 树分配新结点的概率比 B+ 树要低，空间使用率更高；</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的三种遍历方式</title>
    <url>/2021/01/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>学习二叉树时，前序中序后序遍历方式是基础知识。最近再刷Leetcode时，发现很多遍历实现的基本本方式已经忘记了，这里将各种方式的原理与代码实现整理如下；</p>
<a id="more"></a>

<h2 id="三种遍历方式原理"><a href="#三种遍历方式原理" class="headerlink" title="三种遍历方式原理"></a>三种遍历方式原理</h2><p>三种遍历方式简单的一句话就是：根左右、左根右、左右根。</p>
<h3 id="相关图示："><a href="#相关图示：" class="headerlink" title="相关图示："></a>相关图示：</h3><blockquote>
<p><a href="https://www.pianshen.com/article/7106254596/">图片来源</a></p>
</blockquote>
<p>前序：<img src="https://i.loli.net/2021/01/24/X9IVJevzxlHY7wk.gif"></p>
<ul>
<li>结果：ABDHIEJCFKG</li>
</ul>
<p>中序：<img src="https://i.loli.net/2021/01/24/7A1YGlJVsypuQUh.gif"></p>
<ul>
<li>结果：HDIBEJAFKCG</li>
</ul>
<p>后序：<img src="https://i.loli.net/2021/01/24/EPcs3vLiAgp794M.gif"></p>
<ul>
<li>结果：HIDJEBKFGCA</li>
</ul>
<h3 id="如何理解前中后序"><a href="#如何理解前中后序" class="headerlink" title="如何理解前中后序"></a>如何理解前中后序</h3><p>理解前中后序的算法本身并不难，很多人直接就可以把前中后序算法结果写在纸面上。但还是要简单的说下过程：</p>
<p>首先看一张遍历图示：</p>
<p><img src="https://i.loli.net/2021/01/24/t31mXoeIgaqLcGW.jpg"></p>
<p>遍历图示显示，遍历的顺序为<strong>从根节点出发，先左子树后右子树。</strong>除了根节点与空节点外<strong>每一个节点均有三个入箭头</strong>，这三个如箭头分别表示：<strong>从父节点来、从左子树返回、从右子树返回</strong>。我们可以认为在<strong>递归算法中</strong>，每个节点均被遍历了三遍，但是哪一遍<strong>访问节点</strong>，决定了前、中、后序算法。</p>
<blockquote>
<p>非递归算法中，是否遍历了三遍、我无法确定。就算是使用栈实现遍历时，不同的算法策略也不尽相同。</p>
</blockquote>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><h4 id="节点定义："><a href="#节点定义：" class="headerlink" title="节点定义："></a>节点定义：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h4 id="构成树代码"><a href="#构成树代码" class="headerlink" title="构成树代码"></a>构成树代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = TreeNode(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">B = TreeNode(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">C = TreeNode(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">D = TreeNode(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">E = TreeNode(<span class="string">&quot;E&quot;</span>)</span><br><span class="line">F = TreeNode(<span class="string">&quot;F&quot;</span>)</span><br><span class="line">G = TreeNode(<span class="string">&quot;G&quot;</span>)</span><br><span class="line">H = TreeNode(<span class="string">&quot;H&quot;</span>)</span><br><span class="line">I = TreeNode(<span class="string">&quot;I&quot;</span>)</span><br><span class="line">J = TreeNode(<span class="string">&quot;J&quot;</span>)</span><br><span class="line">K = TreeNode(<span class="string">&quot;K&quot;</span>)</span><br><span class="line">A.left = B</span><br><span class="line">A.right = C</span><br><span class="line">B.left = D</span><br><span class="line">B.right = E</span><br><span class="line">D.left = H</span><br><span class="line">D.right = I</span><br><span class="line">E.right = J</span><br><span class="line">C.left = F</span><br><span class="line">C.right = G</span><br><span class="line">F.right = K</span><br></pre></td></tr></table></figure>


<h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><h5 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">frontorderTraversal</span>(<span class="params">root</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frontorder</span>(<span class="params">tree</span>):</span></span><br><span class="line">        res.append(tree.val)</span><br><span class="line">        <span class="keyword">if</span> tree.left:</span><br><span class="line">            frontorder(tree.left)</span><br><span class="line">        <span class="keyword">if</span> tree.right:</span><br><span class="line">            frontorder(tree.right)</span><br><span class="line">    frontorder(root)</span><br><span class="line">    <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure>
<h5 id="通用框架——先序"><a href="#通用框架——先序" class="headerlink" title="通用框架——先序"></a>通用框架——先序</h5><blockquote>
<p>这里的通用框架是在刷leetcode过程中，发现的一种类似于递归方式的，只需要更改部分代码，即可从先序转为中序或后序。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">frontorderTraversal</span>(<span class="params"> root</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    1. 递归法可以一行代码完成，无需讨论；</span></span><br><span class="line"><span class="string">    2. 迭代法一般需要通过一个栈保存节点顺序，我们这里直接使用列表</span></span><br><span class="line"><span class="string">      - 首先，我要按照中序遍历的顺序存入栈，这边用的逆序，方便从尾部开始处理</span></span><br><span class="line"><span class="string">      - 在存入栈时加入一个是否需要深化的参数</span></span><br><span class="line"><span class="string">      - 在回头取值时，这个参数应该是否，即直接取值</span></span><br><span class="line"><span class="string">      - 简单调整顺序，即可实现前序和后序遍历</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 迭代法</span></span><br><span class="line">    result = []</span><br><span class="line">    stack = [(<span class="number">1</span>, root)]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        go_deeper, node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> go_deeper:</span><br><span class="line">            <span class="comment"># 左右节点还需继续深化，并且入栈是先右后左</span></span><br><span class="line">            stack.append((<span class="number">1</span>, node.right))</span><br><span class="line">            <span class="comment"># 节点自身已遍历，回头可以直接取值</span></span><br><span class="line">            </span><br><span class="line">            stack.append((<span class="number">1</span>, node.left))</span><br><span class="line">            stack.append((<span class="number">0</span>, node))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(node.val)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>


<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><h5 id="递归：-1"><a href="#递归：-1" class="headerlink" title="递归："></a>递归：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">root</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">tree</span>):</span></span><br><span class="line">        <span class="keyword">if</span> tree.left:</span><br><span class="line">            inorder(tree.left)</span><br><span class="line">        res.append(tree.val)</span><br><span class="line">        <span class="keyword">if</span> tree.right:</span><br><span class="line">            inorder(tree.right)</span><br><span class="line">    inorder(root)</span><br><span class="line">    <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure>
<h5 id="通用框架——中序"><a href="#通用框架——中序" class="headerlink" title="通用框架——中序"></a>通用框架——中序</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params"> root</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    stack = [(<span class="number">1</span>, root)]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        go_deeper, node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> go_deeper:</span><br><span class="line">            <span class="comment"># 左右节点还需继续深化，并且入栈是先右后左</span></span><br><span class="line">            stack.append((<span class="number">1</span>, node.right))</span><br><span class="line">            <span class="comment"># 节点自身已遍历，回头可以直接取值</span></span><br><span class="line">            stack.append((<span class="number">0</span>, node))</span><br><span class="line">            stack.append((<span class="number">1</span>, node.left))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(node.val)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h5 id="教材法"><a href="#教材法" class="headerlink" title="教材法"></a>教材法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = []</span><br><span class="line">        curr = root</span><br><span class="line">        <span class="keyword">while</span>  stack  <span class="keyword">or</span> curr  :</span><br><span class="line">            <span class="comment"># 这里面写while也可以，或者写if都是可以的</span></span><br><span class="line">            <span class="comment"># 这里的代码有优化过</span></span><br><span class="line">            <span class="keyword">while</span>(curr):</span><br><span class="line">                stack.append(curr)</span><br><span class="line">                curr = curr.left</span><br><span class="line">            curr = stack.pop()</span><br><span class="line">            res.append(curr.val)</span><br><span class="line">            curr = curr.right     </span><br><span class="line">        <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure>


<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归:"></a>递归:</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backorderTraversal</span>(<span class="params">root</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backorder</span>(<span class="params">tree</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> tree.left:</span><br><span class="line">            backorder(tree.left)</span><br><span class="line">        <span class="keyword">if</span> tree.right:</span><br><span class="line">            backorder(tree.right)</span><br><span class="line">        res.append(tree.val)</span><br><span class="line">    backorder(root)</span><br><span class="line">    <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure>
<h5 id="通用框架——后序"><a href="#通用框架——后序" class="headerlink" title="通用框架——后序"></a>通用框架——后序</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backorderTraversal</span>(<span class="params"> root</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    stack = [(<span class="number">1</span>, root)]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        go_deeper, node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> go_deeper:</span><br><span class="line">            stack.append((<span class="number">0</span>, node))</span><br><span class="line">            <span class="comment"># 左右节点还需继续深化，并且入栈是先右后左</span></span><br><span class="line">            stack.append((<span class="number">1</span>, node.right))</span><br><span class="line">            <span class="comment"># 节点自身已遍历，回头可以直接取值</span></span><br><span class="line">            </span><br><span class="line">            stack.append((<span class="number">1</span>, node.left))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(node.val)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2021/01/24/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/kyoner/p/11080078.html">参考博客</a></p>
</blockquote>
<p>第二次刷Leetcode_034题目时，涉及到二分查找左右边界时，又出现了算法理解不清楚的问题。发现第一次也并没有去总结，这里总结下。</p>
<a id="more"></a>

<p>二分查找的精髓就是对于细节的把控，搜索空间的定义、左右指针的变换形式，左右指针在左右边界中分别代表的含义等等。都需要细致的理解才可以。</p>
<p>常见的二分查找一个应用场景我们可以分为三种：1.查找一个数 2.查找左边界 3.查找右边界。</p>
<h2 id="二分查找基本框架"><a href="#二分查找基本框架" class="headerlink" title="二分查找基本框架"></a>二分查找基本框架</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码框架就是我们在一开始接触二分查找时所采用的框架形式。</p>
<h2 id="寻找一个数"><a href="#寻找一个数" class="headerlink" title="寻找一个数"></a>寻找一个数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上时寻找一个数时采用的代码，其有几个常见的疑问点：</p>
<p><strong>左右指针的初始值：</strong> 通常左指针初始化均为0，而右指针经常会看到初始化为$right = len(nums)$ 或者 $right = len(nums) - 1$.这两种写法，我们该如何理解呢？队之后左右指针的更新分别又存在什么样子的影响呢？</p>
<p><strong>答：</strong> 左右指针其实就是middle可能遍历的位置范围，我们可以将左右指针<strong>看作middle的搜索范围</strong>。那么根据初始化右指针的情况不同可以</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀树</title>
    <url>/2021/01/24/%E5%89%8D%E7%BC%80%E6%A0%91/</url>
    <content><![CDATA[<h2 id="前缀树的概念"><a href="#前缀树的概念" class="headerlink" title="前缀树的概念"></a>前缀树的概念</h2><blockquote>
<p><a href="https://www.jianshu.com/p/e9610f67b54c">参考地址</a></p>
</blockquote>
<p>前缀树也称之为单词查找树，Trie树，是一种N叉树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。<strong>它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高</strong>。</p>
<a id="more"></a>

<p><img src="D:\nutStore\Learning\leetcode\pictures\trie.webp"></p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符；</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><blockquote>
<p>可以最大限度地减少无谓的字符串比较，故可以用于词频统计和大量字符串排序。</p>
<p>　　跟哈希表比较：</p>
<p>　　　　1，最坏情况时间复杂度比hash表好</p>
<p>　　　　2，没有冲突，除非一个key对应多个值（除key外的其他信息）</p>
<p>　　　　3，自带排序功能（类似Radix Sort），中序遍历trie可以得到排序。</p>
<p>1，虽然不同单词共享前缀，但其实trie是一个以空间换时间的算法。其每一个字符都可能包含至多字符集大小数目的指针（不包含卫星数据）。</p>
<p>每个结点的子树的根节点的组织方式有几种。1&gt;如果默认包含所有字符集，则查找速度快但浪费空间（特别是靠近树底部叶子）。2&gt;如果用链接法(如左儿子右兄弟)，则节省空间但查找需顺序（部分）遍历链表。3&gt;<em>alphabet reduction</em>: 减少字符宽度以减少字母集个数。,4&gt;对字符集使用bitmap，再配合链接法。</p>
<p>2，如果数据存储在外部存储器等较慢位置，Trie会较hash速度慢（hash访问O(1)次外存，Trie访问O(树高)）。</p>
<p>3，长的浮点数等会让链变得很长。可用bitwise trie改进。</p>
</blockquote>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>前缀树本身是一种<strong>数据结构</strong>，是一种树形结构。常见的实现方式包括：1.字典 2.数组。通常其节点由两部分组成：</p>
<ol>
<li>字符数据</li>
<li>单词尾椎标识</li>
</ol>
<h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><h3 id="搜索操作"><a href="#搜索操作" class="headerlink" title="搜索操作"></a>搜索操作</h3><ol>
<li>从根结点开始一次搜索；</li>
<li>取得要查找关键词的第一个字母，并根据该字母选择对应的子树并转到该子树继续进行检索；</li>
<li>在相应的子树上，取得要查找关键词的第二个字母,并进一步选择对应的子树进行检索。</li>
<li>迭代过程……</li>
<li>在某个结点处，关键词的所有字母已被取出，则读取附在该结点上的信息，即完成查找。</li>
</ol>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><ol>
<li>从头到尾遍历字符串的每一个字符</li>
<li>从根节点开始插入，若该字符存在，那就不用插入新节点，要是不存在，则插入新节点</li>
<li>然后顺着插入的节点一直按照上述方法插入剩余的节点</li>
<li>为了统计每一个字符串出现的次数，应该在最后一个节点插入后occurances++，表示这个字符串出现的次数增加一次</li>
</ol>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h4 id="字典实现"><a href="#字典实现" class="headerlink" title="字典实现"></a>字典实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.root = &#123;<span class="string">&quot;End&quot;</span>:<span class="literal">False</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Inserts a word into the trie.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        curNode = self.root</span><br><span class="line">        <span class="keyword">for</span>  c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> curNode.keys()  :</span><br><span class="line">                curNode[c] = &#123;<span class="string">&quot;End&quot;</span>:<span class="literal">False</span>&#125;</span><br><span class="line">            curNode = curNode[c]</span><br><span class="line">        curNode[<span class="string">&quot;End&quot;</span>] = <span class="literal">True</span>     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if the word is in the trie.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        curNode = self.root</span><br><span class="line">        <span class="keyword">for</span>  c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> curNode.keys()  :</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            curNode = curNode[c]</span><br><span class="line">        <span class="keyword">if</span> curNode[<span class="string">&quot;End&quot;</span>] :</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        curNode = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> curNode.keys():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curNode = curNode[c]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h4 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.root = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">27</span>) ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Inserts a word into the trie.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        curNode = self.root</span><br><span class="line">        <span class="keyword">for</span>  c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> curNode[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)] ==<span class="number">0</span>  :</span><br><span class="line">                curNode[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)] = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">27</span>) ]</span><br><span class="line">            curNode = curNode[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)]</span><br><span class="line">        curNode[<span class="number">26</span>] = <span class="literal">True</span>     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if the word is in the trie.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        curNode = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> curNode[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curNode = curNode[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)]</span><br><span class="line">        <span class="keyword">if</span> curNode[<span class="number">26</span>] :</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        curNode = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> curNode[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curNode = curNode[<span class="built_in">ord</span>(c)-<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>二维前缀和</title>
    <url>/2021/01/24/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/solution/yuan-su-he-xiao-yu-deng-yu-yu-zhi-de-zheng-fang-2/">Leetcode讲解</a></p>
<p>在二维数组中涉及到大量计算某区域的算法题目，为了降低时间复杂度，对数组区域进行记忆是必不可少的，这也就提出了二维数组的前缀和（P）概念。</p>
<a id="more"></a>

<p>在得到P的同时，我们可以在 $O（1）$ 的时间复杂度内，得到任意矩形区域的和。</p>
<h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><p><strong>假设</strong>二维数组的 $ A $ 的大小为 $ m * n $ ,其数组下标的范围为$ [1 \dots m] , [1\dots n]$.</p>
<blockquote>
<p>数组下标范围与真实程序中的范围存在偏差，这样写主要为了与后面P数组对应，容易理解。</p>
</blockquote>
<p>数组 $ P $ 是 $ A $ 的前缀和数组，$ P $ 中每一个元素 $ P[i][j] $ 均符合以下定义：</p>
<ul>
<li>如果 $ i , j  $ 均大于 0 ，那么 $ P[i][j] $ 表示数组 $A $ 中以 $ [1,1] $为左上角 ， $ [i , j] $ 为右下角的矩形区域的元素和。</li>
<li>否则，$ P[i][j] $ 等于 0 .</li>
</ul>
<blockquote>
<p>在这里我们就可以发现，$ P $ 数组其实比 $ A $ 数组多了一行一列，并且是在第一行前、第一列前添加了 0 行/列， 这么做是为了计算的统一性。</p>
</blockquote>
<p><strong>任意矩形区域的计算</strong></p>
<p>在得到完整的$ P  $ 数组之后，我们可以在常数时间内得到你想要的<strong>任意的矩形区域</strong>的元素和。我们假设其矩形区域的右上角为 $ (x_1 , y_1) $ ,左下角为 $(x_2 , y_2) $ . 有<br>$$<br>sum = A[x_1\dots x_2][y_1 \dots y_2] = P[x_2][y_2] - P[x_1-1][y_2] - P[x_2][y_1-1] + P[x_1 - 1][y_1 -1]<br>$$</p>
<blockquote>
<p>上式中我们看到其大量的采用 了 - 1的形式，在面对边界时如果P数组不扩充，就会出现数组越界问题。</p>
</blockquote>
<p><strong>证明上式：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">以下图为例，当 A 的大小为 8 * 5，需要求和的矩形区域（深绿色部分）的左上角为 (3, 2)，右下角为 (5, 5) 时，该矩形区域的元素之和为 P[5][5] - P[2][5] - P[5][1] + P[2][1]。</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.leetcode-cn.com/3f83532ef2affcd3532c0b099a3e107ee8e494d0ca100fa81b097460f2167f73-1292-1%E7%9A%84%E5%89%AF%E6%9C%AC%202.png"></p>
<p><strong>数组P的获取</strong></p>
<p>上面讲了数组$ P $ 的应用，那么数组 $P  $ 到底是怎么得到的呢？</p>
<p>还是利用上面的式子有：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">我们按照行优先的顺序依次计算数组 P 中的每个元素，即当我们在计算 P[i][j] 时，数组 P 的前 i - 1 行，以及第 i 行的前 j - 1 个元素都已经计算完成。此时我们可以考虑 (i, j) 这个 1 * 1 的矩形区域，根据上面的等式，有：</span><br><span class="line">A[i][j] = P[i][j] - P[i - 1][j] - P[i][j - 1] + P[i - 1][j - 1]</span><br><span class="line">由于等式中的 A[i][j]，P[i - 1][j]，P[i][j - 1] 和 P[i - 1][j - 1] 均已知，我们可以通过：</span><br><span class="line">P[i][j] = P[i - 1][j] + P[i][j - 1] - P[i - 1][j - 1] + A[i][j]</span><br></pre></td></tr></table></figure>
<p><strong>代码实现</strong></p>
<blockquote>
<p>注意真实数组下标问题</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPresum</span>(<span class="params">nums</span>):</span></span><br><span class="line">    m = <span class="built_in">len</span>(nums)</span><br><span class="line">    n = <span class="built_in">len</span>(nums[<span class="number">0</span>])</span><br><span class="line">    P = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>) ]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> , m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            P[i][j] = nums[i-<span class="number">1</span>][j-<span class="number">1</span>] + P[i-<span class="number">1</span>][j] + P[i][j-<span class="number">1</span>] - P[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> P</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯法</title>
    <url>/2021/01/24/%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    <content><![CDATA[<h3 id="回朔法的思想："><a href="#回朔法的思想：" class="headerlink" title="回朔法的思想："></a>回朔法的思想：</h3><p>回朔法的重要思想在于： 通过枚举法，对所有可能性进行遍历。 但是枚举的顺序是 一条路走到黑，发现黑之后，退一步，再向前尝试没走过的路。直到所有路都试过。因此回朔法可以简单的理解为： 走不通就退一步的方枚举法就叫回朔法。而这里回退点也叫做回朔点。</p>
<a id="more"></a>

<h3 id="回朔关键点"><a href="#回朔关键点" class="headerlink" title="回朔关键点"></a>回朔关键点</h3><p>通过分析发现，回朔法实现的三大技术关键点分别是：</p>
<ol>
<li>一条路走到黑</li>
<li>回退一步</li>
<li>另寻他路</li>
</ol>
<h3 id="关键点的实现"><a href="#关键点的实现" class="headerlink" title="关键点的实现"></a>关键点的实现</h3><p>那么如何才能用代码实现上述三个关键点呢？</p>
<ol>
<li>for 循环</li>
<li>递归</li>
</ol>
<h4 id="解释如下"><a href="#解释如下" class="headerlink" title="解释如下"></a>解释如下</h4><ul>
<li>for循环的作用在于另寻他路： 你可以用for循环可以实现一个路径选择器的功能，该路径选择器可以逐个选择当前节点下的所有可能往下走下去的分支路径。 例如： 现在你走到了节点a，a就像个十字路口，你从上面来到达了a，可以继续向下走。若此时向下走的路有i条，那么你肯定要逐个的把这i条都试一遍才行。而for的作用就是可以让你逐个把所有向下的i个路径既不重复，也不缺失的都试一遍</li>
<li>递归可以实现一条路走到黑和回退一步： 一条路走到黑： 递归意味着继续向着for给出的路径向下走一步。 如果我们把递归放在for循环内部，那么for每一次的循环，都在给出一个路径之后，进入递归，也就继续向下走了。直到递归出口（走无可走）为止。 那么这就是一条路走到黑的实现方法。 递归从递归出口出来之后，就会实现回退一步。</li>
</ul>
<p>因此for循环和递归配合可以实现回朔： 当递归从递归出口出来之后。上一层的for循环就会继续执行了。而for循环的继续执行就会给出当前节点下的下一条可行路径。而后递归调用，就顺着这条从未走过的路径又向下走一步。这就是回朔</p>
<p>说了这么多，回朔法的通常模板是什么呢？ 递归和for又是如何配合的呢？</p>
<h4 id="回朔代码模板"><a href="#回朔代码模板" class="headerlink" title="回朔代码模板"></a>回朔代码模板</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def backward():</span><br><span class="line">    </span><br><span class="line">    if (回朔点）：# 这条路走到底的条件。也是递归出口</span><br><span class="line">        保存该结果</span><br><span class="line">        return   </span><br><span class="line">    </span><br><span class="line">    else:</span><br><span class="line">        for route in all_route_set :  逐步选择当前节点下的所有可能route</span><br><span class="line">            </span><br><span class="line">            if 剪枝条件：</span><br><span class="line">                剪枝前的操作</span><br><span class="line">                return   #不继续往下走了，退回上层，换个路再走</span><br><span class="line">            </span><br><span class="line">            else：#当前路径可能是条可行路径</span><br><span class="line">            </span><br><span class="line">                保存当前数据  #向下走之前要记住已经走过这个节点了。例如push当前节点</span><br><span class="line">        </span><br><span class="line">                self.backward() #递归发生，继续向下走一步了。</span><br><span class="line">                </span><br><span class="line">                回朔清理     # 该节点下的所有路径都走完了，清理堆栈，准备下一个递归。例如弹出当前节点</span><br></pre></td></tr></table></figure>
<p>这里剪枝操作指的是： 对于有些问题，你走着走着，若某种情况发生了，你就已经直到不能继续往下走了，再走也没有用了。而这个情况就被称之为剪枝条件。</p>
<p>而DFS就是一个最典型的回朔法的应用。</p>
<h2 id="本题代码"><a href="#本题代码" class="headerlink" title="本题代码"></a>本题代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(candidates) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        path = []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        ！！！重点！！！</span></span><br><span class="line"><span class="string">        在python中，如果传参是mutable var, 那么传参相当于引用，因此调用后，如果调用函数的内部对该传入变量进行修改，就会导致直接改变原始对象。这就是典型的privacy leak！！发生了。</span></span><br><span class="line"><span class="string">        例如在这个，list就是该mutable var，而如果以path或res 为传参，放在__DFS 中， 那么就相当于在__DFS内部，实际上用的都是一个物理地址下的res和path，类似于全局变量。</span></span><br><span class="line"><span class="string">        因此combinationSum下的局部变量path和res也在——DFS运行的过程中发生了改变。</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        利用这个性质，我们可以把mutable var当成传入参数，从而实现全局变量的效果。</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.__DFS(candidates, target, <span class="number">0</span>, path, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        DFS的实现</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__DFS</span>(<span class="params">self, candidates, target, begin, path, res</span>):</span></span><br><span class="line">        path = path.copy()</span><br><span class="line">        <span class="comment"># 递归出口 就是余数为0</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            res.append(path)   <span class="comment">#记录该符合条件的结果</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#若当前路径有可能可行。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(begin, <span class="built_in">len</span>(candidates)):  <span class="comment"># 我们现在到begin的节点上了</span></span><br><span class="line">            <span class="keyword">if</span> target - candidates[i] &lt; <span class="number">0</span>:  <span class="comment"># 剪枝条件</span></span><br><span class="line">                <span class="keyword">return</span>                      <span class="comment"># 如果当前节点就不行了，就不用继续了,这里到不用继续了即包括该depth不用继续了，也包括该节点更大到child也不用继续了，该节点pop出来</span></span><br><span class="line">            </span><br><span class="line">            path.append(candidates[i])  <span class="comment">#记录当前为止</span></span><br><span class="line">            self.__DFS(candidates, target - candidates[i], i, path, res)<span class="comment"># 向下继续走，记住递归不是return，递归到实现是调用！一旦return发生，递归停止。</span></span><br><span class="line">            path.pop()  <span class="comment"># 回朔清理。当前节点下的所有情况都进行完了，该节点也不应该在path</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序简介与用处</title>
    <url>/2021/01/24/%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%80%E4%BB%8B%E4%B8%8E%E7%94%A8%E5%A4%84/</url>
    <content><![CDATA[<p>堆排序实在数据结构中常见的排序算法，但许久未看已经忘得差不多啦。这里简单的将相关概念记录如下：</p>
<a id="more"></a>

<blockquote>
<p>[参考博客]（<a href="https://www.cnblogs.com/lanhaicode/p/10546257.html%EF%BC%89">https://www.cnblogs.com/lanhaicode/p/10546257.html）</a></p>
</blockquote>
<h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p><strong>堆是利用完全二叉树的结构进行维护的一位数组</strong>，我们可以将其看作是一维数组也可以看作是完全二叉树，物理上是线性结构，理论上是非线性结构。</p>
<p><strong>大顶堆</strong>：每个节点值<strong>大于或等于</strong>左右子节点的值<br><strong>小顶堆</strong>：每个节点值<strong>小于或等于</strong>左右子节点的值<br>这也是堆最重要的特性</p>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p><img src="https://i.loli.net/2020/05/03/aueKbsSfq5Ux8d2.png"></p>
<p>我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子.<img src="https://i.loli.net/2020/05/03/cQMLjeoiRzyCrvX.png"></p>
<p><strong>公式定义：</strong></p>
<p><strong>大顶堆：</strong>arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2] </p>
<p><strong>小顶堆：</strong>arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2] </p>
<h2 id="相关易混淆概念"><a href="#相关易混淆概念" class="headerlink" title="相关易混淆概念"></a>相关易混淆概念</h2><p><strong>平衡树</strong>：比如AVL、红黑树等，其要求左子树节点&lt;根&lt;右子树节点，并且左右子树均符合此定义。也就是说其<strong>整棵树都是有序</strong>的。</p>
<p><strong>为什么不用树存储而使用数组：</strong>1.树存储本身浪费空间 2.堆逻辑上为完全二叉树，这对于数组而言不浪费空间。</p>
<p><strong>堆不适合搜索：</strong>虽然二叉树是适合搜索的，但是堆并不合适，这也是堆部分有序造成的困扰。</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是堆最常见的应用方式，堆排序的过程由三个步骤迭代完成。</p>
<ol>
<li><p>堆的构建</p>
<blockquote>
<p>初始堆的构建，是堆所有的非叶子节点进行调整，时间复杂度为$ O(n) $，自下而上</p>
</blockquote>
</li>
<li><p>出堆</p>
</li>
<li><p>堆调整</p>
<blockquote>
<p>堆调整只需要更改部分节点变化的节点即可，时间复杂度为$ O(log(n)) $ ,是自上而下的</p>
</blockquote>
<p><strong>升序</strong> ： 使用大顶堆</p>
<blockquote>
<p>每个结点的值都<strong>大于</strong>或<strong>等于</strong>其左右孩子结点的值，我们把<strong>大顶堆构建完毕后根节点的值一定是最大的，然后把根节点的和最后一个元素（也可以说最后一个节点）交换位置，那么末尾元素此时就是最大元素了（理解这点很重要）</strong></p>
</blockquote>
<ol>
<li>先n个元素的无序序列，构建成大顶堆</li>
<li>将根节点与最后一个元素交换位置，（<strong>将最大元素”沉”到数组末端</strong>）</li>
<li>交换过后可能不再满足大顶堆的条件，所以需要将剩下的n-1个元素重新构建成大顶堆</li>
<li>重复第二步、第三步直到整个数组排序完成</li>
</ol>
<p><strong>降序</strong> :使用小顶堆</p>
</li>
</ol>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><blockquote>
<p>代码中展示了通过一个大顶堆,构建升序的过程,具体的展示可以见 排序算法总结.md,gif图生动的展示了过程.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建大顶堆的节点交换函数,作为辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oneStep</span>(<span class="params">nums , n , i</span>):</span></span><br><span class="line">    index = i</span><br><span class="line">    left = i*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    right = i*<span class="number">2</span> + <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; n <span class="keyword">and</span> nums[left] &gt; nums[index]:</span><br><span class="line">        index = left</span><br><span class="line">    <span class="keyword">if</span> right &lt; n <span class="keyword">and</span> nums[right] &gt; nums[index]:</span><br><span class="line">        index = right</span><br><span class="line">    <span class="keyword">if</span> index != i:</span><br><span class="line">        nums[i] , nums[index] = nums[index] , nums[i]</span><br><span class="line">        oneStep(nums , n , index)</span><br><span class="line"><span class="comment"># 构建堆函数,自下而上</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildHeap</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)//<span class="number">2</span>-<span class="number">1</span> , -<span class="number">1</span> , -<span class="number">1</span>):</span><br><span class="line">        oneStep(nums , <span class="built_in">len</span>(nums) , i)</span><br><span class="line">    </span><br><span class="line">nums = [<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>]</span><br><span class="line">buildHeap(nums)</span><br><span class="line"><span class="comment"># 不断的出堆,堆调整(自上而下)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    nums[<span class="number">0</span>] , nums[<span class="built_in">len</span>(nums)-<span class="number">1</span>-i] = nums[<span class="built_in">len</span>(nums)-<span class="number">1</span>-i] ,nums[<span class="number">0</span>]</span><br><span class="line">    oneStep(nums , <span class="built_in">len</span>(nums)-<span class="number">1</span>-i , <span class="number">0</span>)</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2021/01/24/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p>最近在刷Leetcode（NO.399）过程中看到了并查集的概念，发现自己并不是很清楚其概念，故这里将相关概念总结如下：</p>
<a id="more"></a>

<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/93647900">知乎专栏</a>、<a href="https://www.cnblogs.com/cyanigence-oi/p/11774190.html">相关博客</a>、<a href="https://leetcode-cn.com/problems/number-of-provinces/solution/python-duo-tu-xiang-jie-bing-cha-ji-by-m-vjdr/">牛客网友解释</a></p>
</blockquote>
<h2 id="并查集的概念"><a href="#并查集的概念" class="headerlink" title="并查集的概念"></a>并查集的概念</h2><p>并查集首先是一种<strong>数据结构</strong>，在这种数据结构中其管理了一系列的<strong>不相交的集合</strong>，并且只存在<strong>合并</strong>与<strong>查询</strong>两种操作。有人将并查集如此解读：</p>
<ul>
<li>并(UNION):合并</li>
<li>查(Find): 查找</li>
<li>集(Set):一个以<strong>字典</strong>为基础的数据结构；</li>
</ul>
<p>并查集跟树有些类似，只不过跟树是相反的。在树这个数据结构里面，每个节点会记录它的子节点。在并查集里，每个节点会记录它的父节点。</p>
<h3 id="两种核心操作"><a href="#两种核心操作" class="headerlink" title="两种核心操作"></a>两种核心操作</h3><ul>
<li>合并：把两个不相交的集合合并为同一个集合</li>
<li>查询：查询当前元素所属集合。</li>
</ul>
<h3 id="并查集核心思想"><a href="#并查集核心思想" class="headerlink" title="并查集核心思想"></a>并查集核心思想</h3><p>用<strong>集合中某元素来代表此集合</strong>，通常此元素为根节点。要想找到此集合的<strong>代表元素</strong>，就需要不断的寻找<strong>父</strong>节点，直到父节点为本身时，即为代表元素。</p>
<h3 id="并查集中的概念梳理"><a href="#并查集中的概念梳理" class="headerlink" title="并查集中的概念梳理"></a>并查集中的概念梳理</h3><blockquote>
<p>来源于<a href="https://leetcode-cn.com/problems/number-of-provinces/solution/python-duo-tu-xiang-jie-bing-cha-ji-by-m-vjdr/">牛客网友解释</a></p>
</blockquote>
<ul>
<li>并查集的初始化：利用字典记录父节点信息</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        记录每个节点的父节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.father = &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>并查集的连通性：在同一棵树里(祖先节点相同)，则说明两节点连通，如下图所示：</p>
<p><img src="https://i.loli.net/2021/01/20/tr6x3aKzNfTgGuy.png" alt="image-20210120161137309"></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_connected</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    判断两节点是否相连</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> self.find(x) == self.find(y)</span><br><span class="line">  </span><br></pre></td></tr></table></figure>


<ul>
<li>添加节点：在字典实现中，需要置父节点为空即可。</li>
</ul>
<p><img src="https://i.loli.net/2021/01/20/mTuaPHWv8Oq2QJB.png" alt="image-20210120161401471"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self,x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    添加新节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> self.father:</span><br><span class="line">        self.father[x] = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>合并节点：合并节点就是将其祖先节点一致，可以任意加入对方的队伍。</p>
<p><img src="https://i.loli.net/2021/01/20/JQebsm2H3YwrqvE.png" alt="image-20210120161558452"></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self,x,y,val</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    合并两个节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    root_x,root_y = self.find(x),self.find(y)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> root_x != root_y:</span><br><span class="line">        self.father[root_x] = root_y</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<ul>
<li>查找祖先：父节点不为空：不停的迭代或者递归均可以</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self,x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    查找根节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    root = x</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> self.father[root] != <span class="literal">None</span>:</span><br><span class="line">        root = self.father[root]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>


<p>  <img src="https://i.loli.net/2021/01/20/Egq4MBtul1CiJz2.gif" alt="Union_Find"></p>
<ul>
<li><p>路径压缩：查询时启动的路径优化算法，就是将路径上所有的节点直接连接到祖先节点</p>
<p><img src="https://i.loli.net/2021/01/20/OkZcPEgNwiB3UpG.gif" alt="Union_PassZip"></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self,x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    查找根节点</span></span><br><span class="line"><span class="string">    路径压缩</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    root = x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> self.father[root] != <span class="literal">None</span>:</span><br><span class="line">        root = self.father[root]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 路径压缩</span></span><br><span class="line">    <span class="keyword">while</span> x != root:</span><br><span class="line">        original_father = self.father[x]</span><br><span class="line">        self.father[x] = root</span><br><span class="line">        x = original_father</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h2 id="并查集的实现："><a href="#并查集的实现：" class="headerlink" title="并查集的实现："></a>并查集的实现：</h2><h3 id="数组实现："><a href="#数组实现：" class="headerlink" title="数组实现："></a>数组实现：</h3><p>在<a href="https://zhuanlan.zhihu.com/p/93647900">知乎专栏</a>介绍中，已经利用数组实现了并查集，不推荐使用。</p>
<ul>
<li><p>找到祖先节点的标志是：本身记为父节点。</p>
</li>
<li><p>采用了递归的方式寻找祖先节点</p>
<p>这里不再赘述。并且我个人认为数组的形式天然不适合作为并查集的实现方式，而字典这种键值对的方式更加适合实现并查集。</p>
</li>
</ul>
<p><strong>不建议适用数组实现</strong></p>
<h3 id="字典实现模板"><a href="#字典实现模板" class="headerlink" title="字典实现模板"></a>字典实现模板</h3><p>这里提供字典的实现方式，并且祖先节点的标志为：自身的父节点为None时为祖先节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        记录每个节点的父节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.father = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        查找根节点</span></span><br><span class="line"><span class="string">        路径压缩</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        root = x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.father[root] != <span class="literal">None</span>:</span><br><span class="line">            root = self.father[root]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 路径压缩</span></span><br><span class="line">        <span class="keyword">while</span> x != root:</span><br><span class="line">            original_father = self.father[x]</span><br><span class="line">            self.father[x] = root</span><br><span class="line">            x = original_father</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self,x,y,val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        合并两个节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        root_x,root_y = self.find(x),self.find(y)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root_x != root_y:</span><br><span class="line">            self.father[root_x] = root_y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_connected</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        判断两节点是否相连</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.find(x) == self.find(y)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        添加新节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> self.father:</span><br><span class="line">            self.father[x] = <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树_Minimum-Spanning-Tree</title>
    <url>/2021/01/24/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-Minimum-Spanning-Tree/</url>
    <content><![CDATA[<p>最小生成树是图的应用之一，是<strong>无向有权图的最短路径</strong>算法。</p>
<a id="more"></a>

<h2 id="图的应用有哪些？"><a href="#图的应用有哪些？" class="headerlink" title="图的应用有哪些？"></a>图的应用有哪些？</h2><p>最小生成树，最短路径，关键路径，拓扑排序，关键路径等。每种应用适用的场景不同，但是却很容易混淆，原因之一就是实践的太少。</p>
<h2 id="最小生成树是什么？"><a href="#最小生成树是什么？" class="headerlink" title="最小生成树是什么？"></a>最小生成树是什么？</h2><p>生成树是<strong>图</strong>的极小连通子图，特点有二：</p>
<ol>
<li>包括<strong>所有</strong>图中顶点，n个顶点；</li>
<li>包括尽可能少的边，n-1条边。</li>
</ol>
<p>意味着增加一条边就会产生回路，减少一条边则非连通。</p>
<p>那么<strong>最小生成树就是所有生成树中，权值和最小的生成树</strong>，最小生成树的性质有三：</p>
<ol>
<li>最小生成树不唯一；</li>
<li>最小生成树边的权值和是唯一的；</li>
<li>边的数量等于定点数量-1.</li>
</ol>
<h2 id="最小生成树的算法：Prim与Kruskal"><a href="#最小生成树的算法：Prim与Kruskal" class="headerlink" title="最小生成树的算法：Prim与Kruskal"></a>最小生成树的算法：Prim与Kruskal</h2><p>Prim与Kruskal算法均是基于<strong>贪心的策略</strong>，两算法中均利用最小树中的性质：</p>
<ul>
<li><p>假设存在带权连通无向图， $ G = （V,E） $, $U$ 标识最小生成树中的节点集，$(u,v)$ 标识一条具有最小权值的边，其中$ u\in U , v\in (V-U) $ ,那么必然存在一颗包含有边$ (u,v) $ 的最小生成树。</p>
<p>上面的性质乍看一下很是不好理解，但可以直接理解为一句话：<strong>当前权值最小的边一定会被选进最小生成树中。</strong></p>
</li>
</ul>
<p>大多数的算法均采用，加入边的方式进行设计，Prim与Kruskal也不例外。</p>
<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><h4 id="算法思想：从点的角度找边"><a href="#算法思想：从点的角度找边" class="headerlink" title="算法思想：从点的角度找边"></a>算法思想：从点的角度找边</h4><p>假设：存在一个无向有权连通图$ G=(V,E) $ , $V_{t}$ 代表最小生成树中的节点，$V_{out} = V - V_t$ 代表未被选入最小生成树的节点，$ E_{t} $ 代表生成树边的集合。</p>
<p>初始$ V_t = {u_0}  , E_t ={} $,重复下个步骤：</p>
<ul>
<li>在所有$u\in V_t , v \in V_{out}$ 寻找最小的权值边$ e_{(u,v)}$ ,将此边加入到$E_{t}$中，节点$v$加入到$V_t$中。</li>
</ul>
<p>直到$V_t = V$为止。</p>
<p>时间复杂度：$O(|V|^2)$，不依赖于边$E$ , 适合于边稠密的情况。</p>
<p>算法执行步骤如下图所示：</p>
<p><img src="https://i.loli.net/2021/01/19/OBDbg3LM5qi4Gck.png" alt="Prim算法示意图"></p>
<h4 id="代码步骤"><a href="#代码步骤" class="headerlink" title="代码步骤"></a>代码步骤</h4><p>参考地址：<a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/solution/prim-and-kruskal-by-yexiso-c500/">牛客网友回答</a></p>
<p>通过维护两个数组：</p>
<ul>
<li>lowCost数组标识：$V_{t}$ 到所有节点的最小花销，如果该节点已经在$V_{t}$ 中，那么置为float(“inf”)；</li>
<li>VStatus数组标识：各节点的访问情况，初始化为0，若已访问则置为-1；</li>
</ul>
<ol>
<li>随机选择起点，加入到$V_t$中，更新lowCost与VStatus数组;</li>
<li>遍历lowCost数组，选择最小边（索引为j），将此边加入$E_{t}$,将此节点加入$V_{t}$,更新$lowCost[j]与VStatus[j]$</li>
<li>此时$V_t$ 已经发生了变化，需要更新所有的lowCost数组值；</li>
<li>重复第2步，直到所有的节点均已加入树中。</li>
</ol>
<p>如图所示：</p>
<p><img src="https://pic.leetcode-cn.com/1611023745-EuGMdh-image.png"></p>
<h4 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h4><blockquote>
<p>以Leetcode1584题为例：</p>
<p>You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].</p>
<p>The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.</p>
<p>Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Prim算法的常规实现形式，未使用堆。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostConnectPoints</span>(<span class="params">self, points: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">distance</span>(<span class="params">pointA , pointB</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(pointA[<span class="number">0</span>] - pointB[<span class="number">0</span>]) + <span class="built_in">abs</span>(pointA[<span class="number">1</span>] - pointB[<span class="number">1</span>])</span><br><span class="line">        length = <span class="built_in">len</span>(points)</span><br><span class="line">        lowCost = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">        vStatus = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">        <span class="comment"># 构造邻接矩阵方便之后的调用，非必须</span></span><br><span class="line">        costMatrix = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span> , length):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span> , length):</span><br><span class="line">                dist = distance(points[i] , points[j])</span><br><span class="line">                costMatrix[i][j] = costMatrix[j][i] = dist</span><br><span class="line">        <span class="comment"># 将第一个点加入V_t,并更新相关数组lowCost,vStatus</span></span><br><span class="line">        vStatus[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">        lowCost[<span class="number">0</span>] = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,length):</span><br><span class="line">            lowCost[j] = costMatrix[<span class="number">0</span>][j]</span><br><span class="line">        output = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 寻找n-1次边</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 找到最小的边与索引</span></span><br><span class="line">            minCost = <span class="built_in">min</span>(lowCost)</span><br><span class="line">            minIndex = lowCost.index(minCost)</span><br><span class="line">            output += minCost</span><br><span class="line">            <span class="comment"># 更新lowCost[j] , vStatus[j]</span></span><br><span class="line">            lowCost[minIndex] = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">            vStatus[minIndex] = -<span class="number">1</span></span><br><span class="line">            <span class="comment"># 更新所有的lowCost</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                <span class="keyword">if</span> vStatus[i] != -<span class="number">1</span> <span class="keyword">and</span> costMatrix[minIndex][i] &lt; lowCost[i]:</span><br><span class="line">                    lowCost[i] = costMatrix[minIndex][i]</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：$O(n^2)$,每一次在更新lowCost的复杂度均为$O(n)$.</li>
<li>空间复杂度：$O(n^2)$.</li>
</ul>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><h4 id="算法思想-从边的角度触发"><a href="#算法思想-从边的角度触发" class="headerlink" title="算法思想:从边的角度触发"></a>算法思想:从边的角度触发</h4><p>假设：存在一个无向有权连通图$ G=(V,E) $ , $V_{t}$ 代表最小生成树中的节点，$V_{out} = V - V_t$ 代表未被选入最小生成树的节点，$ E_{t} $ 代表生成树边的集合。</p>
<p>初始化：$V_t = V , V_{out} = \empty , E_t = {}$,每一个顶点是一棵树，此时的最小生成树是含有N棵树的森林。重复下面的步骤：</p>
<ul>
<li>按照图$ G$ 中权值递增的顺序从边$ E-E_t $ 选择边$e$ , 如果边并没有构成回路则添加进$E_t$ 中，否则舍弃此边。</li>
</ul>
<p>直到$E_t$ 中包含有n-1条边。</p>
<ul>
<li>时间复杂度：$ |E|log|E| $,适合变稀疏的情况。</li>
</ul>
<p>算法执行步骤如下图所示：</p>
<p><img src="https://i.loli.net/2021/01/20/O3MJvk7A4ljUmf1.png" alt="image-20210120133332552"></p>
<h4 id="代码步骤-1"><a href="#代码步骤-1" class="headerlink" title="代码步骤"></a>代码步骤</h4><p>利用<strong>并查集</strong>，很容易解决此类问题。并查集的定义与模板代码，可以看我的解释。</p>
<ol>
<li>构建一个带有并查集的类，并实现相关功能；</li>
<li>计算所有的边长，并记录顶点信息，存储在数组$E$ 中，按照边长排序；</li>
<li>初始化并查集（将所有的顶点加入到并查集中）；</li>
<li>遍历$E$,假设每一个边由$e = [len , i , j]$ 组成：<ul>
<li>如果顶点$i，j$ 属于同一个集合，那么舍弃；</li>
<li>否则进行集合合并操作，并累积output</li>
</ul>
</li>
<li>返回output</li>
</ol>
<p><img src="https://pic.leetcode-cn.com/1611021826-GzvMAP-image.png"></p>
<h4 id="算法代码-1"><a href="#算法代码-1" class="headerlink" title="算法代码"></a>算法代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 同样以1584题为例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.father = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self , x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> self.father:</span><br><span class="line">            self.father[x] = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self , x</span>):</span></span><br><span class="line">        root = x</span><br><span class="line">        <span class="keyword">while</span> self.father[root]:</span><br><span class="line">            root = self.father[root]</span><br><span class="line">        <span class="keyword">while</span> x != root:</span><br><span class="line">            originalFather = self.father[x]</span><br><span class="line">            self.father[x] = root</span><br><span class="line">            x = originalFather</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isConnect</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.find(x)== self.find(y)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self , x ,y</span>):</span></span><br><span class="line">        rootX = self.find(x)</span><br><span class="line">        rootY = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> rootX != rootY:</span><br><span class="line">            self.father[rootX] = rootY</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostConnectPoints</span>(<span class="params">self, points: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">distance</span>(<span class="params">pointA , pointB</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(pointA[<span class="number">0</span>] - pointB[<span class="number">0</span>]) + <span class="built_in">abs</span>(pointA[<span class="number">1</span>] - pointB[<span class="number">1</span>])</span><br><span class="line">        length = <span class="built_in">len</span>(points)</span><br><span class="line">        <span class="comment"># 边排序</span></span><br><span class="line">        E = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span> , length):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span> , length):</span><br><span class="line">                dist = distance(points[i] , points[j])</span><br><span class="line">                E.append([dist,i,j])</span><br><span class="line">        E.sort(key = <span class="keyword">lambda</span> k : k[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 初始化并查集</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            self.add(i)</span><br><span class="line">        </span><br><span class="line">        output = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 从小到大寻找边，如果构成回路则跳过，否则加入</span></span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> E:</span><br><span class="line">            <span class="keyword">if</span> self.isConnect(e[<span class="number">1</span>] , e[<span class="number">2</span>]):</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                output += e[<span class="number">0</span>]</span><br><span class="line">                self.merge(e[<span class="number">1</span>],e[<span class="number">2</span>])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：$O(mlog(m) + m\alpha(m))$,m为索引对的数量</li>
<li>空间复杂度：$O(n^2)$</li>
</ul>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON Simple Research</title>
    <url>/2021/05/22/JSON-Simple-Research/</url>
    <content><![CDATA[<p>Source: <a href="https://www.w3school.com.cn/json/index.asp">w3c</a></p>
<a id="more"></a>

<h2 id="JSON是什么"><a href="#JSON是什么" class="headerlink" title="JSON是什么"></a>JSON是什么</h2><p>JSON是 JavaScript Object Notation,JS对象表示方法，是一种数据的标识格式，与XML类似，指的是数据内容。</p>
<h2 id="JSON特点"><a href="#JSON特点" class="headerlink" title="JSON特点"></a>JSON特点</h2><ul>
<li>JSON 是用来描述<strong>对象</strong>的一种语言，其标记性没有像XML那么重；</li>
<li>JSON 具有“自我描述性”（人类可读）；</li>
<li>JSON 具有层级结构（值中存在值）。</li>
</ul>
<h2 id="JSON与XML语言的主观差异"><a href="#JSON与XML语言的主观差异" class="headerlink" title="JSON与XML语言的主观差异"></a>JSON与XML语言的主观差异</h2><p>先看两个例子，有一个主观对比：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;sites&quot;</span>: [</span><br><span class="line">    &#123; <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;菜鸟教程&quot;</span> , <span class="attr">&quot;url&quot;</span>:<span class="string">&quot;www.runoob.com&quot;</span> &#125;, </span><br><span class="line">    &#123; <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;google&quot;</span> , <span class="attr">&quot;url&quot;</span>:<span class="string">&quot;www.google.com&quot;</span> &#125;, </span><br><span class="line">    &#123; <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;微博&quot;</span> , <span class="attr">&quot;url&quot;</span>:<span class="string">&quot;www.weibo.com&quot;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sites</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>菜鸟教程<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="tag">&lt;<span class="name">url</span>&gt;</span>www.runoob.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>google<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="tag">&lt;<span class="name">url</span>&gt;</span>www.google.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>微博<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="tag">&lt;<span class="name">url</span>&gt;</span>www.weibo.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sites</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>两种语言的创建目的不同，导致他们放在一起比较就不合适。<ul>
<li>JSON是面向JS<strong>对象</strong>的一种数据序列话描述语言，内容为主，格式其次；</li>
<li>XML是<strong>标记</strong>语言，以标签为基础，内容其次。<ul>
<li>能与XML进行比较HTML更加合适。<ul>
<li>HTML标签固定</li>
<li>XML标签自定义</li>
</ul>
</li>
<li>XML是一种明显的树形结构</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="JSON内两种数据"><a href="#JSON内两种数据" class="headerlink" title="JSON内两种数据"></a>JSON内两种数据</h2><ol>
<li>键值对：可表示对象、记录、字典、哈希表等</li>
<li>有序对：列表，向量，序列等</li>
</ol>
<p>这只是一种数据的理解方式，我也可以理解为三种数据：</p>
<ol>
<li>{} ： 对象</li>
<li>[] : 列表</li>
<li>标量</li>
</ol>
<h2 id="JSON语法规则"><a href="#JSON语法规则" class="headerlink" title="JSON语法规则"></a>JSON语法规则</h2><ul>
<li>数据使用键值对表示；</li>
<li>数据之间使用“，”分隔；</li>
<li>{}表示为对象</li>
<li>[]表示为数组</li>
</ul>
<h3 id="键值对的表示形式"><a href="#键值对的表示形式" class="headerlink" title="键值对的表示形式"></a>键值对的表示形式</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;firstName&quot; : &quot;John&quot;</span><br></pre></td></tr></table></figure>
<p>“字段名称” ： “值”</p>
<blockquote>
<p>注意 字段名称 采用了双引号</p>
</blockquote>
<h3 id="值的选择范围"><a href="#值的选择范围" class="headerlink" title="值的选择范围"></a>值的选择范围</h3><ul>
<li>数字(整数或者浮点数)</li>
<li>字符串（需要双引号）</li>
<li>布尔值（true/false）</li>
<li>数组 ([])</li>
<li>对象 ({})</li>
<li>null</li>
</ul>
<h3 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h3><p>JSON 对象在花括号中书写：</p>
<p>对象可以包含多个名称/值对：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">&quot;firstName&quot;</span>:<span class="string">&quot;John&quot;</span> , <span class="attr">&quot;lastName&quot;</span>:<span class="string">&quot;Doe&quot;</span> &#125;</span><br></pre></td></tr></table></figure>
<p>这一点也容易理解，与这条 JavaScript 语句等价：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">firstName = <span class="string">&quot;John&quot;</span></span><br><span class="line">lastName = <span class="string">&quot;Doe&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="JSON-数组"><a href="#JSON-数组" class="headerlink" title="JSON 数组"></a>JSON 数组</h3><p>JSON 数组在方括号中书写：</p>
<p>数组可包含多个对象：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;employees&quot;</span>: [</span><br><span class="line">&#123; <span class="attr">&quot;firstName&quot;</span>:<span class="string">&quot;John&quot;</span> , <span class="attr">&quot;lastName&quot;</span>:<span class="string">&quot;Doe&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="attr">&quot;firstName&quot;</span>:<span class="string">&quot;Anna&quot;</span> , <span class="attr">&quot;lastName&quot;</span>:<span class="string">&quot;Smith&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="attr">&quot;firstName&quot;</span>:<span class="string">&quot;Peter&quot;</span> , <span class="attr">&quot;lastName&quot;</span>:<span class="string">&quot;Jones&quot;</span> &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，对象 “employees” 是包含三个对象的数组。每个对象代表一条关于某人（有姓和名）的记录。</p>
]]></content>
  </entry>
  <entry>
    <title>滑动窗口算法</title>
    <url>/2021/01/24/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>滑动窗口是双指针的技巧之一。滑动窗口技巧一般用于解决子字符串问题。</p>
<a id="more"></a>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/hua-dong-chuang-kou-tong-yong-si-xiang-jie-jue-zi-/">参考地址</a> ， 我个人是在刷LEETCODE438题时，采用了此框架，具体代码可以看这道题目的解析文档。</p>
</blockquote>
<h2 id="滑动窗口框架"><a href="#滑动窗口框架" class="headerlink" title="滑动窗口框架"></a>滑动窗口框架</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在此框架中，几个注意点：</p>
<ol>
<li><p>Need哈希表用于记录目标子字符串中，对应的字母与出现的频次，这代表了你的滑动窗口<strong>应当满足的最低要求</strong>。</p>
<blockquote>
<p>哈希表的应用使得对目标字符串不限于顺序，而且保留了频次。在诸多题目中，均不限于顺序。</p>
</blockquote>
</li>
<li><p>Windows哈希表用于记录<strong>当前滑动窗口</strong>内<strong>目标字符串</strong>出现的字母与频次。</p>
<blockquote>
<p>在形式上与Need哈希表的形式是一摸一样的，但这里是记录的当前滑动窗口内符合条件的字母与频次，这代表Windows既可以不满足，也可以过满足。</p>
</blockquote>
</li>
<li><p>right指针作为迭代下标</p>
</li>
<li><p>窗口扩大与窗口缩小的内部逻辑是对应的</p>
</li>
</ol>
<h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><blockquote>
<p>这里直接摘抄</p>
</blockquote>
<p>滑动窗口算法的思路是这样：</p>
<p>1、我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引左闭右开区间 [left, right) 称为一个「窗口」。</p>
<p>2、我们先不断地增加 right 指针扩大窗口 [left, right)，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。</p>
<p>3、此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right)，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。</p>
<p>4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。</p>
<p>这个思路其实也不难，<strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，</strong>也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。</p>
<p>下面画图理解一下，needs 和 window 相当于计数器，分别记录 T 中字符出现次数和「窗口」中的相应字符的出现次数。</p>
<p>初始状态：</p>
<p><img src="https://pic.leetcode-cn.com/499fb00764379df32e1dbfc29d90230d9fc7df0a1cd5c1855b0bafeb867ccfc7.png"></p>
<p>增加 right，直到窗口 [left, right] 包含了 T 中所有字符：</p>
<p><img src="https://pic.leetcode-cn.com/5389a9b4db5ebaa796fbf1ddba1724469e00ad9fc27b45688ea55eb8f581a98b.png"></p>
<p>现在开始增加 left，缩小窗口 [left, right]。</p>
<p><img src="https://pic.leetcode-cn.com/222cb6badc76bf37e91b012e338b36cbf3b698afd986ebfa94297d900b22e29c.png"></p>
<p>直到窗口中的字符串不再符合要求，left 不再继续移动。</p>
<p><img src="https://pic.leetcode-cn.com/de0164765478570d749d94db184333e3e8cff8c0632b02505f93d7bc6e973ff5.png"></p>
<p>之后重复上述过程，先移动 right，再移动 left…… 直到 right 指针到达字符串 S 的末端，算法结束。</p>
<p>现在开始套模板，只需要思考以下四个问题：</p>
<p>1、当移动 right 扩大窗口，即加入字符时，应该更新哪些数据？</p>
<blockquote>
<p>如果一个字符进入窗口，应该增加 window 计数器；</p>
</blockquote>
<p>2、什么条件下，窗口应该暂停扩大，开始移动 left 缩小窗口？</p>
<blockquote>
<p>当 valid 满足 need 时应该收缩窗口；</p>
</blockquote>
<p>3、当移动 left 缩小窗口，即移出字符时，应该更新哪些数据？</p>
<blockquote>
<p>如果一个字符将移出窗口的时候，应该减少 window 计数器</p>
</blockquote>
<p>4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？</p>
<blockquote>
<p>应该在收缩窗口的时候更新最终结果。</p>
</blockquote>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON&amp;XML&amp;YAML</title>
    <url>/2021/05/22/JSON-XML-YAML/</url>
    <content><![CDATA[<p>常见的信息标注方式有三种，分别是XML、JSON、YAML。HTML是XML的变种，也属于XML格式。下面简单的介绍比较三种信息标注方式。</p>
<a id="more"></a>

<h2 id="直入主题：三种语言简介"><a href="#直入主题：三种语言简介" class="headerlink" title="直入主题：三种语言简介"></a>直入主题：三种语言简介</h2><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><ul>
<li>XML：eXtensible Markup Language , 其构成单位是Tag标签，且标签内包含有名称属性等信息如图：</li>
</ul>
<p><img src="https://i.loli.net/2021/05/20/bXyZ1qtGU39arlQ.png"></p>
<p>​    其中空元素可通过一个&lt;&gt;表示 , 注释通过<!-- --> 表示</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#XML空元素表示</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;china.jpg&quot;</span> <span class="attr">size</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">#XML注释格式</span><br><span class="line"><span class="comment">&lt;!-- This is a comment --&gt;</span></span><br></pre></td></tr></table></figure>
<p>总结：XML格式共包含三种样式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><ul>
<li>JSON：JavaScript Object Notation , <strong>有类型</strong>的键值对表示方式</li>
</ul>
<p><img src="https://i.loli.net/2021/05/20/8gLIM2UmhzpDw4R.png"></p>
<p>总结：JSON格式包含三种样式</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#普通键值对表示</span><br><span class="line">&quot;key&quot; : &quot;Value&quot;</span><br><span class="line">#多值键值对表示</span><br><span class="line">&quot;key&quot; : [&quot;Value1&quot;,&quot;Value2&quot;]</span><br><span class="line">#键值对嵌套表示</span><br><span class="line">&quot;key&quot; : &#123;&quot;subkey&quot; : &quot;subvalue&quot;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h3><ul>
<li>YAML：Ain’t Markup Language ， 无类型键值对</li>
</ul>
<p><img src="https://i.loli.net/2021/05/20/CPzjUJMYg7dh8Gi.png"></p>
<p>  其表示各种关系情况：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#缩进表示所属关系，同Python</span></span><br><span class="line"><span class="attr">name:</span></span><br><span class="line">	<span class="attr">newName :</span> <span class="string">北京理工</span></span><br><span class="line">	<span class="attr">OldName :</span> <span class="string">延安自然科学院</span></span><br><span class="line"><span class="comment"># “-” 表达并列关系</span></span><br><span class="line"><span class="attr">name:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">北京理工大学</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">延安自然科学院</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># “|”表达整块数据</span></span><br><span class="line"><span class="attr">text:</span> <span class="string">|</span></span><br><span class="line"><span class="string">北京理工大学创立与......</span></span><br></pre></td></tr></table></figure>
<p>总结:三种表示形式如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">key :</span> <span class="string">value</span></span><br><span class="line"></span><br><span class="line"><span class="attr">key :</span> <span class="comment">#comment</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">value1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">value2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">key:</span></span><br><span class="line">	<span class="attr">subkey :</span> <span class="string">value</span> </span><br><span class="line">		</span><br></pre></td></tr></table></figure>
<h3 id="实例比较"><a href="#实例比较" class="headerlink" title="实例比较"></a>实例比较</h3><p>XML：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">firstName</span>&gt;</span>Tian<span class="tag">&lt;/<span class="name">firstName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lastName</span>&gt;</span>Song<span class="tag">&lt;/<span class="name">lastName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">streetAddr</span>&gt;</span>中关村南大街5号<span class="tag">&lt;/<span class="name">streetAddr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">city</span>&gt;</span>北京市<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">zipcode</span>&gt;</span>100081<span class="tag">&lt;/<span class="name">zipcode</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prof</span>&gt;</span>ComputerSystem<span class="tag">&lt;/<span class="name">prof</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prof</span>&gt;</span>Security<span class="tag">&lt;/<span class="name">prof</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--最早的通用标记语言，可扩展性好，但很繁琐 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用于INTERNET 信息交互与传递 --&gt;</span></span><br></pre></td></tr></table></figure>
<p>JSON:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    “firstName”: “Tian”,</span><br><span class="line">    “lastName”: “Song”,</span><br><span class="line">    “address”:&#123;“streetAddr”: “中关村南大街5号” ,</span><br><span class="line">               “city”: “北京市” ,</span><br><span class="line">               “zipcode”: “100081”&#125;,</span><br><span class="line">    “prof”:[“ComputerSystem”, “Security”]</span><br><span class="line">&#125;</span><br><span class="line">#信息有类型，适合程序处理，比XML简洁</span><br><span class="line">#用于移动英语云端与节点信息通信，无注释</span><br></pre></td></tr></table></figure>
<p>YAML:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">firstName:</span> <span class="string">Tian</span></span><br><span class="line"><span class="attr">lastName:</span> <span class="string">Song</span></span><br><span class="line"><span class="attr">address:</span></span><br><span class="line">	<span class="string">streetAddr:中关村南大街5号</span></span><br><span class="line">	<span class="string">city:北京市</span></span><br><span class="line">	<span class="attr">zipcode:</span> <span class="number">100081</span></span><br><span class="line"><span class="attr">prof:</span></span><br><span class="line"><span class="string">‐Computer</span> <span class="string">System</span></span><br><span class="line"><span class="string">‐Security</span></span><br><span class="line"><span class="comment"># 信息无类型，文本信息比例最高，可读性好</span></span><br><span class="line"><span class="comment"># 常用于各类系统配置文件，有注释易读</span></span><br></pre></td></tr></table></figure>
<h2 id="XML-JSON-YAML-对比分析"><a href="#XML-JSON-YAML-对比分析" class="headerlink" title="XML,JSON,YAML 对比分析"></a>XML,JSON,YAML 对比分析</h2><p>XML,JSON,YAML是在编程过程中常见的<strong>数据交互语言（inter-change Language）</strong>,常用于配置文件与数据传输。</p>
<p>数据交互语言也是我最近才看到的一种定义，那么其用户不外乎就是两种：机器（Python,Java,etc）与人(Developer)。根据语言的用处不同，自然要求也不一样，如下所示：</p>
<ul>
<li>配置文件时：<ul>
<li>用户：人与机器</li>
<li>要求：首要人能编写与阅读，其次机器能阅读</li>
</ul>
</li>
<li>数据传输时：<ul>
<li>用户：机器与机器</li>
<li>要求：首要机器能阅读，其次人也要阅读</li>
</ul>
</li>
</ul>
<p>常见的语言要求如下：</p>
<ul>
<li>便于人类阅读理解；</li>
<li>具有强大的表达能力，除了键值对外还能支持数组、引用等表达方式；能表达层级关系</li>
<li>便于书写，包括纯手打和使用IDE</li>
<li>存储空间小</li>
<li>…</li>
</ul>
<p>但上面提到的性质很多时刻是冲突的，例如要表达复杂的数据对象，就需要更多的语言规范，可阅读性会下降，存储空间往往会增大。这也就造成了在面向不同的要求时，大家构造出多种数据交互语言。下面这些是我在查询三者之间关系时看到的不同见解，特整理如下：</p>
<h3 id="主观感受方面"><a href="#主观感受方面" class="headerlink" title="主观感受方面"></a>主观感受方面</h3><p><a href="https://dhpo.github.io/2018/02/03/%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-XML-JSON-INI%E4%B8%8EYAML/">参考博客</a></p>
<p>上面参考博客中，作者将三种语言进行了很简单的主观对比，虽然没有很细致，但是我认为主干抓到啦，而且很明显不是那种顾左右而言它的缝合怪，需要向其学习。我简单的将自己的感想与其内容进行总结如下：</p>
<p>XML,JSON,YAML均是<strong>数据交互语言（Inter-change Language）</strong>,那么表示<strong>数据表示</strong>便是首要特点。<strong>数据表示</strong>可以笼统的分为两部分：</p>
<ol>
<li><strong>映射</strong>表示：Key-value或者说Mapping</li>
<li><strong>层次</strong>表示：层级关系或者说嵌套</li>
</ol>
<p>通常来说，能够准确表示<strong>映射</strong>关系与<strong>层次</strong>关系，就能够准确的描述数据的基本结构，这与编程语言中类的定义非常类似，只是没有方法罢了。从这个角度分析XML,JSON,YAML均能够做到，只是各有优缺点。那么我们可以从映射与层次两方面对三种数据语言进行简单分析；</p>
<h4 id="XML-1"><a href="#XML-1" class="headerlink" title="XML"></a>XML</h4><h5 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">firstName</span>&gt;</span>Tian<span class="tag">&lt;/<span class="name">firstName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lastName</span>&gt;</span>Song<span class="tag">&lt;/<span class="name">lastName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">streetAddr</span>&gt;</span>中关村南大街5号<span class="tag">&lt;/<span class="name">streetAddr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">city</span>&gt;</span>北京市<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">zipcode</span>&gt;</span>100081<span class="tag">&lt;/<span class="name">zipcode</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prof</span>&gt;</span>ComputerSystem<span class="tag">&lt;/<span class="name">prof</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prof</span>&gt;</span>Security<span class="tag">&lt;/<span class="name">prof</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--最早的通用标记语言，可扩展性好，但很繁琐 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用于INTERNET 信息交互与传递 --&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析:"></a>简单分析:</h5><p>在XML中，key-value通过<code> &lt;key&gt; value &lt;\key&gt;</code>表示，在XML中通常将<code>&lt;key&gt;</code>称为Tag，每个Tag都有对应的tag将其闭合。tag之间可以嵌套。XML的注释需要写在<code>&lt;!--</code>和<code>--&gt;</code>中，可以是多行的。</p>
<p>在上面的示例中，标签<code>&lt;person&gt;</code>的嵌套有<code>&lt;firstName&gt; &lt;lastName&gt; &lt;address&gt; &lt;prof&gt;</code>标签，层层嵌套形成了一种树状结构。在<code>value</code>中的内容通常称为data，<code>&lt;key&gt;</code>中可以添加<code>attribute</code>，称为metaData,用以标识数据的特性而不是数据内容。<code>value 与 attribute</code>的取舍问题，需要编程人员自行顶多，我在详解XML的文档中有表述。</p>
<p><strong>优点：</strong></p>
<ol>
<li>注重标记，典型树形结构；</li>
<li>以Tag为基础构造，理解简单；</li>
<li>可以注释。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>key重复，造成数据冗余，例如<code>&lt;prof&gt;</code>；</li>
<li>没有数据结构符号。</li>
</ol>
<h4 id="JSON-1"><a href="#JSON-1" class="headerlink" title="JSON"></a>JSON</h4><h5 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    “firstName”: “Tian”,</span><br><span class="line">    “lastName”: “Song”,</span><br><span class="line">    “address”:&#123;“streetAddr”: “中关村南大街5号” ,</span><br><span class="line">               “city”: “北京市” ,</span><br><span class="line">               “zipcode”: “100081”&#125;,</span><br><span class="line">    “prof”:[“ComputerSystem”, “Security”]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="简单分析："><a href="#简单分析：" class="headerlink" title="简单分析："></a>简单分析：</h5><p>在JSON中，<code>key-value</code>用过键值对<code>&quot;key&quot;:value</code>进行标识。而<code>value</code>可以是单纯的标量，也可以对象（<code>&#123;&#125;</code>）或数组（<code>[]</code>）等以此构成了层次关系，常用作<strong>数据传输</strong>，在JSON中存在两种数据结构：</p>
<ul>
<li>对象：<code>&#123;&#125;</code>标识，可表示复杂的数据结构、字典、集合等等</li>
<li>数组：<code>[]</code>标识，可表示序列（列表、数组）等</li>
</ul>
<p>但是JSON中不存在注释，减少了不必要的数据传输。</p>
<p><strong>优点：</strong></p>
<ol>
<li>数据简洁，相比XML；</li>
<li>存在数据结构；</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>没有注释，增加人的阅读难度；</li>
</ol>
<h4 id="YAML-1"><a href="#YAML-1" class="headerlink" title="YAML"></a>YAML</h4><h5 id="例子：-2"><a href="#例子：-2" class="headerlink" title="例子："></a>例子：</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">firstName:</span> <span class="string">Tian</span></span><br><span class="line"><span class="attr">lastName:</span> <span class="string">Song</span></span><br><span class="line"><span class="attr">address:</span></span><br><span class="line">	<span class="string">streetAddr:中关村南大街5号</span></span><br><span class="line">	<span class="string">city:北京市</span></span><br><span class="line">	<span class="attr">zipcode:</span> <span class="number">100081</span></span><br><span class="line"><span class="attr">prof:</span></span><br><span class="line"><span class="string">‐Computer</span> <span class="string">System</span></span><br><span class="line"><span class="string">‐Security</span></span><br><span class="line"><span class="comment"># 信息无类型，文本信息比例最高，可读性好</span></span><br><span class="line"><span class="comment"># 常用于各类系统配置文件，有注释易读</span></span><br></pre></td></tr></table></figure>
<h5 id="简单分析：-1"><a href="#简单分析：-1" class="headerlink" title="简单分析："></a>简单分析：</h5><p>YAML中<code>key-value</code>通过 <code>key:value</code>标识，通过 <code>缩进</code> 标识层级关系，常用作<strong>配置文件</strong>。</p>
<p>其特点在于，<code>key,value</code>均可以直接表示，不用像JSON那样通过双引号标识，当然你要限定使用双引号（强制类型转换）也是可以的，这一点与<code>Python</code>风格一致。存在两种数据结构，与JSON一样：</p>
<ul>
<li>对象：<code>key-value</code> 标识</li>
<li>数组：<code>-</code> 标识</li>
</ul>
<p>注释通过 <code>#</code> 标识，但是不允许多行注释存在。</p>
<p><strong>优点：</strong></p>
<ol>
<li>数据表示简洁；</li>
<li>相较于JSON，可读性更好，但也差不多；</li>
<li>存在注释(JSON)；</li>
<li>存在数据结构(XML)；</li>
<li>存在引用机制(JSON,XML)</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>缩进控制层次不方便；</li>
<li>没有多行注释(XML).</li>
</ol>
<blockquote>
<p>YAML可以说是JSON的加强版，主要体现在加入了注释和引用机制，同时省去了让人眼花的方括号和花括号。使用缩进而不是括号表达层级关系可以让我们能用肉眼看出层级关系，而不需要使用编辑器或是IDE寻找配对的括号，同时省去了不必要的空行，提高了可读性。YAML与JSON相比在加强了表达能力的同时提高了可读性，可以说是在复杂项目中最佳的配置语言了。</p>
</blockquote>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>三种<strong>数据交互语言（Inter-change Language）</strong>,因其历史局限性或者应用不同，各有其特点，但也都是一种数据的表示方式罢了，从<code>key-value</code>,<code>Mapping</code>两个角度分析看，可以迅速掌握其差异点，有利于更好的理解语言特点。对于细节差异，并不需要一一对比分析，浪费时间也没必要。</p>
<h3 id="脉络方面"><a href="#脉络方面" class="headerlink" title="脉络方面"></a>脉络方面</h3><p><a href="https://linux.cn/article-10664-1.html">参考博客</a></p>
<p>作者以历史为脉络整理了，各语言的特点与差异，可作为一种知识补充。</p>
<h3 id="数据维度方面"><a href="#数据维度方面" class="headerlink" title="数据维度方面"></a>数据维度方面</h3><p><a href="https://kyakya.icu/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-ini-yaml-toml-json-xml%E7%AD%89%E6%AF%94%E8%BE%83">参考博客</a></p>
<p>作者提到的数据维度是很有意思的角度，时间所限不一一整理啦。</p>
]]></content>
  </entry>
  <entry>
    <title>XML Simple Research</title>
    <url>/2021/05/22/XML-Simple-Research/</url>
    <content><![CDATA[<p><strong>Source</strong>: <a href="https://www.w3school.com.cn/xml/index.asp">w3c</a></p>
<a id="more"></a>

<h2 id="XML定义"><a href="#XML定义" class="headerlink" title="XML定义"></a>XML定义</h2><p>xml就是一种<strong>数据的存储</strong>格式。</p>
<ul>
<li>XML 指可扩展标记语言（e<em>X</em>tensible <em>M</em>arkup <em>L</em>anguage）</li>
<li>XML 是一种<em>标记语言</em>，很类似 HTML</li>
<li>XML 的设计宗旨是<em>传输数据</em>，而非显示数据</li>
<li>XML 标签没有被预定义。您需要<em>自行定义标签</em>。</li>
<li>XML 被设计为具有<em>自我描述性</em>。</li>
<li>XML 是 <em>W3C 的推荐标准</em></li>
</ul>
<h2 id="XML的用处"><a href="#XML的用处" class="headerlink" title="XML的用处"></a>XML的用处</h2><p>用于 <strong>结构化，存储及传输</strong>数据，所以XML就是一种<strong>序列化数据表现形式</strong>，也可以认为就是数据<strong>内容</strong>，XML就是纯文本也是对的。</p>
<h2 id="XML是一种树结构"><a href="#XML是一种树结构" class="headerlink" title="XML是一种树结构"></a>XML是一种树结构</h2><p>XML文件与HTML文件结构很相似，都是利用tag进行标识的，也都是<strong>树形结构</strong>。</p>
<p><strong>XML实例：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的xml构成可以分为两层的树结构：<br><strong>根元素</strong>：描述整篇文档</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>子元素</strong>：描述根的几个子元素(（to, from, heading 以及 body）)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>根元素结尾：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从树的结构出发我们不难得出：</p>
<ol>
<li>所有元素均可以拥有子元素</li>
<li>相同层级的元素可以称为兄弟姐妹</li>
<li>元素拥有属性与文本；</li>
</ol>
<p><strong>实例：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;COOKING&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Everyday Italian<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>Giada De Laurentiis<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>30.00<span class="tag">&lt;/<span class="name">price</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;CHILDREN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;WEB&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>Erik T. Ray<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2003<span class="tag">&lt;/<span class="name">year</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>39.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>结构示意图：</strong>一本书的结构</p>
<p><img src="https://www.w3school.com.cn/i/ct_nodetree1.gif"></p>
<h2 id="XML语法格式"><a href="#XML语法格式" class="headerlink" title="XML语法格式"></a>XML语法格式</h2><p><a href="https://www.w3school.com.cn/xml/xml_syntax.asp">不赘述</a></p>
<h2 id="XML元素包括什么"><a href="#XML元素包括什么" class="headerlink" title="XML元素包括什么"></a>XML元素包括什么</h2><ol>
<li>内容：文本内容或元素内容</li>
<li>属性</li>
</ol>
<p><strong>实例：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;CHILDREN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;WEB&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>Erik T. Ray<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2003<span class="tag">&lt;/<span class="name">year</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>39.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到上面的例子中：bookstore 与 book 元素仅包含有元素内容，而 title等元素仅包含有文本内容； book 元素具备有属性。</p>
<blockquote>
<p>我尚没有见到过元素内容与文本内容兼备的元素</p>
</blockquote>
</blockquote>
<p><strong>疑问点？</strong></p>
<p>属性与子元素到底有什么差别呢？或者说什么时候用属性比较合适，而什么时候用子元素比较合适？</p>
<p><strong>结论：</strong></p>
<p>尽可能的使用子元素，除非该内容用于标识数据的数据，而不是数据本身。</p>
<p><strong>同一数据的不同表示实例：</strong></p>
<ul>
<li>第一个例子中使用了 date 属性：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span> <span class="attr">date</span>=<span class="string">&quot;08/08/2008&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<ul>
<li>第二个例子中使用了 date 元素：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">date</span>&gt;</span>08/08/2008<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<ul>
<li>第三个例子中使用了扩展的 date 元素（这是我的最爱）：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">date</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">day</span>&gt;</span>08<span class="tag">&lt;/<span class="name">day</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">month</span>&gt;</span>08<span class="tag">&lt;/<span class="name">month</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2008<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>为什么尽可能避免使用属性？</strong></p>
<ol>
<li>属性没有层级结构，不能够标识多重值，元素可以；</li>
<li>属性无法描述为树形结构，元素可以；</li>
<li>属性无法动态扩展，不利于未来变化；</li>
<li>属性不好阅读。</li>
</ol>
<p><strong>不好的XML实例：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span> <span class="attr">day</span>=<span class="string">&quot;08&quot;</span> <span class="attr">month</span>=<span class="string">&quot;08&quot;</span> <span class="attr">year</span>=<span class="string">&quot;2008&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">to</span>=<span class="string">&quot;George&quot;</span> <span class="attr">from</span>=<span class="string">&quot;John&quot;</span> <span class="attr">heading</span>=<span class="string">&quot;Reminder&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">body</span>=<span class="string">&quot;Don&#x27;t forget the meeting!&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>YAML Simple Research</title>
    <url>/2021/05/22/YAML-Simple-Research/</url>
    <content><![CDATA[<p><strong>Source：</strong> <a href="https://yaml.org/spec/1.2/spec.html">official specification</a> ， <a href="https://www.w3schools.io/file/yaml-cheatsheet-syntax/">w3c</a></p>
<a id="more"></a>

<h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>YAML is the abbreviation of “YAML Ain’t Markup Language” . Different from XML(e<em>X</em>tensible <em>M</em>arkup <em>L</em>anguage) , YAML is a kind of <strong>data serialization language</strong> , not Markup Language.</p>
<ul>
<li><strong>Different from Markup Language and Data Serialization Language</strong><ul>
<li>Markup Language: Force on data layout<ul>
<li>eg: XML , HTML</li>
</ul>
</li>
<li>Data Serialization Language: Force on data content<ul>
<li>eg: YAML , JSON，<a href="https://www.w3schools.io/file/toml-introduction/">toml</a>,<a href="https://www.w3schools.io/file/ini-extension-introduction/">ini</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>AML was designed from the start to be useful and friendly to people working with data.</p>
</blockquote>
<h3 id="Importion-points"><a href="#Importion-points" class="headerlink" title="Importion points"></a>Importion points</h3><ul>
<li>It is case sensitive</li>
<li>file extension is .yaml</li>
<li>Tabs are not allowed</li>
</ul>
<h3 id="Two-parts-of-YAML"><a href="#Two-parts-of-YAML" class="headerlink" title="Two parts of YAML"></a>Two parts of YAML</h3><ol>
<li>structural information<ul>
<li>The advantage of YAML is the structural information compressed to the minimalism;</li>
</ul>
</li>
<li>data itself<ul>
<li>can’t not be compressed</li>
</ul>
</li>
</ol>
<blockquote>
<p>自我理解：任何形式的数据标识语言，YAML,XML,HTML,JSON等，都包含有这两部分：结构化信息与数据本身。像上面提到的数据标记语言与数据序列语言，就是对这两部分侧重不同，侧重与结构就是标记语言，侧重于内容就是序列语言。各种语言标识仅仅侧重点不同，一般都具备这两项功能，这也是理解XML,YAML,JSON等语言的切入点之一。</p>
</blockquote>
<h3 id="Language-Goals"><a href="#Language-Goals" class="headerlink" title="Language Goals"></a>Language Goals</h3><ol>
<li>YAML is easily readable by humans.</li>
<li>YAML data is portable between programming languages.</li>
<li>YAML matches the [native data structures](<a href="https://yaml.org/spec/1.2/spec.html#native">https://yaml.org/spec/1.2/spec.html#native</a> data structure//) of agile languages.</li>
<li>YAML has a consistent model to support generic tools.</li>
<li>YAML supports one-pass processing.</li>
<li>YAML is expressive and extensible.</li>
<li>YAML is easy to implement and use.</li>
</ol>
<h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><ul>
<li>Configuration files </li>
<li>Internet messaging  </li>
<li>Object persistence </li>
<li>Data auditing.</li>
</ul>
<h3 id="Relation-with-JSON"><a href="#Relation-with-JSON" class="headerlink" title="Relation with JSON"></a>Relation with JSON</h3><p><strong>YAML is the superSet of JSON</strong> , that means we can transfer ALL YAML file to JSON file ,Whereas no.</p>
<h2 id="Data-Structure-in-YAML"><a href="#Data-Structure-in-YAML" class="headerlink" title="Data Structure in YAML"></a>Data Structure in YAML</h2><p>In YAML, data structures can be adequately represented with three basic primitives (consist with python):</p>
<ul>
<li>mapping: hashes、dictionaries，etc<ul>
<li>Mapping use a colon and space(“: “) to mark each “key: value “pair.</li>
</ul>
</li>
<li>seqences: array、list , etc<ul>
<li>sequences indicate each item with a dash and space(“- “)</li>
</ul>
</li>
<li>scalars: string、number , etc<ul>
<li>basic element</li>
</ul>
</li>
<li>comments: begin with an octothorpe(also called a “hash”, “sharp”, “pound”, or “number sign” - [“**<code>#</code>**”](<a href="https://yaml.org/spec/1.2/spec.html##">https://yaml.org/spec/1.2/spec.html##</a> comment//)).<ul>
<li>not support multline comment</li>
</ul>
</li>
</ul>
<h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h2><h3 id="Collections-Scope"><a href="#Collections-Scope" class="headerlink" title="Collections Scope"></a>Collections Scope</h3><p>There are two ways to represent the scope of collection:</p>
<h4 id="1-indent"><a href="#1-indent" class="headerlink" title="1.indent"></a>1.indent</h4><blockquote>
<p>similar with python language, that the reason way YAML is minimalist data representation.</p>
</blockquote>
<p><strong>examples:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  Sequence of Scalars</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Mark</span> <span class="string">McGwire</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Sammy</span> <span class="string">Sosa</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Ken</span> <span class="string">Griffey</span></span><br><span class="line"><span class="comment">#  Mapping Scalars to Scalar</span></span><br><span class="line"><span class="attr">hr:</span>  <span class="number">65</span>    <span class="comment"># Home runs</span></span><br><span class="line"><span class="attr">avg:</span> <span class="number">0.278</span> <span class="comment"># Batting average</span></span><br><span class="line"><span class="attr">rbi:</span> <span class="number">147</span>   <span class="comment"># Runs Batted In</span></span><br><span class="line"><span class="comment"># Mapping Scalars to Sequences</span></span><br><span class="line"><span class="attr">american:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Boston</span> <span class="string">Red</span> <span class="string">Sox</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Detroit</span> <span class="string">Tigers</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">New</span> <span class="string">York</span> <span class="string">Yankees</span></span><br><span class="line"><span class="attr">national:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">New</span> <span class="string">York</span> <span class="string">Mets</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Chicago</span> <span class="string">Cubs</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Atlanta</span> <span class="string">Braves</span></span><br><span class="line"><span class="comment"># Sequence of Mappings  </span></span><br><span class="line"><span class="bullet">-</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Mark</span> <span class="string">McGwire</span></span><br><span class="line">  <span class="attr">hr:</span>   <span class="number">65</span></span><br><span class="line">  <span class="attr">avg:</span>  <span class="number">0.278</span></span><br><span class="line"><span class="bullet">-</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Sammy</span> <span class="string">Sosa</span></span><br><span class="line">  <span class="attr">hr:</span>   <span class="number">63</span></span><br><span class="line">  <span class="attr">avg:</span>  <span class="number">0.288</span></span><br></pre></td></tr></table></figure>
<h4 id="2-flow-style"><a href="#2-flow-style" class="headerlink" title="2. flow style"></a>2. flow style</h4><p>using explicit <a href="https://yaml.org/spec/1.2/spec.html#indicator//">indicators</a> rather than <a href="https://yaml.org/spec/1.2/spec.html#space/indentation/">indentation</a> to denote scope.</p>
<p>example:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The flow sequence is written as a comma separated list within square brackets.  </span></span><br><span class="line"><span class="bullet">-</span> [<span class="string">name</span>        , <span class="string">hr</span>, <span class="string">avg</span>  ]</span><br><span class="line"><span class="bullet">-</span> [<span class="string">Mark</span> <span class="string">McGwire</span>, <span class="number">65</span>, <span class="number">0.278</span>]</span><br><span class="line"><span class="bullet">-</span> [<span class="string">Sammy</span> <span class="string">Sosa</span>  , <span class="number">63</span>, <span class="number">0.288</span>]</span><br><span class="line"><span class="comment">#  flow mapping uses curly braces.</span></span><br><span class="line"><span class="attr">Mark McGwire:</span> &#123;<span class="attr">hr:</span> <span class="number">65</span>, <span class="attr">avg:</span> <span class="number">0.278</span>&#125;</span><br><span class="line"><span class="attr">Sammy Sosa:</span> &#123;</span><br><span class="line">    <span class="attr">hr:</span> <span class="number">63</span>,</span><br><span class="line">    <span class="attr">avg:</span> <span class="number">0.288</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h3><h4 id="document-start-and-end"><a href="#document-start-and-end" class="headerlink" title="document start and end"></a>document start and end</h4><ol>
<li><p>YAML use three dashes (“—“) to separate  <a href="https://yaml.org/spec/1.2/spec.html#directive//">directives</a> from <a href="https://yaml.org/spec/1.2/spec.html#document//">document</a> <a href="https://yaml.org/spec/1.2/spec.html#content//">content</a> :</p>
<p>for example : two documents in a stream , each with a leading comment</p>
</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ranking of 1998 home runs</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Mark</span> <span class="string">McGwire</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Sammy</span> <span class="string">Sosa</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Ken</span> <span class="string">Griffey</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Team ranking</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Chicago</span> <span class="string">Cubs</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">St</span> <span class="string">Louis</span> <span class="string">Cardinals</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>“—“ : start signal of document , “…” : end signal of document:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">time: 20:03:20</span><br><span class="line">player: Sammy Sosa</span><br><span class="line">action: strike (miss)</span><br><span class="line">...</span><br><span class="line">---</span><br><span class="line">time: 20:03:47</span><br><span class="line">player: Sammy Sosa</span><br><span class="line">action: grand slam</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="ref-in-YAML"><a href="#ref-in-YAML" class="headerlink" title="ref in YAML"></a>ref in YAML</h4><p>Repeated <a href="https://yaml.org/spec/1.2/spec.html#node//">nodes</a> (objects) are first <a href="https://yaml.org/spec/1.2/spec.html#alias/identified/">identified</a> by an <a href="https://yaml.org/spec/1.2/spec.html#anchor//">anchor</a> (marked with the ampersand - [“**<code>&amp;</code>**”](<a href="https://yaml.org/spec/1.2/spec.html#&amp;">https://yaml.org/spec/1.2/spec.html#&amp;</a> anchor//)), and are then <a href="https://yaml.org/spec/1.2/spec.html#alias//">aliased</a> (referenced with an asterisk - [“**<code>\*</code>**”](<a href="https://yaml.org/spec/1.2/spec.html#">https://yaml.org/spec/1.2/spec.html#</a>* alias//)) thereafter.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Single Document with Two Comments</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">hr:</span> <span class="comment"># 1998 hr ranking</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Mark</span> <span class="string">McGwire</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Sammy</span> <span class="string">Sosa</span></span><br><span class="line"><span class="attr">rbi:</span></span><br><span class="line">  <span class="comment"># 1998 rbi ranking</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Sammy</span> <span class="string">Sosa</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ken</span> <span class="string">Griffey</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#  Node for “Sammy Sosa” appears twice in this document</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">hr:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Mark</span> <span class="string">McGwire</span></span><br><span class="line">  <span class="comment"># Following node labeled SS</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&amp;SS</span> <span class="string">Sammy</span> <span class="string">Sosa</span></span><br><span class="line"><span class="attr">rbi:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">*SS</span> <span class="comment"># Subsequent occurrence</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ken</span> <span class="string">Griffey</span></span><br></pre></td></tr></table></figure>
<h3 id="complex-mapping-key"><a href="#complex-mapping-key" class="headerlink" title="complex mapping key"></a>complex mapping key</h3><p>A question mark and space ([“**<code>? </code>**”](<a href="https://yaml.org/spec/1.2/spec.html#">https://yaml.org/spec/1.2/spec.html#</a>? mapping key//)) indicate a complex <a href="https://yaml.org/spec/1.2/spec.html#mapping//">mapping</a> <a href="https://yaml.org/spec/1.2/spec.html#key//">key</a>. Within a <a href="https://yaml.org/spec/1.2/spec.html#style/block/collection">block collection</a>, [key: value pairs](<a href="https://yaml.org/spec/1.2/spec.html#key">https://yaml.org/spec/1.2/spec.html#key</a>: value pair//) can start immediately following the [dash](<a href="https://yaml.org/spec/1.2/spec.html#-">https://yaml.org/spec/1.2/spec.html#-</a> block sequence entry//), [colon](<a href="https://yaml.org/spec/1.2/spec.html#">https://yaml.org/spec/1.2/spec.html#</a>: mapping value//), or [question mark](<a href="https://yaml.org/spec/1.2/spec.html#">https://yaml.org/spec/1.2/spec.html#</a>? mapping key//).</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Mapping between Sequences</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">?</span> <span class="bullet">-</span> <span class="string">Detroit</span> <span class="string">Tigers</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Chicago</span> <span class="string">cubs</span></span><br><span class="line"><span class="string">:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">2001-07-23</span></span><br><span class="line"></span><br><span class="line"><span class="string">?</span> [ <span class="string">New</span> <span class="string">York</span> <span class="string">Yankees</span>,</span><br><span class="line">    <span class="string">Atlanta</span> <span class="string">Braves</span> ]</span><br><span class="line"><span class="string">:</span> [ <span class="number">2001-07-02</span>, <span class="number">2001-08-12</span>,</span><br><span class="line">    <span class="number">2001-08-14</span> ]</span><br><span class="line"><span class="comment"># Compact Nested Mapping    </span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># Products purchased</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">item    :</span> <span class="string">Super</span> <span class="string">Hoop</span></span><br><span class="line">  <span class="attr">quantity:</span> <span class="number">1</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">item    :</span> <span class="string">Basketball</span></span><br><span class="line">  <span class="attr">quantity:</span> <span class="number">4</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">item    :</span> <span class="string">Big</span> <span class="string">Shoes</span></span><br><span class="line">  <span class="attr">quantity:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="Scalar"><a href="#Scalar" class="headerlink" title="Scalar"></a>Scalar</h3><h4 id="scalar-with-block-notation"><a href="#scalar-with-block-notation" class="headerlink" title="scalar with block notation"></a>scalar with block notation</h4><p><a href="https://www.jianshu.com/p/d439a82ca7f8">More Details</a> shown in this blog.</p>
<h5 id="literial-Style"><a href="#literial-Style" class="headerlink" title="literial Style"></a>literial Style</h5><p>using denotation(“|”) , all the  line breaks are significant;</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># In literial style , all the newlines are preserved</span></span><br><span class="line"><span class="string">---</span> <span class="string">|</span></span><br><span class="line">  <span class="string">\//||\/||</span></span><br><span class="line">  <span class="string">//</span> <span class="string">||</span>  <span class="string">||__</span></span><br></pre></td></tr></table></figure>
<h5 id="folded-Style"><a href="#folded-Style" class="headerlink" title="folded Style"></a>folded Style</h5><p>Alternatively , they can be written with the folded style (denoted with “&gt;”),each line break is folded to a space unless it ends an empty or a more indented line.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  In the folded scalars,  newlines become spaces</span></span><br><span class="line"><span class="string">---</span> <span class="string">&gt;</span></span><br><span class="line">  <span class="string">Mark</span> <span class="string">McGwire&#x27;s</span></span><br><span class="line">  <span class="string">year</span> <span class="string">was</span> <span class="string">crippled</span></span><br><span class="line">  <span class="string">by</span> <span class="string">a</span> <span class="string">knee</span> <span class="string">injury.</span></span><br><span class="line"><span class="comment"># Folded newlines are preserved for &quot;more indented&quot; and blank lines</span></span><br><span class="line"></span><br><span class="line"><span class="string">Example</span> <span class="number">2.14</span><span class="string">.</span>  <span class="string">In</span> <span class="string">the</span> <span class="string">folded</span> <span class="string">scalars,</span></span><br><span class="line"><span class="string">newlines</span> <span class="string">become</span> <span class="string">spaces</span></span><br><span class="line"></span><br><span class="line"><span class="string">---</span> <span class="string">&gt;</span></span><br><span class="line">  <span class="string">Mark</span> <span class="string">McGwire&#x27;s</span></span><br><span class="line">  <span class="string">year</span> <span class="string">was</span> <span class="string">crippled</span></span><br><span class="line">  <span class="string">by</span> <span class="string">a</span> <span class="string">knee</span> <span class="string">injury.</span></span><br><span class="line"></span><br><span class="line"><span class="string">Example</span> <span class="number">2.15</span><span class="string">.</span>  <span class="string">Folded</span> <span class="string">newlines</span> <span class="string">are</span> <span class="string">preserved</span></span><br><span class="line"><span class="string">for</span> <span class="string">&quot;more indented&quot;</span> <span class="string">and</span> <span class="string">blank</span> <span class="string">lines</span></span><br><span class="line"></span><br><span class="line"><span class="string">---</span> <span class="string">&gt;</span></span><br><span class="line"> <span class="string">Sammy</span> <span class="string">Sosa</span> <span class="string">completed</span> <span class="string">another</span></span><br><span class="line"> <span class="string">fine</span> <span class="string">season</span> <span class="string">with</span> <span class="string">great</span> <span class="string">stats.</span></span><br><span class="line"></span><br><span class="line">   <span class="number">63</span> <span class="string">Home</span> <span class="string">Runs</span></span><br><span class="line">   <span class="number">0.288</span> <span class="string">Batting</span> <span class="string">Average</span></span><br><span class="line"></span><br><span class="line"> <span class="string">What</span> <span class="string">a</span> <span class="string">year!</span></span><br></pre></td></tr></table></figure>
<h4 id="flow-scalars"><a href="#flow-scalars" class="headerlink" title="flow scalars"></a>flow scalars</h4><p>There are three ways to express <strong>flow scalars</strong>: <br>1.Plain text 2. Double-quoted 3.Single Quoted<br>Features: All <a href="https://yaml.org/spec/1.2/spec.html#style/flow/scalar">flow scalars</a> can span multiple lines; [line breaks](<a href="https://yaml.org/spec/1.2/spec.html#line">https://yaml.org/spec/1.2/spec.html#line</a> break//) are always [folded](<a href="https://yaml.org/spec/1.2/spec.html#line">https://yaml.org/spec/1.2/spec.html#line</a> folding//).</p>
<h5 id="Plain-Text"><a href="#Plain-Text" class="headerlink" title="Plain Text"></a>Plain Text</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Multi-line Flow Scalars</span><br><span class="line">plain:</span><br><span class="line">  This unquoted scalar</span><br><span class="line">  spans many lines.</span><br><span class="line"></span><br><span class="line">quoted: &quot;So does this</span><br><span class="line">  quoted scalar.\n&quot;</span><br><span class="line">  </span><br><span class="line"># Aboved is the same as , from my understanding </span><br><span class="line">plain:   This unquoted scalar spans many lines.</span><br><span class="line"></span><br><span class="line">quoted: &quot;So does this quoted scalar.\n&quot;</span><br></pre></td></tr></table></figure>
<h5 id="Quoted-Scalars"><a href="#Quoted-Scalars" class="headerlink" title="Quoted Scalars"></a>Quoted Scalars</h5><p>The <a href="https://yaml.org/spec/1.2/spec.html#style/flow/double-quoted">double-quoted style</a> provides [escape sequences](<a href="https://yaml.org/spec/1.2/spec.html#escaping/in">https://yaml.org/spec/1.2/spec.html#escaping/in</a> double-quoted scalars/). The <a href="https://yaml.org/spec/1.2/spec.html#style/flow/">single-quoted style</a> is useful when [escaping](<a href="https://yaml.org/spec/1.2/spec.html#escaping/in">https://yaml.org/spec/1.2/spec.html#escaping/in</a> double-quoted scalars/) is not needed.</p>
<blockquote>
<p>双引号用于强制类型转换？？</p>
</blockquote>
<p>For examples:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Quoted Scalars</span></span><br><span class="line"><span class="attr">unicode:</span> <span class="string">&quot;Sosa did fine.\u263A&quot;</span></span><br><span class="line"><span class="attr">control:</span> <span class="string">&quot;\b1998\t1999\t2000\n&quot;</span></span><br><span class="line"><span class="attr">hex esc:</span> <span class="string">&quot;\x0d\x0a is \r\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">single:</span> <span class="string">&#x27;&quot;Howdy!&quot; he cried.&#x27;</span></span><br><span class="line"><span class="attr">quoted:</span> <span class="string">&#x27; # Not a &#x27;</span><span class="string">&#x27;comment&#x27;</span><span class="string">&#x27;.&#x27;</span></span><br><span class="line"><span class="attr">tie-fighter:</span> <span class="string">&#x27;|\-*-/|&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h3><p>In YAML, <a href="https://yaml.org/spec/1.2/spec.html#tag/non-specific/">untagged nodes</a> are given a type depending on the <a href="https://yaml.org/spec/1.2/spec.html#application//">application</a>. The examples in this specification generally use the <a href="https://yaml.org/spec/1.2/spec.html#tag/repository/seq"><strong><code>seq</code></strong></a>, <a href="https://yaml.org/spec/1.2/spec.html#tag/repository/map"><strong><code>map</code></strong></a> and <a href="https://yaml.org/spec/1.2/spec.html#tag/repository/str"><strong><code>str</code></strong></a> types from the <a href="https://yaml.org/spec/1.2/spec.html#schema/failsafe/">fail safe schema</a>. A few examples also use the <a href="https://yaml.org/spec/1.2/spec.html#tag/repository/int"><strong><code>int</code></strong></a>, <a href="https://yaml.org/spec/1.2/spec.html#tag/repository/float"><strong><code>float</code></strong></a>, and <a href="https://yaml.org/spec/1.2/spec.html#tag/repository/null"><strong><code>null</code></strong></a> types from the <a href="https://yaml.org/spec/1.2/spec.html#schema/JSON/">JSON schema</a>. The <a href="https://yaml.org/spec/1.2/spec.html#tag/repository/">repository</a> includes additional types such as <a href="https://yaml.org/type/binary.html"><strong><code>binary</code></strong></a>, <a href="https://yaml.org/type/omap.html"><strong><code>omap</code></strong></a>, <a href="https://yaml.org/type/set.html"><strong><code>set</code></strong></a> and others.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># integers</span><br><span class="line">canonical: 12345</span><br><span class="line">decimal: +12345</span><br><span class="line">octal: 0o14</span><br><span class="line">hexadecimal: 0xC</span><br><span class="line"></span><br><span class="line"># Floating points</span><br><span class="line">canonical: 1.23015e+3</span><br><span class="line">exponential: 12.3015e+02</span><br><span class="line">fixed: 1230.15</span><br><span class="line">negative infinity: -.inf</span><br><span class="line">not a number: .NaN</span><br><span class="line"></span><br><span class="line"># Miscellaneous</span><br><span class="line">null:</span><br><span class="line">booleans: [ true, false ]</span><br><span class="line">string: &#39;012345&#39;</span><br><span class="line"></span><br><span class="line"># Timestamps</span><br><span class="line">canonical: 2001-12-15T02:59:43.1Z</span><br><span class="line">iso8601: 2001-12-14t21:59:43.10-05:00</span><br><span class="line">spaced: 2001-12-14 21:59:43.10 -5</span><br><span class="line">date: 2002-12-14</span><br></pre></td></tr></table></figure>
<p>Explicit typing is denoted with a <a href="https://yaml.org/spec/1.2/spec.html#tag//">tag</a> using the exclamation point ([“**<code>!</code>**”](<a href="https://yaml.org/spec/1.2/spec.html#">https://yaml.org/spec/1.2/spec.html#</a>! tag indicator//)) symbol. <a href="https://yaml.org/spec/1.2/spec.html#tag/global/">Global tags</a> are URIs and may be specified in a <a href="https://yaml.org/spec/1.2/spec.html#tag/shorthand/">tag shorthand</a> notation using a <a href="https://yaml.org/spec/1.2/spec.html#tag/handle/">handle</a>. <a href="https://yaml.org/spec/1.2/spec.html#application//">Application</a>-specific <a href="https://yaml.org/spec/1.2/spec.html#tag/local/">local tags</a> may also be used.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  Various Explicit Tags</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">not-date:</span> <span class="type">!!str</span> <span class="number">2002-04-28</span></span><br><span class="line"></span><br><span class="line"><span class="attr">picture:</span> <span class="type">!!binary</span> <span class="string">|</span></span><br><span class="line"> <span class="string">R0lGODlhDAAMAIQAAP//9/X</span></span><br><span class="line"> <span class="string">17unp5WZmZgAAAOfn515eXv</span></span><br><span class="line"> <span class="string">Pz7Y6OjuDg4J+fn5OTk6enp</span></span><br><span class="line"> <span class="string">56enmleECcgggoBADs=</span></span><br><span class="line"></span><br><span class="line"><span class="attr">application specific tag:</span> <span class="type">!something</span> <span class="string">|</span></span><br><span class="line"> <span class="string">The</span> <span class="string">semantics</span> <span class="string">of</span> <span class="string">the</span> <span class="string">tag</span></span><br><span class="line"> <span class="string">above</span> <span class="string">may</span> <span class="string">be</span> <span class="string">different</span> <span class="string">for</span></span><br><span class="line"> <span class="string">different</span> <span class="string">documents.</span></span><br><span class="line"><span class="comment"># Glbal tags</span></span><br><span class="line"></span><br><span class="line"><span class="string">%TAG</span> <span class="string">!</span> <span class="string">tag:clarkevans.com,2002:</span></span><br><span class="line"><span class="string">---</span> <span class="type">!shape</span></span><br><span class="line">  <span class="comment"># Use the ! handle for presenting</span></span><br><span class="line">  <span class="comment"># tag:clarkevans.com,2002:circle</span></span><br><span class="line"><span class="bullet">-</span> <span class="type">!circle</span></span><br><span class="line">  <span class="attr">center:</span> <span class="string">&amp;ORIGIN</span> &#123;<span class="attr">x:</span> <span class="number">73</span>, <span class="attr">y:</span> <span class="number">129</span>&#125;</span><br><span class="line">  <span class="attr">radius:</span> <span class="number">7</span></span><br><span class="line"><span class="bullet">-</span> <span class="type">!line</span></span><br><span class="line">  <span class="attr">start:</span> <span class="meta">*ORIGIN</span></span><br><span class="line">  <span class="attr">finish:</span> &#123; <span class="attr">x:</span> <span class="number">89</span>, <span class="attr">y:</span> <span class="number">102</span> &#125;</span><br><span class="line"><span class="bullet">-</span> <span class="type">!label</span></span><br><span class="line">  <span class="attr">start:</span> <span class="meta">*ORIGIN</span></span><br><span class="line">  <span class="attr">color:</span> <span class="number">0xFFEEBB</span></span><br><span class="line">  <span class="attr">text:</span> <span class="string">Pretty</span> <span class="string">vector</span> <span class="string">drawing.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Unordered Sets</span></span><br><span class="line"><span class="comment"># Sets are represented as a</span></span><br><span class="line"><span class="comment"># Mapping where each key is</span></span><br><span class="line"><span class="comment"># associated with a null value</span></span><br><span class="line"><span class="string">---</span> <span class="type">!!set</span></span><br><span class="line"><span class="string">?</span> <span class="string">Mark</span> <span class="string">McGwire</span></span><br><span class="line"><span class="string">?</span> <span class="string">Sammy</span> <span class="string">Sosa</span></span><br><span class="line"><span class="string">?</span> <span class="string">Ken</span> <span class="string">Griff</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ordered Mappings</span></span><br><span class="line"><span class="comment"># Ordered maps are represented as</span></span><br><span class="line"><span class="comment"># A sequence of mappings, with</span></span><br><span class="line"><span class="comment"># each mapping having one key</span></span><br><span class="line"><span class="string">---</span> <span class="type">!!omap</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">Mark McGwire:</span> <span class="number">65</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">Sammy Sosa:</span> <span class="number">63</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">Ken Griffy:</span> <span class="number">58</span></span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>Python_协程</title>
    <url>/2021/01/17/Python-%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<p>协程本身的定义，与进程、线程其实差不多，都是用于<strong>控制过程的工具</strong>:</p>
<a id="more"></a>

<blockquote>
<p>[流畅的Python 16章](流畅的Python 16章)</p>
</blockquote>
<h2 id="协程的概念与简单示例"><a href="#协程的概念与简单示例" class="headerlink" title="协程的概念与简单示例"></a>协程的概念与简单示例</h2><p>协程本身的定义，与进程、线程其实差不多，都是用于<strong>控制过程的工具</strong>。协程的协字，我们可以理解为<strong>协作</strong>，协程通过与调用方协作，产出相应的结果。</p>
<p>协程能自然的表述多种算法，例如仿真、游戏、异步I/O等事件驱动型编程形式或协作多任务。</p>
<p><strong>协程：关键字 yield</strong> </p>
<p>上面的关键字，与生成器里面的yield，是一模一样的。其实协程就是一种生成器，只是在协程的概念里面，还存在自己独有的特性。两者还是存在一点点差异。下面给出两个例子：</p>
<p><strong>“生成器”的例子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_123</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">print(<span class="built_in">type</span>(gen_123))</span><br><span class="line"><span class="comment"># &lt;class &#x27;function&#x27;&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>(gen_123()))</span><br><span class="line"><span class="comment"># &lt;class &#x27;generator&#x27;&gt;</span></span><br><span class="line">g = gen_123()</span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<p><strong>协程的例子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用作协程的生成器样例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_coroutine</span>():</span></span><br><span class="line">    print(<span class="string">&quot;coroutine start&quot;</span>)</span><br><span class="line">    <span class="comment"># 注意注意：这里将yield 进行了赋值操作，就是将一个普通的生成器转换为了协程生成器</span></span><br><span class="line">    x = <span class="keyword">yield</span></span><br><span class="line">    print(<span class="string">&quot;coroutine received: &quot;</span> , x)</span><br><span class="line">    print(<span class="string">&quot;coroutine ended&quot;</span>)</span><br><span class="line"> </span><br><span class="line">my_coroutine = simple_coroutine()</span><br><span class="line">print(my_coroutine)</span><br><span class="line"><span class="comment"># &lt;generator object simple_coroutine at 0x042E3F30&gt;</span></span><br><span class="line"><span class="built_in">next</span>(my_coroutine)</span><br><span class="line"><span class="comment"># coroutine start</span></span><br><span class="line">my_coroutine.send(<span class="number">123</span>)</span><br><span class="line"><span class="comment"># coroutine ended</span></span><br><span class="line"><span class="comment"># python-BaseException</span></span><br><span class="line"> <span class="string">&quot;&quot;&quot;Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;D:\pycharm_install\PyCharm 2020.2.3\plugins\python\helpers\pydev\pydevd.py&quot;, line 1448, in _exec</span></span><br><span class="line"><span class="string">    pydev_imports.execfile(file, globals, locals)  # execute the script</span></span><br><span class="line"><span class="string"> &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>差异点：<ul>
<li>纯生成器：直接写明yield即可，不需要赋值</li>
<li>协程生成器：将yield通过赋值符号，赋值给内部的局部变量。这里实现了外部调用者动态键入值的功能。</li>
</ul>
</li>
</ul>
<h3 id="协程的状态"><a href="#协程的状态" class="headerlink" title="协程的状态"></a>协程的状态</h3><p>就像进程那样存在多种状态，协程也是包含有多种状态的，分别是：</p>
<p><strong>GEN_CREATED</strong>:等待开始执行</p>
<p><strong>GEN_RUNNING</strong>:解释器正在执行</p>
<p><strong>GEN_SUSPENDED</strong>:在yield表达式处暂停</p>
<p><strong>GEN_CLOSED</strong>: 执行结束</p>
<p>上面给出的例子中通过 send 方法将数据传递给协程内部变量，而<strong>send方法参数只能成为暂停的yield表达式的值</strong>，故当且仅当协程处于<strong>GEN_SUSPENDED</strong> 状态时，才能够调用send方法。这就需要对协程进行激活，也就是next方法。这也就是为什么上面的例子。</p>
<h3 id="协程语句的执行顺序"><a href="#协程语句的执行顺序" class="headerlink" title="协程语句的执行顺序"></a>协程语句的执行顺序</h3><ul>
<li>创建协程</li>
<li>激活协程</li>
<li>协程交互</li>
</ul>
<p>核心在于，yield 在协程中更能够发挥其功能，其功能可以分为两种：产出与接收。分别对应函数next , send.</p>
<p>比如一句话 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="keyword">yield</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>上面这句话，包含有两层含义：</p>
<ol>
<li>产出 5 .</li>
<li>接收一个值并赋值给x .</li>
</ol>
<p>其执行顺序为：先产出再接收。下面一个例子能够更好的解释：</p>
<p><strong>示例：产出两个值的协程</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_coro2</span>(<span class="params">a</span>):</span></span><br><span class="line">    print(<span class="string">&quot;Started: a = &quot;</span> , a)</span><br><span class="line">    b = <span class="keyword">yield</span> a</span><br><span class="line">    print(<span class="string">&quot;Received: b = &quot;</span> , b)</span><br><span class="line">    c = <span class="keyword">yield</span> a + b</span><br><span class="line">    print(<span class="string">&quot;Received: c = &quot;</span> , c)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>from test import simple_coro2</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>my_coro2 = simple_coro2(14)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>next(my_coro2)</span></span><br><span class="line"><span class="string">Started: a =  14</span></span><br><span class="line"><span class="string">14</span></span><br><span class="line"><span class="string"> 可以看到上面的一个next语句，将协程一直运行到第一个yield 产出值后的位置</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>my_coro2.send(28)</span></span><br><span class="line"><span class="string">Received: b =  28</span></span><br><span class="line"><span class="string">42</span></span><br><span class="line"><span class="string"> 可以看到一个send语句完成了对b的赋值与下一个yield语句产出值两个功能。</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>my_coro2.send(99)</span></span><br><span class="line"><span class="string">Received: c =  99</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="string">StopIteration</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>图示如下：</p>
<p><img src="https://i.loli.net/2021/01/17/5MQnL9GuHIE1T43.png" alt="image-20201110110022552"></p>
<h4 id="协程-实现平均数功能"><a href="#协程-实现平均数功能" class="headerlink" title="协程 实现平均数功能"></a>协程 实现平均数功能</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BEGIN CORO_AVERAGER</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span>():</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">      <span class="comment"># 下面的这一句话有两个含义：1.产出yield 2.接收一个值并赋给term</span></span><br><span class="line">        term = <span class="keyword">yield</span> average  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line"><span class="comment"># END CORO_AVERAGER</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">A coroutine to compute a running average</span></span><br><span class="line"><span class="string"># BEGIN CORO_AVERAGER_TEST</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; coro_avg = averager()  # &lt;1&gt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; next(coro_avg)  # &lt;2&gt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; coro_avg.send(10)  # &lt;3&gt;</span></span><br><span class="line"><span class="string">    10.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; coro_avg.send(30)</span></span><br><span class="line"><span class="string">    20.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; coro_avg.send(5)</span></span><br><span class="line"><span class="string">    15.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># END CORO_AVERAGER_TEST</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到代码与测试的数据，每次我们向协程发送一个值，其会传递出一个平均值，那么他的具体执行顺序是怎样的呢？</p>
<p><img src="C:\Users\QingZhi\AppData\Roaming\Typora\typora-user-images\image-20201110140817893.png" alt="image-20201110140817893"></p>
<ol>
<li>激活协程,next()，并将运行到产出第一个值的位置（此时处于GEN_SUSPENDED 状态 ）</li>
<li>协程交互,send(),首先将调用方数据进行赋值操作，其次一直运行到下一次yield产出值后(又处于GEN_SUSPENDED 状态)；</li>
</ol>
<h2 id="预激协程的装饰器"><a href="#预激协程的装饰器" class="headerlink" title="预激协程的装饰器"></a>预激协程的装饰器</h2><p>上面的例子均需要通过next()方法激活协程，但这一步是很容易遗忘的。而装饰器是一种能够对函数进行包装的设计模式，却不会影响你的使用过程。</p>
<blockquote>
<p>有关装饰器的使用与设计，在其他笔记中已有详细论述，这里直接贴代码。</p>
</blockquote>
<p><strong>装饰器定义：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Decorator: primes `func` by advancing to first `yield`&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">primer</span>(<span class="params">*args,**kwargs</span>):</span>  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">        gen = func(*args,**kwargs)  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">        <span class="built_in">next</span>(gen)  <span class="comment"># &lt;3&gt;</span></span><br><span class="line">        <span class="keyword">return</span> gen  <span class="comment"># &lt;4&gt;</span></span><br><span class="line">    <span class="keyword">return</span> primer</span><br></pre></td></tr></table></figure>
<p><strong>协程定义：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> coroutil <span class="keyword">import</span> coroutine  <span class="comment"># &lt;4&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine  </span><span class="comment"># &lt;5&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span>():</span>  <span class="comment"># &lt;6&gt;</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span> average</span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br></pre></td></tr></table></figure>
<p><strong>代码运行情况展示</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from coroaverager1 import averager</span><br><span class="line">&gt;&gt;&gt; ave = averager()</span><br><span class="line">&gt;&gt;&gt; ave.send(10)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line">&gt;&gt;&gt; ave.send(20)</span><br><span class="line"><span class="number">15.0</span></span><br><span class="line">&gt;&gt;&gt; ave.send(30)</span><br><span class="line"><span class="number">20.0</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>通过装饰器的作用，已经不需要显示的激活操作。</p>
<h2 id="终止协程与异常处理"><a href="#终止协程与异常处理" class="headerlink" title="终止协程与异常处理"></a>终止协程与异常处理</h2><h3 id="协程的终止"><a href="#协程的终止" class="headerlink" title="协程的终止"></a>协程的终止</h3><p>协程应该如何终止，这是一只没有考虑过的问题。下面的例子提供了协程终止实例：</p>
<h4 id="协程终止的样例"><a href="#协程终止的样例" class="headerlink" title="协程终止的样例"></a>协程终止的样例</h4><p><strong>1. 协程迭代结束：抛出 StopIteration 异常</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_coro2</span>(<span class="params">a</span>):</span></span><br><span class="line">    print(<span class="string">&quot;Started: a = &quot;</span> , a)</span><br><span class="line">    b = <span class="keyword">yield</span> a</span><br><span class="line">    print(<span class="string">&quot;Received: b = &quot;</span> , b)</span><br><span class="line">    c = <span class="keyword">yield</span> a + b</span><br><span class="line">    print(<span class="string">&quot;Received: c = &quot;</span> , c)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>from test import simple_coro2</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>my_coro2 = simple_coro2(14)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>next(my_coro2)</span></span><br><span class="line"><span class="string">Started: a =  14</span></span><br><span class="line"><span class="string">14</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>my_coro2.send(28)</span></span><br><span class="line"><span class="string">Received: b =  28</span></span><br><span class="line"><span class="string">42</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>my_coro2.send(99)</span></span><br><span class="line"><span class="string">Received: c =  99</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="string">StopIteration</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 出现协程无法处理的异常</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_coro2</span>(<span class="params">a</span>):</span></span><br><span class="line">    print(<span class="string">&quot;Started: a = &quot;</span> , a)</span><br><span class="line">    b = <span class="keyword">yield</span> a</span><br><span class="line">    print(<span class="string">&quot;Received: b = &quot;</span> , b)</span><br><span class="line">    c = <span class="keyword">yield</span> a + b</span><br><span class="line">    print(<span class="string">&quot;Received: c = &quot;</span> , c)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>from test import simple_coro2</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>coro = simple_coro2(14)</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>next(coro)</span></span><br><span class="line"><span class="string">Started: a =  14</span></span><br><span class="line"><span class="string">14</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>coro.send(&quot;abc&quot;)</span></span><br><span class="line"><span class="string">Received: b =  abc</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="string">  File &quot;F:\git_localRepository\fluentPython\example-code\16-coroutine\test.py&quot;, line 5, in simple_coro2</span></span><br><span class="line"><span class="string">    c = yield a + b</span></span><br><span class="line"><span class="string">TypeError: unsupported operand type(s) for +: &#x27;int&#x27; and &#x27;str&#x27;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面的两个例子说明了协程终止的方式：<strong>异常</strong>。受此启发，Python提供了两种显示终止的协程的方法：throw()与close().</p>
<h4 id="协程终止的专用方法：throw-与-close"><a href="#协程终止的专用方法：throw-与-close" class="headerlink" title="协程终止的专用方法：throw 与 close"></a>协程终止的专用方法：throw 与 close</h4><p><strong>generator.throw( )</strong>: 使生成器在暂停的yield表达式处抛出指定异常。</p>
<ul>
<li>如果此异常被生成器处理了，那么生成器会运行到下一个yield 表达式处，产生的值称为调用generator.throw方法得到的返回值。</li>
<li>未被生成器处理，异常向外抛出，传到调用方。</li>
</ul>
<p><strong>generator.close( )</strong>:致使生成器在暂停的yield处抛出<strong>GeneratorExit异常</strong></p>
<ul>
<li>如果生成器<strong>没有处理此异常</strong>，或者抛出了<strong>StopIteration 异常</strong>，调用方不会报错，正常退出协程。</li>
<li>如果处理了此异常，（在接收到GeneratorExit异常后），仍旧产出值，那么会报RuntimeError异常。</li>
</ul>
<p>下面会展示相关例子用于理解：</p>
<p><strong>定义一个处理指定异常的协程：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoException</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;An exception type for the demonstration.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo_exc_handling</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;-&gt; coroutine started&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            x = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">except</span> DemoException:  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">            print(<span class="string">&#x27;*** DemoException handled. Continuing...&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">            print(<span class="string">&#x27;-&gt; coroutine received: &#123;!r&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;This line should never run.&#x27;</span>)  <span class="comment"># &lt;3&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>close 方法示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Coroutine closing demonstration::</span></span><br><span class="line"><span class="string">调用close方法后，协程就是关闭状态</span></span><br><span class="line"><span class="string"># BEGIN DEMO_CORO_EXC_1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; exc_coro = demo_exc_handling()</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; next(exc_coro)</span></span><br><span class="line"><span class="string">    -&gt; coroutine started</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; exc_coro.send(11)</span></span><br><span class="line"><span class="string">    -&gt; coroutine received: 11</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; exc_coro.send(22)</span></span><br><span class="line"><span class="string">    -&gt; coroutine received: 22</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; exc_coro.close()</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; from inspect import getgeneratorstate</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; getgeneratorstate(exc_coro)</span></span><br><span class="line"><span class="string">    &#x27;GEN_CLOSED&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># END DEMO_CORO_EXC_1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>throw 方法示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Coroutine handling exception::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># BEGIN DEMO_CORO_EXC_2</span></span><br><span class="line"><span class="string"># 抛出的指定异常，能够被处理，那么协程状态还是暂停状态</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; exc_coro = demo_exc_handling()</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; next(exc_coro)</span></span><br><span class="line"><span class="string">    -&gt; coroutine started</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; exc_coro.send(11)</span></span><br><span class="line"><span class="string">    -&gt; coroutine received: 11</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; exc_coro.throw(DemoException)</span></span><br><span class="line"><span class="string">    *** DemoException handled. Continuing...</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; getgeneratorstate(exc_coro)</span></span><br><span class="line"><span class="string">    &#x27;GEN_SUSPENDED&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># END DEMO_CORO_EXC_2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Coroutine not handling exception::</span></span><br><span class="line"><span class="string"># 抛出的指定异常，不能够被处理，那么协程状态就是关闭状态</span></span><br><span class="line"><span class="string"># BEGIN DEMO_CORO_EXC_3</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; exc_coro = demo_exc_handling()</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; next(exc_coro)</span></span><br><span class="line"><span class="string">    -&gt; coroutine started</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; exc_coro.send(11)</span></span><br><span class="line"><span class="string">    -&gt; coroutine received: 11</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; exc_coro.throw(ZeroDivisionError)</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">    ZeroDivisionError</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; getgeneratorstate(exc_coro)</span></span><br><span class="line"><span class="string">    &#x27;GEN_CLOSED&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># END DEMO_CORO_EXC_3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="协程返回值的处理方式"><a href="#协程返回值的处理方式" class="headerlink" title="协程返回值的处理方式"></a>协程返回值的处理方式</h2><p>我们上面的协程都是采用的<strong>产出</strong>的方式，这都是协程在运行过程中的产出，我们能否采用return的方式获得一个最终的结果。例如上面提到的平均值。下面会做一些尝试，并提出一个目前可行的解决方案。</p>
<p><strong>有返回值的协程代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Result = namedtuple(<span class="string">&#x27;Result&#x27;</span>, <span class="string">&#x27;count average&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span>():</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span>  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line">    <span class="keyword">return</span> Result(count, average)  <span class="comment"># &lt;2&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>运行代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> coroaverager2 <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ave = averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(ave)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ave.send(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ave.send(<span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ave.send(<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ave.send(<span class="literal">None</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration: Result(count=<span class="number">3</span>, average=<span class="number">20.0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们发现确实返回了，但是其返回值在StopIteration 异常的一个属性里面。</p>
<p><strong>捕获异常中的值的做法：</strong></p>
<p>根据上面的例子进行一定的改变：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ave = averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(ave)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ave.send(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ave.send(<span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ave.send(<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    ave.send(<span class="literal">None</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> StopIteration <span class="keyword">as</span> exc:</span><br><span class="line"><span class="meta">... </span>    result = exc.value</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result</span><br><span class="line">Result(count=<span class="number">3</span>, average=<span class="number">20.0</span>)</span><br></pre></td></tr></table></figure>
<p>上面的例子捕获的此异常，并获得了异常中的值。</p>
<h2 id="Yield-From"><a href="#Yield-From" class="headerlink" title="Yield From"></a>Yield From</h2><p>yield from 是一种全新的句法结构，作用比yield多。</p>
<p><strong>作用：</strong>在生成器gen中使用 yield from subgen()时 ， subgen() 获得控制权，把产出的值传递给调用gen的调用方，即调用方可以直接控制subgen 。</p>
<blockquote>
<p>上面描述的很抽象，在我理解看来 有三方，两层关系：调用方与gen ， gen与 subgen 。gen就是采用了yield from语法的函数。</p>
</blockquote>
<p>书本中有这么一句话：<strong>yield from 的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来。</strong>这两者可以直接发送和产出值，还可以直接传入异常，不需要在位于中间的协程中添加大量处理异常的样板代码。</p>
<h3 id="Yield-From-用于简化for循环中的yield-表达式"><a href="#Yield-From-用于简化for循环中的yield-表达式" class="headerlink" title="Yield From 用于简化for循环中的yield 表达式"></a>Yield From 用于简化for循环中的yield 表达式</h3><p> 产出目标值的几种方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&quot;ABC&quot;</span>:</span><br><span class="line">        <span class="keyword">yield</span> c</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen2</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> <span class="string">&quot;ABC&quot;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">list</span>(gen()))</span><br><span class="line">print(<span class="built_in">list</span>(gen2()))</span><br><span class="line"><span class="comment"># [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3]</span></span><br><span class="line"><span class="comment"># [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>yield from x 表达式，会首先调用 iter(x) ，并对内部的</li>
</ul>
<h3 id="Yield-From-用做通道"><a href="#Yield-From-用做通道" class="headerlink" title="Yield From 用做通道"></a>Yield From 用做通道</h3><p>这里是Yield From 的主要用处，也是上面提到的话，这种方式的好处在于：能够解决在第4部分的异常值获取问题。</p>
<p><strong>名词解释：</strong></p>
<ul>
<li><strong>委派生成器:</strong> 包含有 yield from <iterable> 表达式的生成器函数</li>
<li><strong>子生成器：</strong>从yield from 表达式中<iterable>部分中获取的生成器</li>
<li><strong>调用方：</strong> 调用 <strong>委派生成器</strong> 部分的代码</li>
</ul>
<p><strong>yield from 结构的用法图示：</strong></p>
<p><img src="C:\Users\QingZhi\AppData\Roaming\Typora\typora-user-images\image-20201110190218832.png" alt="image-20201110190218832"></p>
<p><strong>应用示例：使用 yield from 计算平均值并输出统计报告</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BEGIN YIELD_FROM_AVERAGER</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Result = namedtuple(<span class="string">&#x27;Result&#x27;</span>, <span class="string">&#x27;count average&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># the subgenerator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span>():</span>  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span>  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># &lt;3&gt;</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line">    <span class="keyword">return</span> Result(count, average)  <span class="comment"># &lt;4&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># the delegating generator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span>(<span class="params">results, key</span>):</span>  <span class="comment"># &lt;5&gt;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># &lt;6&gt;</span></span><br><span class="line">        results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager()  <span class="comment"># &lt;7&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># the client code, a.k.a. the caller</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">data</span>):</span>  <span class="comment"># &lt;8&gt;</span></span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> data.items():</span><br><span class="line">        group = grouper(results, key)  <span class="comment"># &lt;9&gt;</span></span><br><span class="line">        <span class="built_in">next</span>(group)  <span class="comment"># &lt;10&gt;</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">            group.send(value)  <span class="comment"># &lt;11&gt;</span></span><br><span class="line">        group.send(<span class="literal">None</span>)  <span class="comment"># important! &lt;12&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(results)  # uncomment to debug</span></span><br><span class="line">    report(results)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># output report</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">report</span>(<span class="params">results</span>):</span></span><br><span class="line">    <span class="keyword">for</span> key, result <span class="keyword">in</span> <span class="built_in">sorted</span>(results.items()):</span><br><span class="line">        group, unit = key.split(<span class="string">&#x27;;&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;&#123;:2&#125; &#123;:5&#125; averaging &#123;:.2f&#125;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">              result.count, group, result.average, unit))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;girls;kg&#x27;</span>:</span><br><span class="line">        [<span class="number">40.9</span>, <span class="number">38.5</span>, <span class="number">44.3</span>, <span class="number">42.2</span>, <span class="number">45.2</span>, <span class="number">41.7</span>, <span class="number">44.5</span>, <span class="number">38.0</span>, <span class="number">40.6</span>, <span class="number">44.5</span>],</span><br><span class="line">    <span class="string">&#x27;girls;m&#x27;</span>:</span><br><span class="line">        [<span class="number">1.6</span>, <span class="number">1.51</span>, <span class="number">1.4</span>, <span class="number">1.3</span>, <span class="number">1.41</span>, <span class="number">1.39</span>, <span class="number">1.33</span>, <span class="number">1.46</span>, <span class="number">1.45</span>, <span class="number">1.43</span>],</span><br><span class="line">    <span class="string">&#x27;boys;kg&#x27;</span>:</span><br><span class="line">        [<span class="number">39.0</span>, <span class="number">40.8</span>, <span class="number">43.2</span>, <span class="number">40.8</span>, <span class="number">43.1</span>, <span class="number">38.6</span>, <span class="number">41.4</span>, <span class="number">40.6</span>, <span class="number">36.3</span>],</span><br><span class="line">    <span class="string">&#x27;boys;m&#x27;</span>:</span><br><span class="line">        [<span class="number">1.38</span>, <span class="number">1.5</span>, <span class="number">1.32</span>, <span class="number">1.25</span>, <span class="number">1.37</span>, <span class="number">1.48</span>, <span class="number">1.25</span>, <span class="number">1.49</span>, <span class="number">1.46</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># END YIELD_FROM_AVERAGER</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码中包含有 子生成器，委派生成器，调用方 三部分定义代码 ，运行结果如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> 9 boys  averaging 40.42kg</span><br><span class="line"> 9 boys  averaging 1.39m</span><br><span class="line">10 girls averaging 42.04kg</span><br><span class="line">10 girls averaging 1.43m</span><br></pre></td></tr></table></figure>
<p>理解上面的代码是很重要的，一开始我自己在看代码时不知道调用方在调用 send() 函数时，究竟是直接作用于内部的子生成器还是作用于外部的委派生成器。作用的位置不同，其逻辑理解也会产生较大的误差。原书中对其内部逻辑的解释很清晰，这里我就直接摘抄下来，看看结果。</p>
<ul>
<li>外层for循环每一迭代会新建一个grouper实例，赋值给group变量，此时group就是委派生成器。</li>
<li>调用 next(group) ，对委派生成器进行激活，从而进入 while True循环，调用了子生成器 average后，在 yield from 表达式处暂停。</li>
<li>内层for 循环调用group.send(value),直接把值传给子生成器 averager. 同时，当前的grouper 实例（group）在yield from表达式处暂停。</li>
<li>内层循环结束后，group 实例依旧在yield from 表达式处暂定，因此，grouper 函数定义体中的results[key]赋值语句还没有执行。</li>
<li>如果外层 for 循环尾部没有，group.send(None) , 那么averager 子生成器永远不会终止，委派生成器 group 永远不会被激活，因此永远不会为 results[key] 进行赋值。</li>
<li>外层 for 循环重新迭代式会创建一个新的 grouper 实例，然后绑定到 group 变量上。前一个grouper实例，被垃圾回收。</li>
</ul>
<p>委派生成器作用是一个管道，那么多几个管道也是可以的，此管道链条需要以一个只使用 yield 表达式的简单生成器结束或者以任何可迭代的对象结束。</p>
<h2 id="应用：仿真系统"><a href="#应用：仿真系统" class="headerlink" title="应用：仿真系统"></a>应用：仿真系统</h2><p>没有去了解相关的内容，如果需要再去看。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划——股票专题解法</title>
    <url>/2021/01/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E8%82%A1%E7%A5%A8%E4%B8%93%E9%A2%98%E8%A7%A3%E6%B3%95/</url>
    <content><![CDATA[<p>我自己对股票问题经常打怵，特将相关算法框架与相关题目解读总结如下：</p>
<a id="more"></a>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/">参考Leetcode解释</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>像动态规划的思想我之前是有总结过的，但是在应用方面还是很薄弱。我个人并不认为是理论的不清晰，更多的情况是由于状态的定义以及状态转移方程推导这两方面的问题，甚至有时需要将状态转移方程转换为递推式才能够更好的解决问题。</p>
<h2 id="动态规划之穷举"><a href="#动态规划之穷举" class="headerlink" title="动态规划之穷举"></a>动态规划之穷举</h2><p>不管是动态规划也好，贪心算法也罢，其实都是解决某类问题的策略，其均是在所有的可能性中探索自己的答案，并快速得到你想要的结果。<strong>穷举法</strong>是最为简单而暴力的解法，但是其平铺直述的将所有的状态展现了出来。有必要了解下股票问题的穷举法。</p>
<p>解答人在这里采用了<strong>状态</strong>来进行穷举，具体到每一天，观察存在哪几种<strong>状态</strong>，并找出每个<strong>状态</strong>对应的<strong>选择</strong>。如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> <span class="keyword">in</span> 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> <span class="keyword">in</span> 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 择优(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>
<p>上面的伪代码中展示的就是利用<strong>状态</strong>进行<strong>穷举</strong>的形式。那么<strong>股票</strong>问题中我们的<strong>状态</strong>有哪些呢？</p>
<ol>
<li>日期:T</li>
<li>交易次数:K</li>
<li>是否持有股票:1，持有； 0，不持有。</li>
</ol>
<p><strong>选择</strong>又有哪些呢？1.买入 2，卖出 3.不做动作。分别用buy,sell,rest表示前面的三种选择。<strong>但是</strong>在股票问题中并不是每一天你都可以任意进行<strong>选择</strong>，其存在某种限制：buy必须在sell后，sell必须在buy后，rest操作还取决于前一天是buy OR sell等等。<strong>选择</strong>往往由题意进行限制。</p>
<p>我们不去管什么限制，仅仅是<strong>穷举</strong>出来的形式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span> <span class="keyword">or</span> <span class="number">1</span>]</span><br><span class="line"><span class="number">0</span> &lt;= i &lt;= n-<span class="number">1</span>, <span class="number">1</span> &lt;= k &lt;= K</span><br><span class="line"><span class="comment">#n 为天数，大 K 为最多交易数</span></span><br><span class="line"><span class="comment">#此问题共 n × K × 2 种状态，全部穷举就能搞定。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; n:</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= k &lt;= K:</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> &#123;<span class="number">0</span>, <span class="number">1</span>&#125;:</span><br><span class="line">            dp[i][k][s] = <span class="built_in">max</span>(buy, sell, rest)</span><br><span class="line"><span class="comment">#比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易            </span></span><br></pre></td></tr></table></figure>
<p><strong>我们的想要的答案是：</strong>$dp[n-1][K][0]$ , 即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 $dp[n - 1][K][1]$？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。</p>
<h2 id="状态转移框架"><a href="#状态转移框架" class="headerlink" title="状态转移框架"></a>状态转移框架</h2><p>上面的<strong>穷举</strong>中其实已经暗含将问题整个<strong>状态定义</strong>为：<strong>dp[i] [w] [j]</strong> 表示第 i 天，在交易次数限制在 w 的情况下，是否持有时所能带来的最大利润。</p>
<blockquote>
<p>我们接下来思考状态之间到底是如何转移的呢？</p>
</blockquote>
<p>根据<strong>选择</strong>进行转移，我们以从是否持有状态出发，如图：</p>
<p><img src="https://pic.leetcode-cn.com/c4eb5f0aa4daf7bef4b3b8af95129bb7394ec58e1ba7b191d9104bbd8ff1ccb3-40198bf2f6894018328b250b772b4a17724a983f99ba359b798a289733bffcbc-file_1559885188422-1.png"></p>
<p>根据上图我们可以写出状态转移方程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][k][<span class="number">0</span>] , dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + price[i] )</span><br><span class="line"><span class="comment">#		      max( 做出rest选择 ， 做出sell选择 )</span></span><br><span class="line"><span class="comment">#解释：今天我没有持有股票，有两种可能：</span></span><br><span class="line"><span class="comment">#要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；</span></span><br><span class="line"><span class="comment">#要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dp[i][k][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][k][<span class="number">1</span>] , dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - price[i] )</span><br><span class="line"><span class="comment">#			 max( rest , buy )</span></span><br><span class="line"><span class="comment">#解释：今天我持有着股票，有两种可能：</span></span><br><span class="line"><span class="comment">#要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；</span></span><br><span class="line"><span class="comment">#要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。</span></span><br></pre></td></tr></table></figure>
<h2 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[-<span class="number">1</span>][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">解释：因为 i 是从 <span class="number">0</span> 开始的，所以 i = -<span class="number">1</span> 意味着还没有开始，这时候的利润当然是 <span class="number">0</span> 。</span><br><span class="line">dp[-<span class="number">1</span>][k][<span class="number">1</span>] = -infinity</span><br><span class="line">解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">解释：因为 k 是从 <span class="number">1</span> 开始的，所以 k = <span class="number">0</span> 意味着根本不允许交易，这时候利润当然是 <span class="number">0</span> 。</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line">解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实上面的边界，这么写起来是很别扭的，我们可以理解为综合考虑：i , k极端情况下的的边界分布。</p>
</blockquote>
<p>以上三部分其实就是讲解了：状态、状态转移方程、边界。相当于提出了一套用于解决股票问题的框架。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="leetcode-0121"><a href="#leetcode-0121" class="headerlink" title="leetcode_0121"></a>leetcode_0121</h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h4><blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Note that you cannot sell a stock before you buy one.</p>
</blockquote>
<p>交易次数仅限于一次,k=1</p>
<p><strong>状态定义：</strong> $dp[i][k][j] , 0 &lt; i &lt; len(prices) , 0&lt;=k&lt;=1$ 表示第 i 天 ，第 K 次交易 ， 持有或不持有，所能获得的最大利润，0 &lt; i &lt; len(prices) , 0&lt;=k&lt;=1</p>
<p><strong>状态转移方程:</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] - price[i] )</span><br><span class="line"><span class="comment"># 第 i 天的状态为1（持有）时，交易一定出现过，k=1(题目限制只能1次)：昨天已经持有，今天选择观望，或者昨天不曾持有，今天选择买入</span></span><br><span class="line"><span class="comment"># dp[i-1][0][0] 在这道题目中一定为0，故应该为</span></span><br><span class="line"><span class="comment"># PS 如果代码仍然按照第一行编写，便会出现错误的结果，所以状态转移方程也根据题目存在差异，框架仅用于切入点。</span></span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>],  - price[i] )</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] ,dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + price[i] )</span><br><span class="line"><span class="comment"># 第 i 天状态为0（不持有）时，交易已经出现，k=1(题目限制只能1次)：昨天未持有，今天选择观望，或者昨天还是持有的，今天选择卖出</span></span><br></pre></td></tr></table></figure>
<ul>
<li>为什么上面没有考虑$dp[i][0][0]$ 这是由于未曾发生交易，这是边界情况，不需要转移好嘛。</li>
</ul>
<p><strong>由于限制交易次数为1次：</strong>状态转移方程等式左侧K均为1，这说明去掉K也是不影响的。</p>
<blockquote>
<p>这里的解释很牵强，我倒认为是由于持有与不持有本身就已经代表是否发生了一次交易，这导致这道题不考虑K也是可以的。</p>
</blockquote>
<p><strong>边界转移方程优化：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">1</span>],  - price[i] )</span><br><span class="line"><span class="comment">#第 i 天已经持有了，那么i-1天已持有，今天观望，或者，i-1 天未持有，今天买入</span></span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">0</span>] ,dp[i-<span class="number">1</span>][<span class="number">1</span>] + price[i] )</span><br><span class="line"><span class="comment">#第 i 天不再持有了，那么i-1天已不再持有，今天观望，或者，i-1 天持有，今天卖出</span></span><br></pre></td></tr></table></figure>
<p><strong>边界方程：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[-<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line"><span class="comment"># 这里的-1虽然代表数组下标，表示尚未开始时的状态，但是-1本身是不合理的，我们一般会特殊处理即可。</span></span><br></pre></td></tr></table></figure>
<h4 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># dp table初始化</span></span><br><span class="line">        dp = [ [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment">#边界表示第0天的状况</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">1</span>],  - prices[i-<span class="number">1</span>] )</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">0</span>] ,dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i-<span class="number">1</span>] )</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h4 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h4><ul>
<li>时间复杂度：一次迭代完成，$O(n)$</li>
<li>空间复杂度：需要一个数组，$ O(n) $</li>
</ul>
<h3 id="leetcode-0122"><a href="#leetcode-0122" class="headerlink" title="leetcode_0122"></a>leetcode_0122</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Say you have an array prices for which the ith element is the price of a given stock on day i.</span><br><span class="line"></span><br><span class="line">Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</span><br><span class="line"></span><br><span class="line">Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.</span><br><span class="line">             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.</span><br><span class="line">             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are</span><br><span class="line">             engaging multiple transactions at the same time. You must sell before buying again.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit = 0.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">1 &lt;= prices.length &lt;= 3 * 10 ^ 4</span><br><span class="line">0 &lt;= prices[i] &lt;= 10 ^ 4</span><br></pre></td></tr></table></figure>
<p>题目中的交易次数是没有限制的。</p>
<p><strong>状态定义：</strong> $dp[i][k][j] , 0 &lt; i &lt; len(prices) , 0&lt;=k&lt;float(“inf”)$ 表示第 i 天 ，第 K 次交易 ， 持有或不持有，所能获得的最大利润</p>
<blockquote>
<p>没有变化</p>
</blockquote>
<p><strong>状态转移方程：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[i][k][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][k][<span class="number">1</span>] , dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i] ) </span><br><span class="line"><span class="comment">#第 i 天 k 次交易 持有状态 = max( 第 i-1 天 k 次交易 持有状态，选择观望 , 第 i-1 天 k-1 次交易 未持有状态，选择买入 )</span></span><br><span class="line">dp[i][k][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][k][<span class="number">0</span>] , dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">1</span>] + prices[i] )</span><br><span class="line"><span class="comment">#第 i 天 k 次交易 未持有状态 = max( 第 i-1 天 k 次交易 未持有状态，选择观望 , 第 i-1 天 k-1 次交易 持有状态，选择卖出 )</span></span><br></pre></td></tr></table></figure>
<p>由于题目中<strong>不对 K 有任何限制</strong>,那么，K的范围就是到无穷大，那么k与k-1的变化是毫无意义的，我们根本不关注到底发生了多少次，故状态转移方程修改如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">1</span>] , dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i] ) </span><br><span class="line"><span class="comment">#第 i 天 持有状态 = max( 第 i-1 天 持有状态，选择观望 , 第 i-1 天 未持有状态，选择买入 )</span></span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">0</span>] , dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i] )</span><br><span class="line"><span class="comment">#第 i 天 未持有状态 = max( 第 i-1 天 未持有状态，选择观望 , 第 i-1 天 持有状态，选择卖出 )</span></span><br></pre></td></tr></table></figure>
<p><strong>边界方程：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[-<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="算法代码-1"><a href="#算法代码-1" class="headerlink" title="算法代码"></a>算法代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">1</span>] , dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>] ) </span><br><span class="line">			<span class="comment">#第 i 天 持有状态 = max( 第 i-1 天 持有状态，选择观望 , 第 i-1 天 未持有状态，选择买入 )</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">0</span>] , dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i-<span class="number">1</span>] )</span><br><span class="line">			<span class="comment">#第 i 天 未持有状态 = max( 第 i-1 天 未持有状态，选择观望 , 第 i-1 天 持有状态，选择卖出 )</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><p>同上</p>
<h3 id="leetcode-0123"><a href="#leetcode-0123" class="headerlink" title="leetcode_0123"></a>leetcode_0123</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Say you have an array for which the ith element is the price of a given stock on day i.</span><br><span class="line"></span><br><span class="line">Design an algorithm to find the maximum profit. You may complete at most two transactions.</span><br><span class="line"></span><br><span class="line">Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [3,3,5,0,0,3,1,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</span><br><span class="line">             Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.</span><br><span class="line">             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are</span><br><span class="line">             engaging multiple transactions at the same time. You must sell before buying again.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit = 0.</span><br></pre></td></tr></table></figure>
<p>K限制在两次以内</p>
<p><strong>状态定义：</strong>$dp[i][k][j] , 0 &lt; i &lt; len(prices) , 0&lt;=k&lt;=2$</p>
<p><strong>状态转移方程：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[i][k][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][k][<span class="number">1</span>] , dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i] ) </span><br><span class="line">            <span class="comment">#第 i 天 k 次交易 持有状态 = max( 第 i-1 天 k 次交易 持有状态，选择观望 , 第 i-1 天 k-1 次交易 未持有状态，选择买入 )</span></span><br><span class="line">dp[i][k][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][k][<span class="number">0</span>] , dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i] )</span><br><span class="line">            <span class="comment">#第 i 天 k 次交易 未持有状态 = max( 第 i-1 天 k 次交易 未持有状态，选择观望 , 第 i-1 天 k-1 次交易 持有状态，选择卖出 )</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>很明显，这次状态转移方程没办法优化。</p>
</blockquote>
<p><strong>边界：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[-<span class="number">1</span>][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[-<span class="number">1</span>][k][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="算法代码-2"><a href="#算法代码-2" class="headerlink" title="算法代码"></a>算法代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [[[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 边界初始化</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            dp[<span class="number">0</span>][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[<span class="number">0</span>][k][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="comment">#迭代过程</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)+<span class="number">1</span>):</span><br><span class="line">            <span class="comment">#其实这里可以采用 for k in range(3,0,-1)</span></span><br><span class="line">            <span class="comment"># 他人的写法</span></span><br><span class="line">            dp[i][<span class="number">2</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>] + prices[i-<span class="number">1</span>])</span><br><span class="line">            dp[i][<span class="number">2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>])</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i-<span class="number">1</span>])</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], -prices[i-<span class="number">1</span>])    </span><br><span class="line">        <span class="comment"># 最大利润寻找</span></span><br><span class="line">        maxprofit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            temp = <span class="built_in">max</span>(dp[-<span class="number">1</span>][k])</span><br><span class="line">            <span class="keyword">if</span> maxprofit &lt; temp:</span><br><span class="line">                maxprofit = temp</span><br><span class="line">        <span class="keyword">return</span> maxprofit</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 迭代逻辑部分，有所更改，用了双循环</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [[[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            dp[<span class="number">0</span>][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[<span class="number">0</span>][k][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 注意K的取值也是从小到大的</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">3</span>):</span><br><span class="line">                dp[i][k][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][k][<span class="number">1</span>] , dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>] ) </span><br><span class="line">            <span class="comment">#第 i 天 k 次交易 持有状态 = max( 第 i-1 天 k 次交易 持有状态，选择观望 , 第 i-1 天 k-1 次交易 未持有状态，选择买入 )</span></span><br><span class="line">                dp[i][k][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][k][<span class="number">0</span>] , dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i-<span class="number">1</span>] )</span><br><span class="line">            <span class="comment">#第 i 天 k 次交易 未持有状态 = max( 第 i-1 天 k 次交易 未持有状态，选择观望 , 第 i-1 天 k-1 次交易 持有状态，选择卖出 )</span></span><br><span class="line">        maxprofit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            temp = <span class="built_in">max</span>(dp[-<span class="number">1</span>][k])</span><br><span class="line">            <span class="keyword">if</span> maxprofit &lt; temp:</span><br><span class="line">                maxprofit = temp</span><br><span class="line">        <span class="keyword">return</span> maxprofit</span><br></pre></td></tr></table></figure>
<h4 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a>算法分析：</h4><h3 id="leetcode-0124"><a href="#leetcode-0124" class="headerlink" title="leetcode_0124"></a>leetcode_0124</h3><p>K没有限制，就是上一题的扩展，这里不做任何解释</p>
<h4 id="算法代码-3"><a href="#算法代码-3" class="headerlink" title="算法代码"></a>算法代码</h4><blockquote>
<p>超出时间限制，暂时不想优化</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, k: <span class="built_in">int</span>, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        dp = [[[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[<span class="number">0</span>][k][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">                </span><br><span class="line">                dp[i][k][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][k][<span class="number">1</span>] , dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>] ) </span><br><span class="line">            <span class="comment">#第 i 天 k 次交易 持有状态 = max( 第 i-1 天 k 次交易 持有状态，选择观望 , 第 i-1 天 k-1 次交易 未持有状态，选择买入 )</span></span><br><span class="line">                dp[i][k][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][k][<span class="number">0</span>] , dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i-<span class="number">1</span>] )</span><br><span class="line">            <span class="comment">#第 i 天 k 次交易 未持有状态 = max( 第 i-1 天 k 次交易 未持有状态，选择观望 , 第 i-1 天 k-1 次交易 持有状态，选择卖出 )</span></span><br><span class="line">        maxprofit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>):</span><br><span class="line">            temp = <span class="built_in">max</span>(dp[-<span class="number">1</span>][k])</span><br><span class="line">            <span class="keyword">if</span> maxprofit &lt; temp:</span><br><span class="line">                maxprofit = temp</span><br><span class="line">        <span class="keyword">return</span> maxprofit</span><br></pre></td></tr></table></figure>
<h3 id="leetcode-0309"><a href="#leetcode-0309" class="headerlink" title="leetcode_0309"></a>leetcode_0309</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Say you have an array for which the ith element is the price of a given stock on day i.</span><br><span class="line"></span><br><span class="line">Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</span><br><span class="line"></span><br><span class="line">You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</span><br><span class="line">After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [1,2,3,0,2]</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: transactions = [buy, sell, cooldown, buy, sell]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>状态定义：</strong> $dp[i][k][j] , 0 &lt; i &lt; len(prices) , 0&lt;=k&lt;float(“inf”)$ 表示第 i 天 ，第 K 次交易 ， 持有或不持有，所能获得的最大利润</p>
<p><strong>状态转移方程：</strong>很明显，并不需要记录K值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>] , dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line"><span class="comment">#  第 i 天 未持有状态 = max( 第 i-1 天 未持有状态，选择观望 , 第 i-1 天持有状态，选择卖出 )</span></span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>] , dp[i-<span class="number">2</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line"><span class="comment">#  第 i 天 持有状态 = max( 第 i-1 天 持有状态，选择观望 , 第 i-1 天 未持有状态，选择买入 )</span></span><br></pre></td></tr></table></figure>
<p><strong>边界方程：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[-<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="算法代码-4"><a href="#算法代码-4" class="headerlink" title="算法代码"></a>算法代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 这里这么处理仅仅是处理一开始不愿意初始化罢了，一开始是没有前天的好嘛，我们的数组只虚拟了一天，也就是dp[0]这一天</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">                dp[i][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">1</span>] , dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>] )</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">1</span>] , dp[i-<span class="number">2</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>] ) </span><br><span class="line">			<span class="comment">#第 i 天 持有状态 = max( 第 i-1 天 持有状态，选择观望 , 第 i-1 天 未持有状态，选择买入 )</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">0</span>] , dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i-<span class="number">1</span>] )</span><br><span class="line">			<span class="comment">#第 i 天 未持有状态 = max( 第 i-1 天 未持有状态，选择观望 , 第 i-1 天 持有状态，选择卖出 )</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h4 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h4><h3 id="leetcode-0714"><a href="#leetcode-0714" class="headerlink" title="leetcode_0714"></a>leetcode_0714</h3><p><strong>状态定义：</strong>什么的都与0122题一摸一样</p>
<p><strong>状态转移方程：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 卖出的时候扣除费用就好 </span></span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">1</span>] , dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>] ) </span><br><span class="line"><span class="comment">#第 i 天 持有状态 = max( 第 i-1 天 持有状态，选择观望 , 第 i-1 天 未持有状态，选择买入 )</span></span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">0</span>] , dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i-<span class="number">1</span>] - fee )</span><br><span class="line"><span class="comment">#第 i 天 未持有状态 = max( 第 i-1 天 未持有状态，选择观望 , 第 i-1 天 持有状态，选择卖出,并扣除费用 )</span></span><br></pre></td></tr></table></figure>
<p><strong>边界：</strong>一样</p>
<h4 id="算法代码："><a href="#算法代码：" class="headerlink" title="算法代码："></a>算法代码：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>], fee: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">1</span>] , dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i-<span class="number">1</span>] ) </span><br><span class="line">			<span class="comment">#第 i 天 持有状态 = max( 第 i-1 天 持有状态，选择观望 , 第 i-1 天 未持有状态，选择买入 )</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>( dp[i-<span class="number">1</span>][<span class="number">0</span>] , dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i-<span class="number">1</span>] - fee )</span><br><span class="line">			<span class="comment">#第 i 天 未持有状态 = max( 第 i-1 天 未持有状态，选择观望 , 第 i-1 天 持有状态，选择卖出,并扣除费用 )</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h4 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h4>]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划算法解释</title>
    <url>/2021/01/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<p>初次见到动态规划是在王道论坛划水的时候，见到时简直一脸懵逼。最近在刷Leetcode发现大量的题目建议采用动态规划的解法，遂将相关概念整理如下。</p>
<a id="more"></a>

<p>参考地址：<a href="https://www.zhihu.com/question/23995189/answer/35324479">知乎众解答</a> <a href="https://www.cnblogs.com/cthon/p/9251909.html">博客漫画引入解释</a></p>
<p>在看大家对动态规划的解读时，发现很有意思的现象，就是大家对动态规划的解读点并不一致。有的是理论型：从动态规划的本质出发，因对动态规划与其他算法的异同进行解释。有的是实战型，直接列出动态规划问题的处理模式。大部分解答甚至会将一部分算法技巧也列入动态规划之中，比如重复记忆等。个人认为这种现象的出现恰是由于动态规划本身定位就存在争论。以下的解释将从理论出发，逐步过渡到实战中的步骤或技巧。</p>
<h2 id="动态规划适用的问题与定义"><a href="#动态规划适用的问题与定义" class="headerlink" title="动态规划适用的问题与定义"></a>动态规划适用的问题与定义</h2><blockquote>
<p>主要参考知乎中[<a href="https://www.zhihu.com/people/anchor89">王勐</a>]的回答</p>
</blockquote>
<p>动态规划是对<strong>某一类问题</strong>的解决算法思路，这类问题具有两个特点：</p>
<ol>
<li><strong>最优子结构</strong> : 每个阶段的最优状态，由之前某阶段的一个或者几个状态得到</li>
<li><strong>无后效性</strong> :而不管这些状态是怎么得到的。</li>
</ol>
<p>一开始看不懂上面在说什么，接着向下看即可。很多解答中还提到了<strong>重复子问题</strong>，并将其列入动态规划的定义之中，我个人认为那并不是核心特点。要清楚动态规划的定位，那么首先需要弄清楚一系列的相关概念，例如递推、贪心、递归、搜索等等。</p>
<h3 id="问题导入"><a href="#问题导入" class="headerlink" title="问题导入"></a>问题导入</h3><p>在处理很多问题时，其实我们可以引入<strong>时间步</strong>的概念，比如迷宫问题，可以假设一个时间步走一次。那么每个时间步我们称其为<strong>阶段</strong>，而一个阶段可以有多种<strong>状态</strong>，比如你在第 $n$ 步可以自由的选择向尚未走过的多个方向前进，导致你的状态产生多个。</p>
<blockquote>
<p>比如说我想计算第100个非波那契数，每一个非波那契数就是这个问题的一个状态，每求一个新数字只需要之前的两个状态。所以同一个时刻，最多只需要保存两个状态，空间复杂度就是常数；每计算一个新状态所需要的时间也是常数且状态是线性递增的，所以时间复杂度也是线性的。</p>
<p>上面这种状态计算很直接，只需要依照固定的模式从旧状态计算出新状态就行（a[i]=a[i-1]+a[i-2]），不需要考虑是不是需要更多的状态，也不需要选择哪些旧状态来计算新状态。对于这样的解法，我们叫<strong>递推</strong>。</p>
</blockquote>
<p>上面是其回答的原句，比我自己举得例子要更加直观。<strong>阶段</strong>就是随着问题的开展，在某个时刻可能会得到的不同状态的集合。非波那契数列中，每一步会计算得到一个新数字，所以每个阶段只有一个状态。而迷宫问题，你可以有多种选择，自然你的阶段状态数是多个。从头开始走了几步就是第几个阶段，走了n步所处的位置我们称为一个状态，而走了n步所有可能到达的位置的集合就是这个阶段的所有可能的状态。虽然说起来很绕口，但是很好理解。</p>
<h3 id="相关算法的适用问题"><a href="#相关算法的适用问题" class="headerlink" title="相关算法的适用问题"></a>相关算法的适用问题</h3><p>有了阶段，针对不同问题，计算新状态的方式是不同的，就需要不同的算法，从而衍生出递推、贪心、动归等等。</p>
<p>假设：问题存在n个阶段，并且每个阶段存在多个状态，不同阶段的状态数不一定相同，一个阶段的一个状态可以得到下个阶段的所有状态中的几个。</p>
<p>共识：要计算出最终阶段的状态数，必然其经历了<strong>之前每个阶段</strong>的部分状态。</p>
<p>分歧：不同的问题对之前阶段状态的需求不同，导致了不同的算法。</p>
<h4 id="贪心算法适用问题"><a href="#贪心算法适用问题" class="headerlink" title="贪心算法适用问题"></a>贪心算法适用问题</h4><p>贪心算法的特点便是<strong>鼠目寸光</strong>，“下一步的最优<strong>只需要</strong>由当前最优得到”。</p>
<p>例如棋盘问题：从棋盘左上角到右下角最短需要几步。我们已经知道，某个阶段存在多个状态，你走了n步，可以到达的位置很多，但是有哪些位置可以让你在第n+1步中走得最远呢？？？答案很明显，即是在第n步中走得最远的位置。</p>
<p>这类问题特点，<strong>下一步最优是从当前最优得到的</strong>，解决此问题，只需寻出每一步的最优值即可，解决此类问题的算法为<strong>贪心</strong>，计算的方法为<strong>递推</strong>。</p>
<h4 id="搜索算法适用问题"><a href="#搜索算法适用问题" class="headerlink" title="搜索算法适用问题"></a>搜索算法适用问题</h4><p>搜索算法的特点是考虑全局问题，下一步的选择需要考虑之前<strong>所有阶段的状态</strong>。</p>
<p>例如迷宫问题，计算从起点到终点的最短路线时，只保存当前阶段的状态是不够的，题目要求你最短，故需要知道之前走过的所有位置。即使你当前阶段的位置不变，之前路线的不同会影响你之后选择的路线。这时需要保存之前每个阶段经历的状态，根据这些信息才能计算出下一个状态。每个阶段的状态或许不多，但是每个状态都可以转移到下一阶段的多个状态，所以解的复杂度就是指数的，因此时间复杂度也是指数的。刚刚提到的之前的路线会影响到下一步的选择，这个令人不开心的情况就叫做<strong>有后效性</strong>。</p>
<p>此类问题的解决方式，就是暴力解决，也就是最直观的搜索算法。</p>
<h4 id="动态规划适用问题"><a href="#动态规划适用问题" class="headerlink" title="动态规划适用问题"></a>动态规划适用问题</h4><p>有一类问题，看似需要所有状态，但其实不用。</p>
<p>例如最长上升子序列问题，</p>
<blockquote>
<p>假装我们年幼无知想用搜索去寻找最长上升子序列。怎么搜索呢？需要从头到尾依次枚举是否选择当前的数字，每选定一个数字就要去看看是不是满足“上升”的性质，这里第i个阶段就是去思考是否要选择第i个数，第i个阶段有两个状态，分别是选和不选。哈哈，依稀出现了刚刚迷宫找路的影子！咦慢着，每次当我决定要选择当前数字的时候，只需要和之前选定的一个数字比较就行了！这是和之前迷宫问题的本质不同！这就可以纵容我们不需要记录之前所有的状态啊！既然我们的选择已经不受之前状态的组合的影响了，那时间复杂度自然也不是指数的了啊！虽然我们不在乎某序列之前都是什么元素，但我们还是需要这个序列的长度的。所以我们只需要记录以某个元素结尾的LIS长度就好！因此第i个阶段的最优解只是由前i-1个阶段的最优解得到的，然后就得到了DP方程。</p>
<p><img src="D:/nutStore/Learning/leetcode/pictures/equation.svg"></p>
</blockquote>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>每个阶段只有一个状态-&gt;递推；<br>每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心；<br>每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索；<br>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。</p>
<blockquote>
<p>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到，这些状态也是上一阶段**”最优”**状态.</p>
</blockquote>
<p>这个性质叫做<strong>最优子结构</strong>；</p>
<blockquote>
<p>而不管之前这个状态是如何得到的</p>
</blockquote>
<p>这个性质叫做<strong>无后效性</strong>。</p>
<p>通过这一部分：</p>
<ol>
<li>应该理解了<strong>最优子结构</strong>、<strong>无后效性</strong>,但还是偏抽象，接下来的例子中会进一步进行解释。</li>
<li>各种算法适用的问题类型。</li>
</ol>
<h2 id="动态规划的本质"><a href="#动态规划的本质" class="headerlink" title="动态规划的本质"></a>动态规划的本质</h2><blockquote>
<p>知乎徐凯强 Andy的回答</p>
</blockquote>
<p>在这一部分，不再是单纯的理论上理解动态规划的概念，其涉及了动态规划的思考方式与本质的讨论。</p>
<h3 id="本质是什么"><a href="#本质是什么" class="headerlink" title="本质是什么"></a>本质是什么</h3><p>动态规划的本质，是对问题*<strong>状态的定义*</strong>和*<strong>状态转移方程*的定义</strong>。</p>
<p><strong>动态规划中递推式的求解方法不是动态规划的本质。</strong></p>
<blockquote>
<p> 维基百科定义</p>
<p> <strong>dynamic programming</strong> is a method for solving a complex problem by <strong>breaking it down into a collection of simpler subproblems</strong>.</p>
</blockquote>
<p>动态规划是通过<strong>拆分问题</strong>，定义问题与状态之间的关系，进而是问题能够通过递推（或分治）的方式解决。</p>
<p>作者认为<strong>如何拆分问题</strong>，是动态规划的核心。<strong>拆分问题</strong>，靠<strong>状态的定义</strong>与<strong>状态转移方程</strong>的定义。</p>
<h3 id="什么是状态的定义"><a href="#什么是状态的定义" class="headerlink" title="什么是状态的定义"></a>什么是状态的定义</h3><p>对于状态的定义就是你对问题<strong>从可拆分的角度</strong>重新对其定义。</p>
<p>例如经典的最长上升子序列问题：</p>
<blockquote>
<p>给定一个数列，长度为N，<br>求这个数列的最长上升（递增）子数列（LIS）的长度.<br>以<br>1 7 2 8 3 4<br>为例。<br>这个数列的最长递增子数列是 1 2 3 4，长度为4；<br>次长的长度为3， 包括 1 7 8; 1 2 3 等.</p>
</blockquote>
<p>此问题提出，一开始<strong>找不到子问题</strong>，需要你从其他角度，将其定义为<strong>可拆分子问题</strong>，否则没有子问题只能通过暴力方式解决。</p>
<p>重新定义为：</p>
<blockquote>
<p>给定一个数列，长度为N，<br>设<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="[公式]">为：以数列中第k项结尾的最长递增子序列的长度.<br>求<img src="https://www.zhihu.com/equation?tex=F_%7B1%7D..F_%7BN%7D" alt="[公式]"> 中的最大值.</p>
</blockquote>
<p>显然，这个新问题与原问题等价。<br>而对于<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="[公式]">来讲，<img src="https://www.zhihu.com/equation?tex=F_%7B1%7D+..+F_%7Bk-1%7D" alt="[公式]">都是<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="[公式]">的子问题：因为以第k项结尾的最长递增子序列（下称LIS），包含着以第<img src="https://www.zhihu.com/equation?tex=1..k-1" alt="[公式]">中某项结尾的LIS。</p>
<p>上述的新问题<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="[公式]">也可以叫做状态，定义中的“<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="[公式]">为数列中第k项结尾的LIS的长度”，就叫做对状态的定义。之所以把<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="[公式]">做“状态”而不是“问题” ，一是因为避免跟原问题中“问题”混淆，二是因为这个新问题是数学化定义的。</p>
<p>对问题的定义可以有多种，这只是其中一种。作者在回答中对此有其他定义，但没必要均罗列到上面。</p>
<h3 id="什么是状态转移方程"><a href="#什么是状态转移方程" class="headerlink" title="什么是状态转移方程"></a>什么是状态转移方程</h3><p>状态与状态之间的关系，就叫做<strong>状态转移方程</strong>。</p>
<p>比如，对于LIS问题，我们的第一种定义：</p>
<blockquote>
<p>设<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="[公式]">为：以数列中第k项结尾的最长递增子序列的长度.</p>
</blockquote>
<p>设A为题中数列，状态转移方程为：</p>
<blockquote>
<p><img src="https://www.zhihu.com/equation?tex=F_%7B1%7D+=+1" alt="[公式]"> （根据状态定义导出边界情况）<br><img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D=max(F_%7Bi%7D+1+%7C+A_%7Bk%7D%3EA_%7Bi%7D,+i%5Cin+(1..k-1))+" alt="[公式]"><img src="https://www.zhihu.com/equation?tex=(k%3E1)" alt="[公式]"></p>
</blockquote>
<p>用文字解释一下是：<br>以第k项结尾的LIS的长度是：保证第i项比第k项小的情况下，以第i项结尾的LIS长度加一的最大值，取遍i的所有值（i小于k）。</p>
<p>这里可以看出，这里的状态转移方程，就是定义了问题和子问题之间的关系。<br>可以看出，状态转移方程就是带有条件的递推式。</p>
<h3 id="动态规划迷思"><a href="#动态规划迷思" class="headerlink" title="动态规划迷思"></a>动态规划迷思</h3><ul>
<li><p>缓存、重叠子问题、记忆化</p>
<p>这些仅仅是在DP问题中求解递推式的<strong>技巧</strong>。以Fibonacci数列为例，计算第100项的时候，需要计算第99项和98项；在计算第101项的时候，需要第100项和第99项，这时候你还需要重新计算第99项吗？不需要，你只需要在第一次计算的时候把它记下来就可以了。</p>
<p>上述的需要再次计算的“第99项”，就叫“重叠子问题”。如果没有计算过，就按照递推式计算，如果计算过，直接使用，就像“缓存”一样，这种方法，叫做“记忆化”，这是递推式求解的技巧。这种技巧，通俗的说叫“花费空间来节省时间”。<strong>都不是动态规划的本质，**</strong>不是动态规划的核心。**</p>
</li>
<li><p>递归</p>
<p>递归是递推式求解的方法。</p>
</li>
</ul>
<h3 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h3><p>在这一部分我们对动态规划的本质有了一个直观的理解，也就是<strong>状态定义</strong> + <strong>状态转移方程</strong>。通过<strong>拆分为子问题</strong>的思想对状态进行定义，通过<strong>定义分析</strong>获得状态间的递推公式。这就是动态规划的<strong>本质</strong>。</p>
<h2 id="动态规划的样例解读"><a href="#动态规划的样例解读" class="headerlink" title="动态规划的样例解读"></a>动态规划的样例解读</h2><blockquote>
<p>知乎<a href="https://www.zhihu.com/people/ruan-xing-zhi">阮行止</a>解答</p>
</blockquote>
<h3 id="DAG最短路径"><a href="#DAG最短路径" class="headerlink" title="DAG最短路径"></a>DAG最短路径</h3><p>问题：给定一个城市的地图，所有的道路都是单行道，而且不会构成环。每条道路都有过路费，问您从S点到T点花费的最少费用。</p>
<p><img src="D:/nutStore/Learning/leetcode/pictures/DAG.jpg"></p>
<p><strong>状态定义</strong>：记$f(P)$ 为从S点到P点的最少费用。</p>
<blockquote>
<p>要想到达T点，要么经过C要么经过D</p>
</blockquote>
<p><strong>状态转移方程:</strong>$f(T) = \min{ f(C)+20 , f(D)+10}$</p>
<ul>
<li>无后效性：一旦获得$f(P)$ ，并不关心$f(P)$ 是如何得到的。</li>
<li>最优子结构：对于P，我们当然只关心到P的最小费用，即f(P)。如果我们从S走到T是 <img src="https://www.zhihu.com/equation?tex=S+%5Cto+P%5Cto+Q%5Cto+T" alt="[公式]"> ，那肯定S走到Q的最优路径是 <img src="https://www.zhihu.com/equation?tex=S%5Cto+P%5Cto+Q" alt="[公式]"> 。对一条最优的路径而言，从S走到<strong>沿途上所有的点（子问题）</strong>的最优路径，都是这条大路的一部分。这个问题的最优子结构性质是显然的。</li>
</ul>
<p>既然这两个性质都满足，那么本题可以DP。式子明显为：</p>
<p><img src="https://www.zhihu.com/equation?tex=f(P)=%5Cmin%E2%81%A1%5C%7Bf(R)+w_%7BR%E2%86%92P%7D%5C%7D" alt="[公式]"></p>
<p>其中R为有路通到P的所有的点， <img src="https://www.zhihu.com/equation?tex=w_%7BR%E2%86%92P%7D" alt="[公式]"> 为R到P的过路费。</p>
<h4 id="小结：-2"><a href="#小结：-2" class="headerlink" title="小结："></a>小结：</h4><p>原答案中作者还有其他方面的阐述，这里不表。这里展示了DP算法中状态定义以及状态转移方程的样子，可作为经典理解。</p>
<h2 id="DP问题的技巧"><a href="#DP问题的技巧" class="headerlink" title="DP问题的技巧"></a>DP问题的技巧</h2><blockquote>
<p>知乎 Mingqi 解答</p>
</blockquote>
<p>在这一部分，我们会讨论动态规划<strong>非本质</strong>的技巧，但却常常能够是代码质量得到提升。其认为动态规划的特点有三个：</p>
<blockquote>
<p>再次提及维基定义</p>
<p><strong>dynamic programming</strong> is a method for solving a complex problem by <strong>breaking it down into a collection of simpler subproblems</strong>, solving each of those subproblems <strong>just once</strong>, and <strong>storing their solutions</strong>.</p>
</blockquote>
<ol>
<li>把原来的问题分解成了几个<strong>相似的子问题</strong>。（强调“相似子问题”）</li>
<li>所有的子问题都<strong>只需要解决一次</strong>。（强调“只解决一次”）</li>
<li><strong>储存</strong>子问题的解。（强调“储存”）</li>
</ol>
<h4 id="理解存储的好处"><a href="#理解存储的好处" class="headerlink" title="理解存储的好处"></a>理解存储的好处</h4><p>以斐波那契数列(Fibonacci)的例子：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">1， 1， 2， 3， 5， 8， 13 ，21 ...</span><br></pre></td></tr></table></figure>
<p>其状态转移方程为：</p>
<p>![](D:/nutStore/Learning/leetcode/pictures/equation (1).svg)</p>
<p>我们通常是从上至下分解问题，再向上返回结果。n=6时的计算图为：</p>
<p><img src="D:/nutStore/Learning/leetcode/pictures/computeTree.jpg"></p>
<p><strong>出现大量重复计算</strong>，无法体现其<strong>子问题只解决一次</strong>的特点。可以利用<strong>存储子问题的解</strong>的方式，解决上述问题，一般利用数组存储。其计算图为：</p>
<p><img src="D:/nutStore/Learning/leetcode/pictures/computeTee2.jpg"></p>
<p>这个例子其实并不是动态规划的经典例子，其使用单纯的<strong>递推</strong>，也是一样的结果。但可以用来理解<strong>存储重复子问题</strong>的效果。</p>
<h4 id="理解动态规划算法的优势"><a href="#理解动态规划算法的优势" class="headerlink" title="理解动态规划算法的优势"></a>理解动态规划算法的优势</h4><p>这里的优势是相对于暴力解决法。还是以最长上升子数列的长度（LIS）为例：</p>
<p>给定一个数列：</p>
<p><img src="D:/nutStore/Learning/leetcode/pictures/LIS.JPG"></p>
<p>最长上升子数列为：</p>
<p><img src="D:/nutStore/Learning/leetcode/pictures/LIS2.jpg"></p>
<p>其长度为4.</p>
<p>暴力解决方式：穷举法</p>
<p><img src="D:/nutStore/Learning/leetcode/pictures/LIS3.jpg"></p>
<p>其时间复杂度为：</p>
<p>![](D:/nutStore/Learning/leetcode/pictures/equation (2).svg)</p>
<p>动态规划解决：</p>
<p><strong>状态转移方程：</strong></p>
<p><img src="https://www.zhihu.com/equation?tex=F_%7B1%7D+=+1" alt="[公式]"> （根据状态定义导出边界情况）<br><img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D=max(F_%7Bi%7D+1+%7C+A_%7Bk%7D%3EA_%7Bi%7D,+i%5Cin+(1..k-1))+" alt="[公式]"><img src="https://www.zhihu.com/equation?tex=(k%3E1)" alt="[公式]"></p>
<p>其计算图为：</p>
<p><img src="D:/nutStore/Learning/leetcode/pictures/LIS4.jpg"></p>
<p>可以看到这里的计算量相较于穷举法已经下降了很多。</p>
<p>同样的可以使用存储的方式减少计算量。</p>
<p>未使用存储：</p>
<p><img src="D:/nutStore/Learning/leetcode/pictures/LIS5.jpg"></p>
<p>使用存储：</p>
<p><img src="D:/nutStore/Learning/leetcode/pictures/LIS6.jpg"></p>
<h4 id="小结：-3"><a href="#小结：-3" class="headerlink" title="小结："></a>小结：</h4><p>在这一部分我们能够理解动态规划中<strong>存储</strong>的重要性，其是动态规划高效的核心。</p>
<p><strong>动态规划本身是将原问题通过某种定义，演变成可拆分为子问题的形式，通过解决小问题从而以递推或分治的方式解决大问题。那么其本身的形式，必然存在大量的重复子问题，通过存储的方式，可以有效的降低时间复杂度，减少不必要的计算。</strong></p>
<h2 id="DP的实践"><a href="#DP的实践" class="headerlink" title="DP的实践"></a>DP的实践</h2><p>上面的几部分内容，均针对如何更好地理解动态规划，并没有涉及深入的实践环节。像这样的解答网上也有很多，例如知乎<a href="https://www.zhihu.com/people/iamshuaidi">帅地</a>的答案就偏向于实践。</p>
<p>我个人在接触之时，也看了很多实践的帖子，我个人的感受为：很多帖子只是花式的告诉你如何操作你就解决了动态规划问题，但是你个人还是不知道如何审题，无法确认此问题是否是动态规划问题。而且很多帖子不讲DP的本质，一开始就告诉你先整个数组，用于存储，这就很懵逼，对于我这样的小白肯定是不友好的，就像做数学题只注重套路没有看到此题的本质。</p>
<p>大家所说的也是大同小异，无非是：</p>
<ol>
<li><strong>定义状态</strong> 2.<strong>寻找状态转移方程</strong> 3.<strong>寻找边界</strong> 4.<strong>存储</strong></li>
</ol>
<p>光说不做假把式，实际问题更需要灵活的解决，好吧，我去刷题啦。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2021/01/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h1><blockquote>
<p><a href="https://www.zhihu.com/search?type=content&q=%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93">知乎参考地址</a></p>
</blockquote>
<p>最近在刷Leetcode过程中，部分题目需要手写排序算法。发现很多之前学习过的排序算法，均已经玩的差不多啦。特将常见的排序算法思想与算法实现总结如下：</p>
<a id="more"></a>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><blockquote>
<p>这里直接采用<a href="https://zhuanlan.zhihu.com/p/40695917">LeetCode</a>回答所采用的准备工作，用于测试或算法部件</p>
</blockquote>
<ul>
<li>生成算法需要的数列：随机数列</li>
<li>对于一些极端情况，考虑算法的效率，需要生成基本有序的数列</li>
<li>测试算法性能的函数</li>
<li>判断数列是否有序</li>
<li>数列中元素相互交换</li>
<li>数列的拷贝</li>
</ul>
<h3 id="生成随机数列"><a href="#生成随机数列" class="headerlink" title="生成随机数列"></a>生成随机数列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateRandomArray</span>(<span class="params">n, <span class="built_in">min</span>, <span class="built_in">max</span></span>):</span></span><br><span class="line">    arr = []</span><br><span class="line">    arr = [randint(<span class="built_in">min</span>, <span class="built_in">max</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>
<h3 id="生成基本有序的数列"><a href="#生成基本有序的数列" class="headerlink" title="生成基本有序的数列"></a>生成基本有序的数列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateNearlyOrderedArray</span>(<span class="params">n, swapTimes</span>):</span></span><br><span class="line">    arr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        arr.append(i)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(swapTimes):</span><br><span class="line">        posx = randint(<span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">        posy = randint(<span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">        arr[posx], arr[posy] = arr[posy], arr[posx]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>
<h3 id="判断数列是否有序"><a href="#判断数列是否有序" class="headerlink" title="判断数列是否有序"></a>判断数列是否有序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSorted</span>(<span class="params">alist</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(alist)-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> alist[i] &gt; alist[i+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="测试算法性能"><a href="#测试算法性能" class="headerlink" title="测试算法性能"></a>测试算法性能</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = timeit.Timer(<span class="string">&#x27;testSort(&quot;某种排序算法函数&quot;, alist)&#x27;</span>, <span class="string">&#x27;from __main__ import testSort, 某种排序算法函数, alist&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;某种排序算法：%s s&#x27;</span> %t1.timeit(number=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># func表示要检测的算法函数，alist为传入的数列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testSort</span>(<span class="params">func, alist</span>):</span></span><br><span class="line">    alist =  func(alist)</span><br><span class="line">    <span class="keyword">assert</span> isSorted(alist), <span class="string">&quot;排序算法错误\n&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="数列中元素互换"><a href="#数列中元素互换" class="headerlink" title="数列中元素互换"></a>数列中元素互换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist[i], alist[j] = alist[j], alist[i]</span><br></pre></td></tr></table></figure>
<h3 id="数列拷贝"><a href="#数列拷贝" class="headerlink" title="数列拷贝"></a>数列拷贝</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接使用切片</span></span><br><span class="line"><span class="comment"># list = [8,6,2,3,1,5,7,4]</span></span><br><span class="line">alist=<span class="built_in">list</span>[:]</span><br></pre></td></tr></table></figure>


<h2 id="比较类排序"><a href="#比较类排序" class="headerlink" title="比较类排序"></a>比较类排序</h2><p>指通过比较元素间的相对次序，来完成排序的算法，但其时间复杂度<strong>无法超过$O(n\log(n))$</strong>,也称为<strong>非线性时间</strong>比较类排序。</p>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h4><h5 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h5><p>冒泡排序要对一个列表<strong>多次重复遍历</strong>。它要比较<strong>相邻</strong>的两项，并且交换顺序排错的项。每对 列表实行一次遍历，就有一个最大项排在了正确的位置。</p>
<p>大体上讲，列表的每一个数据项都会在 其相应的位置 “冒泡”。如果列表有 n 项，第一次遍历就要比较 n-1 对数据。最不理想的情况下（逆序）：需要遍历 $n-1$ 次，最理想的情况下：需要遍历$1$ 次</p>
<h5 id="算法图解"><a href="#算法图解" class="headerlink" title="算法图解"></a>算法图解</h5><p><img src="D:/nutStore/Learning/leetcode/pictures/bubbleSort.webp"></p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(alist)</span><br><span class="line">    exchange = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">            <span class="keyword">if</span> alist[j] &gt; alist[j+<span class="number">1</span>]:</span><br><span class="line">                alist[j], alist[j+<span class="number">1</span>] = alist[j+<span class="number">1</span>], alist[j]</span><br><span class="line">                exchange = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 如果发现整个排序过程中没有交换，提前结束</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exchange:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure>
<h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h5><ul>
<li><p>时间复杂度：$O(n^2)$</p>
<ul>
<li>最理想$O(n)$</li>
</ul>
</li>
<li><p>空间复杂度：$O(1)$</p>
</li>
<li><p>稳定</p>
</li>
</ul>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h5><p>很经典的排序算法。通过一趟排序将数据分割为两部分，一部分的数据均比另一部分的数据要小；再按照此方法对两部分数据分别进行快速排序，可利用递归方式实现。通常步骤：</p>
<ol>
<li>从数列中挑选一个基准；</li>
<li>重新排序数列，所有比基准小的元素放在基准前面，所有比基准大的放在基准后面（<strong>基准本身已排好</strong>）；</li>
<li>递归的把左右两区进行上述两步骤。</li>
</ol>
<h5 id="算法图解-1"><a href="#算法图解-1" class="headerlink" title="算法图解"></a>算法图解</h5><p><img src="D:/nutStore/Learning/leetcode/pictures/quickSort.webp"></p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span>(<span class="params">alist, l, r</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#当数列的大小比较小的时候，数列近乎有序的概率较大</span></span><br><span class="line">    <span class="comment"># if (r - l &lt;= 15):</span></span><br><span class="line">    <span class="comment">#     insertionSortHelp(alist, l, r)</span></span><br><span class="line">    <span class="comment">#     return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># p = partition(alist, l, r)</span></span><br><span class="line">    p = partition(alist, l, r)</span><br><span class="line"></span><br><span class="line">    quickSort(alist, l, p-<span class="number">1</span>)</span><br><span class="line">    quickSort(alist, p+<span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在alist[l...r]中寻找j,使得alist[l...j] &lt;= alist[l], alist[j+1...r] &gt;alist[l]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">alist, l, r</span>):</span></span><br><span class="line">    pos = randint(l, r)</span><br><span class="line">    alist[pos], alist[l] = alist[l], alist[pos]</span><br><span class="line">    v = alist[l]</span><br><span class="line">    <span class="comment"># v = alist[l]</span></span><br><span class="line">    <span class="comment"># j 表示v值所应当在的位置</span></span><br><span class="line">    j = l</span><br><span class="line">    i = l + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> alist[i] &lt;= v:</span><br><span class="line">            alist[j+<span class="number">1</span>],alist[i] = alist[i],alist[j+<span class="number">1</span>]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    alist[l], alist[j] = alist[j], alist[l]</span><br><span class="line">    <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure>
<h5 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h5><ul>
<li>时间复杂度：$n\log(n)$</li>
<li>空间复杂度：$n\log(n)$</li>
</ul>
<h4 id="手写上面的快排"><a href="#手写上面的快排" class="headerlink" title="手写上面的快排"></a>手写上面的快排</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span>(<span class="params">nums , l , r</span>):</span></span><br><span class="line">	<span class="keyword">if</span> l &gt;= r :</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">   	p = partition(nums , l , r)</span><br><span class="line">    </span><br><span class="line">    quickSort(nums , l , p-<span class="number">1</span>)</span><br><span class="line">    quickSort(nums , p+<span class="number">1</span> , r)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">nums , l , r</span>):</span></span><br><span class="line">    v = nums[l]</span><br><span class="line">    <span class="comment"># 表示V值所在的位置</span></span><br><span class="line">    j = l</span><br><span class="line">    <span class="comment"># 工作指针</span></span><br><span class="line">    i = l + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; v:</span><br><span class="line">          j += <span class="number">1</span></span><br><span class="line">          nums[i] , nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>] , nums[i]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    nums[j] , nums[l] = nums[l] , nums[j]</span><br><span class="line">	<span class="keyword">return</span> j</span><br></pre></td></tr></table></figure>
<p>上面partition函数中需要仔细分辨，例如一开始工作指针与V值所在位置的理解，以及最后的变化；</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="简单插入排序"><a href="#简单插入排序" class="headerlink" title="简单插入排序"></a>简单插入排序</h4><h5 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h5><p>它总是保持一个位置靠前的 已排好的子表，然后每一个新的数据项被 “插入” 到前边的子表里，排好的子表增加一项。我们认为只含有一个数据项的列表是已经排好的。每排后面一个数据（从 1 开始到 n-1），这 个的数据会和已排好子表中的数据比较。比较时，我们把之前已经排好的列表中比这个数据大的移到它的右边。当子表数据小于当前数据，或者当前数据已经和子表的所有数据比较了时，就可 以在此处插入当前数据项。</p>
<h5 id="算法图解-2"><a href="#算法图解-2" class="headerlink" title="算法图解"></a>算法图解</h5><p><img src="D:/nutStore/Learning/leetcode/pictures/insertSort.webp"></p>
<h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(alist)):</span><br><span class="line">        currentvalue=alist[i]</span><br><span class="line">        position=i</span><br><span class="line">        <span class="keyword">while</span> alist[position-<span class="number">1</span>]&gt;currentvalue <span class="keyword">and</span> position&gt;<span class="number">0</span>:</span><br><span class="line">            alist[position]=alist[position-<span class="number">1</span>]</span><br><span class="line">            position=position-<span class="number">1</span></span><br><span class="line">        alist[position]=currentvalue</span><br><span class="line">    <span class="keyword">return</span> alist </span><br></pre></td></tr></table></figure>
<h5 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h5><ul>
<li>时间复杂度：$O(n^2)$</li>
<li>空间复杂度:$O(1)$</li>
</ul>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><h5 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h5><p>这个是插入排序的修改版，根据步长由长到短分组，进行排序，直到步长为1为止，属于插入排序的一种。</p>
<h5 id="算法图解-3"><a href="#算法图解-3" class="headerlink" title="算法图解"></a>算法图解</h5><p><img src="D:/nutStore/Learning/leetcode/pictures/shellSort.webp"></p>
<h5 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shellSort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(alist)</span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap):</span><br><span class="line">            gapInsetionSort(alist, i, gap)</span><br><span class="line">        gap = gap // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> alist</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gapInsetionSort</span>(<span class="params">alist,startpos,gap</span>):</span></span><br><span class="line">    <span class="comment">#希尔排序的辅助函数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startpos+gap,<span class="built_in">len</span>(alist),gap):</span><br><span class="line">        position=i</span><br><span class="line">        currentvalue=alist[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> position&gt;startpos <span class="keyword">and</span> alist[position-gap]&gt;currentvalue:</span><br><span class="line">            alist[position]=alist[position-gap]</span><br><span class="line">            position=position-gap</span><br><span class="line">        alist[position]=currentvalue</span><br></pre></td></tr></table></figure>
<h5 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h5><ul>
<li>时间复杂度：$n\log (n)$</li>
<li></li>
</ul>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><h5 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h5><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<ul>
<li><p>初始状态：无序区为R[1..n]，有序区为空；</p>
</li>
<li><p>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</p>
</li>
<li><p>n-1趟结束，数组有序化了。</p>
</li>
</ul>
<h5 id="算法图解-4"><a href="#算法图解-4" class="headerlink" title="算法图解"></a>算法图解</h5><p><img src="D:/nutStore/Learning/leetcode/pictures/SelectSort.webp"></p>
<h5 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(alist)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 寻找[i,n]区间里的最小值</span></span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> alist[j] &lt; alist[min_index]:</span><br><span class="line">                min_index = j</span><br><span class="line">        alist[i], alist[min_index] = alist[min_index], alist[i]</span><br><span class="line">    <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure>


<h5 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h5><ul>
<li>时间复杂度：$O(n^2)$</li>
<li>空间复杂度:$O(1)$</li>
</ul>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h5 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h5><p>堆排序是一种基于二叉堆（Binary Heap）结构的排序算法，所谓二叉堆，我们通过完全二叉树来对比，只不过相比较完全二叉树而言，二叉堆的所有父节点的值都大于（或者小于）它的孩子节点，像这样：</p>
<p><img src="D:/nutStore/Learning/leetcode/pictures/heapSort.jpg"></p>
<p>首先需要引入最大堆的定义：</p>
<ul>
<li>最大堆中的最大元素值出现在根结点（堆顶）</li>
<li>堆中每个父节点的元素值都大于等于其孩子结点</li>
</ul>
<h5 id="算法图解-5"><a href="#算法图解-5" class="headerlink" title="算法图解"></a>算法图解</h5><p><img src="D:/nutStore/Learning/leetcode/pictures/heapSort.webp"></p>
<h5 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#建立堆函数：</span></span><br><span class="line"></span><br><span class="line">void heapify(<span class="built_in">int</span> arr[], <span class="built_in">int</span> n, <span class="built_in">int</span> i) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">int</span> largest = i; // 将最大元素设置为堆顶元素</span><br><span class="line">    <span class="built_in">int</span> l = <span class="number">2</span>*i + <span class="number">1</span>; // left = <span class="number">2</span>*i + <span class="number">1</span> </span><br><span class="line">    <span class="built_in">int</span> r = <span class="number">2</span>*i + <span class="number">2</span>; // right = <span class="number">2</span>*i + <span class="number">2</span> </span><br><span class="line">  </span><br><span class="line">    // 如果 left 比 root 大的话</span><br><span class="line">    <span class="keyword">if</span> (l &lt; n &amp;&amp; arr[l] &gt; arr[largest]) </span><br><span class="line">        largest = l; </span><br><span class="line">  </span><br><span class="line">    // I如果 right 比 root 大的话</span><br><span class="line">    <span class="keyword">if</span> (r &lt; n &amp;&amp; arr[r] &gt; arr[largest]) </span><br><span class="line">        largest = r; </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (largest != i) </span><br><span class="line">    &#123; </span><br><span class="line">        swap(arr[i], arr[largest]); </span><br><span class="line">  </span><br><span class="line">        // 递归地定义子堆</span><br><span class="line">        heapify(arr, n, largest); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>堆排序的方法如下，把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">void heapSort(<span class="built_in">int</span> arr[], <span class="built_in">int</span> n) </span><br><span class="line">&#123; </span><br><span class="line">    // 建立堆</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">        heapify(arr, n, i); </span><br><span class="line">  </span><br><span class="line">    // 一个个从堆顶取出元素</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i=n-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) </span><br><span class="line">    &#123; </span><br><span class="line">        swap(arr[<span class="number">0</span>], arr[i]);  </span><br><span class="line">        heapify(arr, i, <span class="number">0</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<h5 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h5><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="二路归并排序"><a href="#二路归并排序" class="headerlink" title="二路归并排序"></a>二路归并排序</h4><h5 id="算法思想-6"><a href="#算法思想-6" class="headerlink" title="算法思想"></a>算法思想</h5><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
<ul>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<p><img src="D:/nutStore/Learning/leetcode/pictures/MergeSort2.jpg"></p>
<h5 id="算法图解-6"><a href="#算法图解-6" class="headerlink" title="算法图解"></a>算法图解</h5><p><img src="D:/nutStore/Learning/leetcode/pictures/MergeSort.webp"></p>
<h5 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#之前copy了一份归并排序的算法，但那份代码包含太多优化行，导致算法思路不清晰</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">arr,l,r</span>):</span></span><br><span class="line">    <span class="comment"># l == r 时，不做任何处理，单独有序</span></span><br><span class="line">    <span class="keyword">if</span> l &lt; r :</span><br><span class="line">        m = <span class="built_in">int</span>((l + r) / <span class="number">2</span>)</span><br><span class="line">        mergeSort(arr,l,m)</span><br><span class="line">        mergeSort(arr , m+<span class="number">1</span> , r)</span><br><span class="line">        merge(arr , l ,m , r)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">arr , l , m , r</span>):</span></span><br><span class="line">    copyl = arr[l:m+<span class="number">1</span>]</span><br><span class="line">    copyr = arr[m+<span class="number">1</span>:r+<span class="number">1</span>]</span><br><span class="line">    lenl = <span class="built_in">len</span>(copyl)</span><br><span class="line">    lenr = <span class="built_in">len</span>(copyr)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    k = l</span><br><span class="line">    <span class="keyword">while</span> i &lt; lenl <span class="keyword">and</span> j &lt; lenr :</span><br><span class="line">        <span class="keyword">if</span> copyl[i] &lt; copyr[j]:</span><br><span class="line">            arr[k] = copyl[i]</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arr[k] = copyr[ j]</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; lenl :</span><br><span class="line">        arr[k] = copyl[i]</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; lenr:</span><br><span class="line">        arr[k] = copyr[j]</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>注意：这里进行小的优化，当数列的长度小于等于15的时候，我们一般认为数列此时基本有序，这时候采用直接插入排序非常快。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自底向上的归并算法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeBU</span>(<span class="params">alist</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(alist)</span><br><span class="line">    <span class="comment">#表示归并的大小</span></span><br><span class="line">    size = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> size &lt;= n:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n-size, size+size):</span><br><span class="line">            merge(alist, i, i+size-<span class="number">1</span>, <span class="built_in">min</span>(i+size+size-<span class="number">1</span>, n-<span class="number">1</span>))</span><br><span class="line">        size += size</span><br><span class="line">    <span class="keyword">return</span> alist</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并有序数列alist[start....mid] 和 alist[mid+1...end]，使之成为有序数列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">alist, start, mid, end</span>):</span></span><br><span class="line">    <span class="comment"># 复制一份</span></span><br><span class="line">    blist = alist[start:end+<span class="number">1</span>]</span><br><span class="line">    l = start</span><br><span class="line">    k = mid + <span class="number">1</span></span><br><span class="line">    pos = start</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> pos &lt;= end:</span><br><span class="line">        <span class="keyword">if</span> (l &gt; mid):</span><br><span class="line">            alist[pos] = blist[k-start]</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> (k &gt; end):</span><br><span class="line">            alist[pos] = blist[l-start]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> blist[l-start] &lt;= blist[k-start]:</span><br><span class="line">            alist[pos] = blist[l-start]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            alist[pos] = blist[k-start]</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        pos += <span class="number">1</span></span><br></pre></td></tr></table></figure>


<h5 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h5><h4 id="多路归并排序"><a href="#多路归并排序" class="headerlink" title="多路归并排序"></a>多路归并排序</h4><p>这里没有写</p>
<h2 id="非比较排序"><a href="#非比较排序" class="headerlink" title="非比较排序"></a>非比较排序</h2><p>非比较排序打破了时间复杂度$n\log n$ 的限制</p>
<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><h5 id="算法思想-7"><a href="#算法思想-7" class="headerlink" title="算法思想"></a>算法思想</h5><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<ul>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ul>
<h5 id="算法图解-7"><a href="#算法图解-7" class="headerlink" title="算法图解"></a>算法图解</h5><p><img src="D:/nutStore/Learning/leetcode/pictures/countSort.webp"></p>
<h5 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">countingSort</span><span class="params">(arr, maxValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bucket = <span class="keyword">new</span> Array(maxValue + <span class="number">1</span>),</span><br><span class="line">        sortedIndex = <span class="number">0</span>;</span><br><span class="line">        arrLen = arr.length,</span><br><span class="line">        bucketLen = maxValue + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arrLen; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bucket[arr[i]]) &#123;</span><br><span class="line">            bucket[arr[i]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bucket[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; bucketLen; j++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr[sortedIndex++] = j;</span><br><span class="line">            bucket[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="算法分析-7"><a href="#算法分析-7" class="headerlink" title="算法分析"></a>算法分析</h5><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><h5 id="算法思想-8"><a href="#算法思想-8" class="headerlink" title="算法思想"></a>算法思想</h5><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<p>桶排序的原理是将数组分到有限数量的桶中，再对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。</p>
<p>排序过程：</p>
<ol>
<li>假设待排序的一组数统一的分布在一个范围中，并将这一范围划分成几个子范围，也就是桶</li>
<li>将待排序的一组数，分档规入这些子桶，并将桶中的数据进行排序</li>
<li>将各个桶中的数据有序的合并起</li>
</ol>
<h5 id="算法图解-8"><a href="#算法图解-8" class="headerlink" title="算法图解"></a>算法图解</h5><p><img src="D:/nutStore/Learning/leetcode/pictures/buckgetSort.jpg"></p>
<h5 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">bucketSort</span><span class="params">(arr, bucketSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> i;</span><br><span class="line">    <span class="keyword">var</span> minValue = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; minValue) &#123;</span><br><span class="line">          minValue = arr[i];                <span class="comment">// 输入数据的最小值</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; maxValue) &#123;</span><br><span class="line">          maxValue = arr[i];                <span class="comment">// 输入数据的最大值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 桶的初始化</span></span><br><span class="line">    <span class="keyword">var</span> DEFAULT_BUCKET_SIZE = <span class="number">5</span>;            <span class="comment">// 设置桶的默认数量为5</span></span><br><span class="line">    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;</span><br><span class="line">    <span class="keyword">var</span> bucketCount = Math.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">var</span> buckets = <span class="keyword">new</span> Array(bucketCount);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    arr.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        insertionSort(buckets[i]);                      <span class="comment">// 对每个桶进行排序，这里使用了插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">            arr.push(buckets[i][j]);                     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="算法分析-8"><a href="#算法分析-8" class="headerlink" title="算法分析"></a>算法分析</h5><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><h5 id="算法思想-9"><a href="#算法思想-9" class="headerlink" title="算法思想"></a>算法思想</h5><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<ul>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ul>
<h5 id="算法图解-9"><a href="#算法图解-9" class="headerlink" title="算法图解"></a>算法图解</h5><p><img src="D:/nutStore/Learning/leetcode/pictures/redixSort.webp"></p>
<h5 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var counter = [];</span><br><span class="line">function radixSort(arr, maxDigit) &#123;</span><br><span class="line">    var mod = <span class="number">10</span>;</span><br><span class="line">    var dev = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(var j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            var bucket = parseInt((arr[j] % mod) / dev);</span><br><span class="line">            <span class="keyword">if</span>(counter[bucket]==null) &#123;</span><br><span class="line">                counter[bucket] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            counter[bucket].push(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        var pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(var j = <span class="number">0</span>; j &lt; counter.length; j++) &#123;</span><br><span class="line">            var value = null;</span><br><span class="line">            <span class="keyword">if</span>(counter[j]!=null) &#123;</span><br><span class="line">                <span class="keyword">while</span> ((value = counter[j].shift()) != null) &#123;</span><br><span class="line">                      arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="算法分析-9"><a href="#算法分析-9" class="headerlink" title="算法分析"></a>算法分析</h5><p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p>
<p>基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>
]]></content>
      <categories>
        <category>Technology</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_Learning_Effective_Go_Docs.md</title>
    <url>/2021/09/25/Go-Learning-Effective-Go-Docs/</url>
    <content><![CDATA[<p>EffectiveGo_简单笔记</p>
<p><strong>地址:</strong> <a href="https://golang.google.cn/doc/effective_go">教材</a></p>
<a id="more"></a>

<p>可用于快速了解GO语言.</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Effective_Go provide:</p>
<ul>
<li><strong>Go language</strong> properties and idioms</li>
<li><strong>Established conventions</strong> for programming in Go</li>
</ul>
<p>This document gives tips for writting clear,idiomatic Go code.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Go standard package is a short path to understand <strong>Excellent Go Code</strong>. Fortunately many lib provide self-contained executable example you can run directly from the golang.org web site,such as <a href="https://golang.org/pkg/strings/#example_Map">this one</a>.</p>
<h2 id="Formatting"><a href="#Formatting" class="headerlink" title="Formatting"></a>Formatting</h2><p>Formatting issues are the most contentious but the least consequential. While in real life, every one may adapt different code style. The best way is Every developer adapt same code style.</p>
<p>In Go language, the machine could take care of most formatting issues. The <strong>gofmt</strong> program could read Go code and emits the source in a standard style. The standard style may include: indentation and vertical alignment, retaining and if necessary reformatting comments. </p>
<p><strong>Example Code: before</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span> <span class="comment">// name of the object</span></span><br><span class="line">    value <span class="keyword">int</span> <span class="comment">// its value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>After gofmt:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	name  <span class="keyword">string</span> <span class="comment">// name of the object</span></span><br><span class="line">	value <span class="keyword">int</span>    <span class="comment">// its value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Formatting include:</p>
<ul>
<li>Indentation: GO use TAB as default</li>
<li>Line length: No length limit</li>
<li>Parentheses: Control structures(if, for, switch) do not have parenthese in their syntax</li>
</ul>
<h2 id="Commentary"><a href="#Commentary" class="headerlink" title="Commentary"></a>Commentary</h2><p>Go provides block(/* */) comments and line comments(//). line comments is the same as other language, While block coments may serve as package comments.</p>
<h3 id="Types"><a href="#Types" class="headerlink" title="Types:"></a><strong>Types:</strong></h3><ul>
<li><p>package comments: Appear before top-level declarations </p>
<blockquote>
<p>For multi-file packages, the package comment only needs to be present in one file, and any one will do. The package comment should introduce the package and provide information relevant to the package as a whole. It will appear first on the <code>godoc</code> page and should set up the detailed documentation that follows.</p>
</blockquote>
</li>
<li><p>doc comments: Apeear above the declarations.</p>
<blockquote>
<p>In go, every export(Capital Letter start) needs doc comments</p>
</blockquote>
</li>
<li><p>general comments: others</p>
</li>
</ul>
<h3 id="Conventions"><a href="#Conventions" class="headerlink" title="Conventions"></a>Conventions</h3><p><strong>godoc</strong> process Go source files to extract documentation about the package. The document quality is based on the comments quality. So thire are some rules we need to obey:</p>
<ul>
<li><p>Package Comments:  introduce the package and provide information relevant to the package as a whole. It will appear first on the <code>godoc</code> page and should set up the detailed documentation that follows.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Package regexp implements a simple library for regular expressions.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The syntax of the regular expressions accepted is:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    regexp:</span></span><br><span class="line"><span class="comment">        concatenation &#123; &#x27;|&#x27; concatenation &#125;</span></span><br><span class="line"><span class="comment">    concatenation:</span></span><br><span class="line"><span class="comment">        &#123; closure &#125;</span></span><br><span class="line"><span class="comment">    closure:</span></span><br><span class="line"><span class="comment">        term [ &#x27;*&#x27; | &#x27;+&#x27; | &#x27;?&#x27; ]</span></span><br><span class="line"><span class="comment">    term:</span></span><br><span class="line"><span class="comment">        &#x27;^&#x27;</span></span><br><span class="line"><span class="comment">        &#x27;$&#x27;</span></span><br><span class="line"><span class="comment">        &#x27;.&#x27;</span></span><br><span class="line"><span class="comment">        character</span></span><br><span class="line"><span class="comment">        &#x27;[&#x27; [ &#x27;^&#x27; ] character-ranges &#x27;]&#x27;</span></span><br><span class="line"><span class="comment">        &#x27;(&#x27; regexp &#x27;)&#x27;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> regexp</span><br></pre></td></tr></table></figure>
<p>If package is simple, the package comments can be brief:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package path implements utility routines for</span></span><br><span class="line"><span class="comment">// manipulating slash-separated filename paths.</span></span><br></pre></td></tr></table></figure></li>
<li><p>Doc comments: The first sentence should be a one-sentence summary that starts with <strong>the name being declared</strong>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Compile parses a regular expression and returns, if successful,</span></span><br><span class="line"><span class="comment">// a Regexp that can be used to match against text.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compile</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="params">(*Regexp, error)</span></span> &#123;</span><br></pre></td></tr></table></figure></li>
<li><p>Comments do not need extra formatting such as banners of stars.</p>
</li>
</ul>
<h2 id="Names"><a href="#Names" class="headerlink" title="Names"></a>Names</h2><p>Name, in Go language, has syntax effect: the visibility of a name outside a package is determined by whether its first character is upper case. </p>
<h3 id="Package-Name"><a href="#Package-Name" class="headerlink" title="Package Name"></a>Package Name</h3><ul>
<li>Package Name is an accessor for the content.</li>
<li>convention:<ul>
<li>packages are given lower case, single-word names;</li>
<li>No underscore,No mixedCaps</li>
<li>the package name is the base name of its source directory; <ul>
<li>the package in <code>src/encoding/base64</code> is imported as <code>&quot;encoding/base64&quot;</code> but has name <code>base64</code>, not <code>encoding_base64</code> and not <code>encodingBase64</code>.</li>
</ul>
</li>
</ul>
</li>
<li>The importer of a package will use the name to refer to its contents, so exported names in the package can use that fact to avoid repetition.</li>
</ul>
<h3 id="Interface-Name"><a href="#Interface-Name" class="headerlink" title="Interface Name"></a>Interface Name</h3><p>By convention, one-method interfaces are named by the method name plus an -er suffix or similar modification to construct an agent noun: <code>Reader</code>, <code>Writer</code>, <code>Formatter</code>, <code>CloseNotifier</code> etc.</p>
<h3 id="MixedCap"><a href="#MixedCap" class="headerlink" title="MixedCap"></a>MixedCap</h3><p>the convention in Go is to use <code>MixedCaps</code> or <code>mixedCaps</code> rather than underscores to write multiword names.</p>
<h2 id="Semicolons"><a href="#Semicolons" class="headerlink" title="Semicolons"></a>Semicolons</h2><p>In Go language, Semicolons(;) is used to terminate statement. The lexer would add semicolons autumatically based on some rules:</p>
<p><strong>Rules:</strong></p>
<ul>
<li><p>Add semicolons : if the newline comes after a token that could end a statement, insert a semicolon:</p>
<ul>
<li>identifier: <code>int</code> , <code>string</code>  </li>
<li>basic literial: a number or const string  </li>
<li>some tokens: <code>break continue fallthrough return ++ -- ) &#125;</code></li>
</ul>
</li>
<li><p>Omit semicolons: Closing identifier, such as</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="keyword">for</span> &#123; dst &lt;- &lt;-src &#125; &#125;()</span><br></pre></td></tr></table></figure></li>
<li><p>you cannot put the opening brace of a control structure (<code>if</code>, <code>for</code>, <code>switch</code>, or <code>select</code>) on the next line. If you do, a semicolon will be inserted before the brace, which could cause unwanted effects. </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// right</span></span><br><span class="line"><span class="keyword">if</span> i &lt; f() &#123;</span><br><span class="line">    g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//wrong</span></span><br><span class="line"><span class="keyword">if</span> i &lt; f()  <span class="comment">// wrong!</span></span><br><span class="line">&#123;           <span class="comment">// wrong!</span></span><br><span class="line">    g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Idiomatic</strong>:</p>
<ul>
<li><code>;</code>,Go programs have semicolons only in places such as <code>for</code> loop clauses, to separate the initializer, condition, and continuation elements. </li>
<li><code>;</code>, separate multiple statements on a line, should you write code that way.</li>
</ul>
<h2 id="Control-structures"><a href="#Control-structures" class="headerlink" title="Control structures"></a>Control structures</h2><p>In Go language, there is only <code>if , for , switch</code> as control structure while no <code>do, while</code> loop. </p>
<ul>
<li>Same with other language: <code>break,continue</code> statements is the same as others</li>
<li>Different :<ul>
<li>in <code>switch</code> structure, <code>type</code> is optional label</li>
<li><code>select</code></li>
</ul>
</li>
</ul>
<p><strong>Syntax</strong> in Go: No need parentheses while the body must always be brace-delimited.</p>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><ul>
<li><p>Ordinary syntan: Writting simple <code>if</code> in multiple lines.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Intersting syntax: <code>if</code> with initialization statement</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := file.Chmod(<span class="number">0664</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Print(err)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li></li>
</ul>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>There are three forms in <code>for</code> syntaxs:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Like a C for</span></span><br><span class="line"><span class="keyword">for</span> init; condition; post &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Like a C while</span></span><br><span class="line"><span class="keyword">for</span> condition &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Like a C for(;;)</span></span><br><span class="line"><span class="keyword">for</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="for-with-range"><a href="#for-with-range" class="headerlink" title="for with range:"></a><strong>for with range:</strong></h4><p>range statements is a good way to loop array, slice, map, channel, the syntax is :</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you only need the first item in the range (the key or index), drop the second:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> m &#123;</span><br><span class="line">    <span class="keyword">if</span> key.expired() &#123;</span><br><span class="line">        <span class="built_in">delete</span>(m, key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you only need the second item in the range (the value), use the <em>blank identifier</em>, an underscore, to discard the first:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> array &#123;</span><br><span class="line">    sum += value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Range does more work for <code>string</code>:Breaking out individual Unicode code points by parsing the UTF-8. Erroneous encodings consume one byte and produce the replacement rune U+FFFD.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> pos, char := <span class="keyword">range</span> <span class="string">&quot;日本\x80語&quot;</span> &#123; <span class="comment">// \x80 is an illegal UTF-8 encoding</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;character %#U starts at byte position %d\n&quot;</span>, char, pos)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//character U+65E5 &#x27;日&#x27; starts at byte position 0</span></span><br><span class="line"><span class="comment">//character U+672C &#x27;本&#x27; starts at byte position 3</span></span><br><span class="line"><span class="comment">//character U+FFFD &#x27;�&#x27; starts at byte position 6</span></span><br><span class="line"><span class="comment">//character U+8A9E &#x27;語&#x27; starts at byte position 7</span></span><br></pre></td></tr></table></figure>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch has the same mwaning as other language. In go language, if the <code>switch</code> has no expression it switches on <code>true</code>. It’s therefore possible—and idiomatic—to write an <code>if</code>-<code>else</code>-<code>if</code>-<code>else</code> chain as a <code>switch</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unhex</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>There is no automatic fall through, but cases can be presented in comma-separated lists.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shouldEscape</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> c &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;&amp;&#x27;</span>, <span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Type-switch"><a href="#Type-switch" class="headerlink" title="Type switch"></a>Type switch</h4><p>A switch can also be used to discover the dynamic type of an interface variable. Such a <em>type switch</em> uses the syntax of a type assertion with the keyword <code>type</code> inside the parentheses. If the switch declares a variable in the expression, the variable will have the corresponding type in each clause. It’s also idiomatic to reuse the name in such cases, in effect declaring a new variable with the same name but a different type in each case.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">t = functionOfSomeType()</span><br><span class="line"><span class="keyword">switch</span> t := t.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;unexpected type %T\n&quot;</span>, t)     <span class="comment">// %T prints whatever type t has</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;boolean %t\n&quot;</span>, t)             <span class="comment">// t has type bool</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;integer %d\n&quot;</span>, t)             <span class="comment">// t has type int</span></span><br><span class="line"><span class="keyword">case</span> *<span class="keyword">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;pointer to boolean %t\n&quot;</span>, *t) <span class="comment">// t has type *bool</span></span><br><span class="line"><span class="keyword">case</span> *<span class="keyword">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;pointer to integer %d\n&quot;</span>, *t) <span class="comment">// t has type *int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>Three unusual features in Go Functions:</p>
<h3 id="Multiple-return-values"><a href="#Multiple-return-values" class="headerlink" title="Multiple return values"></a>Multiple return values</h3><p>Like PYTHON, functions in go could return multiple values. A standard example in package <code>os</code> is <code>Write</code> method:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *File)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">it returns the number of bytes written and a non-nil error when n != len(b).</span><br></pre></td></tr></table></figure>
<h3 id="Named-result-parameters"><a href="#Named-result-parameters" class="headerlink" title="Named result parameters"></a>Named result parameters</h3><p>The return parameters of a Go function can be given names and used as regular variables, just like incoming parameters. When named, they are initialized to the ZERO values for their types when the function begins; if the function executes a <code>return</code> statement with no arguments, the current values of the result parameters are used as the returned values.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextInt</span><span class="params">(b []<span class="keyword">byte</span>, pos <span class="keyword">int</span>)</span> <span class="params">(value, nextPos <span class="keyword">int</span>)</span></span> &#123;</span><br></pre></td></tr></table></figure>
<ul>
<li>Make code shorter and clearer</li>
</ul>
<p>Because named results are initialized and tied to an unadorned return, they can simplify as well as clarify. Here’s a version of <code>io.ReadFull</code> that uses them well:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFull</span><span class="params">(r Reader, buf []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(buf) &gt; <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> nr <span class="keyword">int</span></span><br><span class="line">        nr, err = r.Read(buf)</span><br><span class="line">        n += nr</span><br><span class="line">        buf = buf[nr:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h3><p>Go’s <code>defer</code> statement schedules a function call (the <em>deferred</em> function) to be run immediately before the function executing the <code>defer</code> returns. It’s an unusual but effective way to deal with situations such as resources that must be released regardless of which path a function takes to return. The canonical examples are unlocking a mutex or closing a file.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Contents returns the file&#x27;s contents as a string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contents</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()  <span class="comment">// f.Close will run when we&#x27;re finished.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result []<span class="keyword">byte</span></span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := f.Read(buf[<span class="number">0</span>:])</span><br><span class="line">        result = <span class="built_in">append</span>(result, buf[<span class="number">0</span>:n]...) <span class="comment">// append is discussed later.</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err  <span class="comment">// f will be closed if we return here.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(result), <span class="literal">nil</span> <span class="comment">// f will be closed if we return here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li> First, it guarantees that you will never forget to close the file, a mistake that’s easy to make if you later edit the function to add a new return path. </li>
<li> Second, it means that the close sits near the open, which is much clearer than placing it at the end of the function.</li>
</ul>
<p>Deferred functions are executed in LIFO order,</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;entering:&quot;</span>, s)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">un</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;leaving:&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> un(trace(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">    fmt.Println(<span class="string">&quot;in a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> un(trace(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">    fmt.Println(<span class="string">&quot;in b&quot;</span>)</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">entering: b</span><br><span class="line">in b</span><br><span class="line">entering: a</span><br><span class="line">in a</span><br><span class="line">leaving: a</span><br><span class="line">leaving: b</span><br></pre></td></tr></table></figure>
<h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><h3 id="Allocation"><a href="#Allocation" class="headerlink" title="Allocation"></a>Allocation</h3><p>Three allocation methods in Go language, <code>new</code> <code>make</code> <code>composite literals</code>; While <code>new</code> and <code>make</code> are build in functions, <code>composite literals</code> is a kind of initialise format. Different allocation method with different feature.</p>
<p><strong><code>new</code></strong>: build in function, allocate memory , <strong>zeros</strong> it, ,return the pointer(*T) of type <code>T</code>.</p>
<ul>
<li><p>Apply Type: Any</p>
</li>
<li><p>Basic Format: <code>new(type)</code></p>
<ul>
<li><p>Zeros struct:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SyncedBuffer <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock    sync.Mutex</span><br><span class="line">    buffer  bytes.Buffer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p *SyncedBuffer = <span class="built_in">new</span>(SyncedBuffer) <span class="comment">// type *SyncedBuffer</span></span><br><span class="line">p := <span class="built_in">new</span>(SyncedBuffer)  <span class="comment">// type *SyncedBuffer</span></span><br></pre></td></tr></table></figure></li>
<li><p>Zeros slice:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *[]<span class="keyword">int</span> = <span class="built_in">new</span>([]<span class="keyword">int</span>)       <span class="comment">// allocates slice structure; *p == nil; </span></span><br><span class="line">p := <span class="built_in">new</span>([]<span class="keyword">int</span>)					<span class="comment">//allocates slice structure; *p == nil; </span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong><code>make</code></strong>:build in function,  allocate memory, <strong>initialized</strong> it, return the value(T) of type <code>T</code> .</p>
<ul>
<li><p>Aapply Type: only slices, maps, channels</p>
</li>
<li><p>Basic Format: <code>make(type , length , capacity)</code></p>
<ul>
<li><p>Initialized Slice:</p>
<p>A slice, for example, is a three-item descriptor containing a pointer to the data (inside an array), the length, and the capacity, and until those items are initialized, the slice is <code>nil</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>allocates an array of 100 ints and then creates a slice structure with length 10 and a capacity of 100 pointing at the first 10 elements of the array. When making a slice, the capacity can be omitted;</p>
</li>
</ul>
</li>
</ul>
<p><strong><code>composite literals</code></strong>:  a kind of initialise format, allocate memory, <strong>initialized</strong> it , return the value(T) of type <code>T</code></p>
<ul>
<li><p>Apply Type: Any</p>
</li>
<li><p>Basic Format: <code>Type&#123;value_0, ..., value_n&#125;</code> or <code>Type&#123;item_y : value_x, item_x: value_x, ... &#125;</code></p>
<ul>
<li><p>Initialized Slice:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> figure out </span></span><br><span class="line">s := []<span class="keyword">string</span>      &#123;Enone: <span class="string">&quot;no error&quot;</span>, Eio: <span class="string">&quot;Eio&quot;</span>, Einval: <span class="string">&quot;invalid argument&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Initialized Struct:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> *<span class="title">File</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    f := File&#123;fd, name, <span class="literal">nil</span>, <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;f</span><br><span class="line">    <span class="comment">//  equals to:   return &amp;File&#123;fd, name, nil, 0&#125;</span></span><br><span class="line">    <span class="comment">//  equals to:  return &amp;File&#123;fd: fd, name: name&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Data-structure"><a href="#Data-structure" class="headerlink" title="Data structure"></a>Data structure</h3></li>
</ul>
</li>
</ul>
<h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p>Array is primarily as the building block for Slice.</p>
<p><strong>Features:</strong></p>
<ul>
<li>Arrays are values. Assigning one array to another copies all the elements.</li>
<li>In particular, if you pass an array to a function, it will receive a <em>copy</em> of the array, not a pointer to it.</li>
<li>The size of an array is part of its type. The types <code>[10]int</code> and <code>[20]int</code> are distinct.</li>
</ul>
<p>The value property can be useful but also expensive; if you want C-like behavior and efficiency, you can pass a pointer to the array.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func Sum(a *[3]float64) (sum float64) &#123;</span><br><span class="line">    for _, v :&#x3D; range *a &#123;</span><br><span class="line">        sum +&#x3D; v</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array :&#x3D; [...]float64&#123;7.0, 8.5, 9.1&#125;</span><br><span class="line">x :&#x3D; Sum(&amp;array)  &#x2F;&#x2F; Note the explicit address-of operator</span><br></pre></td></tr></table></figure>
<p>But even this style isn’t idiomatic Go. Use slices instead.</p>
<h4 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h4><p>Slice wrap arrays to give a more general, powerful and convinent interface to sequence of data. Most array programming in GO is done with slices rather than simple arrays.</p>
<p><strong>Features:</strong></p>
<ul>
<li>Slices hold the references to an underlaying array<ul>
<li>if you assign one slice to another, both refer to the same array.</li>
<li>If a functions take Slice argument, changes it makes to the slices elements will be visible to the caller.</li>
</ul>
</li>
</ul>
<p>The length of a slice may be changed as long as it still fits within the limits of the underlying array; just assign it to a slice of itself. The <em>capacity</em> of a slice, accessible by the built-in function <code>cap</code>, reports the maximum length the slice may assume. Here is a function to append data to a slice. If the data exceeds the capacity, the slice is reallocated. The resulting slice is returned. The function uses the fact that <code>len</code> and <code>cap</code> are legal when applied to the <code>nil</code> slice, and return 0.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func Append(slice, data []byte) []byte &#123;</span><br><span class="line">    l :&#x3D; len(slice)</span><br><span class="line">    if l + len(data) &gt; cap(slice) &#123;  &#x2F;&#x2F; reallocate</span><br><span class="line">        &#x2F;&#x2F; Allocate double what&#39;s needed, for future growth.</span><br><span class="line">        newSlice :&#x3D; make([]byte, (l+len(data))*2)</span><br><span class="line">        &#x2F;&#x2F; The copy function is predeclared and works for any slice type.</span><br><span class="line">        copy(newSlice, slice)</span><br><span class="line">        slice &#x3D; newSlice</span><br><span class="line">    &#125;</span><br><span class="line">    slice &#x3D; slice[0:l+len(data)]</span><br><span class="line">    copy(slice[l:], data)</span><br><span class="line">    return slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We must return the slice afterwards because, although <code>Append</code> can modify the elements of <code>slice</code>, the slice itself (the run-time data structure holding the pointer, length, and capacity) is passed by value.</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><strong>What Map ?</strong></p>
<p>The key can be of any type for which the equality operator is defined, such as integers, floating point and complex numbers, strings, pointers, interfaces (as long as the dynamic type supports equality), structs and arrays. Slices cannot be used as map keys, because equality is not defined on them. Like slices, maps hold references to an underlying data structure. If you pass a map to a function that changes the contents of the map, the changes will be visible in the caller.</p>
<p><strong>initialize Map</strong></p>
<p>Maps can be constructed using the usual composite literal syntax with colon-separated key-value pairs, so it’s easy to build them during initialization.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timeZone = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;UTC&quot;</span>:  <span class="number">0</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">    <span class="string">&quot;EST&quot;</span>: <span class="number">-5</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">    <span class="string">&quot;CST&quot;</span>: <span class="number">-6</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">    <span class="string">&quot;MST&quot;</span>: <span class="number">-7</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">    <span class="string">&quot;PST&quot;</span>: <span class="number">-8</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Features</strong></p>
<ul>
<li><p><strong>get value:</strong> simliar with slice</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">offset := timeZone[<span class="string">&quot;EST&quot;</span>]</span><br></pre></td></tr></table></figure></li>
<li><p><strong>apply the key which not in map</strong> : return zeros of value type</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">attended := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>&#123;</span><br><span class="line">    <span class="string">&quot;Ann&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;Joe&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> attended[person] &#123; <span class="comment">// will be false if person is not in the map</span></span><br><span class="line">    fmt.Println(person, <span class="string">&quot;was at the meeting&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>two var is accept : <strong>get gistinguish a missing entry from zeros value</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> seconds <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">seconds, ok = timeZone[tz]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">offset</span><span class="params">(tz <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> seconds, ok := timeZone[tz]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> seconds</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">&quot;unknown time zone:&quot;</span>, tz)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Omit value:</strong> <code>_</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, present := timeZone[tz]</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Delete map entry</strong>:<code>delete</code> function</p>
<p>SAFE function even if the key is already absent from the map.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(timeZone, <span class="string">&quot;PDT&quot;</span>)  <span class="comment">// Now on Standard Time</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h2><h3 id="constant"><a href="#constant" class="headerlink" title="constant"></a>constant</h3><ul>
<li><p>CreateTime: compile time</p>
</li>
<li><p>can only be: <code>numbers</code>,<code>characters</code>,<code>string</code>,<code>booleans</code></p>
</li>
<li><p>Define location: could be defined as locals in <strong>functions</strong></p>
</li>
<li><p>constant expression: only constant expression</p>
<ul>
<li><code>1&lt;&lt;3</code> : Correct </li>
<li><code>math.Sin(math.Pi)</code>: Wrong</li>
</ul>
</li>
<li><p>enumerated constant: <code>iota</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteSize <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _           = <span class="literal">iota</span> <span class="comment">// ignore first value by assigning to blank identifier</span></span><br><span class="line">    KB ByteSize = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    MB</span><br><span class="line">    GB</span><br><span class="line">    TB</span><br><span class="line">    PB</span><br><span class="line">    EB</span><br><span class="line">    ZB</span><br><span class="line">    YB</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="variable"><a href="#variable" class="headerlink" title="variable"></a>variable</h3></li>
<li><p>CreateTime: Runtime</p>
</li>
<li><p>can be any type</p>
</li>
<li><p>initializer can be a general expression computed at run time.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    home   = os.Getenv(<span class="string">&quot;HOME&quot;</span>)</span><br><span class="line">    user   = os.Getenv(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">    gopath = os.Getenv(<span class="string">&quot;GOPATH&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="init-function"><a href="#init-function" class="headerlink" title="init function"></a>init function</h3><ul>
<li><p>Call Time:After all the variable declarations in the package have evaluated;</p>
</li>
<li><p>a common use of <code>init</code> functions is to verify or repair correctness of the program state before real execution begins.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> user == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;$USER not set&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> home == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        home = <span class="string">&quot;/home/&quot;</span> + user</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> gopath == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        gopath = home + <span class="string">&quot;/go&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// gopath may be overridden by --gopath flag on command line.</span></span><br><span class="line">    flag.StringVar(&amp;gopath, <span class="string">&quot;gopath&quot;</span>, gopath, <span class="string">&quot;override default GOPATH&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2></li>
</ul>
<p>Methods can be divited into two types: Values methods OR Pointer methods.For Example:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// values method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(slice ByteSlice)</span> <span class="title">Append</span><span class="params">(data []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="comment">// Body exactly the same as the Append function defined above.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pointer method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ByteSlice)</span> <span class="title">Append</span><span class="params">(data []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    slice := *p</span><br><span class="line">    <span class="comment">// Body as above, without the return.</span></span><br><span class="line">    *p = slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Difference:</strong> The rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers.</p>
<ul>
<li>pointer methods can modify the receiver</li>
<li>value methods will receive a copy of value, so the change will be discard</li>
</ul>
<p>In GO language the pointer method is recommend. When the value is addressable, the complier would rewrite that expression for us. For example, coder wirte <code>b.write</code>, the complier would rewrite it to <code>(&amp;b).write</code>.</p>
<h2 id="Interface-and-other-types"><a href="#Interface-and-other-types" class="headerlink" title="Interface and other types"></a>Interface and other types</h2><h2 id="The-blank-identifier"><a href="#The-blank-identifier" class="headerlink" title="The blank identifier"></a>The blank identifier</h2><p>The blank identifier <code>_</code> can be assigned with any value of any type, with the value discarded harmlessly.</p>
<h3 id="usage-scenario"><a href="#usage-scenario" class="headerlink" title="usage scenario"></a>usage scenario</h3><ul>
<li><p>The blank identifier in multiple assignment</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err := os.Stat(path); os.IsNotExist(err) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s does not exist\n&quot;</span>, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Unused imports and variables: half-written program</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = fmt.Printf <span class="comment">// For debugging; delete when done.</span></span><br><span class="line"><span class="keyword">var</span> _ io.Reader    <span class="comment">// For debugging; delete when done.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fd, err := os.Open(<span class="string">&quot;test.go&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> use fd.</span></span><br><span class="line">    _ = fd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>import for side effect</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;net/http/pprof&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>interface checks</p>
<p>…</p>
</li>
</ul>
<h2 id="Embedding"><a href="#Embedding" class="headerlink" title="Embedding"></a>Embedding</h2><p>In GO language there is no typical, type-driver notion of subclassing, while it have the ability to borrow the implementation by <code>embedding</code> types with interface or struct.</p>
<h3 id="embedding-in-interface"><a href="#embedding-in-interface" class="headerlink" title="embedding in interface"></a>embedding in interface</h3><p>Interface embedding is simple.For example, we define two basic interface <code>Reader</code> <code>Writer</code> ,and embedding them into complex interface <code>ReadWriter</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// embedding in interface</span></span><br><span class="line"><span class="comment">// ReadWriter is the interface that combines the Reader and Writer interfaces.</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This says just what it looks like: A <code>ReadWriter</code> can do what a <code>Reader</code> does <em>and</em> what a <code>Writer</code> does; it is a union of the embedded interfaces. Only interfaces can be embedded within interfaces.</p>
<h3 id="embedding-in-struct"><a href="#embedding-in-struct" class="headerlink" title="embedding in struct"></a>embedding in struct</h3><p> Embedding in struct is far-reaching than interface. Two steps in struct way:</p>
<ol>
<li><p>struct definition with embedding</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    reader *Reader</span><br><span class="line">    writer *Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>provide forwarding methods</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *ReadWriter)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rw.reader.Read(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="difference-from-subclassing"><a href="#difference-from-subclassing" class="headerlink" title="difference from subclassing"></a>difference from subclassing</h3></li>
</ol>
<p>There’s an important way in which embedding differs from subclassing. When we embed a type, the methods of that type become methods of the outer type, but when they are invoked the receiver of the method is the inner type, not the outer one. In our example, when the <code>Read</code> method of a <code>bufio.ReadWriter</code> is invoked, it has exactly the same effect as the forwarding method written out above; the receiver is the <code>reader</code> field of the <code>ReadWriter</code>, not the <code>ReadWriter</code> itself.</p>
<h2 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h2><h2 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h2><h2 id="A-web-server"><a href="#A-web-server" class="headerlink" title="A web server"></a>A web server</h2>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
</search>
